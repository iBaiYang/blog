---
layout: post
categories: PHP
title: PHP 正则判断常用示例
meta: 正则判断常用示例
---
* content
{:toc}

### 正文

正则匹配，我们有时会在程序中用到，但使用频率不太高，所以容易忘记，这里记一下常用的几个例子。

判断手机号：

```php
$mobile = '18409060101';
$g = '/^1[34578]\d{9}$/';
if ( !preg_match($g, $mobile) ) {
     echo '非手机号';
}
```

说明：

```php
// "^"符号表示必须是1开头;
// "[ ]"的意思是第二个数字必须是中括号中一个数字;
// 而 \d 则表示0-9任意数字,后跟{9}表示长度是9个数字;
// 后面的$表示结尾;
// 开始和结尾的 / 是正则表达式必须放在这个中间, 有的后面可能还跟模式 
```

还有这几种写法：

```php
$g = '/^1[34578]{1}\d{9}$/';
$g = '/^1[34578][0-9]{9}$/';
$g = '/^(13[0-9]|15[0|3|6|7|8|9]|18[8|9])\d{8}$/';
$g = '/^(1(([35][0-9])|(47)|[8][01236789]))\d{8}$/';
$g = '/^13[\d]{9}$|^14[5,7]{1}\d{8}$|^15[^4]{1}\d{8}$|^17[0,6,7,8]{1}\d{8}$|^18[\d]{9}$/'; 
```

再发一个座机的：

```php
$g = '/^0\d{2,3}(\-)?\d{7,8}$/'; 
```

判断邮箱：

```php
$email = 'abc-123@123.com.cn';
$pattern = '/^([0-9A-Za-z\\-_\\.]+)@([0-9a-z]+\\.[a-z]{2,3}(\\.[a-z]{2})?)$/i';
if ( !preg_match($pattern, $email) ) {
     echo '非邮箱';
} 
```

说明：

```php
// \ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。
// 例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。
// + 匹配一个或者多个，等价于 {1,}
// ? 匹配前面的子表达式零次或一次，等价于 {0,1} ，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?
// * 匹配前面的子表达式零次或多次，等价于{0,} 。要匹配 * 字符，请使用 \*
// . 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \.
// /内容/i 构成一个不区分大小写的正则表达式 
```

其他写法：

```php
$pattern = '/^[a-z]([a-z0-9]*[-_\.]?[a-z0-9]+)*@([a-z0-9]*[-_]?[a-z0-9]+)+[\.][a-z]{2,3}([\.][a-z]{2})?$/i';
$pattern = '/^[a-z]([a-z0-9]*[-_]?[a-z0-9]+)*@([a-z0-9]*[-_]?[a-z0-9]+)+[\.][a-z]{2,3}([\.][a-z]{2})?$/i';
$pattern = '/^\w[-\w.+]*@([A-Za-z0-9][-A-Za-z0-9]+\.)+[A-Za-z]{2,14}$/';
$pattern = '/^([a-z0-9]*[-_\.]?[a-z0-9]+)*@([a-z0-9]*[-_]?[a-z0-9]+)+[\.][a-z]{2,3}([\.][a-z]{2})?$/i';
$pattern = '/^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,})$/i'; 
```

碰到一个问题，就是判断一个字符串是不是数字，立刻想到正则，后来又看到了一个函数is_numeric()，
可以直接查看是否为数字串。

#### PCRE

PCRE 函数:
```
preg_filter — 执行一个正则表达式搜索和替换
preg_grep — 返回匹配模式的数组条目
preg_last_error_msg — Returns the error message of the last PCRE regex execution
preg_last_error — 返回最后一个PCRE正则执行产生的错误代码
preg_match_all — 执行一个全局正则表达式匹配
preg_match — 执行匹配正则表达式
preg_quote — 转义正则表达式字符
preg_replace_callback_array — Perform a regular expression search and replace using callbacks
preg_replace_callback — 执行一个正则表达式搜索并且使用一个回调进行替换
preg_replace — 执行一个正则表达式的搜索和替换
preg_split — 通过一个正则表达式分隔字符串
```

PREG 常量:
```
常量 	描述 	自哪个版本起
PREG_PATTERN_ORDER 	结果按照"规则"排序，仅用于preg_match_all()， 即$matches[0]是完整规则的匹配结果， $matches[1]是第一个子组匹配的结果，等等。 	since
PREG_SET_ORDER 	结果按照"集合"排序，仅用于preg_match_all()， 即$matches[0]保存第一次匹配结果的所有结果(包含子组)信息, $matches[1]保存第二次的结果信息，等等。 	 
PREG_OFFSET_CAPTURE 	查看PREG_SPLIT_OFFSET_CAPTURE的描述。 	4.3.0
PREG_SPLIT_NO_EMPTY 	这个标记告诉 preg_split() 进返回非空部分。 	 
PREG_SPLIT_DELIM_CAPTURE 	这个标记告诉 preg_split() 同时捕获括号表达式匹配到的内容。 	4.0.5
PREG_SPLIT_OFFSET_CAPTURE 	如果设置了这个标记，每次出现的匹配子串的偏移量也会被返回。注意，这会改变返回数组中的值， 每个元素都是由匹配子串作为第0个元素，它相对目标字符串的偏移量作为第1个元素的数组。这个 标记只能用于 preg_split()。 	4.3.0
PREG_NO_ERROR 	没有匹配错误时调用 preg_last_error() 返回。 	5.2.0
PREG_INTERNAL_ERROR 	如果有PCRE内部错误时调用 preg_last_error() 返回。 	5.2.0
PREG_BACKTRACK_LIMIT_ERROR 	如果调用回溯限制超出，调用preg_last_error()时返回。 	5.2.0
PREG_RECURSION_LIMIT_ERROR 	如果递归限制超出，调用preg_last_error()时返回。 	5.2.0
PREG_BAD_UTF8_ERROR 	如果最后一个错误时由于异常的utf-8数据(仅在运行在 UTF-8 模式正则表达式下可用)。 导致的，调用preg_last_error()返回。 	5.2.0
PREG_BAD_UTF8_OFFSET_ERROR 	如果偏移量与合法的urf-8代码不匹配(仅在运行在 UTF-8 模式正则表达式下可用)。 调用preg_last_error()返回。 	5.3.0
PCRE_VERSION 	PCRE版本号和发布日期(比如： "7.0 18-Dec-2006")。 	5.2.4
```

<br/><br/><br/><br/><br/>
### 参考资料

PCRE 函数 <https://www.php.net/manual/zh/ref.pcre.php>

PHP 手册 函数参考 文本处理 PCRE PCRE 函数 <https://www.php.net/manual/zh/function.preg-match.php>

PHP 正则表达式(PCRE) <https://www.runoob.com/php/php-pcre.html>

<http://www.cnblogs.com/blogforly/p/5644049.html>

<http://www.runoob.com/php/php-preg_match.html>

<http://www.jquerycn.cn/a_16278>

<http://www.runoob.com/regexp/regexp-tutorial.html>

<http://www.jb51.net/article/16108.htm>

<http://www.runoob.com/w3cnote/php-email-regrex.html>

is_numeric() 函数  <https://www.runoob.com/php/php-is_numeric-function.html>