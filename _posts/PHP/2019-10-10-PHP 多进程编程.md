---
layout: post
categories: PHP
title: PHP 多进程编程
meta: 多进程编程
---
* content
{:toc}

### 正文

#### 进程和线程的观众席

进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。换句话说就是，在系统调度多个cpu的时候，一个程序的基本单元。

进程有两个特性部分：资源所有权和调度执行。 资源所有权是指进程包括了进程运行所需要的内存空间、I/O等资源。 
调度执行是指进程执行过程中间的执行路径，或者说程序的指令执行流。 这两个特性部分是可以分开的，分开后，拥有资料所有权的通常称为进程，
拥有执行代码的可分派部分的被称之为线程或轻量级进程。

线程有“执行的线索”的意思在里面，而进程在多线程环境中被定义为资源所有者，其还是会存储进程的进程控制块。 

更多关于进程和线程的内容，看一下参考资料。

#### php编程常见的进程和线程

1、在web应用中，我们每次访问php，就建立一个PHP进程，当然也会建立至少一个PHP线程。

2、PHP使用pcntl来进行多进程编程

3、PHP中使用pthreads来进行多线程编程

4、nginx的每个进程只有一个线程，每个线程可以处理多个客户端的访问

5、php-fpm使用多进程模型，每个进程只有一个线程，每个线程只能处理一个客户端访问。

6、apache可能使用多进程模型，也可能使用多线程模型，取决于使用哪种SAPI.

#### PHP进程环境

php中的进程是以扩展的形式来完成。通过这些扩展，我们能够很轻松的完成进程的一系列动作。

    pcntl扩展：主要的进程扩展，完成进程创建于等待操作。
    posix扩展：完成posix兼容机通用api,如获取进程id,杀死进程等。
    sysvmsg扩展：实现system v方式的进程间通信之消息队列。
    sysvsem扩展：实现system v方式的信号量。
    sysvshm扩展：实现system v方式的共享内存。
    sockets扩展：实现socket通信。

这些扩展只能在linux/mac中使用，window下是不支持。最后建议php版本为5.5+。

pthreads 是一组允许用户在 PHP 中使用多线程技术的面向对象的 API。 它提供了创建多线程应用所需的全套工具。

#### 编程实例

说这么多进程线程的异同，而不实际操作是不会明白真正的异同和用途的。

我们看一下PHP中多进程编码的实例：

```
parentPid = posix_getpid();
echo "parent progress pid:{$parentPid}\n";
$childList = array();
$pid = pcntl_fork();
echo "fork pid:{$pid}\n";
if ( $pid == -1) {
    // 创建失败
    exit("fork progress error!\n");
} else if ($pid == 0) {
    // 子进程执行程序
    $pid = posix_getpid();
    $repeatNum = 3;
    for ( $i = 1; $i <= $repeatNum; $i++) {
        echo "({$pid})child progress is running! {$i} \n";
        $rand = rand(1,3);
        sleep($rand);
    }
    exit("({$pid})child progress end!\n");
} else {
    // 父进程执行程序
    echo "({$pid})parent progress is running!\n";
}
// 等待子进程结束
pcntl_wait($status);
echo "({$parentPid})main progress end!";
```

输出结果：

```
parent progress pid:7
fork pid:9
(9)parent progress is running!
fork pid:0
(9)child progress is running! 1 
(9)child progress is running! 2 
(9)child progress is running! 3 
(9)child progress end!
(7)main progress end!
```

再看一个例子，队列消费者实现，你可能会说队列有一个消费者不就可以消费了吗，如果同一队列需要多个消费者呢，我们怎么开启和关闭这些消费者进程。

队列管理服务：
```
namespace rabbitMQ\controllers;

use yii;

class ConsumerController extends BaseController
{
    //项目根目录 ， 如 dirname(__DIR__)
    private $root;
    
    //worker pidfile ，如 /data/log/rabbitMQ/Mail
    private $pidfile;
    
    //worker进程pid
    private $pids = [];

    //consumer
    private $consumer;
    
    //rabbitMQ全局配置 ,连接信息 [ip地址、端口、用户名、密码]
    private $setting = [];
    
    //worker对应queue,exchange,rooting绑定配置 ， 如 ['CMail' => ['queue' => 'queue_mail', 'exchange' => 'async', 'routing' => 'mail']]
    private $bindSetting = [];
    
    //worker实例
    private $worker;
    
    public function initConsumer($consumer)
    {
        $this->consumer = ucfirst($consumer);

        $this->root = Yii::$app->params['root'];
        
        $this->pidfile = Yii::$app->params['pidfile_root'] . $this->consumer;
        
        $this->bindSetting = Yii::$app->params['C' . $this->consumer];

        $this->setting = Yii::$app->params['rabbitMQ'];

        $this->pids = file_exists($this->pidfile) ? 
            explode(',', file_get_contents($this->pidfile))
            : null;
    }

    /**
     * 启动consumer-worker
     */
    public function actionStart($consumer)
    {
        $this->initConsumer($consumer);

        $pid = pcntl_fork();

        if ($pid == -1) {
            die('could not fork');
        } else if ($pid) {
            // 主进程退出
            exit(0);
        } else {
            // 子进程运行
            // 使当前进程成为守护进程，返回回话id。负责我们已关闭运行这一程序的命令框，该程序就结束运行了，用守护进程可以使程序在后台运行。
            posix_setsid();

            // 当前进程 id 写入文件
            if (file_exists($this->pidfile)){
                file_put_contents($this->pidfile, ',' . posix_getpid(), FILE_APPEND);
            } else {
                file_put_contents($this->pidfile, posix_getpid());
            }

            $this->msgqueue();
        }
    }

    /**
     * 停止consumer-worker
     */
    public function actionStop($consumer)
    {
        $this->initConsumer($consumer);

        if (empty($this->pids)) {
            echo "\n" . 'worker not start' . "\n";
            exit();
        }

        foreach ($this->pids as $pid) 
        {
            // 结束指定进程
            posix_kill($pid, SIGTERM);
        }

        unlink($this->pidfile);

        echo "\n" . 'Stop Success' . "\n";
    }
    
    public function actionRestart($consumer)
    {
        $this->actionStop($consumer);
        sleep(2);
        $this->actionStart($consumer);
    }

    public function msgqueue()
    {
        $conn = new \AMQPConnection($this->setting);

        if (!$conn->connect()) {
            echo "\n" . 'Connect Failed' . "\n";
            exit();
        }

        echo "\n" . 'Connect Success' . "\n";

        $channel = new \AMQPChannel($conn);
        
        $ex = new \AMQPExchange($channel);
        $ex->setName($this->bindSetting['exchange']);
        $ex->setType(AMQP_EX_TYPE_DIRECT);
        $ex->setFlags(AMQP_DURABLE);
        $ex->declareExchange();
        
        $q = new \AMQPQueue($channel);

        $q->setName($this->bindSetting['queue']);
        $q->setFlags(AMQP_DURABLE);
        $q->declareQueue();
        $q->bind(
            $this->bindSetting['exchange'],
            $this->bindSetting['routing']
        );

        if (!file_exists($this->root . '/workers/' . $this->consumer . '.php')) {
            echo "\n" . 'worker does not exist' . "\n";
            exit();
        }

        $workerName = 'rabbitMQ\\workers\\' . $this->consumer;

        $this->worker = new $workerName();

        $channel->qos(0,1);
        $q->consume(array($this->worker, 'run'));

        $conn->disconnect();
    }
}
```

邮件消费推送服务：
```
namespace rabbitMQ\workers;

use Yii;

class Mail 
{
    /** @var  \common\logics\push\MailLogic $mailService */
    private $mailService;

    public function __construct()
    {
        $this->mailService = Yii::$container->get('mailService');
    }

    public function run($envelope, $queue)
    {
        $msg = $envelope->getBody();
        $this->mailService->sendMail($msg);
        Yii::$app->db->close();
        $queue->ack($envelope->getDeliveryTag());
    }
}
```

我们运行多次下面命令，生成多个这一队列的消费者：

> php yii consumer/start mail

需要停止这些消费者，只需要运行一次就可以实现：

> php yii consumer/stop mail

<br/><br/><br/><br/><br/>
### 参考资料

PHP进程及进程间通信 <https://www.cnblogs.com/aksir/p/6777671.html>

Qt 中的多线程技术 <https://zhuanlan.zhihu.com/p/52612180>

PHP 手册 函数参考 进程控制扩展 进程控制 <https://www.php.net/manual/zh/book.pcntl.php>

PHP 手册 函数参考 进程控制扩展 POSIX <https://www.php.net/manual/zh/book.posix.php>

PHP 手册 函数参考 进程控制扩展 pthreads <https://www.php.net/manual/zh/book.pthreads.php>

PHP 线程，进程和并发 <https://blog.csdn.net/qq_36514588/article/details/81868323>

记录PHP的进程和线程理解 <https://www.cnblogs.com/fuwentao/p/9241420.html>

线程和进程的区别是什么？ <https://www.zhihu.com/question/25532384?sort=created>

多线程编程 - PHP 实现 <https://www.cnblogs.com/zhenbianshu/p/7978835.html>

linux环境下多线程编程 <https://zhuanlan.zhihu.com/p/73317603>

认识系统服务 (daemons) <https://www.cnblogs.com/cshaptx4869/p/11115334.html>

深入研究PHP及Zend Engine的线程安全模型 <http://blog.codinglabs.org/articles/zend-thread-safety.html>

"守护进程"（daemon）就是一直在后台运行的进程 <https://www.cnblogs.com/boodoog/p/6043083.html>

【Linux编程】守护进程(daemon)详解与创建 <https://blog.csdn.net/a511244213/article/details/79625801>
