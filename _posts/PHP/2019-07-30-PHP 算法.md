---
layout: post
categories: PHP
title: PHP 算法
meta: 算法
---
* content
{:toc}

### 正文

**什么是算法**

直白地说，算法就是任何明确定义的计算过程，它接收一些值或集合作为输入，并产生一些值或集合作为输出。这样，算法就是将输入转换为输出的一系列计算过程。
来源：Thomas H. Cormen, Chales E. Leiserson (2009), 《算法导论第三版》。

简而言之，我们可以说算法就是用来解决一个特定任务的一系列步骤（是的，不止计算机在使用算法，人类也同样如此）。目前，一个有效的算法应该含有三个重要特性：

- 它必须是有限的：如果你设计的算法永无休止地尝试解决问题，那么它是无用的。
- 它必须具备明确定义的指令：算法的每一步都必须准确定义，在任何场景下指令都应当没有歧义。
- 它必须是有效的：一个算法被设计用以解决某个问题，那么它就应当能解决这个问题，并且仅仅使用纸和笔就能证明该算法是收敛的。

**对数**

log<sub>10</sub>100 相当于问：将多少个10相乘的结果为100？答案当然是2个了。
因此log<sub>10</sub>100=2，即对数运算是幂运算的逆运算：

| left               | right                 |
| ------------------ | --------------------- |
| 2<sup>3</sup> = 8  | log<sub>2</sub>8 = 3  |
| 2<sup>4</sup> = 16 | log<sub>2</sub>16 = 4 |
| 2<sup>5</sup> = 32 | log<sub>2</sub>32 = 5 |
| 2<sup>6</sup> = 64 | log<sub>2</sub>64 = 6 |
| 2<sup>7</sup> = 128 | log<sub>2</sub>128 = 7 |

**运行时间**

以二分查找为例，使用它可节省多少时间呢？简单查找，逐个地检查数字，如果列表包含100个数字，最多需要猜100次。
换而言之最多需要猜测的次数与列表长度相同，这被称为线性时间(linear time)，而二分查找则不同，如果列表包含100个元素，
最多需要7次，如果列表包含40亿个数字，最多需猜32次，二分查找的运行时间为对数时间 `O(log)` 。

**大O表示法**

大O表示法是一种特殊的表示法 ，指出了算法的速度有多快。

在这种情况下，知道这些算法的速度有快有慢：

- 算法的运行时间以不同的速度增加
  - 例如简单查找与二分查找的区别

| 元素                | 简单查找  | 二分查找 |
| ----------------- | ----- | ---- |
| 100个元素            | 100ms | 7ms  |
| 10000个元素          | 10s   | 14ms |
| 1 000 000 000 个元素 | 11天   | 30ms |

- 大O表示法指出了算法有多快，例如列表包含`n`个元素，简单查找需要检查每个元素，因此需要执行`n`次操作。
  使用大`O`表示法，这个运行时间为`O(n)`,二分查找需要执行log<sub>2</sub>n次操作，使用大`O`表示为`O(log n)`

- 一些常见的大O运行时间
  - `O(log n)` ，也叫对数时间，这样的算法包括二分算法。
  - `O(n)` ，也叫线性时间，这样的算法包括简单查找。
  - `O(n * log n)` ，快速排序。
  - O(n<sup>2</sup>) ，选择排序。
  - `O(n!)` ，即阶乘时间。

注意
- 算法的速度指的并非时间，而是操作数的增速
- 谈论算法的速度时间时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加
- 算法的运行时间用大O表示法表示
- `O(log n`)比`O(n)`快，当需要搜索的元素越多时，前者比后者快的越多

**编写解决实际问题的程序过程**

- 如何用数据形式描述问题，即将问题抽象为一个数学模型
- 问题所涉及到的数据量的大小及数据之间的关系
- 如何在计算机中储存数据及体现数据之间的关系
- 处理数据时需要对数据执行的操作
- 编写的程序的性能是否良好

**数据(Data)**

- 数据 ：是客观事物的符号表示，在计算机科学中指的是所有能输入到计算机中并被计算机程序处理的符号的总称。
- 数据元素(Data Element) ：是数据的基本单位，在程序中通常作为一个整体来进行考虑和处理。一个数据元素可由若干个数据项(Data Item)组成。
- 数据项(Data Item) ：是数据的不可分割的最小单位。数据项是对客观事物某一方面特性的数据描述。
- 数据对象(Data Object) ：:是性质相同的数据元素的集合，是数据的一个子集。如字符集合C=`{‘A’,’B’,’C,…}` 。
- 数据结构 ：相互之间具有一定联系的数据元素的集合。
- 数据的逻辑结构 ：数据元素之间的相互关系称为逻辑结构。
- 数据操作 ：对数据要进行的运算。
- 数据类型(Data Type) ：指的是一个值的集合和定义在该值集上的一组操作的总称。

**数据的逻辑结构有四种基本类型**

- 集合 ：结构中数据元素之间除了“属于同一个集合"外,再也没有其他的关系
- 线性结构 ：结构中的数据元素存在一对一的关系
- 树形结构 ：结构中的数据元素存在一对多的关系
- 网状或者图状结构 ：结构中的数据元素存在多对多的关系

**数据结构的储存方式**

由数据元素之间的关系在计算机中有两种不同的表示方法——顺序表示和非顺序表示，从而导出两种储存方式，顺序储存结构和链式储存结构

- 顺序存储结构 ：用数据元素在存储器中的相对位置来表示数据元素之间的逻辑结构(关系)，数据元素存放的地址是连续的
- 链式存储结构 ：在每一个数据元素中增加一个存放另一个元素地址的指针(pointer)，用该指针来表示数据元素之间的逻辑结构(关系)，数据元素存放的地址是否连续没有要求

数据的逻辑结构和物理结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构

**算法(Algorithm)**

是对特定问题求解方法(步骤)的一种描述，是指令的有限序列，其中每一条指令表示一个或多个操作。

> 算法具有以下五个特性

- 有穷性： 一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成
- 确定性：算法中每一条指令必须有确切的含义，不存在二义性，且算法只有一个入口和一个出口
- 可行性： 一个算法是能行的，即算法描述的操作都可以通过已经实现的基本运算执行有限次来实现
- 输入： 一个算法有零个或多个输入，这些输入取自于某个特定的对象集合
- 输出： 一个算法有一个或多个输出，这些输出是同输入有着某些特定关系的量

> 算法和程序是两个不同的概念

一个计算机程序是对一个算法使用某种程序设计语言的具体实现。算法必须可终止意味着不是所有的计算机程序都是算法。

> 评价一个好的算法有以下几个标准

- 正确性(Correctness )： 算法应满足具体问题的需要
- 可读性(Readability)： 算法应容易供人阅读和交流，可读性好的算法有助于对算法的理解和修改
- 健壮性(Robustness)： 算法应具有容错处理，当输入非法或错误数据时，算法应能适当地作出反应或进行处理，而不会产生莫名其妙的输出结果
- 通用性(Generality)： 算法应具有一般性 ，即算法的处理结果对于一般的数据集合都成立

> 效率与存储量需求： 效率指的是算法执行的时间；存储量需求指算法执行过程中所需要的最大存储空间，一般地，这两者与问题的规模有关

**算法的时间复杂度**

算法中基本操作重复执行的次数是问题规模n的某个函数，其时间量度记作`T(n)=O(f(n))`，称作算法的渐近时间复杂度(Asymptotic Time complexity)，简称时间复杂度

**算法的空间复杂度**

是指算法编写成程序后，在计算机中运行时所需存储空间大小的度量，记作：`S(n)=O(f(n))`,其中n为问题规模

**递归和循环的简单比较**

1. 从程序上看，递归表现为自己调用自己，循环则没有这样的形式。
2. 递归是从问题的最终目标出发，逐渐将复杂问题化为简单问题，并且简单的问题的解决思路和复杂问题一样，同时存在基准情况，就能最终求得问题，是逆向的。而循环是从简单问题出发，一步步的向前发展，最终求得问题，是正向的。
3. 任意循环都是可以用递归来表示的，但是想用循环来实现递归（除了单向递归和尾递归），都必须引入栈结构进行压栈出栈。
4. 一般来说，非递归的效率高于递归。而且递归函数调用是有开销的，递归的次数受堆栈大小的限制。

#### 简易结构

用 PHP 的方式实现的各类算法合集：

```
├──Package
│    ├── Sort  排序篇
│    │    ├── BubbleSort.php          冒泡排序
│    │    ├── HeapSort.php            堆排序 
│    │    ├── MBaseSort.php           基数排序 MSD
│    │    ├── LBaseSort.php           基数排序 LSD
│    │    ├── QuickSort.php           快速排序
│    │    ├── ShuttleSort.php         飞梭排序
│    │    ├── ShellSort.php           希尔排序
│    │    ├── MergeSort.php           归并排序
│    │    ├── InsertSort.php          插入排序
│    │    └── SelectSort.php          选择排序
│    │
│    ├── Query 查找篇
│    │    ├── BinaryQuery.php         二分查找
│    │    ├── InseertQuery.php        插入查找
│    │    ├── FibonacciQuery.php      斐波那契查找
│    │    ├── BFSQuery.php            广度优先查找
│         ├── Kmp.php                 算法导论-KMP算法
│         ├── DijkstraQuery.php       迪克斯特拉算法
│    │    └── QulickQuery.php         快速查找
│    │     
│    ├── Structure 数据结构
│    │    ├── StackExample.php         堆栈   先进后出 LIFO (Last In First Out)
│    │    ├── LinearChain.php          线性表 单链存储
│    │    └── LinearOrder.php          线性表 顺序存储
│    │    └── BinarySearchTree.php     二叉搜索树  
│    │     
│    ├── Tools 小工具集
│    │    └──  SystemSwitch.php       堆栈实现进制转换  
│    │  
│    └── Other 其他
│         ├──  MonkeyKing.php         约瑟夫环
│         ├──  DynamicProgramming.php 动态规划
│         ├──  Fibonacci.php          斐波那契数列
│         ├──  StealingApples.php     偷苹果求余
│         ├──  HanoiGames.php         汉诺塔游戏
│         ├──  BidirectionalQueue.php 双向队列
│         ├──  ColorBricks.php        彩色砖块
│         ├──  GetCattle.php          牛年求牛
│         ├──  OnlyNumbers.php        求唯一数
│         ├──  PokerGames.php         洗扑克牌
│         ├──  Interval.php           抽奖区间算法
│         ├──  Maze.php               迷宫寻址算法
│         ├──  AntsClimb.php          蚂蚁爬杆算法
│         ├──  Encryption.php         对称加密算法
│         ├──  ElevatorDispatch.php   编程之美-电梯调度算法
│         ├──  PointInTriangle.php    向量叉集计算点是否在三角形中
│         ├──  TraversalOfBinary.php  二叉树非递归遍历算法实现
│         ├──  Knapsack.php           贪心算法之背包问题实现
│         └──  BigSmallReplace.php    Hello World 输出 Olleh Dlrow
│         └──  Solution.php           Facebook面试题之岛屿周长算法
│         └──  RotationSort.php       Facebook面试题之顺时针回旋算法
│         └──  Square.php             Facebook面试题之判断四个点能否组成正方形算法
│         └──  Prim.php               Prim算法(最小生成树算法)
│         └──  CartesianProduct.php   笛卡尔积算法
│         └──  Square.php             面试题之平面任意四点能否组成一个矩形
│         └──  Judge.php              面试题之扑克牌中任选五张判断是不是顺子
│         └──  Factorial.php          面试题之N的阶乘末尾有多少个0
|         └──  HashTable.php          HashTable
│     
├──LICENSE
└──README.md
```

**当然**
```
用 PHP 实现算法并替代官方提供的函数是愚蠢的事情 .但这并不代表斟酌算法就是件无意义的事 , 每个算法都是一种思想的结晶 , 学习优秀的思想 , 开拓思维, 加油(ง •̀_•́)ง
```

### 排序篇

各种排序算法的时间、空间复杂度、稳定性对比分析：

![]({{site.baseurl}}/images/20210120/20210120145346.jpg)

#### 冒泡排序

冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，
如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端。

说是冒泡，就是小的冒泡上来。
```php
<?php
/**
 * 冒泡排序（数组排序）
 * @param $array
 * @return bool | array
 */
function bubbleSort($array)
{
    $count = count($array);
    if ($count <= 0) {
        return false;
    }
    
    for ($i = 0 ; $i < $count; $i++) {
        for ($j = $count - 1; $j > $i; $j--) {
            if ($array[$j] < $array[$j - 1]) {
                $tmp = $array[$j];
                $array[$j] = $array[$j - 1];
                $array[$j - 1] = $tmp;
            }
        }
    }

    return $array;
}
```

举例：
```php
<?php
$array = array(8, 4, 10, 2, 6);
$array = bubbleSort($array);
print_r($array); // 输出 Array ( [0] => 2 [1] => 4 [2] => 6 [3] => 8 [4] => 10 ) 
```

打印一下过程:
```
0  1  2  3  4  -> 0  1  2  3  4  
// $i = 0
8, 4, 10, 2, 6 -> 8, 4, 10, 2, 6  // $j = 4
8, 4, 10, 2, 6 -> 8, 4, 2, 10, 6  // $j = 3
8, 4, 2, 10, 6 -> 8, 2, 4, 10, 6  // $j = 2
8, 2, 4, 10, 6 -> 2, 8, 4, 10, 6  // $j = 1

// $i = 1
2, 8, 4, 10, 6 -> 2, 8, 4, 6, 10  // $j = 4
2, 8, 4, 6, 10 -> 2, 8, 4, 6, 10  // $j = 3
2, 8, 4, 6, 10 -> 2, 4, 8, 6, 10  // $j = 2

// $i = 2
2, 4, 8, 6, 10 -> 2, 4, 8, 6, 10  // $j = 4
2, 4, 8, 6, 10 -> 2, 4, 6, 8, 10  // $j = 3

// $i = 3
2, 4, 6, 8, 10 -> 2, 4, 6, 8, 10  // $j = 4

// $i = 4
// $j = 4 for循环不进入

// $i = 5 for循环不进入
```

特别说明，里面有两次循环，内层循环的目的是把最小的数向最前面互换，外层循环的目的是把前面已经排好序的数跳过，然后用内层循环继续选择后面最小的数。

总结可以看出，就是小的不断往前排，最小的先到最前面。

这种写法，与上面的本质是一样的：
```
/**
 * bubbleSort
 *
 * @param array $container
 * @return array
 */
function bubbleSort(array $container) {
    $count = count($container);
    for ($i = $count - 1; $i >= 1; $i--) {
        for ($j = $count - 1; $j >= $count - $i; $j--) {
            if ($container[$j] < $container[$j - 1]) {
                $temp = $container[$j];
                $container[$j] = $container[$j - 1];
                $container[$j - 1] = $temp;
            }
        }
    }
    
    return $container;
}
```

还有下面这种沉底的算法，前后两个数比较，把大的数交换到下面，循环一轮后，最大的数就到最底部了。
下一轮循环就没有必要对刚才沉到最底部的数字进行比较，以此类推得到最终排序。
```
/**
 * bubbleSort
 *
 * @param array $container
 * @return array
 */
function bubbleSort(array $container)
{
    $count = count($container);
    for ($j = 1; $j < $count; $j++) {
        for ($i = 0; $i < $count - $j; $i++) {
            if ($container[$i] > $container[$i + 1]) {
                $temp = $container[$i];
                $container[$i] = $container[$i + 1];
                $container[$i + 1] = $temp;
            }
        }
    }
    
    return $container;
}
```

#### 快速排序

快速排序（Quicksort）是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，
其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，
整个排序过程可以递归进行，以此达到整个数据变成有序序列。

快速排序的思路是选取一个基准，然后逐个对比，比基准小的放左边，比基准大的放右边，
使用递归（recursive）再分别对比分割后的左右小集群，不断缩小对比范围，最后合并返回。

```
/**
 * QuickSort
 *
 * @param array $container
 * @return array
 */
function QuickSort(array $container)
{
    $count = count($container);
    if ($count <= 1) { 
        // 基线条件为空或者只包含一个元素，只需要原样返回数组
        return $container;
    }
    
    $pivot = $container[0]; // 基准值 pivot
    $left  = $right = [];
    
    for ($i = 1; $i < $count; $i++) {
        if ($container[$i] < $pivot) {
            $left[] = $container[$i];
        } else {
            $right[] = $container[$i];
        }
    }
    $left  = QuickSort($left);
    $right = QuickSort($right);
    
    return array_merge($left, [$container[0]], $right);
}
```

快速排序使用分而治之【 divide and conquer,D&C 】的策略，是一种解决问题的思路，D&C 解决问题的过程包括两个步骤：
1. 找出基线条件，这种条件必须尽可能简单
2. 不断将问题分解（或者说缩小规模），直到符合基线条件

举例：

```php
$array = array(8, 4, 10, 2, 6);
$array = QuickSort($array);
print_r($array); // 输出 Array ( [0] => 2 [1] => 4 [2] => 6 [3] => 8 [4] => 10 ) 
```

打印一下过程：
```
Array ( [0] => 8 [1] => 4 [2] => 10 [3] => 2 [4] => 6 )
Array ( [0] => 4 [1] => 2 [2] => 6 )
Array ( [0] => 2 )
Array ( [0] => 6 )
Array ( [0] => 10 ) 
```

特别说明，里面用到了递归，核心思想是取一个数，划分左右，不断缩小，不断合并，然后排序完成。

#### 插入排序

插入排序基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，
时间复杂度为O(n^2)。是稳定的排序方法。插入排序的基本思想是：每步将一个待排序的纪录，按其关键码值的大小插入前面已经排序的文件中适当位置上，
直到全部插入完为止。

插入排序的思路是每次往后走一步，对前面的数字进行排序，因为前面数字已经排好序，所以这一次只要把新加入进来的数字找到目标位置插入进去就好了。
如此，直到最后一步。

```
/**
 * InsertSort
 *
 * @param array $container
 * @return array
 */
function InsertSort(array $container)
{
    $count = count($container);
    if ($count <= 0) {
        return false;
    }
    
    for($i = 1; $i < $count; $i++) {
        $j = $i;
        while ($j >= 1) {
            if ($container[$j] < $container[$j -1]) {
                $temp = $container[$j - 1];
                $container[$j -1] = $container[$j];
                $container[$j] = $temp;
            } else {
                break;
            }

            $j--;
        }
        
    }

    return $container;
}
```

同样的原理，只是把while换成了for：
```
function InsertSort($array) {
    $count = count($array);
    if ($count <= 0) {
        return false;
    }
    
    for($i = 1 ; $i < $count; $i++) {
        for($j = $i; $j >= 1; $j--) {
            if ($array[$j] < $array[$j - 1]) {
                $tmp = $array[$j - 1];
                $array[$j - 1] = $array[$j];
                $array[$j] = $tmp;
            } else {
                break;
            }
        }
    }

    return $array;
}
```

还有这种思路，与上面细微差别是先确定这个数的具体位置，后加入这个位置，优点是赋值次数减少，提升运算效率：
```
function InsertSort(array $container) {
    $count = count($container);
    for ($i = 1; $i < $count; $i++) {
        $temp = $container[$i];
        $j    = $i - 1;
        while ($j >= 0 && $container[$j] > $temp) {
            $container[$j+1] = $container[$j];
            $j--;
        }
        if ($i != $j+1) {
            $container[$j+1] = $temp;
        }
    }
    
    return $container;
}
```

#### 希尔排序

希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。
希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，
当增量减至1时，整个文件恰被分成一组，算法便终止。

![]({{site.baseurl}}/images/20210121/20210121110909.png)

```
/**
 * ShellSort
 *
 * @param array $container
 * @return array
 */
function ShellSort(array $container)
{
    $count = count($container);
    for ($increment = intval($count / 2); $increment > 0; $increment = intval($increment / 2)) {
        for ($i = $increment; $i < $count; $i++) {
            $temp = $container[$i];
            for ($j = $i; $j >= $increment; $j -= $increment) {
                if ($temp < $container[$j - $increment]) {
                    $container[$j] = $container[$j - $increment];
                } else {
                    break;
                }
            }
            $container[$j] = $temp;
        }
    }
    return $container;
}
```

#### 选择排序

选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，
存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。

选择排序的思路是，从左边开始寻找最小的数交换位置，这样最左边这个数就是最小的，接下来再看第二位应该放的数字，依次向右前进，
直到最后一位完成数字从小到大排序。

```
/**
 * SelectSort
 *
 * @param array $container
 * @return array
 */
function SelectSort(array $container)
{
    $count = count($container);
    for ($i = 0; $i < $count; $i++){
        $k = $i;
        for ($j = $i + 1; $j < $count; $j++){
            if($container[$j] < $container[$k]){
                $k = $j;
            }
        }
        if($k != $i){
            $temp          = $container[$i];
            $container[$i] = $container[$k];
            $container[$k] = $temp;
        }
    }
    return $container;
}
```

选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。

#### 堆排序

堆(heap)是计算机科学中一类特殊的数据结构的统称，通常是一个可以被看做一棵树的数组对象。

关于堆：
* 堆总是一棵完全二叉树（下面）：
* 堆中某个节点的值总是不大于或不小于其父节点的值；
* 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。

数据结构：
```
# 从1开始
堆 {k1,k2,ki,…,kn}  {ki <= k2i, ki <= k(2i+1)} | {ki >= k2i, ki >= (k2i+1)},  (i = 1,2,3,4...n/2)
# 从0开始
堆 {k0,k1,k2,ki,…,kn}  {ki <= k(2i+1), ki <= k(2i+2)} | {ki >= k(2i+1), ki >= k(2i+2)},  (i = 0,1,2,3,4...[ceil(n/2)-1])
```

**完全二叉树** 除最后一层外，每一层上的节点数均达到最大值；在最后一层上只缺少右边的若干结点。

小根堆实现图：

![]({{site.baseurl}}/images/20210116/20210116145347.jpg)

**堆排序算法**：堆排序就是利用堆进行排序的方法，它的基本思想是（假设利用大根堆）：将待排序的序列构造成一个大根堆。
此时，整个序列的最大值就是堆顶的根节点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），
然后将剩余的 n - 1 个序列重新构造成一个堆，这样就会得到 n 个元素中的次小的值。如此反复执行，便能得到一个有序序列了。

因为建堆的时间复杂度是 `O(n)`（调用一次）；调整堆的时间复杂度是 `logn`，调用了 n-1 次；总体上来说，堆排序的时间复杂度是 `O(nlogn)`。

大根堆排序类：
```php
<?php
class heapSort
{
    /**
     * @var int
     */
    protected $count;
    
    /**
     * @var array
     */
    protected $data;
    
    /**
     * HeapSort constructor.
     *
     * @param array $data
     */
    public function __construct(array $data){
        $this->count = count($data);
        $this->data  = $data;
    }
    
    /**
     * Action
     *
     * @return array
     */
    public function run() {
        $this->createHeap();
        while ($this->count > 0) {
            /* 这是一个大顶堆 , 所以堆顶的节点必须是最大的，根据此特点 , 每次都将堆顶数据移到最后一位，然后对剩余数据节点再次建造堆就可以 */
            $this->swap($this->data[0], $this->data[--$this->count]);
            $this->buildHeap($this->data, 0, $this->count);
        }
        return $this->data;
    }
    
    /**
     * 创建一个堆
     */
    public function createHeap() {
        $i = floor($this->count / 2) + 1;
        while ($i--) {
            $this->buildHeap($this->data, $i, $this->count);
        }
    }
    
    /**
     * 从 数组 的第 $i 个节点开始至 数组长度为0 结束 , 递归的将其 ( 包括其子节点 ) 转化为一个大顶堆
     *
     * @param $data
     * @param $i
     * @param $count
     */
    public function buildHeap(array &$data, $i, $count) {
        if (false === $i < $count) {
            return;
        }
        // 获取左 / 右节点
        $right = ($left = 2 * $i + 1) + 1;
        $max   = $i;
        // 如果左子节点大于当前节点 , 那么记录左节点键名
        if ($left < $count && $data[$i] < $data[$left]) {
            $max = $left;
        }
        // 如果右节点大于刚刚记录的 $max , 那么再次交换
        if ($right < $count && $data[$max] < $data[$right]) {
            $max = $right;
        }
        if ($max !== $i && $max < $count) {
            $this->swap($data[$i], $data[$max]);
            $this->buildHeap($data, $max, $count);
        }
    }
    
    /**
     * 交换空间
     *
     * @param $left
     * @param $right
     */
    public function swap(&$left, &$right) {
        list($left, $right) = array ($right, $left);
    }
}
```

示例：
```
$array  = array (4, 21, 41, 2, 53, 1, 213, 31, 21, 423, 56);
$result = (new heapSort($array))->run();
print_r($result);
```

#### 归并排序

归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。
将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。

![]({{site.baseurl}}/images/20210120/20210120145344.png)

```
class MergeSort
{
    /**
     * MergeSort constructor.
     * 是开始递归函数的一个驱动函数
     *
     * @param array $arr 待排序的数组
     */
    public function __construct(array $arr)
    {
        $this->mSort($arr, 0, count($arr) - 1);
        var_dump($arr);
    }
    /**
     * 实际实现归并排序的程序
     *
     * @param $arr     array   需要排序的数组
     * @param $left    int     子序列的左下标值
     * @param $right   int     子序列的右下标值
     */
    public function mSort(&$arr, $left, $right)
    {
        if ($left < $right) {
            //说明子序列内存在多余1个的元素，那么需要拆分，分别排序，合并
            //计算拆分的位置，长度/2 去整
            $center = floor(($left + $right) / 2);
            //递归调用对左边进行再次排序：
            $this->mSort($arr, $left, $center);
            //递归调用对右边进行再次排序
            $this->mSort($arr, $center + 1, $right);
            //合并排序结果
            $this->mergeArray($arr, $left, $center, $right);
        }
    }
    /**
     * 将两个有序数组合并成一个有序数组
     *
     * @param &$arr   , 待排序的所有元素
     * @param $left   , 排序子数组A的开始下标
     * @param $center , 排序子数组A与排序子数组B的中间下标，也就是数组A的结束下标
     * @param $right  , 排序子数组B的结束下标（开始为$center+1)
     */
    public function mergeArray(&$arr, $left, $center, $right)
    {
        echo '| ' . $left . ' - ' . $center . ' - ' . $right . ' - ' . implode(',', $arr) . PHP_EOL;
        //设置两个起始位置标记
        $a_i  = $left;
        $b_i  = $center + 1;
        $temp = [];
        while ($a_i <= $center && $b_i <= $right) {
            //当数组A和数组B都没有越界时
            if ($arr[ $a_i ] < $arr[ $b_i ]) {
                $temp[] = $arr[ $a_i++ ];
            } else {
                $temp[] = $arr[ $b_i++ ];
            }
        }
        //判断 数组A内的元素是否都用完了，没有的话将其全部插入到C数组内：
        while ($a_i <= $center) {
            $temp[] = $arr[ $a_i++ ];
        }
        //判断 数组B内的元素是否都用完了，没有的话将其全部插入到C数组内：
        while ($b_i <= $right) {
            $temp[] = $arr[ $b_i++ ];
        }
        //将$arrC内排序好的部分，写入到$arr内：
        for ($i = 0, $len = count($temp); $i < $len; $i++) {
            $arr[ $left + $i ] = $temp[ $i ];
        }
    }
}
```

#### 飞梭排序

```
/**
 * ShuttleSort
 *
 * @param array $data
 * @return array
 */
function ShuttleSort(array $data)
{
    /**
     * 替换方法
     *
     * @param array $data
     * @param       $i
     * @param       $j
     * @return array
     */
    $swap = function (array &$data, $i, $j) {
        $temp     = $data[$i];
        $data[$i] = $data[$j];
        $data[$j] = $temp;
        return $data;
    };
    $count = count($data);
    $left  = 0;
    $right = $count - 1;
    while ($left < $right) {
        // 从左到右
        $lastRight = 0;
        for ($i = $left; $i < $right; $i++) {
            if ($data[$i] > $data[$i + 1]) {
                $swap($data, $i, 1 + $i);
                $lastRight = $i;
            }
        }
        $right = $lastRight;
        // 从右到左
        $lastLeft = 0;
        for ($j = $right; $left < $j; $j--) {
            if ($data[$j - 1] > $data[$j]) {
                $swap($data, $j - 1, $j);
                $lastLeft = $j;
            }
        }
        $left = $lastLeft;
    }
    return $data;
}
```

#### 中文排序实现

```
class ChineseTextNumberSort
{
    /**
     * @var string text
     */
    const CHINESE_DIGITAL_MATCHING = '/\x{96f6}|\x{4e00}|\x{4e8c}|\x{4e09}|\x{56db}|\x{4e94}|\x{516d}|\x{4e03}|\x{516b}|\x{4e5d}|\x{5341}/ui';
    
    /**
     * @var string  regular rules [! order can not arbitrarily change]
     */
    const MODEL_REGULAR_A = <<<REGEXPS
/^\x{7b2c}(\x{4e00}|\x{4e8c}|\x{4e09}|\x{56db}|\x{4e94}|\x{516d}|\x{4e03}|\x{516b}|\x{4e5d}|\x{5341}){1}(\x{7ae0}|\x{8282}|\x{8bfe}|\x{5355}\x{5143})([\f\n\r\t\v]|\x09|\s){1}+/u
REGEXPS;
    const MODEL_REGULAR_D = '/^(\d{1,2})(\x{9875})\-{1}/u';
    const MODEL_REGULAR_E = '/^(\d{1,2})\-/i';
    const MODEL_REGULAR_F = '/^(\d{1,2})([\f\n\r\t\v]|\x09|\s)+/i';
    const MODEL_REGULAR_G = '/^(\d{1,2})(\x{3001}{1})+/u';
    const MODEL_REGULAR_H = '/\x{518c}(\d{1,2})(\s){1}(\x{ff1a}|\:){1}/u';
    const MODEL_REGULAR_I = '/([\f\n\r\t\v]|\x09|\s){1}(\d+)/i';
    const MODEL_REGULAR_B = '/^\d{1,2}+/i';
    const MODEL_REGULAR_C = '/^\d{1,2}([\f\n\r\t\v]|\x09|\s){1}+/i';
    
    /**
     * 解析文本到十位
     *
     * @param $text
     * @return false|float|int|string
     */
    public function parsingText($text)
    {
        $structure = '';
        $mapping   = array ('零', '一', '二', '三', '四', '五', '六', '七', '八', '九', '十');
        preg_match_all(static::CHINESE_DIGITAL_MATCHING, $text, $structure, PREG_PATTERN_ORDER);
        if (empty($structure[0])) {
            return 0;
        }
        $currentNum = 0;
        foreach ($structure[0] as $plane => $matchNum) {
            if ($matchNum === '十') {
                if ($plane === 0) {
                    $currentNum += 10;
                    continue;
                }
                if ($plane === 1) {
                    $index      = array_search($structure[0][0], $mapping);
                    $currentNum -= $index;
                    $currentNum += $index * 10;
                    continue;
                }
            }
            $index      = array_search($matchNum, $mapping);
            $currentNum += $index;
        }
        return $currentNum;
    }
    
    /**
     * isChinese
     *
     * @param $text
     * @return bool
     */
    public function isCompletelyChinese($text)
    {
        return boolval(preg_match('/^[\x7f-\xff]+$/', $text));
    }
    
    /**
     * regularModel
     *
     * @param $regularModel
     * @param $text
     * @return bool
     */
    public function regularModel($regularModel, $text)
    {
        return boolval(preg_match($regularModel, $text));
    }
    
    /**
     * extractModel
     *
     * @param $regularModel
     * @param $text
     * @return string
     * @throws \Exception
     */
    public function extractModel($regularModel, $text)
    {
        $result = '';
        if (preg_match($regularModel, $text, $result)) {
            return trim($result[$this->modelMappingIndex($regularModel)]);
        }
        throw new Exception('The matching error');
    }
    
    /**
     * modelMappingIndex
     *
     * @param $regularModel
     * @return int|mixed
     */
    protected function modelMappingIndex($regularModel)
    {
        return array (
                   static::MODEL_REGULAR_A => 1,
                   static::MODEL_REGULAR_B => 0,
                   static::MODEL_REGULAR_C => 0,
                   static::MODEL_REGULAR_D => 1,
                   static::MODEL_REGULAR_E => 1,
                   static::MODEL_REGULAR_F => 1,
                   static::MODEL_REGULAR_G => 1,
                   static::MODEL_REGULAR_H => 1,
                   static::MODEL_REGULAR_I => 2
               )[$regularModel] ?? 1;
    }
    
    /**
     * chineseConversionNum
     *
     * @param $text
     * @return mixed
     */
    public function chineseConversionNum($text)
    {
        if ($this->regularModel(static::CHINESE_DIGITAL_MATCHING, $text)) {
            $mapping = array ('零', '一', '二', '三', '四', '五', '六', '七', '八', '九', '十');
            return array_search($text, $mapping);
        }
        return ltrim($text, 0);
    }
    
    /**
     * getAllModelRegular
     *
     * @return array
     * @throws \ReflectionException
     */
    public function getAllModelRegular()
    {
        $constants  = (new \ReflectionClass(__CLASS__))->getConstants();
        $collection = array ();
        foreach ($constants as $key => $value) {
            if (strpos($key, 'MODEL_REGULAR_') !== false) {
                $collection[$key] = $value;
            }
        }
        return $collection;
    }
    
    /**
     * modelAnalysis
     *
     * @param $text
     * @return int|string
     * @throws \ReflectionException
     */
    public function modelAnalysis($text)
    {
        foreach ($this->getAllModelRegular() as $item) {
            if ($this->regularModel($item, $text)) {
                return $item;
            }
        }
        throw new Exception('Model Analysis of the failure !');
    }
    
    /**
     * textAnalysis
     *
     * @param $text
     * @return int
     */
    public function textAnalysis($text)
    {
        try {
            return (int)$this->chineseConversionNum($this->extractModel(
                $this->modelAnalysis($text),
                $text
            )
            );
        } catch (Exception $e) {
            return 0;
        }
    }
    
    /**
     * chineseTextList
     *
     * @param array $list
     * @return array
     */
    public function chineseTextListSorter(array $list)
    {
        $container = $generate = array ();
        foreach ($list as $item) {
            $container[] = $this->textAnalysis($item);
        }
        if (count($container) !== count($list)) {
            return $list;
        }
        uksort($list, function ($left, $right) use ($container) {
            if ($left == $right) {
                return 0;
            }
            return $container[$left] < $container[$right] ? -1 : 1;
        });
        return array_values($list);
    }
}
```

### 查找篇

### 数据结构

### 小工具集

### 其他

<br/><br/><br/><br/><br/>
### 参考资料

用 PHP 的方式实现的各类算法合集 <https://github.com/m9rco/algorithm-php>

PHP实现八大算法 <https://www.cnblogs.com/zixuanfy/p/7617451.html>

PHP的基本算法合集 <https://www.php.cn/php-weizijiaocheng-394062.html>

PHP算法 <https://www.jianshu.com/p/cb2ad99029c8>

php数据结构和算法 <https://www.csdn.net/gather_21/MtTacg3sMzkxNy1ibG9n.html>

七大常用PHP算法 <http://www.sohu.com/a/118661179_468191> 

堆排序算法与PHP实现 <https://www.cnblogs.com/iampeter/p/3223487.html>

PHP实现排序算法----堆排序（Heap Sort） <https://blog.csdn.net/baidu_30000217/article/details/53087079>

PHP实现堆排序 <https://www.cnblogs.com/zhenbianshu/p/5273995.html>
