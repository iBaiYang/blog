---
layout: post
categories: PHP
title: PHP 算法
meta: 算法
---
* content
{:toc}

### 正文

**什么是算法**

直白地说，算法就是任何明确定义的计算过程，它接收一些值或集合作为输入，并产生一些值或集合作为输出。这样，算法就是将输入转换为输出的一系列计算过程。
来源：Thomas H. Cormen, Chales E. Leiserson (2009), 《算法导论第三版》。

简而言之，我们可以说算法就是用来解决一个特定任务的一系列步骤（是的，不止计算机在使用算法，人类也同样如此）。目前，一个有效的算法应该含有三个重要特性：

- 它必须是有限的：如果你设计的算法永无休止地尝试解决问题，那么它是无用的。
- 它必须具备明确定义的指令：算法的每一步都必须准确定义，在任何场景下指令都应当没有歧义。
- 它必须是有效的：一个算法被设计用以解决某个问题，那么它就应当能解决这个问题，并且仅仅使用纸和笔就能证明该算法是收敛的。

**对数**

log<sub>10</sub>100 相当于问：将多少个10相乘的结果为100？答案当然是2个了。
因此log<sub>10</sub>100=2，即对数运算是幂运算的逆运算：

| left               | right                 |
| ------------------ | --------------------- |
| 2<sup>3</sup> = 8  | log<sub>2</sub>8 = 3  |
| 2<sup>4</sup> = 16 | log<sub>2</sub>16 = 4 |
| 2<sup>5</sup> = 32 | log<sub>2</sub>32 = 5 |
| 2<sup>6</sup> = 64 | log<sub>2</sub>64 = 6 |
| 2<sup>7</sup> = 128 | log<sub>2</sub>128 = 7 |

**运行时间**

以二分查找为例，使用它可节省多少时间呢？简单查找，逐个地检查数字，如果列表包含100个数字，最多需要猜100次。
换而言之最多需要猜测的次数与列表长度相同，这被称为线性时间(linear time)，而二分查找则不同，如果列表包含100个元素，
最多需要7次，如果列表包含40亿个数字，最多需猜32次，二分查找的运行时间为对数时间 `O(log)` 。

**大O表示法**

大O表示法是一种特殊的表示法 ，指出了算法的速度有多快。

在这种情况下，知道这些算法的速度有快有慢：

- 算法的运行时间以不同的速度增加
  - 例如简单查找与二分查找的区别

| 元素                | 简单查找  | 二分查找 |
| ----------------- | ----- | ---- |
| 100个元素            | 100ms | 7ms  |
| 10000个元素          | 10s   | 14ms |
| 1 000 000 000 个元素 | 11天   | 30ms |

- 大O表示法指出了算法有多快，例如列表包含`n`个元素，简单查找需要检查每个元素，因此需要执行`n`次操作。
  使用大`O`表示法，这个运行时间为`O(n)`,二分查找需要执行log<sub>2</sub>n次操作，使用大`O`表示为`O(log n)`

- 一些常见的大O运行时间
  - `O(log n)` ，也叫对数时间，这样的算法包括二分算法。
  - `O(n)` ，也叫线性时间，这样的算法包括简单查找。
  - `O(n * log n)` ，快速排序。
  - O(n<sup>2</sup>) ，选择排序。
  - `O(n!)` ，即阶乘时间。

注意
- 算法的速度指的并非时间，而是操作数的增速
- 谈论算法的速度时间时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加
- 算法的运行时间用大O表示法表示
- `O(log n`)比`O(n)`快，当需要搜索的元素越多时，前者比后者快的越多

**编写解决实际问题的程序过程**

- 如何用数据形式描述问题，即将问题抽象为一个数学模型
- 问题所涉及到的数据量的大小及数据之间的关系
- 如何在计算机中储存数据及体现数据之间的关系
- 处理数据时需要对数据执行的操作
- 编写的程序的性能是否良好

**数据(Data)**

- 数据 ：是客观事物的符号表示，在计算机科学中指的是所有能输入到计算机中并被计算机程序处理的符号的总称。
- 数据元素(Data Element) ：是数据的基本单位，在程序中通常作为一个整体来进行考虑和处理。一个数据元素可由若干个数据项(Data Item)组成。
- 数据项(Data Item) ：是数据的不可分割的最小单位。数据项是对客观事物某一方面特性的数据描述。
- 数据对象(Data Object) ：:是性质相同的数据元素的集合，是数据的一个子集。如字符集合C=`{‘A’,’B’,’C,…}` 。
- 数据结构 ：相互之间具有一定联系的数据元素的集合。
- 数据的逻辑结构 ：数据元素之间的相互关系称为逻辑结构。
- 数据操作 ：对数据要进行的运算。
- 数据类型(Data Type) ：指的是一个值的集合和定义在该值集上的一组操作的总称。

**数据的逻辑结构有四种基本类型**

- 集合 ：结构中数据元素之间除了“属于同一个集合"外,再也没有其他的关系
- 线性结构 ：结构中的数据元素存在一对一的关系
- 树形结构 ：结构中的数据元素存在一对多的关系
- 网状或者图状结构 ：结构中的数据元素存在多对多的关系

**数据结构的储存方式**

由数据元素之间的关系在计算机中有两种不同的表示方法——顺序表示和非顺序表示，从而导出两种储存方式，顺序储存结构和链式储存结构

- 顺序存储结构 ：用数据元素在存储器中的相对位置来表示数据元素之间的逻辑结构(关系)，数据元素存放的地址是连续的
- 链式存储结构 ：在每一个数据元素中增加一个存放另一个元素地址的指针(pointer)，用该指针来表示数据元素之间的逻辑结构(关系)，数据元素存放的地址是否连续没有要求

数据的逻辑结构和物理结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构

**算法(Algorithm)**

是对特定问题求解方法(步骤)的一种描述，是指令的有限序列，其中每一条指令表示一个或多个操作。

> 算法具有以下五个特性

- 有穷性： 一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成
- 确定性：算法中每一条指令必须有确切的含义，不存在二义性，且算法只有一个入口和一个出口
- 可行性： 一个算法是能行的，即算法描述的操作都可以通过已经实现的基本运算执行有限次来实现
- 输入： 一个算法有零个或多个输入，这些输入取自于某个特定的对象集合
- 输出： 一个算法有一个或多个输出，这些输出是同输入有着某些特定关系的量

> 算法和程序是两个不同的概念

一个计算机程序是对一个算法使用某种程序设计语言的具体实现。算法必须可终止意味着不是所有的计算机程序都是算法。

> 评价一个好的算法有以下几个标准

- 正确性(Correctness )： 算法应满足具体问题的需要
- 可读性(Readability)： 算法应容易供人阅读和交流，可读性好的算法有助于对算法的理解和修改
- 健壮性(Robustness)： 算法应具有容错处理，当输入非法或错误数据时，算法应能适当地作出反应或进行处理，而不会产生莫名其妙的输出结果
- 通用性(Generality)： 算法应具有一般性 ，即算法的处理结果对于一般的数据集合都成立

> 效率与存储量需求： 效率指的是算法执行的时间；存储量需求指算法执行过程中所需要的最大存储空间，一般地，这两者与问题的规模有关

**算法的时间复杂度**

算法中基本操作重复执行的次数是问题规模n的某个函数，其时间量度记作`T(n)=O(f(n))`，称作算法的渐近时间复杂度(Asymptotic Time complexity)，简称时间复杂度

**算法的空间复杂度**

是指算法编写成程序后，在计算机中运行时所需存储空间大小的度量，记作：`S(n)=O(f(n))`,其中n为问题规模

**递归和循环的简单比较**

1. 从程序上看，递归表现为自己调用自己，循环则没有这样的形式。
2. 递归是从问题的最终目标出发，逐渐将复杂问题化为简单问题，并且简单的问题的解决思路和复杂问题一样，同时存在基准情况，就能最终求得问题，是逆向的。而循环是从简单问题出发，一步步的向前发展，最终求得问题，是正向的。
3. 任意循环都是可以用递归来表示的，但是想用循环来实现递归（除了单向递归和尾递归），都必须引入栈结构进行压栈出栈。
4. 一般来说，非递归的效率高于递归。而且递归函数调用是有开销的，递归的次数受堆栈大小的限制。

#### 简易结构

用 PHP 的方式实现的各类算法合集：

```
├──Package
│    ├── Sort  排序篇
│    │    ├── BubbleSort.php          冒泡排序
│    │    ├── HeapSort.php            堆排序 
│    │    ├── MBaseSort.php           基数排序 MSD
│    │    ├── LBaseSort.php           基数排序 LSD
│    │    ├── QuickSort.php           快速排序
│    │    ├── ShuttleSort.php         飞梭排序
│    │    ├── ShellSort.php           希尔排序
│    │    ├── MergeSort.php           归并排序
│    │    ├── InsertSort.php          插入排序
│    │    └── SelectSort.php          选择排序
│    │
│    ├── Query 查找篇
│    │    ├── BinaryQuery.php         二分查找
│    │    ├── InsertQuery.php        插入查找
│    │    ├── FibonacciQuery.php      斐波那契查找
│    │    ├── BFSQuery.php            广度优先查找
│         ├── Kmp.php                 算法导论-KMP算法
│         ├── DijkstraQuery.php       迪克斯特拉算法
│    │    └── QulickQuery.php         快速查找
│    │     
│    ├── Structure 数据结构
│    │    ├── StackExample.php         堆栈   先进后出 LIFO (Last In First Out)
│    │    ├── LinearChain.php          线性表 单链存储
│    │    └── LinearOrder.php          线性表 顺序存储
│    │    └── BinarySearchTree.php     二叉搜索树  
│    │     
│    ├── Tools 小工具集
│    │    └──  SystemSwitch.php       堆栈实现进制转换  
│    │  
│    └── Other 其他
│         ├──  MonkeyKing.php         约瑟夫环
│         ├──  DynamicProgramming.php 动态规划
│         ├──  Fibonacci.php          斐波那契数列
│         ├──  StealingApples.php     偷苹果求余
│         ├──  HanoiGames.php         汉诺塔游戏
│         ├──  BidirectionalQueue.php 双向队列
│         ├──  ColorBricks.php        彩色砖块
│         ├──  GetCattle.php          牛年求牛
│         ├──  OnlyNumbers.php        求唯一数
│         ├──  PokerGames.php         洗扑克牌
│         ├──  Interval.php           抽奖区间算法
│         ├──  Maze.php               迷宫寻址算法
│         ├──  AntsClimb.php          蚂蚁爬杆算法
│         ├──  Encryption.php         对称加密算法
│         ├──  ElevatorDispatch.php   编程之美-电梯调度算法
│         ├──  PointInTriangle.php    向量叉集计算点是否在三角形中
│         ├──  TraversalOfBinary.php  二叉树非递归遍历算法实现
│         ├──  Knapsack.php           贪心算法之背包问题实现
│         └──  BigSmallReplace.php    Hello World 输出 Olleh Dlrow
│         └──  Solution.php           Facebook面试题之岛屿周长算法
│         └──  RotationSort.php       Facebook面试题之顺时针回旋算法
│         └──  Square.php             Facebook面试题之判断四个点能否组成正方形算法
│         └──  Prim.php               Prim算法(最小生成树算法)
│         └──  CartesianProduct.php   笛卡尔积算法
│         └──  Square.php             面试题之平面任意四点能否组成一个矩形
│         └──  Judge.php              面试题之扑克牌中任选五张判断是不是顺子
│         └──  Factorial.php          面试题之N的阶乘末尾有多少个0
|         └──  HashTable.php          HashTable
│     
├──LICENSE
└──README.md
```

**当然**
```
用 PHP 实现算法并替代官方提供的函数是愚蠢的事情 .但这并不代表斟酌算法就是件无意义的事 , 每个算法都是一种思想的结晶 , 学习优秀的思想 , 开拓思维, 加油(ง •̀_•́)ง
```

数组转换相关函数：`is_array()`, `explode()`, `implode()`, `split()`, `preg_split()`, `unset()`。

[对数组进行排序](https://www.php.net/manual/zh/array.sorting.php) PHP官方 排序函数属性：

| 函数名称 	| 排序依据 	| 数组索引键保持 	| 排序的顺序 	| 相关函数 |
| ----- | ----- | ---- | ---- | ---- |
| array_multisort() 	| 值 	| 键值关联的保持，数字类型的不保持 	| 第一个数组或者由选项指定 	| array_walk() | 
| asort() 	| 值 	| 是 	| 由低到高 	| arsort() | 
| arsort() 	| 值 	| 是 	| 由高到低 	| asort() | 
| krsort() 	| 键 	| 是 	| 由高到低 	| ksort() | 
| ksort() 	| 键 	| 是 	| 由低到高 	| asort() | 
| natcasesort() 	| 值 	| 是 	| 自然排序，大小写不敏感 	| natsort() | 
| natsort() 	| 值 	| 是 	| 自然排序 	| natcasesort() | 
| rsort() 	| 值 	| 否 	| 由高到低 	| sort() | 
| shuffle() 	值 	| 否 	| 随机 	| array_rand() |
| sort() 	| 值 	| 否 	| 由低到高 	| rsort() | 
| uasort() 	| 值 	| 是 	| 由用户定义 	| uksort() | 
| uksort() 	| 键 	| 是 	| 由用户定义 	| uasort() | 
| usort() 	| 值 	| 否 	| 由用户定义 	| uasort() |

### 排序篇

各种排序算法的时间、空间复杂度、稳定性对比分析：

![]({{site.baseurl}}/images/20210120/20210120145346.jpg)

#### 冒泡排序

冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，
如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端。

说是冒泡，就是小的冒泡上来。
```php
<?php
/**
 * 冒泡排序（数组排序）
 * @param $array
 * @return bool | array
 */
function bubbleSort($array)
{
    $count = count($array);
    if ($count <= 0) {
        return false;
    }
    
    for ($i = 0 ; $i < $count; $i++) {
        for ($j = $count - 1; $j > $i; $j--) {
            if ($array[$j] < $array[$j - 1]) {
                $tmp = $array[$j];
                $array[$j] = $array[$j - 1];
                $array[$j - 1] = $tmp;
            }
        }
    }

    return $array;
}
```

举例：
```php
<?php
$array = array(8, 4, 10, 2, 6);
$array = bubbleSort($array);
print_r($array); // 输出 Array ( [0] => 2 [1] => 4 [2] => 6 [3] => 8 [4] => 10 ) 
```

打印一下过程:
```
0  1  2  3  4  -> 0  1  2  3  4  
// $i = 0
8, 4, 10, 2, 6 -> 8, 4, 10, 2, 6  // $j = 4
8, 4, 10, 2, 6 -> 8, 4, 2, 10, 6  // $j = 3
8, 4, 2, 10, 6 -> 8, 2, 4, 10, 6  // $j = 2
8, 2, 4, 10, 6 -> 2, 8, 4, 10, 6  // $j = 1

// $i = 1
2, 8, 4, 10, 6 -> 2, 8, 4, 6, 10  // $j = 4
2, 8, 4, 6, 10 -> 2, 8, 4, 6, 10  // $j = 3
2, 8, 4, 6, 10 -> 2, 4, 8, 6, 10  // $j = 2

// $i = 2
2, 4, 8, 6, 10 -> 2, 4, 8, 6, 10  // $j = 4
2, 4, 8, 6, 10 -> 2, 4, 6, 8, 10  // $j = 3

// $i = 3
2, 4, 6, 8, 10 -> 2, 4, 6, 8, 10  // $j = 4

// $i = 4
// $j = 4 for循环不进入

// $i = 5 for循环不进入
```

特别说明，里面有两次循环，内层循环的目的是把最小的数向最前面互换，外层循环的目的是把前面已经排好序的数跳过，然后用内层循环继续选择后面最小的数。

总结可以看出，就是小的不断往前排，最小的先到最前面。

这种写法，与上面的本质是一样的：
```
/**
 * bubbleSort
 *
 * @param array $container
 * @return array
 */
function bubbleSort(array $container) {
    $count = count($container);
    for ($i = $count - 1; $i >= 1; $i--) {
        for ($j = $count - 1; $j >= $count - $i; $j--) {
            if ($container[$j] < $container[$j - 1]) {
                $temp = $container[$j];
                $container[$j] = $container[$j - 1];
                $container[$j - 1] = $temp;
            }
        }
    }
    
    return $container;
}
```

还有下面这种沉底的算法，前后两个数比较，把大的数交换到下面，循环一轮后，最大的数就到最底部了。
下一轮循环就没有必要对刚才沉到最底部的数字进行比较，以此类推得到最终排序。
```
/**
 * bubbleSort
 *
 * @param array $container
 * @return array
 */
function bubbleSort(array $container)
{
    $count = count($container);
    for ($j = 1; $j < $count; $j++) {
        for ($i = 0; $i < $count - $j; $i++) {
            if ($container[$i] > $container[$i + 1]) {
                $temp = $container[$i];
                $container[$i] = $container[$i + 1];
                $container[$i + 1] = $temp;
            }
        }
    }
    
    return $container;
}
```

#### 快速排序

快速排序（Quicksort）是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，
其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，
整个排序过程可以递归进行，以此达到整个数据变成有序序列。

快速排序的思路是选取一个基准，然后逐个对比，比基准小的放左边，比基准大的放右边，
使用递归（recursive）再分别对比分割后的左右小集群，不断缩小对比范围，最后合并返回。

```
/**
 * QuickSort
 *
 * @param array $container
 * @return array
 */
function QuickSort(array $container)
{
    $count = count($container);
    if ($count <= 1) { 
        // 基线条件为空或者只包含一个元素，只需要原样返回数组
        return $container;
    }
    
    $pivot = $container[0]; // 基准值 pivot
    $left  = $right = [];
    
    for ($i = 1; $i < $count; $i++) {
        if ($container[$i] < $pivot) {
            $left[] = $container[$i];
        } else {
            $right[] = $container[$i];
        }
    }
    $left  = QuickSort($left);
    $right = QuickSort($right);
    
    return array_merge($left, [$container[0]], $right);
}
```

快速排序使用分而治之【 divide and conquer,D&C 】的策略，是一种解决问题的思路，D&C 解决问题的过程包括两个步骤：
1. 找出基线条件，这种条件必须尽可能简单
2. 不断将问题分解（或者说缩小规模），直到符合基线条件

举例：

```php
$array = array(8, 4, 10, 2, 6);
$array = QuickSort($array);
print_r($array); // 输出 Array ( [0] => 2 [1] => 4 [2] => 6 [3] => 8 [4] => 10 ) 
```

打印一下过程：
```
Array ( [0] => 8 [1] => 4 [2] => 10 [3] => 2 [4] => 6 )
Array ( [0] => 4 [1] => 2 [2] => 6 )
Array ( [0] => 2 )
Array ( [0] => 6 )
Array ( [0] => 10 ) 
```

特别说明，里面用到了递归，核心思想是取一个数，划分左右，不断缩小，不断合并，然后排序完成。

#### 插入排序

插入排序基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，
时间复杂度为O(n^2)。是稳定的排序方法。插入排序的基本思想是：每步将一个待排序的纪录，按其关键码值的大小插入前面已经排序的文件中适当位置上，
直到全部插入完为止。

插入排序的思路是每次往后走一步，对前面的数字进行排序，因为前面数字已经排好序，所以这一次只要把新加入进来的数字找到目标位置插入进去就好了。
如此，直到最后一步。

```
/**
 * InsertSort
 *
 * @param array $container
 * @return array
 */
function InsertSort(array $container)
{
    $count = count($container);
    if ($count <= 0) {
        return false;
    }
    
    for($i = 1; $i < $count; $i++) {
        $j = $i;
        while ($j >= 1) {
            if ($container[$j] < $container[$j -1]) {
                $temp = $container[$j - 1];
                $container[$j -1] = $container[$j];
                $container[$j] = $temp;
            } else {
                break;
            }

            $j--;
        }
        
    }

    return $container;
}
```

同样的原理，只是把while换成了for：
```
function InsertSort($array) {
    $count = count($array);
    if ($count <= 0) {
        return false;
    }
    
    for($i = 1 ; $i < $count; $i++) {
        for($j = $i; $j >= 1; $j--) {
            if ($array[$j] < $array[$j - 1]) {
                $tmp = $array[$j - 1];
                $array[$j - 1] = $array[$j];
                $array[$j] = $tmp;
            } else {
                break;
            }
        }
    }

    return $array;
}
```

还有这种思路，与上面细微差别是先确定这个数的具体位置，后加入这个位置，优点是赋值次数减少，提升运算效率：
```
function InsertSort(array $container) {
    $count = count($container);
    for ($i = 1; $i < $count; $i++) {
        $temp = $container[$i];
        $j    = $i - 1;
        while ($j >= 0 && $container[$j] > $temp) {
            $container[$j+1] = $container[$j];
            $j--;
        }
        if ($i != $j+1) {
            $container[$j+1] = $temp;
        }
    }
    
    return $container;
}
```

#### 希尔排序

希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。
希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，
当增量减至1时，整个文件恰被分成一组，算法便终止。

![]({{site.baseurl}}/images/20210121/20210121110909.png)

```
/**
 * ShellSort
 *
 * @param array $container
 * @return array
 */
function ShellSort(array $container)
{
    $count = count($container);
    for ($increment = intval($count / 2); $increment > 0; $increment = intval($increment / 2)) {
        for ($i = $increment; $i < $count; $i++) {
            $temp = $container[$i];
            for ($j = $i; $j >= $increment; $j -= $increment) {
                if ($temp < $container[$j - $increment]) {
                    $container[$j] = $container[$j - $increment];
                } else {
                    break;
                }
            }
            $container[$j] = $temp;
        }
    }
    return $container;
}
```

#### 选择排序

选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，
存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。

选择排序的思路是，从左边开始寻找最小的数交换位置，这样最左边这个数就是最小的，接下来再看第二位应该放的数字，依次向右前进，
直到最后一位完成数字从小到大排序。

```
/**
 * SelectSort
 *
 * @param array $container
 * @return array
 */
function SelectSort(array $container)
{
    $count = count($container);
    for ($i = 0; $i < $count; $i++){
        $k = $i;
        for ($j = $i + 1; $j < $count; $j++){
            if($container[$j] < $container[$k]){
                $k = $j;
            }
        }
        if($k != $i){
            $temp          = $container[$i];
            $container[$i] = $container[$k];
            $container[$k] = $temp;
        }
    }
    return $container;
}
```

选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。

#### 堆排序

堆(heap)是计算机科学中一类特殊的数据结构的统称，通常是一个可以被看做一棵树的数组对象。

关于堆：
* 堆总是一棵完全二叉树（下面）：
* 堆中某个节点的值总是不大于或不小于其父节点的值；
* 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。

数据结构：
```
# 从1开始
堆 {k1,k2,ki,…,kn}  {ki <= k2i, ki <= k(2i+1)} | {ki >= k2i, ki >= (k2i+1)},  (i = 1,2,3,4...n/2)
# 从0开始
堆 {k0,k1,k2,ki,…,kn}  {ki <= k(2i+1), ki <= k(2i+2)} | {ki >= k(2i+1), ki >= k(2i+2)},  (i = 0,1,2,3,4...[ceil(n/2)-1])
```

**完全二叉树** 除最后一层外，每一层上的节点数均达到最大值；在最后一层上只缺少右边的若干结点。

小根堆实现图：

![]({{site.baseurl}}/images/20210116/20210116145347.jpg)

**堆排序算法**：堆排序就是利用堆进行排序的方法，它的基本思想是（假设利用大根堆）：将待排序的序列构造成一个大根堆。
此时，整个序列的最大值就是堆顶的根节点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），
然后将剩余的 n - 1 个序列重新构造成一个堆，这样就会得到 n 个元素中的次小的值。如此反复执行，便能得到一个有序序列了。

因为建堆的时间复杂度是 `O(n)`（调用一次）；调整堆的时间复杂度是 `logn`，调用了 n-1 次；总体上来说，堆排序的时间复杂度是 `O(nlogn)`。

大根堆排序类：
```php
<?php
class heapSort
{
    /**
     * @var int
     */
    protected $count;
    
    /**
     * @var array
     */
    protected $data;
    
    /**
     * HeapSort constructor.
     *
     * @param array $data
     */
    public function __construct(array $data){
        $this->count = count($data);
        $this->data  = $data;
    }
    
    /**
     * Action
     *
     * @return array
     */
    public function run() {
        $this->createHeap();
        while ($this->count > 0) {
            /* 这是一个大顶堆 , 所以堆顶的节点必须是最大的，根据此特点 , 每次都将堆顶数据移到最后一位，然后对剩余数据节点再次建造堆就可以 */
            $this->swap($this->data[0], $this->data[--$this->count]);
            $this->buildHeap($this->data, 0, $this->count);
        }
        return $this->data;
    }
    
    /**
     * 创建一个堆
     */
    public function createHeap() {
        // $i = floor($this->count / 2) + 1;
        $i = floor($this->count / 2);
        // 从 数组 的第 $i-1 个节点开始至 数组长度为0 结束 , 递归的将其 ( 包括其子节点 ) 转化为一个堆
        while ($i--) {
            $this->buildHeap($this->data, $i, $this->count);
        }
    }
    
    /**
     * 将 数组 转换为 第 $i 个节点 为根的大顶堆
     * 
     * @param $data
     * @param $i
     * @param $count
     */
    public function buildHeap(array &$data, $i, $count) {
        if (false === $i < $count) {
            return;
        }
        // 获取左 / 右节点
        $right = ($left = 2 * $i + 1) + 1;
        $max   = $i;
        // 如果左子节点大于当前节点 , 那么记录左节点键名
        if ($left < $count && $data[$i] < $data[$left]) {
            $max = $left;
        }
        // 如果右节点大于刚刚记录的 $max , 那么再次交换
        if ($right < $count && $data[$max] < $data[$right]) {
            $max = $right;
        }
        if ($max !== $i && $max < $count) {
            $this->swap($data[$i], $data[$max]);
            $this->buildHeap($data, $max, $count);
        }
    }
    
    /**
     * 交换空间
     *
     * @param $left
     * @param $right
     */
    public function swap(&$left, &$right) {
        list($left, $right) = array ($right, $left);
    }
}
```

示例：
```
$array  = array (4, 21, 41, 2, 53, 1, 213, 31, 21, 423, 56);
$result = (new heapSort($array))->run();
print_r($result);
```

#### 归并排序

归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。
将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。

![]({{site.baseurl}}/images/20210120/20210120145344.png)

```php
<?php
class MergeSort
{
	private $arr;
	
    /**
     * MergeSort constructor.
     * @param array $arr 待排序的数组
     */
    public function __construct(array $arr)
    {
		$this->arr = $arr;
    }
    
    /**
	 * 开始递归函数的一个驱动函数
	 */
	public function run()
	{
		$this->mSort($this->arr, 0, count($this->arr) - 1);
	}
	
	/**
     * 获取数组
     * @return array
     */
	public function getArr()
	{
		return $this->arr;
	}
	
    /**
     * 实际实现归并排序的程序
     *
     * @param $arr     array   需要排序的数组
     * @param $left    int     子序列的左下标值
     * @param $right   int     子序列的右下标值
     */
    public function mSort(&$arr, $left, $right)
    {
        if ($left < $right) {
            echo $left . ' - ' . $right .PHP_EOL;
            
            //说明子序列内存在多余1个的元素，那么需要拆分，分别排序，合并
            //计算拆分的位置，长度/2 去整
            $center = floor(($left + $right) / 2);
            //递归调用对左边进行再次排序：
            $this->mSort($arr, $left, $center);
            //递归调用对右边进行再次排序
            $this->mSort($arr, $center + 1, $right);
            //合并排序结果
            $this->mergeArray($arr, $left, $center, $right);
        }
    }
    
    /**
     * 将两个有序数组合并成一个有序数组
     *
     * @param &$arr   , 待排序的所有元素
     * @param $left   , 排序子数组A的开始下标
     * @param $center , 排序子数组A与排序子数组B的中间下标，也就是数组A的结束下标
     * @param $right  , 排序子数组B的结束下标（开始为$center+1)
     */
    public function mergeArray(&$arr, $left, $center, $right)
    {
        echo '| ' . $left . ' - ' . $center . ' - ' . $right . ' - ' . implode(',', $arr);
        
        //设置两个起始位置标记
        $a_i  = $left;
        $b_i  = $center + 1;
        $temp = [];
        while ($a_i <= $center && $b_i <= $right) {
            //当数组A和数组B都没有越界时，取小的那个，循环交叉对比取值
            if ($arr[ $a_i ] < $arr[ $b_i ]) {
                $temp[] = $arr[ $a_i++ ];
            } else {
                $temp[] = $arr[ $b_i++ ];
            }
        }
        //判断 数组A内的元素是否都用完了，没有的话将其全部插入到C数组内：
        while ($a_i <= $center) {
            $temp[] = $arr[ $a_i++ ];
        }
        //判断 数组B内的元素是否都用完了，没有的话将其全部插入到C数组内：
        while ($b_i <= $right) {
            $temp[] = $arr[ $b_i++ ];
        }
        
        echo ' - ' . implode(',', $temp) . PHP_EOL;
        
        //将$arrC内排序好的部分，写入到$arr内：
        for ($i = 0, $len = count($temp); $i < $len; $i++) {
            $arr[ $left + $i ] = $temp[ $i ];
        }
    }
}

$a = [34,5,55,14,88,5];
$t = new MergeSort($a);
$t->run();
print_r($t->getArr());
```

输出：
```
0 - 5
0 - 2
0 - 1
| 0 - 0 - 1 - 34,5,55,14,88,5 - 5,34
| 0 - 1 - 2 - 5,34,55,14,88,5 - 5,34,55
3 - 5
3 - 4
| 3 - 3 - 4 - 5,34,55,14,88,5 - 14,88
| 3 - 4 - 5 - 5,34,55,14,88,5 - 5,14,88
| 0 - 2 - 5 - 5,34,55,5,14,88 - 5,5,14,34,55,88
Array
(
    [0] => 5
    [1] => 5
    [2] => 14
    [3] => 34
    [4] => 55
    [5] => 88
)
```

#### 飞梭排序

飞梭排序是冒泡排序的轻微变形。不同的地方在于，飞梭排序是从低到高，然后从高到低，来回排序，而冒泡排序则仅从低到高去比较序列里的每个元素。

先对数组从左到右进行沉底排序（升序），则最大的元素去到最右端；

再对数组从右到左进行冒泡排序（降序），则最小的元素去到最左端；

以此类推，依次改变冒泡的方向，并不断缩小未排序元素的范围，直到最后一个元素结束。

```php
<?php
/**
 * ShuttleSort
 *
 * @param array $data
 * @return array
 */
function ShuttleSort(array $data) {
    /**
     * 替换方法
     *
     * @param array $data
     * @param       $i
     * @param       $j
     * @return array
     */
    $swap = function (array &$data, $i, $j) {
        $temp     = $data[$i];
        $data[$i] = $data[$j];
        $data[$j] = $temp;
        return $data;
    };
    
    $count = count($data);
    $left  = 0;
    $right = $count - 1;
    while ($left < $right) {
        // 从左到右
        $lastRight = 0;
        for ($i = $left; $i < $right; $i++) {
            if ($data[$i] > $data[$i + 1]) {
                $swap($data, $i, 1 + $i);
                $lastRight = $i;
            }
        }
        $right = $lastRight;
        
        // 从右到左
        $lastLeft = 0;
        for ($j = $right; $left < $j; $j--) {
            if ($data[$j - 1] > $data[$j]) {
                $swap($data, $j - 1, $j);
                $lastLeft = $j;
            }
        }
        $left = $lastLeft;
    }
    
    return $data;
}
```

#### 中文数字排序

```
class ChineseTextNumberSort
{
    /**
     * @var string text
     */
    const CHINESE_DIGITAL_MATCHING = '/\x{96f6}|\x{4e00}|\x{4e8c}|\x{4e09}|\x{56db}|\x{4e94}|\x{516d}|\x{4e03}|\x{516b}|\x{4e5d}|\x{5341}/ui';
    
    /**
     * @var string  regular rules [! order can not arbitrarily change]
     */
    const MODEL_REGULAR_A = <<<REGEXPS
/^\x{7b2c}(\x{4e00}|\x{4e8c}|\x{4e09}|\x{56db}|\x{4e94}|\x{516d}|\x{4e03}|\x{516b}|\x{4e5d}|\x{5341}){1}(\x{7ae0}|\x{8282}|\x{8bfe}|\x{5355}\x{5143})([\f\n\r\t\v]|\x09|\s){1}+/u
REGEXPS;
    const MODEL_REGULAR_D = '/^(\d{1,2})(\x{9875})\-{1}/u';
    const MODEL_REGULAR_E = '/^(\d{1,2})\-/i';
    const MODEL_REGULAR_F = '/^(\d{1,2})([\f\n\r\t\v]|\x09|\s)+/i';
    const MODEL_REGULAR_G = '/^(\d{1,2})(\x{3001}{1})+/u';
    const MODEL_REGULAR_H = '/\x{518c}(\d{1,2})(\s){1}(\x{ff1a}|\:){1}/u';
    const MODEL_REGULAR_I = '/([\f\n\r\t\v]|\x09|\s){1}(\d+)/i';
    const MODEL_REGULAR_B = '/^\d{1,2}+/i';
    const MODEL_REGULAR_C = '/^\d{1,2}([\f\n\r\t\v]|\x09|\s){1}+/i';
    
    /**
     * 解析文本到十位
     *
     * @param $text
     * @return false|float|int|string
     */
    public function parsingText($text)
    {
        $structure = '';
        $mapping   = array ('零', '一', '二', '三', '四', '五', '六', '七', '八', '九', '十');
        preg_match_all(static::CHINESE_DIGITAL_MATCHING, $text, $structure, PREG_PATTERN_ORDER);
        if (empty($structure[0])) {
            return 0;
        }
        $currentNum = 0;
        foreach ($structure[0] as $plane => $matchNum) {
            if ($matchNum === '十') {
                if ($plane === 0) {
                    $currentNum += 10;
                    continue;
                }
                if ($plane === 1) {
                    $index      = array_search($structure[0][0], $mapping);
                    $currentNum -= $index;
                    $currentNum += $index * 10;
                    continue;
                }
            }
            $index      = array_search($matchNum, $mapping);
            $currentNum += $index;
        }
        return $currentNum;
    }
    
    /**
     * isChinese
     *
     * @param $text
     * @return bool
     */
    public function isCompletelyChinese($text)
    {
        return boolval(preg_match('/^[\x7f-\xff]+$/', $text));
    }
    
    /**
     * regularModel
     *
     * @param $regularModel
     * @param $text
     * @return bool
     */
    public function regularModel($regularModel, $text)
    {
        return boolval(preg_match($regularModel, $text));
    }
    
    /**
     * extractModel
     *
     * @param $regularModel
     * @param $text
     * @return string
     * @throws \Exception
     */
    public function extractModel($regularModel, $text)
    {
        $result = '';
        if (preg_match($regularModel, $text, $result)) {
            return trim($result[$this->modelMappingIndex($regularModel)]);
        }
        throw new Exception('The matching error');
    }
    
    /**
     * modelMappingIndex
     *
     * @param $regularModel
     * @return int|mixed
     */
    protected function modelMappingIndex($regularModel)
    {
        return array (
                   static::MODEL_REGULAR_A => 1,
                   static::MODEL_REGULAR_B => 0,
                   static::MODEL_REGULAR_C => 0,
                   static::MODEL_REGULAR_D => 1,
                   static::MODEL_REGULAR_E => 1,
                   static::MODEL_REGULAR_F => 1,
                   static::MODEL_REGULAR_G => 1,
                   static::MODEL_REGULAR_H => 1,
                   static::MODEL_REGULAR_I => 2
               )[$regularModel] ?? 1;
    }
    
    /**
     * chineseConversionNum
     *
     * @param $text
     * @return mixed
     */
    public function chineseConversionNum($text)
    {
        if ($this->regularModel(static::CHINESE_DIGITAL_MATCHING, $text)) {
            $mapping = array ('零', '一', '二', '三', '四', '五', '六', '七', '八', '九', '十');
            return array_search($text, $mapping);
        }
        return ltrim($text, 0);
    }
    
    /**
     * getAllModelRegular
     *
     * @return array
     * @throws \ReflectionException
     */
    public function getAllModelRegular()
    {
        $constants  = (new \ReflectionClass(__CLASS__))->getConstants();
        $collection = array ();
        foreach ($constants as $key => $value) {
            if (strpos($key, 'MODEL_REGULAR_') !== false) {
                $collection[$key] = $value;
            }
        }
        return $collection;
    }
    
    /**
     * modelAnalysis
     *
     * @param $text
     * @return int|string
     * @throws \ReflectionException
     */
    public function modelAnalysis($text)
    {
        foreach ($this->getAllModelRegular() as $item) {
            if ($this->regularModel($item, $text)) {
                return $item;
            }
        }
        throw new Exception('Model Analysis of the failure !');
    }
    
    /**
     * textAnalysis
     *
     * @param $text
     * @return int
     */
    public function textAnalysis($text)
    {
        try {
            return (int)$this->chineseConversionNum($this->extractModel(
                $this->modelAnalysis($text),
                $text
            )
            );
        } catch (Exception $e) {
            return 0;
        }
    }
    
    /**
     * chineseTextList
     *
     * @param array $list
     * @return array
     */
    public function chineseTextListSorter(array $list)
    {
        $container = $generate = array ();
        foreach ($list as $item) {
            $container[] = $this->textAnalysis($item);
        }
        if (count($container) !== count($list)) {
            return $list;
        }
        uksort($list, function ($left, $right) use ($container) {
            if ($left == $right) {
                return 0;
            }
            return $container[$left] < $container[$right] ? -1 : 1;
        });
        return array_values($list);
    }
}
```

### 查找篇

#### 顺序查找

```php
<?php
/**
 * 顺序查找（数组里查找某个值的键）
 * @param $array 给定数组
 * @param $high 最大键，结束位置
 * @param $value 要查找的值
 * @return int
 */
function sequence_search($array, $high, $value)
{
     for( $i=0; $i <= $high; $i++) {
          if ($array[$i] == $value) {
               break;
          }
     }
     if ($i <= $high) {
          return $i;
     } else {
          return -1;
     }
} 
```

举例：
```php
$array = array(2, 4, 6, 8, 10);
$key = sequence_search($array, 3, 6);
echo $key;   // 输出 2 
```

#### 二分查找

二分查找是在排好序的数组中查找指定值的数组键值。

```php
/**
 * 二分查找（数组里查找某个值的键），也叫半分法
 * @param $array 给定数组
 * @param $low 最小键，开始位置
 * @param $high 最大键，结束位置
 * @param $value 要查找的值
 * @return int
 */
function binary_search($array, $low, $high, $value)
{
     if ( $low <= $high ) {
          $mid = intval( ($low+$high)/2 );
          if ( $array[$mid] == $value ) {
               return $mid;
          } elseif ( $value < $array[$mid] ) {
               return binary_search ( $array, $low, $mid-1, $value );
          } else {
               return binary_search ( $array, $mid+1, $high, $value );
          }
     }
     
     return -1;
}
```

举例：

```php
$array = array(2, 4, 6, 8, 10, 12, 14);
$key = binary_search($array, 2, 7 , 8);
echo $key;     // 输出 3 
```

特别说明，$value必须在数组$low与$high的值之间存在，否则都返回-1。

这里看到数组要是排好序的，如果是乱序的，可以用下面的函数排序（除了数字，也可对字符排序）：
```
sort() - 对数组进行升序排列
rsort() - 对数组进行降序排列
```

```php
/**
 * 递归版 二分查找
 *
 * @param array  $container
 * @param        $search
 * @param int    $low
 * @param string $top
 * @return int|string
 */
function BinaryQueryRecursive(array $container, $search, $low = 0, $top = 'default')
{
    $top === 'default' && $top = count($container);
    if ($low <= $top) {
        $mid = intval(floor($low + $top) / 2);
        if (!isset($container[$mid])) {
            return '没找着哦';
        }
        if ($container[$mid] == $search) {
            return $mid;
        }
        if ($container[$mid] < $search) {
            return BinaryQueryRecursive($container, $search, $mid + 1, $top);
        } else {
            return BinaryQueryRecursive($container, $search, $low, $mid - 1);
        }
    }
}
```

```php
/**
 * 非递归版 二分查找
 *
 * @param array $container
 * @param       $search
 * @return int|string
 */
function BinaryQuery(array $container, $search)
{
    $top = count($container);
    $low = 0;
    while ($low <= $top) {
        $mid = intval(floor(($low + $top) / 2));
        if (!isset($container[$mid])) {
            return '没找着哦';
        }
        if ($container[$mid] == $search) {
            return $mid;
        }
        $container[$mid] < $search && $low = $mid + 1;
        $container[$mid] > $search && $top = $mid - 1;
    }
}
```

#### 快速查询

就是二分查找

```php
function QuickQuery($array, $value, $low = 0, $high = 0)
{
    //判断是否为第一次调用
    if (count($array) != 0 and $high == 0) {
        $high = count($array);
    }
    //如果还存在剩余的数组元素
    if ($low <= $high) {
        //取$low和$high的中间值
        $mid = intval(($low + $high) / 2);
        //如果找到则返回
        if ($array[$mid] == $value) {
            return $mid;
        } else if ($value < $array[$mid]) {//如果没有找到，则继续查找
            return QuickQuery($array, $value, $low, $mid - 1);
        } else {
            return QuickQuery($array, $value, $mid + 1, $high);
        }
    }
    return -1;
}

echo QuickQuery([4, 5, 7, 8, 9, 10, 8], 8);
```

####  插入查找

思路分析：对于数组长度比较大，关键字分布又是比较均匀的来说，插值查找的效率比折半查找的效率高。

它是二分查找的改进。
在英文词典里查找“apple”，你下意识里翻开词典是翻前面的书页还是后面的书页呢？如果再查“zoo”,你又会怎么查？
显然你不会从词典中间开始查起，而是有一定目的地往前或往后翻。

分布比较均匀的情况下，用密度乘以间隔长度就该是我们要找的值，理论根据：`p = (yb - ya) / (xb - xa) = (yc - ya) / (xc - xa)` 。

```php
/**
 * insertQuery
 *
 * @param array $container
 * @param       $num
 * @return bool|float|int
 */
function insertQuery(array $container, $num)
{
    $count = count($container);
    $lower = 0;
    $high  = $count - 1;

    while ($lower <= $high) {
        if ($container[ $lower ] == $num) {
            return $lower;
        }
        if ($container[ $high ] == $num) {
            return $high;
        }

//        $left  = intval($lower + $num - $container[ $lower ]);
//        $right = ($container[ $high ] - $container[ $lower ]) * ($high - $lower);
//        $middle = $left /$right;
        
        $middle = intval(($high - $lower) * ($num - $container[ $lower ]) / ($container[ $high ] - $container[ $lower ])) + $lower;

        if ($num < $container[ $middle ]) {
            $high  = $middle - 1;
        } else if ($num > $container[ $middle ]) {
            $lower = $middle + 1;
        } else {
            return $middle;
        }
    }
    return false;
}
```

#### 斐波那契查找

思路分析：斐波那契查找 利用黄金分割原理

斐波那契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、····，
在数学上，斐波那契被递归方法如下定义：`F(1)=1，F(2)=1，F(n)=f(n-1)+F(n-2) （n>=2）`。
该数列越往后相邻的两个数的比值越趋向于黄金比例值（0.618）。

斐波那契查找就是在二分查找的基础上根据斐波那契数列进行分割的。在斐波那契数列找一个等于略大于查找表中元素个数的数F[n]，
将原查找表扩展为长度为F[n] (如果要补充元素，则补充重复最后一个元素，直到满足F[n]个元素)，完成后进行斐波那契分割，
即F[n]个元素分割为前半部分F[n-1]个元素，后半部分F[n-2]个元素，找出要查找的元素在那一部分并递归，直到找到。

斐波那契查找的时间复杂度还是O(log 2 n )，但是 与折半查找相比，斐波那契查找的优点是它只涉及加法和减法运算，
而不用除法，而除法比加减法要占用更多的时间，因此，斐波那契查找的运行时间理论上比折半查找小，但是还是得视具体情况而定。

对于斐波那契数列：1、1、2、3、5、8、13、21、34、55、89……（也可以从0开始），前后两个数字的比值随着数列的增加，越来越接近黄金比值0.618。
比如这里的89，把它想象成整个有序表的元素个数，而89是由前面的两个斐波那契数34和55相加之后的和，
也就是说把元素个数为89的有序表分成由前55个数据元素组成的前半段和由后34个数据元素组成的后半段，
那么前半段元素个数和整个有序表长度的比值就接近黄金比值0.618，假如要查找的元素在前半段，
那么继续按照斐波那契数列来看，55 = 34 + 21，所以继续把前半段分成前34个数据元素的前半段和后21个元素的后半段，
继续查找，如此反复，直到查找成功或失败，这样就把斐波那契数列应用到查找算法中了。

![]({{site.baseurl}}/images/20210128/20210128184389.png)

从图中可以看出，当有序表的元素个数不是斐波那契数列中的某个数字时，需要把有序表的元素个数长度补齐，让它成为斐波那契数列中的一个数值，
当然把原有序表截断肯定是不可能的，不然还怎么查找。然后图中标识每次取斐波那契数列中的某个值时(F[k])，都会进行-1操作，
这是因为有序表数组位序从0开始的，纯粹是为了迎合位序从0开始。

用迭代实现斐波那契查找算法如下

```php
/**
 * $num == $container[$mid],直接返回
 * $num <  $container[$mid],新范围是第 $low   个到 $mid-1 个，此时范围个数为 produced($key-1)-1 个
 * $num >  $container[$mid],新范围是第 $mid+1 个到 $high  个，此时范围个数为 produced($key-2)-1 个
 */
class FibonacciQuery
{
    /**
     * FibonacciQuery constructor.
     *
     * @param array $container
     * @param       $num
     */
    public function __construct(array $container, $num)
    {
        $count = count($container);
        $lower = $key = $result = 0;
        $high  = $count - 1;
        //计算$count位于斐波那契数列的位置
        while ($count > ($this->produced($key) - 1)) {
            $key++;
        }
        //将不满的数值补全，补的数值为数组的最后一位
        for ($j = $count; $j < $this->produced($key) - 1; $j++) {
            $container[$j] = $container[$count - 1];
        }
        //查找开始
        while ($lower <= $high) {
            //计算当前分隔的下标
            $mid = $lower + $this->produced($key - 1) - 1;
            if ($num < $container[$mid]) {
                $high = $mid - 1;
                $key  -= 1;    //斐波那契数列数列下标减一位
            } else if ($num > $container[$mid]) {
                $lower = $mid + 1;
                $key   -= 2;    //斐波那契数列数列下标减两位
            } else {
                if ($mid <= $count - 1) {
                    $result = $mid;
                    break;
                } else { //这里$mid大于$count-1说明是补全数值，返回$count-1
                    $result = $count - 1;
                    break;
                }
            }
            
        }
        var_dump($result);
    }

    /**
     * 创建一个生产斐波那契数列
     *
     * @param $length
     * @return int
     */
    public function produced($length)
    {
        if ($length < 2) {
            return ($length == 0 ? 0 : 1);
        }
        return $this->produced($length - 1) + $this->produced($length - 2);
    }
}
```

测试：
```
new FibonacciQuery([4, 5, 7, 8, 9, 10], 8);
```

#### 暴力匹配算法

暴力匹配算法是一种最容易想到的字符串匹配算法。

假设现在我们面临这样一个问题：有一个文本串 S，和一个模式串 P，现在要查找 P 在 S 中的位置，怎么查找呢？

如果用暴力匹配的思路，并假设现在文本串 S 匹配到 i 位置，模式串 P 匹配到 j 位置，则有：

* 如果当前字符匹配成功（即 `S[i] == P[j]）`，则 `i++，j++`，继续匹配下一个字符；
* 如果失配（即 `S[i]! = P[j]`），令 `i = i - (j - 1)，j = 0`。相当于每次匹配失败时，i 回溯，j 被置为0。

理清楚了暴力匹配算法的流程及内在的逻辑，咱们可以写出暴力匹配的代码，如下：
```php
function ViolentMatch($haystack, $needle) {
    $haystackLen = mb_strlen($haystack, 'utf-8');
    $needleLen = mb_strlen($needle, 'utf-8');
    
    $i = $j = 0;
    while ($i < $haystackLen && $j < $needleLen) {  
        if ($haystack[$i] == $needle[$j]) {  
            //①如果当前字符匹配成功（即S[i] == P[j]），则i++，j++      
            $i++;  
            $j++;  
        } else {  
            //②如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0      
            $i = $i - $j + 1;  
            $j = 0;  
        }  
    }  
    
    // 匹配成功，返回模式串p在文本串s中的位置，否则返回-1  
    if ($j == $needleLen) {
        return $i - $j;  
    } else {
        return -1;  
    } 
}
```

测试代码：
```php
echo ViolentMatch("BBC ABCDAB ABCDABCDABDE", "ABCDABD");
```

整个过程如下所示：

![]({{site.baseurl}}/images/20210202/20210202113255.png)

#### KMP算法

KMP算法是一种改进的字符串匹配算法。

KMP 算法是 D.E.Knuth、J,H,Morris 和 V.R.Pratt 三人于 1977 年联合发表，称之为 Knuth-Morria-Pratt 算法，简称 KMP 算法。
该算法相对于 Brute-Force（暴力）算法有比较大的改进，主要是消除了主串指针的回溯，从而使算法效率有了某种程度的提高。

KMP精要：KMP在进行朴素匹配时，如果发现不匹配字符时，通过对已经匹配的那部分字符串的最大前缀来快速找到下一个模式串需要匹配的位置。
KMP对模式进行预处理时间复杂度O(m)，匹配时间复杂度O(n)，总的KMP时间复杂度为O(m+n)。
参考 阮一峰 [字符串匹配的KMP算法](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html) 。
具体代码实现，参考[从头到尾彻底理解 KMP](https://wiki.jikexueyuan.com/project/kmp-algorithm/) 。

![]({{site.baseurl}}/images/20210202/20210202113257.png)

KMP 的算法流程：

![]({{site.baseurl}}/images/20210202/20210202113258.jpg)

* 假设现在文本串 S 匹配到 i 位置，模式串 P 匹配到 j 位置
    * 如果 j = -1，或者当前字符匹配成功（即 S[i] == P[j]），都令 i++，j++，继续匹配下一个字符；
    * 如果 j != -1，且当前字符匹配失败（即 S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串 P 相对于文本串 S 向右移动了 j - next [j] 位。
        * 换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的 next 值（next 数组的求解会在下文的 3.3.3 节中详细阐述），即移动的实际位数为：j - next[j]，且此值大于等于1。
  

代码类：
```php
class KMP
{
    public  $haystack;
    public  $needle;
    private $_haystackLen;
    private $_needleLen;
    private $_matchTable;
    private $_isMatch;

    //构造函数
    function __construct($haystack, $needle)
    {
        $this->haystack = $haystack;
        $this->needle   = $needle;
        //初始化一些参数
        $this->_haystackLen = $this->getLen($this->haystack);
        $this->_needleLen   = $this->getLen($this->needle);
        $this->_matchTable  = $this->getMatchTable();
        $this->_isMatch     = false;
    }


    //类似strpos函数功能
    public function strpos()
    {
        //haystack
        $haystackIdx = $matchNum = 0;
        while ($haystackIdx <= $this->_haystackLen - $this->_needleLen) {
            //needle
            $needIdx = 0;
            for (; $needIdx < $this->_needleLen; $needIdx++) {
                if (strcmp($this->haystack[$haystackIdx], $this->needle[$needIdx]) <> 0) {
                    if ($matchNum > 0) {
                        $lastMatchValue = $this->getLastMatchValue($needIdx - 1);
                        $haystackIdx    += $this->getStep($matchNum, $lastMatchValue);
                        $matchNum       = 0;
                    } else {
                        $haystackIdx++;
                    }
                    break;
                } else {
                    $haystackIdx++;
                    $matchNum++;
                    if ($matchNum == $this->_needleLen) {
                        $this->_isMatch = true;
                        break;
                    }
                }
            }
            if ($this->_isMatch == true) {
                break;
            }
        }
        return $this->_isMatch ? $haystackIdx - $this->_needleLen : false;
    }

    //获取字符长度
    private function getLen($str)
    {
        return mb_strlen($str, 'utf-8');
    }

    //获取部分匹配表
    private function getMatchTable()
    {
        $matchTable = [];
        for ($i = 0; $i < $this->_needleLen; $i++) {
            $intersectLen = 0;
            $nowStr       = mb_substr($this->needle, 0, $i + 1, 'utf-8');
            $preFixArr    = $this->getPreFix($nowStr);
            $sufFixArr    = $this->getSufFix($nowStr);
            if ($preFixArr && $sufFixArr) {
                $intersectArr = array_intersect($preFixArr, $sufFixArr);
                if (!empty($intersectArr)) {
                    $intersect    = array_pop($intersectArr);
                    $intersectLen = mb_strlen($intersect, 'utf-8');
                }
            }
            $matchTable[$i] = $intersectLen;
        }
        return $matchTable;
    }

    //获取前缀数组
    private function getPreFix($str)
    {
        $outArr = [];
        $strLen = $this->getLen($str);
        if ($strLen > 1) {
            for ($i = 1; $i < $strLen; $i++) {
                $outArr[] = mb_substr($str, 0, $i, 'utf-8');
            }
        }
        return $outArr;
    }

    //获取后缀数组
    private function getSufFix($str)
    {
        $outArr = [];
        $strLen = $this->getLen($str);
        if ($strLen > 1) {
            for ($i = 1; $i < $strLen; $i++) {
                $outArr[] = mb_substr($str, $i, null, 'utf-8');
            }
        }
        return $outArr;
    }

    //计算步长
    private function getStep($matchNum, $lastMatchValue)
    {
        return $matchNum - $lastMatchValue;
    }

    //获取最后匹配值
    private function getLastMatchValue($index)
    {
        return isset($this->_matchTable[$index]) ? $this->_matchTable[$index] : 0;
    }

}
```

测试类：
```php
$str    = 'a b a c a a b a c a b a c a b a a b b';
$subStr = 'a b a c a b';
$kmp    = new KMP($str, $subStr);
var_dump($kmp->strpos());
$kmp->haystack = 'pull requests';
$kmp->needle   = 'sts';
var_dump($kmp->strpos());
$kmp->haystack = 'i love you';
$kmp->needle   = 'hate';
var_dump($kmp->strpos());
```

#### 广度优先搜索

这里面涉及到 [什么是 “图”](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653197523&idx=2&sn=893c01a31446d3c479c312836ae83819&chksm=8c99e609bbee6f1fb0df2fb60edb8fba5166b49ef200ab8fb3af4ff144b3f96b283a34ff776c&scene=21#wechat_redirect) ,
[深度优先遍历 和 广度优先遍历 ](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653197523&idx=1&sn=4edecca7392534177eef521511ff740b&chksm=8c99e609bbee6f1fdb736f1bc45da5f6b6765ce190db68eac5a65ca22cc2694dc151f8db828f&scene=21#wechat_redirect) ,
等。

**什么是 深度/广度 优先遍历？**

深度优先遍历简称DFS（Depth First Search），广度优先遍历简称BFS（Breadth First Search），它们是遍历图当中所有顶点的两种方式。

深度优先遍历（DFS）：先深入探索，走到头再回退寻找其他出路的遍历方式。 二叉树的前序、中序、后序遍历，本质上就是深度优先遍历。

![]({{site.baseurl}}/images/20210203/20210203113278.jpeg)

广度优先遍历（BFS）：一层一层由内而外的遍历方式。 二叉树的层序遍历，本质上就是广度优先遍历。

![]({{site.baseurl}}/images/20210203/20210203113279.jpeg)


深度优先遍历，可以使用回溯：自后向前追溯曾经访问过的路径，就叫做回溯。
要想实现回溯，可以利用栈的先入后出特性，也可以采用递归的方式（因为递归本身就是基于方法调用栈来实现）。

广度优先遍历，可以使用重放：把遍历过的顶点按照之前的遍历顺序重新回顾，就叫做重放。
同样的，要实现重放也需要额外的存储空间，可以利用队列的先入先出特性来实现。

下面实现**广度优先遍历**。

思路分析： BFS并不使用经验法则算法。从算法的观点，所有因为展开节点而得到的子节点都会被加进一个先进先出的队列中

时间复杂度：O(n)

宽度优先搜索算法（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。
Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和宽度优先搜索类似的思想。
其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。
换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。

```php
<?php
class BFSQuery
{
    /**
     * @var array 关系网络
     */
    protected $relationship;
    /**
     * @var \SplQueue 处理队列
     */
    protected $queue;

    /**
     * @var string 搜索结果
     */
    protected $target;

    /**
     * BFSQuery constructor.
     *
     * @param array  $relationship
     * @param string $target
     */
    public function __construct(array $relationship, $target)
    {

        $this->relationship = $relationship;
        $this->queue        = new SplQueue();
        $this->target       = $target;
        $this->generator($this->relationship);
    }

    /**
     * 开始入列
     *
     * @param array $relation
     * @return \Generator
     */
    public function generator($relation)
    {
        foreach ($relation as $value) {
            $this->schedule($value);
        }
    }


    /**
     * 队列入队
     *
     * @param  $item
     * @return int
     */
    public function schedule($item)
    {
        $this->queue->enqueue($item);
    }

    /**
     * 队列中查找符合条件
     *
     * @return string
     */
    public function run()
    {
        $result = $this->target . '没有人有~!';
        while (!$this->queue->isEmpty()) {
            // 出队列
            $item = $this->queue->dequeue();
            if (!isset($item['friend'])) {
                continue;
            }
            if (!isset($item['fruit'])) {
                continue;
            }
            $totalFruit = count($item['fruit']);
            $mark       = 0;
            while ($totalFruit > $mark) {
                if ($item['fruit'][$mark] === $this->target) {
                    $result = '找到了～！';
                    break 2;
                }
                $mark++;
            }
            $this->generator($item['friend']);
        }
        return $result;
    }
}
```

方案测试：你现在需要一个 `mango` ,所以你需要在你的朋友圈里搜刮，你可以先从Jack 与 tom 身上找，
然后再从他们的朋友身上找，然后再从他们朋友的朋友哪里找：
```
$me = array (
    'jack' => array (
        'fruit'  => array ('apple', 'banana', 'dragon'),
        'friend' => array (
            'lucy' => array (
                'fruit'  => array ('bear', 'watermelon'),
                'friend' => array (
                    'marco' => array (
                        'fruit'  => array ('mango', 'cherry'), // Mango 在这儿
                        'friend' => array (
                            '...',
                        )
                    ),
                ),
            ),
            'bob'  => array (
                'fruit'  => array ('orange', 'mangosteen', 'peach'),
                'friend' => array (
                    '',
                ),
            ),

        ),
    ),
    'tom'  => array (
        'fruit'  => array (
            'apple',
            'banana',
        ),
        'friend' => array (
            'lucy' => array (
                'fruit'  => array (),
                'friend' => array (
                    'lucy' => array (
                        'fruit'  => array ('bear', 'watermelon'),
                        'friend' => array (
                            'marco' => array (
                                'fruit'  => array ('mango', 'cherry'), // Mango 在这儿也有
                                'friend' => array (
                                    '...',
                                )
                            ),
                        ),
                    ),
                ),
            ),
            'bob'  => array (
                'fruit'  => array ('apple', 'peach'),
                'friend' => array (
                    'marco' => array (
                        'fruit'  => array ('mango', 'cherry'), // Mango 在这儿也有
                        'friend' => array (
                            'Marco 有无数多的盆友...',
                        )
                    ),
                )
            ),
        ),
    )
);

echo (new BFSQuery($me, 'mango'))->run();
```

SplQueue标准类：
```
/**
 * The SplDoublyLinkedList class provides the main functionalities of a doubly linked list.
 * @link https://php.net/manual/en/class.spldoublylinkedlist.php
 */
class SplDoublyLinkedList implements Iterator, Countable, ArrayAccess, Serializable
{
        const IT_MODE_LIFO = 2;
        const IT_MODE_FIFO = 0;
        const IT_MODE_DELETE = 1;
        const IT_MODE_KEEP = 0;


        /**
         * Add/insert a new value at the specified index
         * @param mixed $index The index where the new value is to be inserted.
         * @param mixed $value The new value for the index.
         * @link https://php.net/spldoublylinkedlist.add
         * @return void
         * @since 5.5
         */
        public function add($index, $value) {}

        /**
         * Pops a node from the end of the doubly linked list
         * @link https://php.net/manual/en/spldoublylinkedlist.pop.php
         * @return mixed The value of the popped node.
         */
        public function pop () {}

        /**
         * Shifts a node from the beginning of the doubly linked list
         * @link https://php.net/manual/en/spldoublylinkedlist.shift.php
         * @return mixed The value of the shifted node.
         */
        public function shift () {}

        /**
         * Pushes an element at the end of the doubly linked list
         * @link https://php.net/manual/en/spldoublylinkedlist.push.php
         * @param mixed $value <p>
         * The value to push.
         * </p>
         * @return void
         */
        public function push ($value) {}

        /**
         * Prepends the doubly linked list with an element
         * @link https://php.net/manual/en/spldoublylinkedlist.unshift.php
         * @param mixed $value <p>
         * The value to unshift.
         * </p>
         * @return void
         */
        public function unshift ($value) {}

        /**
         * Peeks at the node from the end of the doubly linked list
         * @link https://php.net/manual/en/spldoublylinkedlist.top.php
         * @return mixed The value of the last node.
         */
        public function top () {}

        /**
         * Peeks at the node from the beginning of the doubly linked list
         * @link https://php.net/manual/en/spldoublylinkedlist.bottom.php
         * @return mixed The value of the first node.
         */
        public function bottom () {}

        /**
         * Counts the number of elements in the doubly linked list.
         * @link https://php.net/manual/en/spldoublylinkedlist.count.php
         * @return int the number of elements in the doubly linked list.
         */
        public function count () {}

        /**
         * Checks whether the doubly linked list is empty.
         * @link https://php.net/manual/en/spldoublylinkedlist.isempty.php
         * @return bool whether the doubly linked list is empty.
         */
        public function isEmpty () {}

        /**
         * Sets the mode of iteration
         * @link https://php.net/manual/en/spldoublylinkedlist.setiteratormode.php
         * @param int $mode <p>
         * There are two orthogonal sets of modes that can be set:
         * </p>
         * The direction of the iteration (either one or the other):
	 * <b>SplDoublyLinkedList::IT_MODE_LIFO</b> (Stack style)
         * @return void
         */
        public function setIteratorMode ($mode) {}

        /**
         * Returns the mode of iteration
         * @link https://php.net/manual/en/spldoublylinkedlist.getiteratormode.php
         * @return int the different modes and flags that affect the iteration.
         */
        public function getIteratorMode () {}

        /**
         * Returns whether the requested $index exists
         * @link https://php.net/manual/en/spldoublylinkedlist.offsetexists.php
         * @param mixed $index <p>
         * The index being checked.
         * </p>
	 * @return bool true if the requested <i>index</i> exists, otherwise false
         */
        public function offsetExists ($index) {}

        /**
         * Returns the value at the specified $index
         * @link https://php.net/manual/en/spldoublylinkedlist.offsetget.php
         * @param mixed $index <p>
         * The index with the value.
         * </p>
	 * @return mixed The value at the specified <i>index</i>.
         */
        public function offsetGet ($index) {}

        /**
         * Sets the value at the specified $index to $newval
         * @link https://php.net/manual/en/spldoublylinkedlist.offsetset.php
         * @param mixed $index <p>
         * The index being set.
         * </p>
         * @param mixed $value <p>
	 * The new value for the <i>index</i>.
         * </p>
         * @return void
         */
        public function offsetSet ($index, $value) {}

        /**
         * Unsets the value at the specified $index
         * @link https://php.net/manual/en/spldoublylinkedlist.offsetunset.php
         * @param mixed $index <p>
         * The index being unset.
         * </p>
         * @return void
         */
        public function offsetUnset ($index) {}

        /**
         * Rewind iterator back to the start
         * @link https://php.net/manual/en/spldoublylinkedlist.rewind.php
         * @return void
         */
        public function rewind () {}

        /**
         * Return current array entry
         * @link https://php.net/manual/en/spldoublylinkedlist.current.php
         * @return mixed The current node value.
         */
        public function current () {}

        /**
         * Return current node index
         * @link https://php.net/manual/en/spldoublylinkedlist.key.php
         * @return string|float|int|bool|null The current node index.
         */
        public function key () {}

        /**
         * Move to next entry
         * @link https://php.net/manual/en/spldoublylinkedlist.next.php
         * @return void
         */
        public function next () {}

        /**
         * Move to previous entry
         * @link https://php.net/manual/en/spldoublylinkedlist.prev.php
         * @return void
         */
        public function prev () {}

        /**
         * Check whether the doubly linked list contains more nodes
         * @link https://php.net/manual/en/spldoublylinkedlist.valid.php
         * @return bool true if the doubly linked list contains any more nodes, false otherwise.
         */
        public function valid () {}

        /**
         * Unserializes the storage
         * @link https://php.net/manual/en/spldoublylinkedlist.serialize.php
         * @param string $data The serialized string.
         * @return void
         * @since 5.4
         */
         public function unserialize($data) {}

         /**
         * Serializes the storage
         * @link https://php.net/manual/en/spldoublylinkedlist.unserialize.php
         * @return string The serialized string.
         * @since 5.4
         */
         public function  serialize () {}


        /**
         * @return array
         * @since 7.4
         */
        public function __debugInfo(){}

        /**
         * @return array
         * @since 7.4
         */
        public function __serialize(): array {}

        /**
         * @param array $data
         * @since 7.4
         */
        public function __unserialize(array $data): void {}

}

/**
 * The SplQueue class provides the main functionalities of a queue implemented using a doubly linked list.
 * @link https://php.net/manual/en/class.splqueue.php
 */
class SplQueue extends SplDoublyLinkedList {


        /**
         * Adds an element to the queue.
         * @link https://php.net/manual/en/splqueue.enqueue.php
         * @param mixed $value <p>
         * The value to enqueue.
         * </p>
         * @return void
         */
        public function enqueue ($value) {}

        /**
         * Dequeues a node from the queue
         * @link https://php.net/manual/en/splqueue.dequeue.php
         * @return mixed The value of the dequeued node.
         */
        public function dequeue () {}

    /**
     * Sets the mode of iteration
     * @link https://php.net/manual/en/spldoublylinkedlist.setiteratormode.php
     * @param int $mode <p>
     * There are two orthogonal sets of modes that can be set:
     * </p>
     * The direction of the iteration (either one or the other):
     * <b>SplDoublyLinkedList::IT_MODE_LIFO</b> (Stack style)
     * @return void
     */
    public function setIteratorMode ($mode) {}

}
```

#### 迪克斯特拉算法

这里面涉及到[图的 “最短路径” 问题 ](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653197626&idx=1&sn=fca7472af006a7f8890ee84ad7cf1116&chksm=8c99e7e0bbee6ef6faa1a34160a5e135503425e37552e90dfca2fbc10f223dbf3b875e84e418&scene=21#wechat_redirect) ，
[Dijkstra 算法的优化 ](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653197794&idx=1&sn=8286ba52dd8e909197324148ffe6b7d7&chksm=8c99e738bbee6e2e16332dea4c5daef34dc2db6166149244c5406b1042c46d166e83e2e6f2df&scene=21#wechat_redirect) ，
还有[图的 “多源” 最短路径 ](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653197861&idx=1&sn=ed3140e711821206b5b50cd418614660&chksm=8c99e4ffbbee6de92ae00262ce1230bce3de384d3cadcf99c3f51aca4ca0c5f7f5a9f2e857df&scene=21#wechat_redirect) ,
等。

思路分析：单源最短路径问题

Dijkstra 算法一般的表述通常有两种方式，一种用永久和临时标号方式，一种是用OPEN, CLOSE表的方式，
这里均采用永久和临时标号的方式。注意该算法要求图中不存在负权边。
因此，在包含负边全的图中要找出最短路径，可以使用另一种算法 -- 贝克曼-福德算法

```php
class DijkstraQuery
{
    /**
     * @var array
     */
    protected $graph;
    /**
     * @var array
     */
    protected $processed;
    /**
     * @var int
     */
    protected $infinity;
    /**
     * @var string
     */
    protected $start;
    /**
     * @var string
     */
    protected $end;

    /**
     * DijkstraQuery constructor.
     *
     * @param array $graph
     * @param       $start
     * @param       $end
     */
    public function __construct(array $graph, $start, $end)
    {
        $this->graph     = $graph;
        $this->start     = $start;
        $this->end       = $end;
        $this->processed = array ();
        $this->infinity  = mt_getrandmax();
    }

    /**
     * 最短路径
     *
     * @return string
     */
    public function calculate()
    {
        $costs             = $this->graph[$this->start];
        $costs[$this->end] = $this->infinity;
        $node              = $this->findLowestCostNode($costs);

        while (null !== $node) {
            $cost      = $costs[$node];
            $neighbors = $this->graph[$node]  ?? array ();
            foreach ($neighbors as $neighbor => $distance) {
                $newCost = $cost + $distance;
                if ($costs[$neighbor] > $newCost) {
                    $costs[$neighbor] = $newCost;
                }
            }
            array_push($this->processed, $node);
            $node = $this->findLowestCostNode($costs);
        }

        return 'The shortest distance for：' . $costs[$this->end];
    }

    /**
     * findLowestCostNode
     *
     * @param $costs
     * @return null
     */
    protected function findLowestCostNode($costs)
    {
        $lowestCost     = $this->infinity;
        $lowestCostNode = null;
        foreach ($costs as $node => $cost) {
            if ($cost < $lowestCost && !in_array($node, $this->processed)) {
                $lowestCost     = $cost;
                $lowestCostNode = $node;
            }
        }
        return $lowestCostNode;
    }
}

// +--------------------------------------------------------------------------
// | 验证 me --> claire
// +--------------------------------------------------------------------------
//  ∞
$graph = array (
    'me'     => array (
        'alice' => 6,
        'bob'   => 2,
    ),
    'alice'  => array (
        'claire' => 1,
    ),
    'bob'    => array (
        'alice'  => 3,
        'claire' => 5,
    ),
    'claire' => array (// 没有任何邻居

    ),
);
echo (new DijkstraQuery($graph, 'me', 'claire'))->calculate();
```

### 数据结构

![]({{site.baseurl}}/images/20210705/20210705130029.png)

#### 线性表 顺序存储

线性表是⼀个有限序列，表中各个元素是相继排列的，且每两个相邻元素之间都有直接前驱和直接后继的逻辑关系。

线性表有 顺序表、 单链表、 循环链表、 双向链表 等。

定义：线性表(Linear List) ：是由n(n≧0)个数据元素(结点) `[a1，a2， …an]` 组成的有限序列。数据元素是一个抽象的符号，其具体含义在不同的情况下一般不同。
该序列中的所有结点具有相同的数据类型。其中数据元素的个数n称为线性表的长度。
当n=0时，称为空表。
当n>0时，将非空的线性表记作： (a1，a2，…an) a1称为线性表的第一个(首)结点，an称为线性表的最后一个(尾)结点。

基本说明：线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。
注意，这句话只适用大部分线性表，而不是全部。比如，循环链表逻辑层次上也是一种线性表（存储层次上属于链式存储）
但是把最后一个数据元素的尾指针指向了首位结点）。

基本特点：
1. 存在一个唯一的被称为`第一个`的数据元素
2. 存在一个唯一的被称为`最后一个`的数据元素
3. 除第一个元素外，每个元素均有唯一一个直接前驱
4. 除最后一个元素外，每个元素均有唯一一个直接后继

```php
<?php
/**
 * LinearList  线性表
 *
 * -------------------------------------------------------------
 * [线性表顺序存储]
 * =======
 * 把线性表的结点按逻辑顺序依次存放在一组地址连续的存储单元里，用这种方法存储的线性表简称线性表。
 * -------------------------------------------------------------
 * [顺序存储的线性表的特点]
 * =======
 *    - 线性表的逻辑顺序与物理顺序一致；
 *    - 数据元素之间的关系是以元素在计算机内“物理位置相邻”来体现。
 * -------------------------------------------------------------
 * @param array
 */
class LinearOrder extends ArrayObject
{
    const PRECURSOR_KEY    = 0;
    const PRECURSOR_VALUE  = 1;

    const SUBSEQUENT_KEY   = 0;
    const SUBSEQUENT_VALUE = 1;

    const ASSIGN_KEY       = 0;
    const DEFAULT_KEY      = 1;

    const DELETE_KEY       = 0;
    const DELETE_VALUE     = 1;

    /**
     * @var array|mixed 线性表
     */
    public $oll;

    /**
     * LinearList constructor.  线性表初始化
     *
     * @param array $oll
     */
    public function __construct($oll = array ())
    {
        echo '---------------------------'.PHP_EOL;
        echo var_export($oll).PHP_EOL;
        echo '---------------------------'.PHP_EOL;
        parent::__construct($oll);
        $this->oll = $this->getIterator();
    }

    /**
     * @return void 清空线性表
     */
    public function __destruct()
    {
        unset($this->oll);
    }

    /**
     * 调试用请无视
     *
     * @param $name
     * @param $arguments
     * @return mixed
     */
    public function __call($name, $arguments)
    {
        $this->preDispatch(); // 调试用，请无视
        return call_user_func_array(array($this, $name), $arguments);
    }

    /**
     * 判断线性表是否为空
     *
     * @return boolean 为空返回true,否则返回false
     */
    protected function isEmpty()
    {
        return $this->getLength() > 0 ? false : true;
    }

    /**
     * 返回线性表的长度
     *
     * @return int
     */
    protected function getLength()
    {
        return $this->oll->count();
    }

    /**
     * 返回线性表中下标为$key的元素
     *
     * @param mixed $key 线性表元素的下标
     * @return mixed
     */
    protected function getElement($key)
    {
        return $this->oll->offsetGet($key);
    }

    /**
     * 返回线性表中某个元素的位置
     *
     * @param mixed $value 线性表中某个元素的值
     * @return int 从1开始,如果返回-1表示不存在该元素
     */
    protected function getElementPosition($value)
    {
        $i = 0;
        $this->oll->rewind();
        while ($this->oll->valid()) {
            $i++;
            if (strcmp($value, $this->oll->current()) === 0) {
                return $i;
            }
            $this->oll-> next();
        }
        return -1;
    }

    /**
     * 返回线性表中某个元素的直接前驱元素
     *
     * @param string $value 线性表中某个元素的值
     * @param int    $tag   如果$value为下标则为1, 如果$value为元素值则为0
     * @return array|bool        array('value'=>...)直接前驱元素值，array('key'=>...)直接前驱元素下标
     */
    protected function getElementPrecursor($value, $tag = self::PRECURSOR_VALUE)
    {
        $i    = 0;
        $prev = null;
        $this->oll->rewind();
        while ($this->oll->valid()) {
            $key     = $this->oll->key();
            $current = $this->oll->current();
            if (strcmp($key, $value) === 0) {
                if ($i == 1) {
                    return false;
                }
                return array ('value' => $this->getElement($prev), 'key' => $prev);
            }
            if ($tag == self::PRECURSOR_VALUE) {
                if (strcmp($current, $value) === 0) {
                    if ($i == 1) {
                        return false;
                    }
                    return array ('value' => $this->getElement($prev), 'key' => $prev);
                }
            }
            $i++;
            $prev = $this->oll->key();
            $this->oll->next();
        }
    }

    /**
     * 返回某个元素的直接后继元素
     *
     * @param string   $value $value线性表中某个元素的值
     * @param int $tag   如果$value为下标则为1,如果$value为元素值则为0
     * @return array|bool       array('value'=>...)直接后继元素值，array('key'=>...)直接后继元素下标
     */
    protected function getElementSubsequent($value, $tag = self::SUBSEQUENT_KEY)
    {
        $i   = 0;
        $len = $this->getLength();
        $this->oll->rewind();
        while ($this->oll->valid()) {
            $key     = $this->oll->key();
            $current = $this->oll->current();
            if ($tag == self::SUBSEQUENT_KEY) {
                if (strcmp($key, $value) == 0) {
                    if ($i == $len) {
                        return false;
                    }
                    $this->oll->next();
                    return array ('value' => $this->oll->current(), 'key' => $this->oll->key());
                }
            }
            if ($tag == self::SUBSEQUENT_VALUE) {
                if (strcmp($current, $value) == 0) {
                    if ($i == $len) {
                        return false;
                    }
                    $this->oll->next();
                    return array ('value' => $this->oll->current(), 'key' => $this->oll->key());
                }
            }
            $i++;
            $this->oll->next();
        }
        return false;
    }

    /**
     * 在指定位置插入一个新的结点
     *
     * @param string $p     新结点插入位置,从0开始
     * @param string $value 线性表新结点的值
     * @param null   $key   线性表新结点的下标
     * @param int    $tag   是否指定新结点的下标,1表示默认下标,0表示指定下标
     * @return bool         插入成功返回true，失败返回false
     */
    protected function getInsertElement($p, $value, $key = null, $tag = self::DEFAULT_KEY)
    {
        $p   = (int)$p;
        $i   = 0;
        if ($p > $this->getLength() || $p < 1) {
            return false;
        }
        $this->oll->rewind();
        while ($this->oll->valid()) {
            if ($i != $p) {
                $i++;
                $this->oll->next();
            }
            switch ($tag){
                case self::DEFAULT_KEY:
                    $this->oll->append($value);
                    break 2;
                case self::ASSIGN_KEY:
                    $this->oll->offsetSet($key, $value);
                    break 2;
            }
        }
        return true;
    }

    /**
     * 根据元素位置返回线性表中的某个元素
     *
     * @param mixed $position 元素位置从1开始
     * @return array|bool  array('value'=>...)元素值，array('key'=>...)元素下标
     */
    protected function getElemForPos($position)
    {
        $i        = 0;
        $len      = $this->getLength();
        $position = (int)$position;
        if ($position > $len || $position < 1) {
            return false;
        }
        $this->oll->rewind();
        while ($this->oll->valid()) {
            if ($i == $position) {
                return array ('value' => $this->oll->current(), 'key' => $this->oll->key());
            }
            $i++;
            $this->oll->next();
        }
    }

    /**
     * 根据下标或者元素值删除线性表中的某个元素
     *
     * @param mixed $value 元素下标或者值
     * @param int   $tag   0表示$value为下标，1表示$value为元素值
     * @return bool 成功返回true,失败返回false
     */
    protected function getDeleteElement($value, $tag = self::DELETE_KEY)
    {
        $this->oll->rewind();
        while ($this->oll->valid())
        {
            $key     = $this->oll->key();
            $current = $this->oll->current();
            if ($tag ==  self::DELETE_KEY) {
                if (strcmp($key, $value) === 0) {
                    $this->oll->offsetUnset($key);
                }
            }
            if ($tag == self::DELETE_VALUE) {
                if (strcmp($current, $value) === 0) {
                    $this->oll->offsetUnset($key);
                }
            }
            $this->oll->next();
        }
        return true;
    }

    /**
     * 根据元素位置删除线性表中的某个元素
     *
     * @param int $position 元素位置从1开始
     * @return bool 成功返回true,失败返回false
     */
    protected function getDeleteEleForPos($position)
    {
        $len      = $this->getLength();
        $i        = 0;
        $position = (int)$position;
        if ($position > $len || $position < 1) {
            return false;
        }
        $this->oll->rewind();
        while ($this->oll->valid()) {
            $key     = $this->oll->key();
            if ($i == $position) {
                $this->oll->offsetUnset($key);
            }
            $i++;
            $this->oll->next();
        }
        return true;
    }

    /**
     * 调试用
     *
     * @param bool $isDebug
     * @return bool
     */
    protected function preDispatch($isDebug = true)
    {
        if (!$isDebug) {
            return false;
        }
        $debug      = debug_backtrace()[1];
        $reflection = new ReflectionMethod($this, $debug['args'][0]);
        $args       = '';
        if(isset($debug['args'][1])){
            foreach ($debug['args'][1] as &$value){
                if( is_array($value )){
                    $args .= json_encode($debug['args'][1]).', ';
                }else{
                    $args .= $value.', ';
                }
            }
        }
        $args = trim($args,', ');
        echo "\t".$reflection->getDocComment() . PHP_EOL;
        echo "\t{$debug['args'][0]}({$args})\n" . PHP_EOL;
    }
}

$echo = function ($str, $action) {
    echo $str . "\t->\t" . var_export($action, true) . PHP_EOL;
    echo "--------------------------- " . PHP_EOL;
};

$oll = new LinearOrder(array ('name' => 'Jack', 10, "age", 'msg' => 10, 666));
$echo('判断线性表是否为空', $oll->isEmpty());
$echo('返回线性表的长度', $oll->getLength());
$echo('根据下标返回线性表中的某个元素', $oll->getElement(1));
$echo('返回线性表中某个元素的位置', $oll->getElementPosition(666));
$echo('返回线性表中某个元素的直接前驱元素', $oll->getElementPrecursor(666, LinearOrder::PRECURSOR_VALUE));
$echo('返回线性表中某个元素的直接后继元素', $oll->getElementSubsequent(0, LinearOrder::SUBSEQUENT_KEY));
$echo('根据元素位置返回线性表中的某个元素', $oll->getElemForPos(2));
$echo('根据下标或者元素值删除线性表中的某个元素', $oll->getDeleteElement('name', LinearOrder::DELETE_KEY));
$echo('在指定位置插入一个新的结点', $oll->getInsertElement(3, "插入新节点", "qzone", LinearOrder::ASSIGN_KEY));
$echo('$oll->oll的内容 ', $oll->oll);
```

线性表顺序存储用到了Iterator：
```
/**
 * Interface for external iterators or objects that can be iterated
 * themselves internally.
 * @link https://php.net/manual/en/class.iterator.php
 */
interface Iterator extends Traversable {

    /**
     * Return the current element
     * @link https://php.net/manual/en/iterator.current.php
     * @return mixed Can return any type.
     */
    public function current();

    /**
     * Move forward to next element
     * @link https://php.net/manual/en/iterator.next.php
     * @return void Any returned value is ignored.
     */
    public function next();

    /**
     * Return the key of the current element
     * @link https://php.net/manual/en/iterator.key.php
     * @return string|float|int|bool|null scalar on success, or null on failure.
     */
    public function key();

    /**
     * Checks if current position is valid
     * @link https://php.net/manual/en/iterator.valid.php
     * @return bool The return value will be casted to boolean and then evaluated.
     * Returns true on success or false on failure.
     */
    public function valid();

    /**
     * Rewind the Iterator to the first element
     * @link https://php.net/manual/en/iterator.rewind.php
     * @return void Any returned value is ignored.
     */
    public function rewind();
}
```

继承的ArrayObject类：
```
/**
 * This class allows objects to work as arrays.
 * @link https://php.net/manual/en/class.arrayobject.php
 */
class ArrayObject implements IteratorAggregate, ArrayAccess, Serializable, Countable {
    /**
     * Properties of the object have their normal functionality when accessed as list (var_dump, foreach, etc.).
     */
    const STD_PROP_LIST = 1;

    /**
     * Entries can be accessed as properties (read and write).
     */
    const ARRAY_AS_PROPS = 2;


    /**
     * Construct a new array object
     * @link https://php.net/manual/en/arrayobject.construct.php
     * @param array|object $array The input parameter accepts an array or an Object.
     * @param int $flags Flags to control the behaviour of the ArrayObject object.
     * @param string $iteratorClass Specify the class that will be used for iteration of the ArrayObject object. ArrayIterator is the default class used.
     *
     */
    public function __construct($array = array(), $flags = 0, $iteratorClass = "ArrayIterator") { }

    /**
     * Returns whether the requested index exists
     * @link https://php.net/manual/en/arrayobject.offsetexists.php
     * @param mixed $key <p>
     * The index being checked.
     * </p>
     * @return bool true if the requested index exists, otherwise false
     */
    public function offsetExists($key) { }

    /**
     * Returns the value at the specified index
     * @link https://php.net/manual/en/arrayobject.offsetget.php
     * @param mixed $key <p>
     * The index with the value.
     * </p>
     * @return mixed|false The value at the specified index or false.
     */
    public function offsetGet($key) { }

    /**
     * Sets the value at the specified index to newval
     * @link https://php.net/manual/en/arrayobject.offsetset.php
     * @param mixed $key <p>
     * The index being set.
     * </p>
     * @param mixed $value <p>
     * The new value for the <i>index</i>.
     * </p>
     * @return void
     */
    public function offsetSet($key, $value) { }

    /**
     * Unsets the value at the specified index
     * @link https://php.net/manual/en/arrayobject.offsetunset.php
     * @param mixed $key <p>
     * The index being unset.
     * </p>
     * @return void
     */
    public function offsetUnset($key) { }

    /**
     * Appends the value
     * @link https://php.net/manual/en/arrayobject.append.php
     * @param mixed $value <p>
     * The value being appended.
     * </p>
     * @return void
     */
    public function append($value) { }

    /**
     * Creates a copy of the ArrayObject.
     * @link https://php.net/manual/en/arrayobject.getarraycopy.php
     * @return array a copy of the array. When the <b>ArrayObject</b> refers to an object
     * an array of the public properties of that object will be returned.
     */
    public function getArrayCopy() { }

    /**
     * Get the number of public properties in the ArrayObject
     * When the <b>ArrayObject</b> is constructed from an array all properties are public.
     * @link https://php.net/manual/en/arrayobject.count.php
     * @return int The number of public properties in the ArrayObject.
     */
    public function count() { }

    /**
     * Gets the behavior flags.
     * @link https://php.net/manual/en/arrayobject.getflags.php
     * @return int the behavior flags of the ArrayObject.
     */
    public function getFlags() { }

    /**
     * Sets the behavior flags.
     * @link https://php.net/manual/en/arrayobject.setflags.php
     * @param int $flags <p>
     * The new ArrayObject behavior.
     * It takes on either a bitmask, or named constants. Using named
     * constants is strongly encouraged to ensure compatibility for future
     * versions.
     * </p>
     * <p>
     * The available behavior flags are listed below. The actual
     * meanings of these flags are described in the
     * predefined constants.
     * <table>
     * ArrayObject behavior flags
     * <tr valign="top">
     * <td>value</td>
     * <td>constant</td>
     * </tr>
     * <tr valign="top">
     * <td>1</td>
     * <td>
     * ArrayObject::STD_PROP_LIST
     * </td>
     * </tr>
     * <tr valign="top">
     * <td>2</td>
     * <td>
     * ArrayObject::ARRAY_AS_PROPS
     * </td>
     * </tr>
     * </table>
     * </p>
     * @return void
     */
    public function setFlags($flags) { }

    /**
     * Sort the entries by value
     * @link https://php.net/manual/en/arrayobject.asort.php
     * @param int $flags [optional]
     * @return void
     */
    public function asort($flags = SORT_REGULAR) { }

    /**
     * Sort the entries by key
     * @link https://php.net/manual/en/arrayobject.ksort.php
     * @param int $flags [optional]
     * @return void
     */
    public function ksort($flags = SORT_REGULAR) { }

    /**
     * Sort the entries with a user-defined comparison function and maintain key association
     * @link https://php.net/manual/en/arrayobject.uasort.php
     * @param callback $callback <p>
     * Function <i>cmp_function</i> should accept two
     * parameters which will be filled by pairs of entries.
     * The comparison function must return an integer less than, equal
     * to, or greater than zero if the first argument is considered to
     * be respectively less than, equal to, or greater than the
     * second.
     * </p>
     * @return void
     */
    public function uasort($callback) { }

    /**
     * Sort the entries by keys using a user-defined comparison function
     * @link https://php.net/manual/en/arrayobject.uksort.php
     * @param callback $callback <p>
     * The callback comparison function.
     * </p>
     * <p>
     * Function <i>cmp_function</i> should accept two
     * parameters which will be filled by pairs of entry keys.
     * The comparison function must return an integer less than, equal
     * to, or greater than zero if the first argument is considered to
     * be respectively less than, equal to, or greater than the
     * second.
     * </p>
     * @return void
     */
    public function uksort($callback) { }

    /**
     * Sort entries using a "natural order" algorithm
     * @link https://php.net/manual/en/arrayobject.natsort.php
     * @return void
     */
    public function natsort() { }

    /**
     * Sort an array using a case insensitive "natural order" algorithm
     * @link https://php.net/manual/en/arrayobject.natcasesort.php
     * @return void
     */
    public function natcasesort() { }

    /**
     * Unserialize an ArrayObject
     * @link https://php.net/manual/en/arrayobject.unserialize.php
     * @param string $data <p>
     * The serialized <b>ArrayObject</b>.
     * </p>
     * @return void The unserialized <b>ArrayObject</b>.
     */
    public function unserialize($data) { }

    /**
     * Serialize an ArrayObject
     * @link https://php.net/manual/en/arrayobject.serialize.php
     * @return string The serialized representation of the <b>ArrayObject</b>.
     */
    public function serialize() { }

    /**
     * @return array
     * @since 7.4
     */
    public function __debugInfo(){}


    /**
     * @return array
     * @since 7.4
     */
    public function __serialize(): array {}

    /**
     * @param array $data
     * @since 7.4
     */
    public function __unserialize(array $data): void {}

    /**
     * Create a new iterator from an ArrayObject instance
     * @link https://php.net/manual/en/arrayobject.getiterator.php
     * @return ArrayIterator An iterator from an <b>ArrayObject</b>.
     */
    public function getIterator() { }

    /**
     * Exchange the array for another one.
     * @link https://php.net/manual/en/arrayobject.exchangearray.php
     * @param mixed $array <p>
     * The new array or object to exchange with the current array.
     * </p>
     * @return array the old array.
     */
    public function exchangeArray($array) { }

    /**
     * Sets the iterator classname for the ArrayObject.
     * @link https://php.net/manual/en/arrayobject.setiteratorclass.php
     * @param string $iteratorClass <p>
     * The classname of the array iterator to use when iterating over this object.
     * </p>
     * @return void
     */
    public function setIteratorClass($iteratorClass) { }

    /**
     * Gets the iterator classname for the ArrayObject.
     * @link https://php.net/manual/en/arrayobject.getiteratorclass.php
     * @return string the iterator class name that is used to iterate over this object.
     */
    public function getIteratorClass() { }
}
```

#### 线性表 单链存储

```php
<?php

/**
 * LinearChain  线性表 - 单链表存储
 * [线性表单链存储]
 * =======
 * 用一组任意的存储单元存储线性表中的数据元素，用这种方法存储的线性表简称线性链表。
 * -------------------------------------------------------------
 * [单链存储的线性表的特点]
 * =======
 *    - 存储链表中结点的一组任意的存储单元可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上
 *    - 链表中结点的逻辑顺序和物理顺序不一定相同
 * -------------------------------------------------------------
 */
class LinearChain
{
    /**
     * @var  string  下一结点指针
     */
    public $next;

    /**
     * @var string 头结点数据
     */
    public $elem;

    /**
     * @var int 链表长度
     */
    public $length;

    /**
     * LinearChain constructor.  线性表初始化
     */
    public function __construct()
    {
        $this->next = $this->elem = $this->length = null;
    }

    /**
     * 清空单链表
     *
     * @return mixed
     */
    public function clearChain()
    {
        if ($this->length <= 0) {
            return false;
        }
        while ($this->next != null) {
            $q          = $this->next->next;
            $this->next = null;
            unset($this->next);
            $this->next = $q;
        }
        $this->length = 0;
    }

    /**
     * 返回单链表长度
     *
     * @return mixed
     */
    public function getLength()
    {
        return $this->length;
    }

    /**
     * 判断单链表是否为空
     *
     * @return bool 为空返回true,不为空返回false
     */
    public function getIsEmpty()
    {
        return $this->length == 0 && $this->next == null;
    }

    /**
     * 头插入法建表
     *
     * @param array $arr 建立单链表的数据
     * @return mixed
     */
    protected function getHeadCreateChain(array $arr)
    {
        $this->clearChain();
        $iterator = $this->generator($arr);
        $iterator->rewind();
        while ($iterator->valid()) {
            $node       = new stdClass();
            $node->elem = $iterator->current();
            $node->next = $this->next;
            $this->next = $node;
            $this->length++;
            $iterator->next();
        }
        return $this->next;
    }

    /**
     * 尾插入法建表
     *
     * @param array $arr 建立单链表的数据
     * @return mixed
     */
    protected function getTailCreateChain(array $arr)
    {
        $this->clearChain();
        $self     = $this;
        $iterator = $this->generator($arr);
        $iterator->rewind();
        while ($iterator->valid()) {
            $node       = new stdClass();
            $node->elem = $iterator->current();
            $node->next = $self->next;
            $self->next = $node;
            $self       = $node;
            $iterator->next();
            $this->length++;
        }
        return $this->next;
    }

    /**
     * 返回第$i个元素，头插法实现
     *
     * @param int $i 元素位序，从1开始
     * @return mixed
     */
    protected function getElemForPos($i)
    {
        $i = (int)$i;
        if ($i > $this->length || $i < 1) {
            return null;
        }
        $mark = 1;
        $self = $this->next;
        while ($mark < $i) {
            $box  = $self->next;
            $self = $box;
            $mark++;
        }
        return $self;
    }

    /**
     * 查找单链表中是否存在某个值的元素
     * 如果有返回该元素结点，否则返回null
     *
     * @param mixed $value 查找的值
     * @return mixed
     */
    protected function getElemIsExist($value)
    {
        $self = $this;
        while ($self->next != null && strcmp($self->elem, $value) !== 0) {
            $self = $self->next;
        }
        if (strcmp($self->elem, $value) === 0) {
            return $self;
        }
        return null;
    }

    /**
     * 查找单链表中是否存在某个值的元素
     * 如果有返回该元素位序，否则返回-1
     *
     * @param mixed $value 查找的值
     * @return mixed
     */
    protected function getElemPosition($value)
    {
        $self = $this;
        $mark = 0;
        while ($self->next != null && strcmp($self->elem, $value) !== 0) {
            $self = $self->next;
            $mark++;
        }
        if (strcmp($self->elem, $value) === 0) {
            return $mark;
        }
        return -1;
    }

    /**
     * 单链表的插入操作
     *
     * @param int   $key   插入元素的位序，即在什么位置插入新的元素,从1开始
     * @param mixed $value 插入的新的元素值
     * @return boolean 插入成功返回true，失败返回false
     */
    protected function getInsertElem($key, $value)
    {
        if ($key > $this->length || $key < 1) {
            return false;
        }
        $mark = 1;
        $self = $this;
        while ($self->next != null && $mark < $key) {
            $self = $self->next;
            $mark++;
        }
        $node       = new stdClass();
        $node->elem = $value;
        $node->next = $self->next;
        $self->next = $node;
        $this->length++;
        return true;
    }

    /**
     * 遍历单链表中的所有元素
     *
     * @return array 包括单链中的所有元素
     */
    protected function getAllElem()
    {
        $result = array ();
        if ($this->getIsEmpty()) {
            return $result;
        }
        $self = $this->next;
        while ($self->next != null) {
            array_push($result, $self->elem);
            $self = $self->next;
        }
        array_push($result, $self->elem);
        return $result;
    }

    /**
     * 根据Key 删除单链中的元素
     *
     * @param int $key 元素位序
     * @return boolean 删除成功返回true,失败返回false
     */
    protected function getDeleteElem($key)
    {
        $key = (int)$key;
        if ($key > $this->length || $key < 1) {
            return false;
        }
        $self = $this;
        $mark = 1;
        while ($mark < $key) {
            $self = $self->next;
            $mark++;
        }
        $node       = $self->next;
        $self->next = $node->next;
        $this->length--;
        return true;
    }

    /**
     * 删除单链表中值为$value的前 $i($i>=1) 个结点
     *
     * @param mixed mixed 待查找的值
     * @param $i    mixed 删除的次数，即删除查找到的前$i个
     * @return mixed
     */
    protected function getDeleteElemForValue($value, $i = 1)
    {
        if ($i > 1) {
            $this->getDeleteElemForValue($value, $i - 1);
        }
        $vp = $this->getElemPosition($value);
        $this->getDeleteElem($vp);
        return $this->getAllElem();
    }

    /**
     * 删除单链表所有重复的值
     *
     * @return mixed
     */
    protected function getElemUnique()
    {
        if ($this->getIsEmpty()) {
            return $this->getAllElem();
        }
        $self = $this;
        while ($self->next != null) {
            $node = $self->next;
            $ptr  = $self;
            while ($node->next != null) {
                if (strcmp($self->elem, $node->elem) === 0) {
                    $ptr->next = $node->next;
                    unset($node->next);
                    $node = $ptr->next;
                    $this->length--;
                } else {
                    $ptr  = $node;
                    $node = $node->next;
                }
            }
            $self = $self->next;
        }
        return $this->getAllElem();
    }

    /**
     * 迭代器生产
     *
     * @param array $info
     * @return \ArrayIterator
     */
    protected function generator(array $info)
    {
        return (new ArrayObject($info))->getIterator();
    }

    /**
     * 调试用请无视
     *
     * @param $name
     * @param $arguments
     * @return mixed
     */
    public function __call($name, $arguments)
    {
        $this->preDispatch(); // 调试用，请无视
        return call_user_func_array(array ($this, $name), $arguments);
    }

    /**
     * 调试用请无视！
     *
     * @param bool $isDebug
     * @return bool
     */
    protected function preDispatch($isDebug = true)
    {
        if (!$isDebug) {
            return false;
        }
        $debug      = debug_backtrace()[1];
        $reflection = new ReflectionMethod($this, $debug['args'][0]);
        $args       = '';
        if (isset($debug['args'][1])) {
            foreach ($debug['args'][1] as &$value) {
                if (is_array($value)) {
                    $args .= json_encode($debug['args'][1]) . ', ';
                } else {
                    $args .= $value . ', ';
                }
            }
        }
        $args = trim($args, ', ');
        echo "\t" . $reflection->getDocComment() . PHP_EOL;
        echo "\t{$debug['args'][0]}({$args})\n" . PHP_EOL;
    }
}

$echo     = function ($str, $action) {
    echo $str . "\t->\t" . var_export($action, true) . PHP_EOL;
    echo "--------------------------- " . PHP_EOL;
};
$personal = array (
    "One",
    "Two",
    "Three",
    "Four",
    "Five",
);

$oll = new LinearChain();
$echo('头插入链表数据', $oll->getHeadCreateChain($personal));
$echo('尾插入链表数据', $oll->getTailCreateChain($personal));
$echo('返回第二个数据', $oll->getElemForPos(2));
$echo('是否存在Tow呢？', $oll->getElemIsExist("Two"));
$echo('One 的下标示是', $oll->getElemPosition("One"));
$echo('从2号位插入一个Four', $oll->getInsertElem(2, "Four"));
$echo('遍历整个单链表', $oll->getAllElem());
$echo('删除第一个元素', $oll->getDeleteElem(1));
$echo('删除Three 前一个', $oll->getDeleteElemForValue("Three", 1));
$echo('去重链表中重复值', $oll->getElemUnique());
```

#### 堆栈

栈(Stack)：是限制在表的一端进行插入和删除操作的线性表。又称为后进先出LIFO (Last In First Out)或先进后出FILO (First In Last Out)线性表。

```php
<?php
/**
 * -------------------------------------------------------------
 * [栈的定义]
 * =======
 * 栈(Stack)：是限制在表的一端进行插入和删除操作的线性表。又称为后进先出LIFO (Last In First Out)或先进后出FILO (First In Last Out)线性表。
 * 栈顶(Top)：允许进行插入、删除操作的一端，又称为表尾。用栈顶指针(top)来指示栈顶元素。
 * 栈底(Bottom)：是固定端，又称为表头。
 * 空栈：当表中没有元素时称为空栈。
 * [栈的实现方式]
 * =======
 *   - 硬堆栈：利用CPU中的某些寄存器组或类似的硬件或使用内存的特殊区域来实现。这类堆栈容量有限，但速度很快；
 *   - 软堆栈：这类堆栈主要在内存中实现。堆栈容量可以达到很大。在实现方式上，又有动态方式和静态方式两种
 * -------------------------------------------------------------
 * [定义]
 * =======
 * 线性表(Linear List) ：是由n(n≧0)个数据元素(结点) [a1，a2， …an] 组成的有限序列。数据元素是一个抽象的符号，其具体含义在不同的情况下一般不同。
 * 该序列中的所有结点具有相同的数据类型。其中数据元素的个数n称为线性表的长度。
 * 当n=0时，称为空表。
 * 当n>0时，将非空的线性表记作： (a1，a2，…an) a1称为线性表的第一个(首)结点，an称为线性表的最后一个(尾)结点。
 * -------------------------------------------------------------
 * [线性表顺序存储]
 * =======
 * 把线性表的结点按逻辑顺序依次存放在一组地址连续的存储单元里，用这种方法存储的线性表简称线性表。
 * -------------------------------------------------------------
 * [顺序存储的线性表的特点]
 * =======
 *    - 线性表的逻辑顺序与物理顺序一致；
 *    - 数据元素之间的关系是以元素在计算机内“物理位置相邻”来体现。
 * -------------------------------------------------------------
 * @param array
 */
class StackExample
{
    /**
     * @var null   栈元素
     */
    protected $elem;
    /**
     * @var null 下一个节点
     */
    protected $next;
    /**
     * @var int 栈长度
     */
    protected $length;

    /**
     * 初始化栈
     * StackExample constructor.
     */
    public function __construct()
    {
        $this->elem   = $this->next = null;
        $this->length = 0;
    }

    /**
     * 判断栈是否空栈
     *
     * @return boolean 如果为空栈返回true,否则返回false
     */
    protected function getIsEmpty()
    {
        return $this->elem ? false : true;
    }

    /**
     * 将所有元素出栈
     *
     * @return array 返回所有栈内元素
     */
    protected function getAllPopStack()
    {
        $result = array ();
        if ($this->getIsEmpty()) {
            return $result;
        }
        while ($this->elem != null) {
            $result[]   = $this->elem->elem;
            $this->elem = $this->elem->next;
        }
        $this->length = 0;
        return $result;
    }

    /**
     * 返回栈内元素个数
     *
     * @return int
     */
    protected function getLength()
    {
        return $this->length;
    }

    /**
     * 元素进栈
     *
     * @param mixed $element 进栈元素值
     * @return void
     **/
    protected function setPushStack($element)
    {
        $stack       = new stdClass();
        $stack->elem = $element;
        $stack->next = $this->elem;
        $this->elem  = &$stack;
        $this->length++;
    }

    /**
     * 元素出栈
     *
     * @return boolean 出栈成功返回true,否则返回false
     **/
    protected function getPopStack()
    {
        if ($this->getIsEmpty()) {
            return false;
        }
        $node       = $this->elem;
        $this->elem = $node->next;
        $this->length--;
        
        return $node;
    }

    /**
     * 仅返回栈内所有元素
     *
     * @return array 栈内所有元素组成的一个数组
     */
    protected function getAllElem()
    {
        $result = array ();
        if ($this->getIsEmpty()) {
            return $result;
        }
        $node = $this->elem;
        while ($node != null) {
            $result[] = $node->elem;
            $node     = $node->next;
        }
        return $result;
    }

    /**
     * 返回栈内某个元素的个数
     *
     * @param mixed $elem 待查找的元素的值
     * @return int
     **/
    protected function getCountForElem($elem)
    {
        $result = $this->getAllElem();
        $count  = 0;
        foreach ($result as $value) {
            if ($elem === $value) {
                $count++;
            }
        }
        return $count;
    }

    /**
     * 调试用请无视
     *
     * @param $name
     * @param $arguments
     * @return mixed
     */
    public function __call($name, $arguments)
    {
        $this->preDispatch(); // 调试用，请无视
        return call_user_func_array(array ($this, $name), $arguments);
    }

    /**
     * 调试用
     *
     * @param bool $isDebug
     * @return bool
     */
    protected function preDispatch($isDebug = true)
    {
        if (!$isDebug) {
            return false;
        }
        $debug      = debug_backtrace()[1];
        $reflection = new ReflectionMethod($this, $debug['args'][0]);
        $args       = '';
        if (isset($debug['args'][1])) {
            foreach ($debug['args'][1] as &$value) {
                if (is_array($value)) {
                    $args .= json_encode($debug['args'][1]) . ', ';
                } else {
                    $args .= $value . ', ';
                }
            }
        }
        $args = trim($args, ', ');
        echo "\t" . $reflection->getDocComment() . PHP_EOL;
        echo "\t{$debug['args'][0]}({$args})\n" . PHP_EOL;
    }
}

$echo = function ($str, $action) {
    echo $str . "\t->\t" . var_export($action, true) . PHP_EOL;
    echo "--------------------------- " . PHP_EOL;
};
```

调用：
```php
$stack = new StackExample();
$stack->setPushStack('First');
$stack->setPushStack('Second');
$echo('返回栈内所有元素', $stack->getAllElem());
$stack->setPushStack('Third');
$echo('返回栈内所有元素', $stack->getAllElem());
$stack->getPopStack();
$echo('返回栈内所有元素', $stack->getAllElem());
```

输出：
```
返回栈内所有元素	->	array (
  0 => 'Second',
  1 => 'First',
)
--------------------------- 
返回栈内所有元素	->	array (
  0 => 'Third',
  1 => 'Second',
  2 => 'First',
)
--------------------------- 
返回栈内所有元素	->	array (
  0 => 'Second',
  1 => 'First',
)
--------------------------- 
```

我们也可以使用php的Spl标准库的SplStack类实现栈。

SplStack类通过使用一个双向链表(SplDoublyLinkedList)来提供栈的主要功能。

```php
<?php
//SplStack Mode is LIFO (Last In First Out)
 
$q = new SplStack();

$q[] = 1;
$q[] = 2;
$q[] = 3;
$q->push(4);
$q->add(4,5);

$q->rewind();
while($q->valid()){
    echo $q->current(),"\n";
    $q->next();
}
?>
```

输出：
```
5
4
3
2
1
```

```php
<?php
/**
 * KitchenQueue
 * -------------------------------------------------------------
 * [游戏说明]
 * 假设你要为饭店创建一个接受顾客点菜单点应用程序，这个应用程序存储一系列点菜服务，服务员添加菜单，
 * 而厨师取出菜单并制作菜肴
 * -------------------------------------------------------------
 *
 * @license   MIT
 */

class KitchenQueue
{
    /**
     * @var \stdClass $cooking
     */
    protected $cooking;

    /**
     * 服务员
     *
     * @param $dishes
     */
    public function waiter($dishes)
    {
        $node          = new \stdClass();
        $node->element = $dishes;
        $node->next    = $this->cooking;
        $this->cooking = $node;
    }

    /**
     * 厨师
     *
     * @return \stdClass
     */
    public function kitchen()
    {
        return $this->cooking;
    }
}

$kitchen = new KitchenQueue();
$kitchen->waiter("Qin Jiao Rou Si");
$kitchen->waiter("Ma Po Dou Fu");
$kitchen->waiter("Fu Qi Fei Pian");
$kitchen->waiter("Kou Shui Ji");
var_dump($kitchen->kitchen());
```

#### 二叉搜索树

```php
<?php
/**
 * 二叉搜索树
 * 
 * 二叉搜索树或者是一棵空树，或者是具有下列性质的二叉树：
 * 1.每个结点都有一个作为搜索依据的关键码(value)，所有结点的关键码互不相同。
 * 2.左子树（如果非空）上所有结点的关键码都小于根结点的关键码。
 * 3.右子树（如果非空）上所有结点的关键码都大于根结点的关键码。
 * 4.左子树和右子树也是二叉搜索树。
 * 
 * class Node {
 *  public $value;
 *  public $left = null;
 *  public $right = null;
 * }
 */
class BinarySearchTree
{
    /**
     * @var $root 根节点
     */
    public $root = null;

    /**
     * 创建新节点
     * @param $data  关键码
     */
    protected function createNode($data)
    {
        $node = new stdClass();
        $node->value = $data;
        $node->left = null;
        $node->right = null;
        return $node;
    }


    /**
     * 插入节点
     * @param $node  根节点
     * @param $value 关键值
     */
    public function insert(&$node, $value)
    {
        if(empty($value) && $value !== 0) {
            return ;
        }

        if ($node == null) {
            $node = $this->createNode($value);
        } else if ($value < $node->value) {
            $this->insert($node->left, $value);
        } else {
            $this->insert($node->right, $value);
        }
    }

    /**
     * 先序遍历
     * @param $node 根节点
     */
    public function preOrder(&$node)
    {
       if ($node != null) {
            echo $node->value . PHP_EOL ;
            $this->preOrder($node->left);
            $this->preOrder($node->right);
        }

    }
    /**
     * 中序遍历
     * @param $node 根节点
     */
    public function middleOrder(&$node)
    {
       if ($node != null) {
           $this->middleOrder($node->left);
            echo $node->value . PHP_EOL ;
            $this->middleOrder($node->right);
        }

    }

    /**
     * 后序遍历
     * @param $node 根节点
     */
    public function afterOrder(&$node)
    {
       if ($node != null) {
            $this->afterOrder($node->left);
            $this->afterOrder($node->right);
            echo $node->value . PHP_EOL;
        }
    }

    /**
     * 获取最大值
     * @param $node 根节点
     */
    public function findMax(&$node) 
    {
        while($node->right != null) {
            $node = $node->right;
        }
        return $node->value;
    }
   
}

$tree = new BinarySearchTree();
$tree->insert($tree->root, 3);
$tree->insert($tree->root, 9);
$tree->insert($tree->root, 2);
$tree->insert($tree->root, 20);

echo "先序遍历".PHP_EOL;
$tree->preOrder($tree->root); //324
echo "中序遍历" . PHP_EOL;

$tree->middleOrder($tree->root); //324
echo "后序遍历" . PHP_EOL;

$tree->afterOrder($tree->root); //234

$max = $tree->findMax($tree->root); 

var_dump($max);
```

### 小工具集

#### 堆栈实现进制转换

```php
<?php
/**
 * SystemSwitch
 *
 * -------------------------------------------------------------
 * 十进制整数转换为二、八、十六进制整数   n = (n div d) * d + n mod d
 * -------------------------------------------------------------
 */
class SystemSwitch
{
    /**
     * @var array
     */
    protected $systemGather;

    /**
     * @var int
     */
    protected $input;

    /**
     * @var mixed
     */
    protected $output;

    /**
     * SystemSwitch constructor.
     *
     * @param $input
     * @param $output
     */
    public function __construct($input, $output)
    {
        $this->systemGather = array (2, 8, 16);
        $this->input        = $input;
        $this->output       = $output;
    }

    public function run()
    {
        $before = $this->input;
        $stack  = new StackExample();
        while ($this->input != 0) {
            $mod = $this->input % $this->output;
            $stack->setPushStack($mod);
            $this->input = (int)($this->input - $mod) / $this->output;
        }
        $output = '';
        if ($this->output == 16) {
            $output .= '0x';
        } else if ($this->output == 8) {
            $output .= '0';
        }

        foreach ($stack->getAllPopStack() as $value) {
            if ($this->output == 16) {
                switch ($value) {
                    case 10:
                        $value = 'A';
                        break;
                    case 11:
                        $value = 'B';
                        break;
                    case 12:
                        $value = 'C';
                        break;
                    case 13:
                        $value = 'D';
                        break;
                    case 14:
                        $value = 'E';
                        break;
                    case 15:
                        $value = 'F';
                        break;
                }
            }
            $output .= $value;
        }
        // 因为输出语句会自动将整型的数转换为10进制输出
        // 也即如果转换后的结果为0xff,直接将0xff输出会得到255，所以返回一数组
        return array (
            'before' => $before,                           // 转换之前
            'after'  => intval($output, $this->output),    // 转换后的整型数（整型）
            'string' => $output                            // 转换后的整型数的字符串表示（字符串型）
        );
    }
}

// load the stack
define("DS", DIRECTORY_SEPARATOR);
require_once dirname(__DIR__) . DS . 'Structure' . DS . 'StackExample.php';
$systemObj = new SystemSwitch(6, 16);
$result    = $systemObj->run();
var_dump($result);
```

#### YieldExample

```php
<?php
/**
 * YieldExample
 *
 * -------------------------------------------------------------
 * 思路分析：笔记局 ,觉得需要认真学习的 Yield
 * -------------------------------------------------------------
 *  [由来]
 *  PHP从5.5引入了yield关键字，增加了迭代生成器和协程的支持，但并未在言本身级别实现一个完善的协程解决方案。
 *  PHP协程也是基于Generator，Generator可以视为一种“可中断”的函数，而 yield 构成了一系列的“中断点”。
 *  PHP 协程没有resume关键字，而是“在使用的时候唤起”协程。了解如何在PHP中实现协程，首先要解决迭代生成器。
 *  PHP > 手册 > 语言参考 > 生成器 http://php.net/manual/zh/language.generators.overview.php
 * -------------------------------------------------------------
 *  [概念]
 *  “协程”（Coroutine）概念最早由 Melvin Conway 于1958年提出。
 *   协程可以理解为纯用户态的线程，其通过协作而不是抢占来进行切换。
 *   相对于进程或者线程，协程所有的操作都可以在用户态完成，创建和切换的消耗更低。
 *   总的来说，协程为协同任务提供了一种运行时抽象，这种抽象非常适合于协同多任务调度和数据流处理。
 *   在现代操作系统和编程语言中，因为用户态线程切换代价比内核态线程小，协程成为了一种轻量级的多任务模型。
 * -------------------------------------------------------------
 *   [协程与进程线程的区别]
 *   对于操作系统来说只有进程和线程，协程的控制由应用程序显式调度，非抢占式的
 *   协程的执行最终靠的还是线程，应用程序来调度协程选择合适的线程来获取执行权
 *   切换非常快，成本低。一般占用栈大小远小于线程（协程KB级别，线程MB级别），
 *   所以可以开更多的协程，协程比线程更轻量级
 * -------------------------------------------------------------
 */

/**
 * 协程生产器
 *
 * @param     $start
 * @param     $end
 * @param int $step
 * @return \Generator
 */
$SyncFactory = function ($start, $end, $step = 1) {
    for ($i = $start; $i <= $end; $i += $step) {
        yield $i;
    }
};
/**
 * 普通的生产器
 *
 * @param     $start
 * @param     $end
 * @param int $step
 */
$UsualFactory = function ($start, $end, $step = 1) {
    for ($i = $start; $i <= $end; $i += $step) {
        //var_dump($i);
    }
};

$SyncFactory(1, 100000);  //class Generator#2  PHP 协程没有resume关键字，而是“在使用的时候唤起”协程
// Generator 这个东西是从 generators返回的 http://php.net/manual/zh/class.generator.php
$UsualFactory(1, 100000);

/**
 * 从编程角度上看，协程的思想本质上就是控制流的主动让出（yield）和恢复（resume）机制，迭代器常被用来实现协程，
 * 所以大部分的语言实现的协程中都有yield关键字，比如Python、PHP、Lua。但也有特殊比如Go就使用的是通道来通信。
 */
foreach ($SyncFactory(1, 10) as $value) {
    echo $value . "\n";       // 我理解的是相当于开了100000协程跑这次输出操作
} // 那就尝试将它唤醒吧

/**
 * [中断点]
 * 我们从生成器认识协程需要认识到：生成器是一种具有中断点的函数，而yield构成了中断点。
 * 比如, 你调用$range->rewind()，那么xrange()里的代码就会运行到控制流第一次出现yield的地方，
 * 而函数内传递给yield语句的值，即为迭代的当前值，可以通过$xrange->current()获取。
 * [PHP中的协程实现]
 * PHP的协程支持是在迭代生成器的基础上，增加了可以回送数据给生成器的功能，从而达到双向通信即：
 * -------------------------------------------------------------
 *       >>>  生成器<---数据--->调用者 <<<
 * -------------------------------------------------------------
 */
echo '/* ------------------------- Yield接收与发送数据 ------------------------- */';
/**
 * 容器接收示例
 */
function container()
{
    $test = yield "Hello ";
    var_dump($test);
    $test = yield "World ";
    var_dump($test);
}

$container = container(); // 这里又进化成 Generator对象了,还记得SPL 那一坨么？ 传送门 [http://php.net/manual/zh/book.spl.php]

var_dump($container->key());     // 返回当前产生的键
var_dump($container->current()); // 返回当前产生的值

$container->next();              //  生成器继续执行 ,这个next 看下输出结果发现返回了个NULL  你打印什么了？
$container->send('强势占位');

var_dump($container->key());       // null
var_dump($container->current());   // null

if (!$container->valid()) {
    echo "我没有被关闭" . PHP_EOL;
}

echo '/* ------------------------- 协程与任务调度 ------------------------- */';

/**
 * yield指令提供了任务中断自身的一种方法，然后把控制交回给任务调度器。
 * 而PHP语言本身只是提供程序中断的功能，至于任务调度器需要我们自己实现，
 * 同时协程在运行多个其他任务时，yield还可以用来在任务和调度器之间进行通信。
 */

/**
 * PHP协程任务
 * 简单的定义具有任何ID标识的协程函数，如一个轻量级的协程函数示例代码
 * @form http://wiki.phpboy.net/doku.php?id=2017-07:54-PHP_Yield%E5%8D%8F%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A.md
 *
 * @version  1.0
 */
class Task
{
    protected $taskId;
    protected $coroutine;
    protected $sendValue        = null;
    protected $beforeFirstYield = true;

    /**
     * Task constructor.
     *
     * @param            $taskId
     * @param \Generator $coroutine
     */
    public function __construct($taskId, Generator $coroutine)
    {
        $this->taskId    = $taskId;
        $this->coroutine = $coroutine;
    }

    /**
     * setSendValue
     *
     * @param $sendValue
     */
    public function setSendValue($sendValue)
    {
        $this->sendValue = $sendValue;
    }

    /**
     * 跑起来的巨人
     *
     * @return mixed
     */
    public function run()
    {
        if ($this->beforeFirstYield) {
            $this->beforeFirstYield = false;
            return $this->coroutine->current();
        } else {
            $retval          = $this->coroutine->send($this->sendValue);
            $this->sendValue = null;
            return $retval;
        }
    }

    /**
     * getTaskId
     *
     * @return mixed
     */
    public function getTaskId()
    {
        return $this->taskId;
    }

    /**
     * 协程关了没？
     *
     * @return bool
     */
    public function isFinished()
    {
        return !$this->coroutine->valid();
    }
}

/**
 * PHP协程调度器
 * 简单来说，是可以在多个任务之间相互协调，及任务之间相互切换的一种进程资源的分配器。
 * 调度器的实现方式有多种,大致分为两类：一是，队列；二是，定时器
 *
 * @version  1.0
 */
class Scheduler
{
    protected $maxTaskId = 0;
    protected $taskMap   = []; // taskId => task
    protected $taskQueue;

    public function __construct()
    {
        // http://php.net/manual/zh/class.splqueue.php
        $this->taskQueue = new SplQueue();
    }

    /**
     * 创建一个task 开启一个协程
     *
     * @param \Generator $coroutine
     * @return int
     */
    public function newTask(Generator $coroutine)
    {
        $tid  = ++$this->maxTaskId;
        $task = new Task($tid, $coroutine);

        $this->taskMap[$tid] = $task;
        $this->schedule($task);
        return $tid;
    }

    /**
     * 队列入队
     *
     * @param \Task $task
     */
    public function schedule(Task $task)
    {
        $this->taskQueue->enqueue($task);
    }

    /**
     * 消费队列内容
     */
    public function run()
    {
        GLOBAL $i;
        while (!$this->taskQueue->isEmpty()) {
            // 出队列
            $task   = $this->taskQueue->dequeue();
            $retval = $task->run(); // 跑Task 中的 run

            echo "Scheduler runtime:" . ++$i . "  retval is:\n";
            if ($retval instanceof SystemCall) {
                $retval($task, $this);  // 如果为函数调用则这样跑起来
                continue;
            }

            if ($task->isFinished()) {  // 结束了就删掉
                unset($this->taskMap[$task->getTaskId()]);
            } else {
                $this->schedule($task); // 那就回炉重造
            }
        }
    }
}

class SystemCall
{
    protected $callback;

    public function __construct(callable $callback)
    {
        $this->callback = $callback;
    }

    /**
     * 以函数方式调用
     *
     * @param \Task      $task
     * @param \Scheduler $scheduler
     * @return mixed
     */
    public function __invoke(Task $task, Scheduler $scheduler)
    {
        $callback = $this->callback;
        return $callback($task, $scheduler);
    }
}

/**
 * newTask()方法创建一个新任务，然后把这个任务放入任务map数组里，接着它通过把任务放入任务队列里来实现对任务的调度。
 * 接着run()方法扫描任务队列，运行任务，如果一个任务结束了，那么它将从队列里删除，否则它将在队列的末尾再次被调度。
 */

function getTaskId()
{
    return new SystemCall(function (Task $task, Scheduler $scheduler) {
        $task->setSendValue($task->getTaskId());
        $scheduler->schedule($task);
    });
}

function task($max)
{
    $tid = (yield getTaskId());
    for ($i = 0; $i < $max; $i++) {
        echo "this is task  $tid iteration $i .\n";
        yield;
    }
}

$scheduler = new Scheduler();
$scheduler->newTask(task(3));
$scheduler->newTask(task(3));

//function testYield()
//{
//    yield getTaskId();
//}

//var_dump(testYield()->current());
$scheduler->run();

/*
function task1() {
    for ($i = 1; $i <= 10; ++$i) {
        echo "This is task 1 iteration $i.\n";
        yield;
    }
}

function task2() {
    for ($i = 1; $i <= 5; ++$i) {
        echo "This is task 2 iteration $i.\n";
        yield;
    }
}
$scheduler->newTask(task1(21));
$scheduler->newTask(task2(21));
$scheduler->run();
*/

// 最后回顾一下知识点,协程不一定能提高速度，但它一定能节约到内存
/**
 * 协程创建
 *
 * @param     $start
 * @param     $limit
 * @param int $step
 * @return \Generator
 */
function xrange($start, $limit, $step = 1)
{
    for ($i = $start; $i <= $limit; $i += $step) {
        yield $i;
    }
}

$max = 999999;
$c   = new codeStatus(true);
$c->timeStart();

$simpleStart = microtime(true);
foreach (range(1, $max, 2) as $number) {
}
$simpleEnd = microtime(true);
$c->timeEnd();
print_r($c->showStatus());

$c = new codeStatus(true);
$c->timeStart();
$start = microtime(true);
foreach (xrange(1, $max, 2) as $number) {
}

$end = microtime(true);
$c->timeEnd();
print_r($c->showStatus());


/**
 * 程序耗时统计
 *
 * @version  1.0
 */
class codeStatus
{
    /**
     * @param:boolen $time_type时间类型, boolen$show_m是否显示内存,
     * boolen$show_type,false是array,ture为json,$regmax是数据保留几位
     */
    public         $regmax;
    public         $runTime = 0;
    public         $time_type;
    public         $is_show_memory;
    public         $show_type;
    private static $t1;
    private static $t2;

    public function __construct($time_type = false, $show_m = true, $show_type = false, $regmax = 3)
    {
        $this->regmax         = $regmax;
        $this->is_show_memory = $show_m;
        $this->time_type      = $time_type;
        $this->show_type      = $show_type;
    }

    public function timeStart()
    {
        self::$t1 = microtime(true);
    }

    public function timeEnd()
    {
        self::$t2 = microtime(true);
    }

    private function getTime()
    {
        if (self::$t1 != '' && self::$t2 != '') {
            if ($this->time_type == false) {
                return '耗时' . round(self::$t2 - self::$t1, $this->regmax) . '秒';
            } else if ($this->time_type == true) {
                return '耗时' . round(self::$t2 - self::$t1, ($this->regmax + 3)) * 1000 . '毫秒';
            }
        } else {
            return "error param";
        }
    }

    private function getmemory()
    {
        $memory = (!function_exists('memory_get_usage')) ? '0' : round(memory_get_usage() / 1024, $this->regmax) . 'KB';
        return '占用内存：' . $memory;
    }

    public function showStatus()
    {
        if ($this->is_show_memory == true) {
            $arr = array (self::getTime(), self::getmemory());
        } else {
            $arr = array (self::getTime());
        }
        if ($this->show_type == false) {
            return $arr;
        } else {
            return json_encode($arr);
        }
    }
}
```

### 其他

#### 数组双向队列

用PHP实现一个双向队列：
```php
class Deque
{
     private $queue = array();

     public function addFirst ( $item )
     {
          return array_unshift( $this->queue, $item );
     }

     public function addLast ( $item )
     {
          return array_push( $this->queue, $item );
     }

     public function removeFirst ()
     {
          return array_shift( $this->queue );
     }

     public function removeLast ()
     {
          return array_pop( $this->queue );
     }
} 
```

#### 线性表删除

```php
/**
 * 线性表的删除（数组中实现）,删除数组中指定的键的值
 * @param $array
 * @param $i
 * @return mixed
 */
function delete_array_element($array, $i)
{
    $len = count($array);
    for ( $j = $i; $j < $len; $j++ )
    {
        $array[ $j ] = $array [ $j + 1 ];
    }
    array_pop($array);

    return $array;
}
```

举例：

```php
$array = array(2, 4, 6, 8, 10);
$array = delete_array_element($array, 2);
print_r($array); // 输出 Array ( [0] => 2 [1] => 4 [2] => 8 [3] => 10 ) 
```

<br/><br/><br/><br/><br/>
### 参考资料

PHP 手册 函数参考 变量与类型相关扩展 数组 数组 函数 <https://www.php.net/manual/zh/ref.array.php>

用 PHP 的方式实现的各类算法合集 <https://github.com/m9rco/algorithm-php>

PHP实现八大算法 <https://www.cnblogs.com/zixuanfy/p/7617451.html>

PHP的基本算法合集 <https://www.php.cn/php-weizijiaocheng-394062.html>

PHP算法 <https://www.jianshu.com/p/cb2ad99029c8>

php数据结构和算法 <https://www.csdn.net/gather_21/MtTacg3sMzkxNy1ibG9n.html>

七大常用PHP算法 <http://www.sohu.com/a/118661179_468191> 

堆排序算法与PHP实现 <https://www.cnblogs.com/iampeter/p/3223487.html>

PHP实现排序算法----堆排序（Heap Sort） <https://blog.csdn.net/baidu_30000217/article/details/53087079>

PHP实现堆排序 <https://www.cnblogs.com/zhenbianshu/p/5273995.html>

哪本《数据结构与算法》最好？ <https://www.zhihu.com/question/21628833/answer/54623559>

数据结构与算法必备的 50 个代码实现 <https://zhuanlan.zhihu.com/p/67490380>

常见数据结构与算法整理总结（上） <https://www.cnblogs.com/xkzhangsanx/p/10888179.html>

PHP实现各种经典算法 <http://www.cnblogs.com/hellohell/p/5718175.html>

php面试题之二——数据结构和算法（高级部分） <https://blog.csdn.net/s1070/article/details/51174725>

阮一峰 字符串匹配的KMP算法 <http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html>

从头到尾彻底理解 KMP <https://wiki.jikexueyuan.com/project/kmp-algorithm/>

KMP算法—终于全部弄懂了 <https://blog.csdn.net/dark_cy/article/details/88698736>

PHP 手册 函数参考 其它基本扩展 SPL 数据结构 The SplStack class <https://www.php.net/manual/zh/class.splstack.php>
