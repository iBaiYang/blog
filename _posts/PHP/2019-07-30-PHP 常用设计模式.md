---
layout: post
categories: PHP
title: PHP 常用设计模式
meta: PHP 常用设计模式
---
* content
{:toc}

### 正文

设计模式（Design pattern）是什么：设计模式是一套被反复使用、多数人知晓、经过分类编目的代码设计的经验总结。
使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。

为什么会有设计模式：在软件开发过程中，一个功能的实现方式多种多样，不同方法的可扩展性、可维护性以及复用性都是不一样的。
随着一个人对自己项目代码的要求增加，他会逐渐思考和实践出自己的一套方法或者思想，这种方法或思想决定了他设计出的架构或者编写出的代码的质量优劣。
设计模式就属于这样一种经验的积累，是由大量优秀的工程师或者架构师总结和提炼的精华，学习好设计模式等于让我们站在了巨人的肩膀上，
从一个高的起点出发，可以避免走很多弯路。

**设计模式的分类**

一般情况下，我们把设计模式分成了三大类：

**创建型（Creational patterns）**

创建型模式是为了解决创建对象时候遇到的问题。因为基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度，
创建型设计模式有两个主导思想：一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合方式。

创建型模式主要有以下五种：
1. 简单工厂模式（Simple Factory） 和 工厂方法模式（Factory method）
2. 抽象工厂模式（Abstract factory）
3. 单例模式（Singleton）
4. 建造者模式（Builder）
5. 原型模式（Prototype）

GOF在《设计模式》一书中将工厂模式分为两类：工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）。
将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。

**结构型模式（Structural pattern）**

结构型模式是通过定义一个简单方法来实现和了解实体间关系，从而简化设计。
1. 适配器模式（Adapter）
2. 桥接模式（Bridge）
3. 合成模式（Composite）
4. 装饰者模式（Decorator）
5. 表象模式（Facade）
6. 享元模式（Flyweight）
7. 代理模式（Proxy）

**行为型模式（Behavioral pattern）**

行为型模式是用来识别对象之间的常用交流模式并加以实现，使得交流变得更加灵活。
1. 策略模式（Strategy）
2. 模板方法模式（Template method）
3. 观察者模式（Observer）
4. 迭代器模式（Iterator）
5. 责任链模式（Chain of responsibility）
6. 命令模式（Command）
7. 备忘录模式（Memento）
8. 状态模式（State）
9. 访问者模式（Visitor）
10. 中介者模式（Mediator）
11. 解释器模式（Interpreter）

**各个设计模式之间的关系**

![](https://raw.githubusercontent.com/iBaiYang/PictureWareroom/master/20190813/20190813142514.png)

#### 工厂方法模式(Factory Method)

三种工厂的比较：
* 简单工厂 ：用来生产同一等级结构中的任意产品。（对于增加新的产品，无能为力）
* 工厂方法 ：用来生产同一等级结构中的固定产品。（支持增加任意产品）
* 抽象工厂 ：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）

##### 简单工厂(Simple Factory)

简单工厂（Simple Factory）又称静态工厂方法模式（Static Factory Method Pattern）

简单工厂,官方解释为：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂模式使一个类的实例化延迟到其子类。

案例:
1. 支付宝、微信、银联的连接方式(connectMode)，支付方式(payMode)。使用工厂模式，“客户”就不需要知道具体的连接方式和支付方式了，只需要调用connectMode 和payMode即可。
2. MySQL、SQL Server、Oracle等数据库的连接方式（connectMode）、查询方式（selectMode）等操作可以使用工厂模式进行封装。下面的例子会讲到。

我们以数据库类创建的案例来说：

产品类：
```
/** 
 * 数据库系列 
 * 
 */  
abstract Class DataBase
{  
    abstract function getOne($sql); //获取一条数据的方法
}  

Class SqlServer extends DataBase
{  
    function __construct() { 
        $connect = "SqlServer 连接方法操作 （腾讯云服务器）";
        return $connect
    }

　　function getOne($sql){
        return "查询后返回数据结果";
    }
}  

Class MySql extends DataBase
{  
   function __construct(){  
       $connect = "MySql 连接方法操作 （阿里云服务器）";
       return $connect
   }

    function getOne($sql){
        return "查询后返回数据结果";
    }
}
```

工厂类：
```
/** 
 *  
 * 创建数据库的工厂类 
 */  
class Factory 
{  
    public static function  createDataBase($type) 
    {  
        switch ($type) 
        {  
            case SqlServer:  
                return new SqlServer();  
            case MySql:  
                return new MySql();  
            //....  
        }
    }  

}  
```

客户类：
```
/** 
 *  
 * 客户通过工厂获取数据 
 */  
class Customer 
{  
    private $database;  
    
    function getDataBase($type) 
    {  
        return $this->database =  Factory::createDataBase($type);  
    } 
}

$custome = new Customer;
$db = $custome->getDataBase("SqlServer");  // 我要获取阿里云的SQL Server数据库的数据。
$data = $db->getOne($sql);
```

通过以上案例可以得知一般情况下工厂模式由以下几个部分组成：
1. 工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑，根据逻辑不同，产生具体的工厂产品。如例子中的Factory类。
2. 抽象产品角色：它一般是具体产品继承的父类或者实现的接口。由接口或者抽象类来实现。如例中的DataBase接口。
3. 具体产品角色：工厂类所创建的对象就是此角色的实例。由一个具体类实现，如例子中的MySql和SqlServer类。

简单工厂的作用是实例化对象，而不需要客户了解这个对象属于哪个具体的子类。简单工厂实例化的类具有相同的接口或者基类，
在子类比较固定并不需要扩展时，可以使用简单工厂，一定程度上可以很好的降低耦合度。

使用工厂设计模式时必须先归类你的产品（需求）找到共同点和特征，然后根据共同的地方创建各自的产品类，
这时候如果没有无法通过客户类去调用每一个产品类，那么耦合度会大大增高（在需求变动的时候）， 这时候创建一个工厂类统一管理产品类，
再通过客户类调用。 那么可以很好的管理代码并一定程度上的解耦。

##### 工厂方法模式(Factory Method)

简单工厂模式实现了产品类的代码跟客户端代码分离，但会有一个问题，优秀的代码是符合“开闭原则”如果你要加一个C类产品，
你就要修改工厂类里面的代码，也就是说要增加条件语句如：switch---case。对于这个问题，接下来的工厂方法模式可以解决这个问题。

工厂方法就是为配一个产品提供一个独立的工厂类，通过不同的工厂实例来创建不同的产品实例。

使用场景:
1. 支付宝、微信、银联的连接方式(connectMode)，支付方式(payMode)。 使用工厂模式，“客户”就不需要要知道具体的连接方式和支付方式了， 
只需要调用connectMode 和 payMode即可。
2. MySQL、SQL Server、Oracle等数据库的连接方式（connectMode）、查询方式（selectMode）等操作可以使用工厂模式进行封装。

看一下案例：

产品类：
```
//抽象产品类
abstract class DataBase
{
    abstract function connect();
    abstract function getOne();
}

//具体产品类
class MySql extends DataBase
{
    function connect()
    {
        return "MySQL连接对象返回";
    }

    function getOne()
    {
        return "MySQL返回查询结果";
    }
}

//具体产品类
class SqlServer extends DataBase
{
    function connect()
    {
        return "SQL Server连接对象返回";
    }

    function getOne()
    {
        return "SQL Server返回查询结果";
    }
}
```

工厂类：
```
//抽象工厂类
abstract class FactoryDataBase{
    function createDataBase(){}
}

//具体工厂类
class FactoryMySql extends FactoryDataBase
{
    public function createDataBase()
    {
        return new MySql();
    }
}

//具体工厂类
class FactorySqlServer extends FactoryDataBase
{
    public function createDataBase()
    {
        return new SqlServer();
    }
}
```

客户：
```
$mysql = new FactoryMySql();
$db1 = $mysql->createDataBase();
$db1->connect($config);
$data = $db1->getOne($sql);
```

工厂方法模式的组成：
1. 抽象工厂角色：这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。
2. 具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。
3. 抽象产品角色：它是具体产品继承的父类或者是实现的接口。
4. 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。

工厂方法模式的优点：
1. 拥有良好的封装性，代码结构清晰。对于每一个对象的创建都是有条件约束的。如：调用一个具体的产品对象，
只需要知道这个产品的类名和约束参数就可以了，不用知道创建对象自身的复杂过程。降低模块之间的耦合度。
2. 拥有良好的扩展性，新增一个产品类，只需要适当的增加工厂类或者扩展一个工厂类，如下面的例子中，当需要增加一个数据库Oracle的操作，
则只需要增加一个Oracle类，工厂类不用修改任务就可完成系统扩展。
3. 屏蔽产品类。这一特点非常重要，产品类的实现如何变化，调用者都不需要关心，它只需要关心产品的接口，只要接口保持不变，系统中的上层模块就不要发生变化。

工厂方法模式仿佛已经把对象的创建进行了很完美的包装，使得客户程序中仅仅处理抽象产品角色提供的接口。那我们是否一定要在代码中遍布工厂呢？
大可不必。也许在下面情况下你可以考虑使用工厂方法模式：
* 当客户程序不需要知道要使用对象的创建过程。
* 客户程序使用的对象存在变动的可能，或者根本就不知道使用哪一个具体的对象。

##### 抽象工厂模式(Abstract Factory)

抽象工厂模式的用意为：给客户端提供一个接口，可以创建多个产品族中的产品对象 ，而且使用抽象工厂模式还要满足以下条件：
1. 系统中有多个产品族，而系统一次只可能消费其中一族产品。
2. 同属于同一个产品族的产品可以使用。

产品族：位于不同产品等级结构中，功能相关联的产品组成的家族。下面例子的 汽车和空调就是两个产品树， 奔驰C200+格力某型号空调就是一个产品族， 
同理， 奥迪A4+海尔某型号空调也是一个产品族。

看案例学习：

产品类：
```
// 汽车（抽象产品接口）
interface AutoProduct
{
    public function dirve();
}


//奥迪A4（具体产品类）
class AudiA4Product implements AutoProduct
{
    //获取汽车名称
    public function dirve()
    {
        echo "开奥迪A4"."<br>";
    }
}

//奔驰C200（具体产品类）
class BenzC200Product implements AutoProduct
{
    //获取汽车名称
    public function dirve()
    {
        echo "开奔驰C200"."<br>";
    }
}
```

```
//空调（抽象产品接口）
interface AirCondition
{
    public function blow();
}

//格力空调某型号（具体产品类）
class GreeAirCondition implements AirCondition
{
    public function blow()
    {
        echo "吹格力空调某型号"."<br>";
    }
}

//海尔空调某型号（具体产品类）
class HaierAirCondition implements AirCondition
{
    public function blow()
    {
        echo "吹海尔空调某型号"."<br>";
    }
}
```

工厂类：
```
//工厂接口
interface Factory
{
    public function getAuto();
    public function getAirCondition();
}


//工厂A = 奥迪A4 + 海尔空调某型号
class AFactory implements Factory
{
    //汽车
    public function getAuto()
    {
        return new AudiA4Product();
    }

    //空调
    public function getAirCondition()
    {
        return new HaierAirCondition();
    }
}

//工厂B = 奔驰C200 + 格力空调某型号
class BFactory implements Factory
{
    //汽车
    public function getAuto()
    {
        return new BenzC200Product();
    }

    //空调
    public function getAirCondition()
    {
        return new GreeAirCondition();
    }
}
```

客户端类：
```
//客户端测试代码
$factoryA = new AFactory();
$factoryB = new BFactory();

//A工厂制作车
$auto_carA = $factoryA->getAuto();
$auto_airA = $factoryA->getAirCondition();

//B工厂制作车
$auto_carB = $factoryB->getAuto();
$auto_airB = $factoryB->getAirCondition();

//开奥迪车+吹海尔空调
$auto_carA->dirve();
$auto_airA->blow(); //热的时候可以吹吹空调

//开奔驰车+吹格力空调;
$auto_carB->dirve();
$auto_airB->blow(); //热的时候可以吹吹空调
```

类图
![](https://raw.githubusercontent.com/iBaiYang/PictureWareroom/master/20190813/20190813141932.png)

抽象工厂模式的组成:
1. 抽象工厂（AbstractFactory）：确定工厂的业务范围。
2. 具体工厂（ConcreteFactory）：每个具体工厂对应一个产品族。具体工厂决定生产哪个具体产品对象。
3. 抽象产品（AbstractProduct）：同一产品等级结构的抽象类。
4. 具体产品（ConcreteProduct）：可供生产的具体产品。

工厂方法模式：
* 一个抽象产品类，可以派生出多个具体产品类。
* 一个抽象工厂类，可以派生出多个具体工厂类。
* 每个具体工厂类只能创建一个具体产品类的实例。

抽象工厂模式：
* 多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。
* 一个抽象工厂类，可以派生出多个具体工厂类。
* 每个具体工厂类可以创建多个具体产品类的实例。

#### 单例模式(Singleton)

单例模式（Singleton Pattern 单件模式或单元素模式）

单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。

单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

单例模式是一种常见的设计模式，在计算机系统中，线程池、缓存、日志对象、对话框、打印机、数据库操作、显卡的驱动程序常被设计成单例。

单例模式有以下3个特点：
1. 只能有一个实例。
2. 必须自行创建这个实例。
3. 必须给其他对象提供这一实例。

单例模式的技巧:
1. 利用$_instance私有变量来保存类的唯一实例化对象；
2. 设计一个getInstance对外公开的函数，可以获取类唯一实例；
3. 防止用户用new实例化，和克隆，构造两个__construct、__clone私有函数；

内在表现为：
* $_instance 必须声明为静态的私有变量
* 构造函数和克隆函数必须声明为私有的,这是为了防止外部程序 new 类从而失去单例模式的意义
* getInstance()方法必须声明为公有的，必须调用此方法以返回唯一实例的一个引用
* ::操作符只能访问静态变量或静态函数
* PHP的单例模式是相对而言的，因为PHP的解释运行机制使得每个PHP页面被解释执行后，所有的相关资源都会被回收。

那么为什么要使用PHP单例模式？

单例模式一个主要应用场合就是应用程序与数据库打交道的场景，在一个应用中会存在大量的数据库操作，针对数据库句柄连接数据库的行为，
使用单例模式可以避免大量的new操作。因为每一次new操作都会消耗系统和内存的资源。使用单例模式生成一个对象后，该对象可以被其它众多对象所使用。

在以往的项目开发中，没使用单例模式前的情况如下：

```
//初始化一个数据库句柄
$db = new DB(...);
//比如有个应用场景是添加一条用户信息
$db->addUserInfo();
......
//然而我们要在另一地方使用这个用户信息，这时要用到数据库句柄资源，可能会这么做，就会导致新建数据库句柄连接数据库，造成重复
......
function test() {
    $db = new DB(...);
    $db->getUserInfo();
}

// 有些朋友也许会说，可以直接使用global关键字！
global $db;
```

的确global可以解决问题，也起到单例模式的作用，但在OOP中，我们拒绝这种编码。因为global存在安全隐患（全局变量不受保护的本质）。

全局变量是面向对象程序员遇到的引发BUG的主要原因之一。这是因为全局变量将类捆绑于特定的环境，破坏了封装。
如果新的应用程序无法保证一开始就定义了相同的全局变量，那么一个依赖于全局变量的类就无法从一个应用程序中提取出来并应用到新应用程序中。

确切的讲，单例模式恰恰是对全局变量的一种改进，避免那些存储唯一实例的全局变量污染命名空间。你无法用错误类型的数据覆写一个单例。
这种保护在不支持命名空间的PHP版本里尤其重要。因为在PHP中命名冲突会在编译时被捕获，并使脚本停止运行。

单例模式的优缺点：

优点：

1. 改进系统的设计

2. 是对全局变量的一种改进

缺点：

1. 难于调试

2. 隐藏的依赖关系

3. 无法用错误类型的数据覆写一个单例

看一个单例示例：
```
class single
{
    // 私有静态属性用以保存对象
    private static $_instance =null;
    
    private $config;
    
    // 私有属性的构造方法 防止被 new
    private function __construct($config)
    {
        $this->config = $config;
    }
    
    // 私有属性的克隆方法 防止被克隆
    private function __clone(){}
    
    // 静态方法 用以实例化调用
    public static function getInstance($config)
    {
        if (!self::$_instance instanceof self) {
            self::$_instance= new self($config);
        }
        
        return self::$_instance;   
    }
    
    public function getConfig()
    {
        return $this->config;
    }
}

$single_case = single::getInstance('sam');
echo $single_case->getConfig();  // 输出sam
$single_case2 = single::getInstance('jack');
echo $single_case2->getConfig();  // 输出sam
```

可以发现第二次赋值时没有成功，这就是单例的作用，只有一个实例。

单例模式分3种：懒汉式单例、饿汉式单例、登记式单例。不过PHP不支持饿汉式单例。

**懒汉式单例**：默认加载的时候不着急实例化，在需要用这个实例的时候才实例化，延时加载。

上面那个就是懒汉式单例，下面再看一个：

```
class User 
{
    // 静态变量保存全局实例
    private static $_instance = null;
    
    // 私有构造函数，防止外界实例化对象
    private function __construct() {
    }
    
    // 私有克隆函数，防止外办克隆对象
    private function __clone() {
    }
    
    // 静态方法，单例统一访问入口
    public static function getInstance() 
    {
        if (!self::$_instance instanceof self) {
            self::$_instance = new self ();
        }
        
        return self::$_instance;
    }
    
    public function getName() 
    {
        echo 'hello world!';
    }
}
```

**饿汉式**：在实例使用之前，不管你用不用，我都先new出来再说，避免了线程安全问题。 java语言支持。

```
// 下面代码会报错  Fatal error: Constant expression contains invalid operations
// 属性声明是由关键字 public，protected 或者 private 开头，然后跟一个普通的变量声明来组成。属性中的变量可以初始化，
// 但是初始化的值必须是常数，这里的常数是指 PHP 脚本在编译阶段时就可以得到其值，而不依赖于运行时的信息才能求值。


// 错误代码就不写了，以免误导！（就是在声明private static $_instance的时候就new self()实例化，PHP不支持这种写法，切记！）
    


// 它是在类加载的时候就立即初始化，并且创建单例对象

// 优点：没有加任何的锁、执行效率比较高，在用户体验上来说，比懒汉式更好

// 缺点：类加载的时候就初始化，不管你用还是不用，我都占着空间，浪费了内存

// 绝对线程安全，在线程还没出现以前就是实例化了，不可能存在访问安全问题
```

再看一个，数据库设计，我们发送一次请求，可能会需要访问不同的表，那么如果每次访问都 new 一个实例，
那必然会造成资源的浪费，所以使用单例模式，可以很好的节省资源。

```
class DataBase
{
    /**
     * 静态成品变量，保存全局实例
     */
    private static $_instance = null;

    /**
     *  测试变量，存储日志信息
     */
    private static $_msg = null;

    /**
     * 私有构造方法，防止外界实例化对象
     */
    private function __construct()
    {
        $connect = "连接数据库操作";
    }

    /**
     * 私有化克隆方法，防止外键克隆对象
     */
    private function __clone()
    {
    }

    /**
     * 静态方法，外界获取实例的唯一接口
     * @return Object 返回对象唯一实例
     */
    public static function getInstance()
    {
        if (!self::$_instance){
            self::$_instance = new DataBase();
            self::$_msg = "这是一个新对象" . "<br>";
        }else{
            self::$_msg = "这个是一个旧的对象" . "<br>";
        }

        return self::$_instance;
    }

    public function log()
    {
        echo self::$_msg;
    }
}

// 客户端测试代码
$dbA = DataBase::getInstance();
$dbA->log();  // 输出 这是一个新对象

$dbB = DataBase::getInstance();
$dbB->log();  // 输出 这个是一个旧的对象

$dbC = DataBase::getInstance();
$dbC->log();  // 输出 这个是一个旧的对象
```

#### 建造者模式(Builder For PHP)

建造者模式：将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示的设计模式。

设计场景：
1. 有一个用户的UserInfo类，创建这个类，需要创建用户的姓名，年龄，爱好等信息，才能获得用户具体的信息结果。
2. 创建一个UserBuilder 用户建造者类，这个类，将UserInfo复杂的创建姓名，年龄，爱好等操作封装起来，简化用户类的创建过程

这是一个用户类:
```
class UserInfo
{
    protected $_userName;
    protected $_userAge;
    protected $_userHobby;

    public function setUserName($userName)
    {
        $this->_userName = $userName;
    }

    public function setUserAge($userAge)
    {
        $this->_userAge = $userAge;
    }

    public function setUserHobby($userHobby)
    {
        $this->_userHobby = $userHobby;
    }

    public function getPeopleInfo()
    {
        echo  "<br>这个人的名字是：" . $this->_userName . "<br>年龄为：" . $this->_userAge . "<br>爱好：" . $this->_userHobby;
    }
}
```

这时候我们要获取一个用户的信息，过程是这样的：
```
$modelUser = new UserInfo();
$modelUser->setUserName('松涛');
$modelUser->setUserAge('23');
$modelUser->setUserHobby('推理小说');
$modelUser->getPeopleInfo();
```

得到的结果是：
```
这个人的名字是：松涛
年龄为：23
爱好：推理小说
```

这时候创建一个用户建造者类：
```
class UserBuilder
{
    protected $_obj;

    public function __construct()
    {
        $this->_obj = new UserInfo();
    }

    public function builderPeople($userInfo)
    {
        $this->_obj->setUserName($userInfo['userName']);
        $this->_obj->setUserAge($userInfo['userAge']);
        $this->_obj->setUserHobby($userInfo['userHobby']);
    }

    public function getBuliderPeopleInfo()
    {
        $this->_obj->getPeopleInfo();
    }
}
```

这个是将复杂的创建过程封装在了builderPeople这个方法里面。 接下来是创建对象:
```
$userArr = array(
    'userName' => '松涛',
    'userAge' => '23',
    'userHobby' => '推理小说'
);

$modelUserBuilder = new UserBuilder();
$modelUserBuilder->builderPeople($userArr);
$modelUserBuilder->getBuliderPeopleInfo();
```

优点：建造者模式可以很好的将一个对象的实现与相关的“业务”逻辑分离开来，从而可以在不改变事件逻辑的前提下,使增加(或改变)实现变得非常容易。

缺点：建造者接口的修改会导致所有执行类的修改。

以下情况应当使用建造者模式：
1. 需要生成的产品对象有复杂的内部结构。
2. 需要生成的产品对象的属性相互依赖，建造者模式可以强迫生成顺序。
3. 在对象创建过程中会使用到系统中的一些其它对象，这些对象在产品对象的创建过程中不易得到。

根据以上例子，我们可以得到建造者模式的效果：
1. 建造者模式的使用使得产品的内部表象可以独立的变化。使用建造者模式可以使客户端不必知道产品内部组成的细节。
2. 每一个Builder都相对独立，而与其它的Builder（独立控制逻辑）无关。
3. 模式所建造的最终产品更易于控制。

建造者模式与工厂模式的区别：

我们可以看到，建造者模式与工厂模式是极为相似的，总体上，建造者模式仅仅只比工厂模式多了一个“导演类”的角色。在建造者模式的类图中，
假如把这个导演类看做是最终调用的客户端，那么图中剩余的部分就可以看作是一个简单的工厂模式了。

与工厂模式相比，建造者模式一般用来创建更为复杂的对象，因为对象的创建过程更为复杂，因此将对象的创建过程独立出来组成一个新的类——导演类。
也就是说，工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品；而建造者模式中，
建造者类一般只提供产品类中各个组件的建造，而将具体建造过程交付给导演类。由导演类负责将各个组件按照特定的规则组建为产品，
然后将组建好的产品交付给客户端。

#### 原型模式(Prototype For PHP)

原型设计模式： 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

原型设计模式简单的来说，就是不去创建新的对象进而保留原型的一种设计模式。

```
interface Prototype {
    public function copy();
}
```

原型类：
```
class PrototypeDemo implements Prototype
{
    private $_name;

    public function __construct($name)
    {
        // 这里可能是复杂的逻辑
        $this->_name = $name;
    }

    public function getMul()
    {
        return $this->_name * $this->_name;
    }

    public function copy()
    {
        // 克隆后的逻辑
        $this->_name ++;
        return clone $this;
    }
}
```

客户类：　　// 输入10  
```
// 客户类
class Client
{
    public function main()
    {
        $pro1 = new PrototypeDemo('10');
        echo $pro1->getMul();

        echo "<br>";

        $pro2 = $pro1->copy();
        echo $pro2->getMul();
    }
}
```

调用客户端：
```
$obj = new Client();
$obj->main();
```

输出结果：
```
100
121
```

显示传入10  然后 getMul 方法做 乘方运算 得到 10*10 = 100

然后克隆对象， 原型类的 copy 方法 被执行时， $_name 自增 1(克隆的逻辑) 后再去 做乘法运算，得到11*11 = 121

缺点：

原型设计模式最主要的缺点就是这个克隆方法需要对类的功能进行检测，这对于全新的类来说较容易，但对已有的类进行改造时将不是件容易的事情；

#### 适配器模式(Adapter For PHP)

适配器模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。

// 设置书的接口
```
// 书接口
interface BookInterface
{
    // 翻页方法
    public function turnPage();

    // 打开书方法
    public function open();
}
```

```
// 纸质书实现类
class Book implements BookInterface
{
    public function turnPage()
    {
        echo "纸质书翻页". "<br>";
    }

    public function open()
    {
        echo "纸质书打开". "<br>";
    }
}
```

客户端测试：
```
// 客户端测试
$book = new Book();
$book->open();
$book->turnPage();
```

输出结果：
```
纸质书打开
纸质书翻页
```

这时候，你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。

如下：
```
// 待适配对象
class Kindle
{
    public function turnPage()
    {
        echo "电子书翻页". "<br>";
    }

    public function open()
    {
        echo "电子书打开". "<br>";
    }
}
```

// 适配器
```
class KindleAdapter implements BookInterface
{
    protected $_kindle;

    public function __construct($obj)
    {
        $this->_kindle = $obj;
    }


    public function turnPage()
    {
        $this->_kindle->turnPage();
    }

    public function open()
    {
        $this->_kindle->open();
    }
}
```

// 客户端测试
```
$kindle = new KindleAdapter(new Kindle());
$kindle->open();
$kindle->turnPage();
```

// 输出结果
```
电子书打开
电子书翻页
```

#### 桥接模式(Bridge For PHP)

桥接模式：将两个原本不相关的类结合在一起，然后利用两个类中的方法和属性，输出一份新的结果。　

案例1. 模拟毛笔

需求：现在需要准备三种粗细（大中小），并且有五种颜色的比

如果使用蜡笔，我们需要准备3*5=15支蜡笔，也就是说必须准备15个具体的蜡笔类。而如果使用毛笔的话，只需要3种型号的毛笔，
外加5个颜料盒，用3+5=8个类就可以实现15支蜡笔的功能。

实际上，蜡笔和毛笔的关键一个区别就在于笔和颜色是否能够分离。即将抽象化(Abstraction)与实现化(Implementation)脱耦，
使得二者可以独立地变化"。关键就在于能否脱耦。蜡笔由于无法将笔与颜色分离，造成笔与颜色两个自由度无法单独变化，
使得只有创建15种对象才能完成任务。而毛笔与颜料能够很好的脱耦（比和颜色是分开的），抽象层面的概念是："毛笔用颜料作画"，
每个参与者（毛笔与颜料）都可以在自己的自由度上随意转换。

Bridge模式将继承关系转换为组合关系，从而降低了系统间的耦合，减少了代码编写量。

案例2. 模拟企业分组发短信

需求：公司现在需要按分组（临时工、正式工、管理层等）以多种形式（QQ、Email、微博等）给员工发送通知。


**适用性**：
1. 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。通过使用Bridge模式对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。
2. 不希望在抽象和它的实现部分之间有一个固定的绑定关系。
3. 一个构件有多于一个的抽象化角色和实现化角色，系统需要它们之间进行动态耦合。

**效果**：
1. Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。
2. 所谓抽象和实现沿着各自维度的变化，即“子类化”它们，得到各个子类之后，便可以任意它们，从而获得不同员工组和不同信息发送模式。
3. Bridge模式的应用一般在“两个非常强的变化维度”，有时候即使有两个变化的维度，
但是某个方向的变化维度并不剧烈——换言之两个变化不会导致纵横交错的结果，并不一定要使用Bridge模式。


看一下示例实现

员工分组：
```
abstract class Staff
{
    abstract public function staffData();
}

class CommonStaff extends Staff
{
    public function staffData()
    {
        return "小名，小红，小黑";
    }
}

class VipStaff extends Staff
{
    public function staffData()
    {
        return '小星、小龙';
    }
}
```

发送形式：
```
// 抽象父类
abstract class SendType
{
    abstract public function send($to, $content);
}

class QQSend extends SendType
{
    public function __construct()
    {
        // 与QQ接口连接方式
    }

    public function send($to, $content)
    {
        return $content. '（To '. $to . ' From QQ）<br>';
    }
}
```

```
class SendInfo
{
    protected $_level;
    protected $_method;

    public function __construct($level, $method)
    {
        //  这里可以使用单例控制资源的消耗
        $this->_level = $level;
        $this->_method = $method;
    }

    public function sending($content)
    {
        $staffArr = $this->_level->staffData();
        $result = $this->_method->send($staffArr, $content);
        echo $result;
    }
}
```

客户端调用：
```
$info = new SendInfo(new VipStaff(), new QQSend());
$info->sending( '回家吃饭');

$info = new SendInfo(new CommonStaff(), new QQSend());
$info->sending( '继续上班');
```

输出结果：
```
回家吃饭（To 小星、小龙 From QQ）
继续上班（To 小名，小红，小黑 From QQ）
```

从上面可以看出，如果增加分组或者是发送信息的类型，都可以直接创建一个类，来拓展，十分方便。

但是Bridge模式虽然是一个非常有用的模式，也非常复杂，它很好的符合了开放-封闭原则和优先使用对象，而不是继承这两个面向对象原则。

#### 模板方法模式(Template Method)

#### 策略模式(Strategy)

使用策略模式，你可以把一族不同的算法（业务）封装到不同的类中，使 client 类可以在不知道具体实现的情况下选择实例化其中一个算法。
策略模式有几种不同的变体，最简单的是下面这种：

第一段代码展示了一族输出算法，分别具体实现了 OutputInterface 的 load 方法，返回序列化结果，json 和数组：
```
<?php
interface OutputInterface
{
    public function load();
}

class SerializedArrayOutput implements OutputInterface
{
    public function load()
    {
        return serialize($arrayOfData);
    }
}

class JsonStringOutput implements OutputInterface
{
    public function load()
    {
        return json_encode($arrayOfData);
    }
}

class ArrayOutput implements OutputInterface
{
    public function load()
    {
        return $arrayOfData;
    }
}
```

通过像上面这样把不同类型的输出算法封装起来，其他的开发者可以很容易地在不影响 client 代码的情况下添加新的输出类型。

每个具体的输出类实现了 OutputInterface —— 这有两个目的，第一是它提供了一个所有输出类都必须遵守的契约，
第二，你将会在本文后面的部分看到，通过实现公共的接口，你可以利用类型约束保证 client 中使用的输出类必须是实现了 OutputInterface 的类。

接下来的一小段代码展示了一个 client 类如何使用其中一个输出算法，并可以在运行时根据需要选用不同的算法。
```
<?php
class SomeClient
{
    private $output;

    public function setOutput(OutputInterface $outputType)
    {
        $this->output = $outputType;
    }

    public function loadOutput()
    {
        return $this->output->load();
    }
}
```

上面的 client类有一个必须在运行时设置的私有属性，并且是“OutputInterface”类型的。 一旦这个属性被设置为具体的实例（三个输出类中之一的实例），
并且 loadOutput 方法被调用，那么它的 load 方法就会被调用，返回回序列化结果或 json 或数组。

```
<?php
$client = new SomeClient();

// Want an array?
$client->setOutput(new ArrayOutput());
$data = $client->loadOutput();

// Want some JSON?
$client->setOutput(new JsonStringOutput());
$data = $client->loadOutput();
```

#### 迭代器模式(Iterator)

#### 命令模式(Command)

#### 观察者模式(Observer)


<br/><br/><br/><br/><br/>
### 参考资料

常见软件架构模式 <https://ibaiyang.github.io/blog/php/2019/07/30/%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F.html>

PHP 设计模式(Design Pattern For PHP) <https://www.cnblogs.com/wilburxu/category/910011.html>

php-the-right-way 设计模式 <http://laravel-china.github.io/php-the-right-way/pages/Design-Patterns.html>

DesignPatternsPHP <https://designpatternsphp.readthedocs.io/en/latest/>

PHP 设计模式概述 <https://segmentfault.com/a/1190000016629282>

PHP设计模式（一）简单工厂模式 （Simple Factory For PHP） <https://segmentfault.com/a/1190000016635395>

PHP设计模式（二）工厂方法模式（Factory Method） <https://segmentfault.com/a/1190000016646401>

PHP设计模式（三）抽象工厂模式（Abstract Factory） <https://segmentfault.com/a/1190000016659904>

PHP设计模式（四）单例模式（Singleton） <https://segmentfault.com/a/1190000016670292>

PHP设计模式（五）建造者模式（Builder For PHP） <https://www.cnblogs.com/wilburxu/p/6179363.html>

PHP设计模式（六）原型模式（Prototype For PHP） <https://www.cnblogs.com/wilburxu/p/6188437.html>

PHP设计模式（七）适配器模式（Adapter For PHP） <https://www.cnblogs.com/wilburxu/p/6200570.html>

PHP设计模式（八）桥接模式（Bridge For PHP） <https://www.cnblogs.com/wilburxu/p/6202097.html>

PHP八大设计模式 <https://blog.csdn.net/flitrue/article/details/52614599>

php各种设计模式简单实践思考 <https://www.cnblogs.com/aksir/p/6777595.html>

工厂方法模式（Factory Method） <https://learnku.com/docs/php-design-patterns/2018/FactoryMethod/1489>

抽象工厂模式（Abstract Factory） <https://www.jianshu.com/p/7deb64f902db>

PHP设计模式-单例模式 <https://www.cnblogs.com/yangjinjin/archive/2013/01/31/2887492.html>

PHP中“简单工厂模式”实例讲解 <https://www.cnblogs.com/hongfei/archive/2012/07/07/2580776.html>

