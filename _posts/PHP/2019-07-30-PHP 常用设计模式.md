---
layout: post
categories: PHP
title: PHP 常用设计模式
meta: PHP 常用设计模式
---
* content
{:toc}

### 正文

#### 工厂方法模式(Factory Method)

##### 简单工厂(Simple Factory)

简单工厂（Simple Factory）又称静态工厂方法模式（Static Factory Method Pattern）

简单工厂,官方解释为：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂模式使一个类的实例化延迟到其子类。

案例:
1. 支付宝、微信、银联的连接方式(connectMode)，支付方式(payMode)。使用工厂模式，“客户”就不需要不要知道具体的连接方式和支付方式了，只需要调用connectMode 和payMode即可。
2. MySQL、SQL Server、Oracle等数据库的连接方式（connectMode）、查询方式（selectMode）等操作可以使用工厂模式进行封装。下面的例子会讲到。

我们以数据库类创建的案例来说：

产品类：
```
/** 
 * 数据库系列 
 * 
 */  
abstract Class DataBase
{  
    abstract function getOne($sql); //获取一条数据的方法
}  

Class SqlServer extends DataBase
{  
    function __construct() { 
        $connect = "SqlServer 连接方法操作 （腾讯云服务器）";
        return $connect
    }

　　function getOne($sql){
        return "查询后返回数据结果";
    }
}  

Class MySql extends DataBase
{  
   function __construct(){  
       $connect = "MySql 连接方法操作 （阿里云服务器）";
       return $connect
   }

    function getOne($sql){
        return "查询后返回数据结果";
    }
}
```

工厂类：
```
/** 
 *  
 * 创建数据库的工厂类 
 */  
class Factory 
{  
    public static function  createDataBase($type) 
    {  
        switch ($type) 
        {  
            case SqlServer:  
                return new SqlServer();  
            case MySql:  
                return new MySql();  
            //....  
        }
    }  

}  
```

客户类：
```
/** 
 *  
 * 客户通过工厂获取数据 
 */  
class Customer 
{  
    private $database;  
    
    function getDataBase($type) 
    {  
        return $this->database =  Factory::createDataBase($type);  
    } 
}

$custome = new Customer;
$db = $custome->getDataBase("SqlServer");  // 我要获取阿里云的SQL Server数据库的数据。
$data = $db->getOne($sql);
```

通过以上案例可以得知一般情况下工厂模式由以下几个部分组成：
1. 工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑，根据逻辑不同，产生具体的工厂产品。如例子中的Factory类。
2. 抽象产品角色：它一般是具体产品继承的父类或者实现的接口。由接口或者抽象类来实现。如例中的DataBase接口。
3. 具体产品角色：工厂类所创建的对象就是此角色的实例。由一个具体类实现，如例子中的MySql和SqlServer类。

简单工厂的作用是实例化对象，而不需要客户了解这个对象属于哪个具体的子类。简单工厂实例化的类具有相同的接口或者基类，
在子类比较固定并不需要扩展时，可以使用简单工厂，一定程度上可以很好的降低耦合度。

使用工厂设计模式时必须先归类你的产品（需求）找到共同点和特征，然后根据共同的地方创建各自的产品类，
这时候如果没有无法通过客户类去调用每一个产品类，那么耦合度会大大增高（在需求变动的时候）， 这时候创建一个工厂类统一管理产品类，
再通过客户类调用。 那么可以很好的管理代码并一定程度上的解耦。

##### 工厂方法模式(Factory Method)

简单工厂模式实现了产品类的代码跟客户端代码分离，但会有一个问题，优秀的代码是符合“开闭原则”如果你要加一个C类产品，
你就要修改工厂类里面的代码，也就是说要增加条件语句如：switch---case。对于这个问题，接下来的工厂方法模式可以解决这个问题。

工厂方法就是为配一个产品提供一个独立的工厂类，通过不同的工厂实例来创建不同的产品实例。

使用场景:
1. 支付宝、微信、银联的连接方式(connectMode)，支付方式(payMode)。 使用工厂模式，“客户”就不需要要知道具体的连接方式和支付方式了， 
只需要调用connectMode 和 payMode即可。
2. MySQL、SQL Server、Oracle等数据库的连接方式（connectMode）、查询方式（selectMode）等操作可以使用工厂模式进行封装。

看一下案例：

产品类：
```
//抽象产品类
abstract class DataBase
{
    abstract function connect();
    abstract function getOne();
}

//具体产品类
class MySql extends DataBase
{
    function connect()
    {
        return "MySQL连接对象返回";
    }

    function getOne()
    {
        return "MySQL返回查询结果";
    }
}

//具体产品类
class SqlServer extends DataBase
{
    function connect()
    {
        return "SQL Server连接对象返回";
    }

    function getOne()
    {
        return "SQL Server返回查询结果";
    }
}
```

工厂类：
```
//抽象工厂类
abstract class FactoryDataBase{
    function createDataBase(){}
}

//具体工厂类
class FactoryMySql extends FactoryDataBase
{
    public function createDataBase()
    {
        return new MySql();
    }
}

//具体工厂类
class FactorySqlServer extends FactoryDataBase
{
    public function createDataBase()
    {
        return new SqlServer();
    }
}
```

客户：
```
$mysql = new FactoryMySql();
$db1 = $mysql->createDataBase();
$db1->connect($config);
$data = $db1->getOne($sql);
```

工厂方法模式的组成：
1. 抽象工厂角色：这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。
2. 具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。
3. 抽象产品角色：它是具体产品继承的父类或者是实现的接口。
4. 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。

工厂方法模式的优点：
1. 拥有良好的封装性，代码结构清晰。对于每一个对象的创建都是有条件约束的。如：调用一个具体的产品对象，
只需要知道这个产品的类名和约束参数就可以了，不用知道创建对象自身的复杂过程。降低模块之间的耦合度。
2. 拥有良好的扩展性，新增一个产品类，只需要适当的增加工厂类或者扩展一个工厂类，如下面的例子中，当需要增加一个数据库Oracle的操作，
则只需要增加一个Oracle类，工厂类不用修改任务就可完成系统扩展。
3. 屏蔽产品类。这一特点非常重要，产品类的实现如何变化，调用者都不需要关心，它只需要关心产品的接口，只要接口保持不变，系统中的上层模块就不要发生变化。

工厂方法模式仿佛已经把对象的创建进行了很完美的包装，使得客户程序中仅仅处理抽象产品角色提供的接口。那我们是否一定要在代码中遍布工厂呢？
大可不必。也许在下面情况下你可以考虑使用工厂方法模式：
* 当客户程序不需要知道要使用对象的创建过程。
* 客户程序使用的对象存在变动的可能，或者根本就不知道使用哪一个具体的对象。


#### 模板方法模式(Template Method)

#### 策略模式(Strategy)

#### 迭代器模式(Iterator)

#### 命令模式(Command)

#### 适配器模式(Adapter)

#### 单例模式(Singleton)

单例模式（Singleton Pattern 单件模式或单元素模式）

单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

单例模式是一种常见的设计模式，在计算机系统中，线程池、缓存、日志对象、对话框、打印机、数据库操作、显卡的驱动程序常被设计成单例。

单例模式有以下3个特点：
1. 只能有一个实例。
2. 必须自行创建这个实例。
3. 必须给其他对象提供这一实例。

内在表现为：
* $_instance 必须声明为静态的私有变量
* 构造函数和克隆函数必须声明为私有的,这是为了防止外部程序 new 类从而失去单例模式的意义
* getInstance()方法必须声明为公有的，必须调用此方法以返回唯一实例的一个引用
* ::操作符只能访问静态变量或静态函数
* PHP的单例模式是相对而言的，因为PHP的解释运行机制使得每个PHP页面被解释执行后，所有的相关资源都会被回收。

那么为什么要使用PHP单例模式？

单例模式一个主要应用场合就是应用程序与数据库打交道的场景，在一个应用中会存在大量的数据库操作，针对数据库句柄连接数据库的行为，
使用单例模式可以避免大量的new操作。因为每一次new操作都会消耗系统和内存的资源。使用单例模式生成一个对象后，该对象可以被其它众多对象所使用。

在以往的项目开发中，没使用单例模式前的情况如下：

```
//初始化一个数据库句柄
$db = new DB(...);
//比如有个应用场景是添加一条用户信息
$db->addUserInfo();
......
//然而我们要在另一地方使用这个用户信息，这时要用到数据库句柄资源，可能会这么做
......
function test() {
    $db = new DB(...);
    $db->getUserInfo();
}

// 有些朋友也许会说，可以直接使用global关键字！
global $db;
```

的确global可以解决问题，也起到单例模式的作用，但在OOP中，我们拒绝这种编码。因为global存在安全隐患（全局变量不受保护的本质）。

全局变量是面向对象程序员遇到的引发BUG的主要原因之一。这是因为全局变量将类捆绑于特定的环境，破坏了封装。
如果新的应用程序无法保证一开始就定义了相同的全局变量，那么一个依赖于全局变量的类就无法从一个应用程序中提取出来并应用到新应用程序中。

确切的讲，单例模式恰恰是对全局变量的一种改进，避免那些存储唯一实例的全局变量污染命名空间。你无法用错误类型的数据覆写一个单例。
这种保护在不支持命名空间的PHP版本里尤其重要。因为在PHP中命名冲突会在编译时被捕获，并使脚本停止运行。

单例模式的优缺点：

优点：

1. 改进系统的设计

2. 是对全局变量的一种改进

缺点：

1. 难于调试

2. 隐藏的依赖关系

3. 无法用错误类型的数据覆写一个单例

看一个单例示例：
```
class single
{
    // 私有静态属性用以保存对象
    private static $_instance =null;
    
    private $config;
    
    // 私有属性的构造方法 防止被 new
    private function __construct($config)
    {
        $this->config = $config;
    }
    
    // 私有属性的克隆方法 防止被克隆
    private function __clone(){}
    
    // 静态方法 用以实例化调用
    public static function getInstance($config)
    {
        if (!self::$_instance instanceof self) {
            self::$_instance= new self($config);
        }
        
        return self::$_instance;   
    }
    
    public function getConfig()
    {
        return $this->config;
    }
}

$single_case = single::getInstance('sam');
echo $single_case->getConfig();  // 输出sam
$single_case2 = single::getInstance('jack');
echo $single_case2->getConfig();  // 输出sam
```

可以发现第二次赋值时没有成功，这就是单例的作用，只有一个实例。

单例模式分3种：懒汉式单例、饿汉式单例、登记式单例。不过PHP不支持饿汉式单例。

**懒汉式单例**：默认加载的时候不着急实例化，在需要用这个实例的时候才实例化，延时加载。

上面那个就是懒汉式单例，下面再看一个：

```
class User 
{
    // 静态变量保存全局实例
    private static $_instance = null;
    
    // 私有构造函数，防止外界实例化对象
    private function __construct() {
    }
    
    // 私有克隆函数，防止外办克隆对象
    private function __clone() {
    }
    
    // 静态方法，单例统一访问入口
    public static function getInstance() 
    {
        if (!self::$_instance instanceof self) {
            self::$_instance = new self ();
        }
        
        return self::$_instance;
    }
    
    public function getName() 
    {
        echo 'hello world!';
    }
}
```

**饿汉式**：在实例使用之前，不管你用不用，我都先new出来再说，避免了线程安全问题。 java语言支持。

```
// 下面代码会报错  Fatal error: Constant expression contains invalid operations
// 属性声明是由关键字 public，protected 或者 private 开头，然后跟一个普通的变量声明来组成。属性中的变量可以初始化，
// 但是初始化的值必须是常数，这里的常数是指 PHP 脚本在编译阶段时就可以得到其值，而不依赖于运行时的信息才能求值。
class User 
{
    // 静态变量保存全局实例
    private static $_instance = new self();
    
    // 私有构造函数，防止外界实例化对象
    private function __construct() {
    }
    
    // 私有克隆函数，防止外办克隆对象
    private function __clone() {
    }
    
    // 静态方法，单例统一访问入口
    public static function getInstance() 
    {        
        return self::$_instance;
    }
    
    public function getName() 
    {
        echo 'hello world!';
    }
}

// 它是在类加载的时候就立即初始化，并且创建单例对象

// 优点：没有加任何的锁、执行效率比较高，在用户体验上来说，比懒汉式更好

// 缺点：类加载的时候就初始化，不管你用还是不用，我都占着空间，浪费了内存

// 绝对线程安全，在线程还没出现以前就是实例化了，不可能存在访问安全问题
```

#### 观察者模式(Observer)


<br/><br/><br/><br/><br/>
### 参考资料

常见软件架构模式 <https://ibaiyang.github.io/blog/php/2019/07/30/%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F.html>

PHP 设计模式概述 <https://segmentfault.com/a/1190000016629282>

PHP八大设计模式 <https://blog.csdn.net/flitrue/article/details/52614599>

php各种设计模式简单实践思考 <https://www.cnblogs.com/aksir/p/6777595.html>

工厂方法模式（Factory Method） <https://learnku.com/docs/php-design-patterns/2018/FactoryMethod/1489>

抽象工厂模式（Abstract Factory） <https://www.jianshu.com/p/7deb64f902db>

PHP设计模式-单例模式 <https://www.cnblogs.com/yangjinjin/archive/2013/01/31/2887492.html>

PHP设计模式（一）简单工厂模式 （Simple Factory For PHP） <https://segmentfault.com/a/1190000016635395>

PHP设计模式（二）工厂方法模式（Factory Method） <https://segmentfault.com/a/1190000016646401>

