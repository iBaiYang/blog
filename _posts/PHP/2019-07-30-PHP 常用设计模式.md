---
layout: post
categories: PHP
title: PHP 常用设计模式
meta: PHP 常用设计模式
---
* content
{:toc}

### 正文

#### 常用PHP设计模式

##### 工厂方法模式(Factory Method)

##### 模板方法模式(Template Method)

##### 策略模式(Strategy)

##### 迭代器模式(Iterator)

##### 命令模式(Command)

##### 适配器模式(Adapter)

##### 单例模式(Singleton)

单例模式（Singleton Pattern 单件模式或单元素模式）

单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

单例模式是一种常见的设计模式，在计算机系统中，线程池、缓存、日志对象、对话框、打印机、数据库操作、显卡的驱动程序常被设计成单例。

单例模式有以下3个特点：
1. 只能有一个实例。
2. 必须自行创建这个实例。
3. 必须给其他对象提供这一实例。

内在表现为：
* $_instance 必须声明为静态的私有变量
* 构造函数和克隆函数必须声明为私有的,这是为了防止外部程序 new 类从而失去单例模式的意义
* getInstance()方法必须声明为公有的，必须调用此方法以返回唯一实例的一个引用
* ::操作符只能访问静态变量或静态函数
* PHP的单例模式是相对而言的，因为PHP的解释运行机制使得每个PHP页面被解释执行后，所有的相关资源都会被回收。

那么为什么要使用PHP单例模式？

单例模式一个主要应用场合就是应用程序与数据库打交道的场景，在一个应用中会存在大量的数据库操作，针对数据库句柄连接数据库的行为，
使用单例模式可以避免大量的new操作。因为每一次new操作都会消耗系统和内存的资源。使用单例模式生成一个对象后，该对象可以被其它众多对象所使用。

在以往的项目开发中，没使用单例模式前的情况如下：

```
//初始化一个数据库句柄
$db = new DB(...);
//比如有个应用场景是添加一条用户信息
$db->addUserInfo();
......
//然而我们要在另一地方使用这个用户信息，这时要用到数据库句柄资源，可能会这么做
......
function test() {
    $db = new DB(...);
    $db->getUserInfo();
}

// 有些朋友也许会说，可以直接使用global关键字！
global $db;
```

的确global可以解决问题，也起到单例模式的作用，但在OOP中，我们拒绝这种编码。因为global存在安全隐患（全局变量不受保护的本质）。

全局变量是面向对象程序员遇到的引发BUG的主要原因之一。这是因为全局变量将类捆绑于特定的环境，破坏了封装。
如果新的应用程序无法保证一开始就定义了相同的全局变量，那么一个依赖于全局变量的类就无法从一个应用程序中提取出来并应用到新应用程序中。

确切的讲，单例模式恰恰是对全局变量的一种改进，避免那些存储唯一实例的全局变量污染命名空间。你无法用错误类型的数据覆写一个单例。
这种保护在不支持命名空间的PHP版本里尤其重要。因为在PHP中命名冲突会在编译时被捕获，并使脚本停止运行。

单例模式的优缺点：

优点：

1. 改进系统的设计

2. 是对全局变量的一种改进

缺点：

1. 难于调试

2. 隐藏的依赖关系

3. 无法用错误类型的数据覆写一个单例

看一个单例示例：
```
class single
{
    // 私有静态属性用以保存对象
    private static $_instance =null;
    
    private $config;
    
    // 私有属性的构造方法 防止被 new
    private function __construct($config)
    {
        $this->config = $config;
    }
    
    // 私有属性的克隆方法 防止被克隆
    private function __clone(){}
    
    // 静态方法 用以实例化调用
    public static function getInstance($config)
    {
        if (!self::$_instance instanceof self) {
            self::$_instance= new self($config);
        }
        
        return self::$_instance;   
    }
    
    public function getConfig()
    {
        return $this->config;
    }
}

$single_case = single::getInstance('sam');
echo $single_case->getConfig();  // 输出sam
$single_case2 = single::getInstance('jack');
echo $single_case2->getConfig();  // 输出sam
```

可以发现第二次赋值时没有成功，这就是单例的作用，只有一个实例。

单例模式分3种：懒汉式单例、饿汉式单例、登记式单例。不过PHP不支持饿汉式单例。

**懒汉式单例**：默认加载的时候不着急实例化，在需要用这个实例的时候才实例化，延时加载。

上面那个就是懒汉式单例，下面再看一个：

```
class User 
{
    // 静态变量保存全局实例
    private static $_instance = null;
    
    // 私有构造函数，防止外界实例化对象
    private function __construct() {
    }
    
    // 私有克隆函数，防止外办克隆对象
    private function __clone() {
    }
    
    // 静态方法，单例统一访问入口
    public static function getInstance() 
    {
        if (!self::$_instance instanceof self) {
            self::$_instance = new self ();
        }
        
        return self::$_instance;
    }
    
    public function getName() 
    {
        echo 'hello world!';
    }
}
```

**饿汉式**：在实例使用之前，不管你用不用，我都先new出来再说，避免了线程安全问题。 java语言支持。

```
// 下面代码会报错  Fatal error: Constant expression contains invalid operations
// 属性声明是由关键字 public，protected 或者 private 开头，然后跟一个普通的变量声明来组成。属性中的变量可以初始化，
// 但是初始化的值必须是常数，这里的常数是指 PHP 脚本在编译阶段时就可以得到其值，而不依赖于运行时的信息才能求值。
class User 
{
    // 静态变量保存全局实例
    private static $_instance = new self();
    
    // 私有构造函数，防止外界实例化对象
    private function __construct() {
    }
    
    // 私有克隆函数，防止外办克隆对象
    private function __clone() {
    }
    
    // 静态方法，单例统一访问入口
    public static function getInstance() 
    {        
        return self::$_instance;
    }
    
    public function getName() 
    {
        echo 'hello world!';
    }
}

// 它是在类加载的时候就立即初始化，并且创建单例对象

// 优点：没有加任何的锁、执行效率比较高，在用户体验上来说，比懒汉式更好

// 缺点：类加载的时候就初始化，不管你用还是不用，我都占着空间，浪费了内存

// 绝对线程安全，在线程还没出现以前就是实例化了，不可能存在访问安全问题
```

##### 观察者模式(Observer)


<br/><br/><br/><br/><br/>
### 参考资料

常见软件架构模式 <https://ibaiyang.github.io/blog/php/2019/07/30/%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F.html>

PHP 设计模式概述 <https://segmentfault.com/a/1190000016629282>

PHP八大设计模式 <https://blog.csdn.net/flitrue/article/details/52614599>

php各种设计模式简单实践思考 <https://www.cnblogs.com/aksir/p/6777595.html>

工厂方法模式（Factory Method） <https://learnku.com/docs/php-design-patterns/2018/FactoryMethod/1489>

抽象工厂模式（Abstract Factory） <https://www.jianshu.com/p/7deb64f902db>

PHP设计模式-单例模式 <https://www.cnblogs.com/yangjinjin/archive/2013/01/31/2887492.html>

