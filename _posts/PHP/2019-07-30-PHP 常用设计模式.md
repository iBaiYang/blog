---
layout: post
categories: PHP
title: PHP 常用设计模式
meta: PHP 常用设计模式
---
* content
{:toc}

### 正文

设计模式（Design pattern）是什么：设计模式是一套被反复使用、多数人知晓、经过分类编目的代码设计的经验总结。
使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。

为什么会有设计模式：在软件开发过程中，一个功能的实现方式多种多样，不同方法的可扩展性、可维护性以及复用性都是不一样的。
随着一个人对自己项目代码的要求增加，他会逐渐思考和实践出自己的一套方法或者思想，这种方法或思想决定了他设计出的架构或者编写出的代码的质量优劣。
设计模式就属于这样一种经验的积累，是由大量优秀的工程师或者架构师总结和提炼的精华，学习好设计模式等于让我们站在了巨人的肩膀上，
从一个高的起点出发，可以避免走很多弯路。

**设计模式的分类**

一般情况下，我们把设计模式分成了三大类：

**创建型模式（Creational patterns）**

在软件工程中，创建型设计模式用于处理对象的实例化。

创建型模式是为了解决创建对象时候遇到的问题。因为基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度，
创建型设计模式有两个主导思想：一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合方式。

* 简单工厂模式（Simple Factory） 
* 静态工厂模式（Static Factory）
* 工厂方法模式（Factory method）
* 抽象工厂模式（Abstract factory）
* 建造者模式（Builder）
* 单例模式（Singleton）
* 多例模式（Multiton）
* 原型模式（Prototype）
* 对象池模式（Pool）

GOF在《设计模式》一书中将工厂模式分为两类：工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）。
将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。

[创建型模式解说地址](https://ibaiyang.github.io/blog/php/2019/07/30/PHP-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F.html)

**结构型模式（Structural pattern）**

结构型设计模式用于处理类和对象的组合。

结构型模式是通过定义一个简单方法来实现和了解实体间关系，从而简化设计。

* 适配器模式（Adapter）
* 桥梁模式（Bridge）
* 组合模式（Composite）
* 数据映射模式（Data Mapper）
* 装饰模式（Decorator）
* 依赖注入模式（Dependency Injection）
* 门面模式（Facade）
* 流接口模式（Fluent Interface）
* 代理模式（Proxy）
* 注册模式（Registry）
* 享元模式（Flyweight）

[结构型模式解说地址](https://ibaiyang.github.io/blog/php/2019/07/30/PHP-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F.html)

**行为型模式（Behavioral pattern）**

行为型设计模式用于处理类的对象间通信。

行为型模式是用来识别对象之间的常用交流模式并加以实现，使得交流变得更加灵活。

* 责任链模式（Chain Of Responsibilities）
* 命令行模式（Command）
* 迭代器模式（Iterator）
* 中介者模式（Mediator）
* 备忘录模式（Memento）
* 空对象模式（Null Object）
* 观察者模式（Observer）
* 规格模式（Specification）
* 状态模式（State）
* 策略模式（Strategy）
* 模板方法模式（Template Method）
* 访问者模式（Visitor）
* 解释器模式（Interpreter）

[行为型模式解说地址](https://ibaiyang.github.io/blog/php/2019/07/30/PHP-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F.html)

**其它**

* 委托模式（Delegation）
* 资源库模式（Repository）
* 服务定位器模式（Service Locator）
* 事件模式（Event）
* 行为模式（Behavior）

**各个设计模式之间的关系**

![]({{site.baseurl}}/images/20190813/20190813142514.png)

#### 委托模式（Delegation）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 资源库模式（Repository）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 服务定位器模式(Service Locator)

* 模式定义

当系统中的组件需要调用某一服务来完成特定的任务时，通常最简单的做法是使用 new 关键字来创建该服务的实例，
或者通过工厂模式来解耦该组件与服务的具体实现部分，以便通过配置信息等更为灵活的方式获得该服务的实例。然而，这些做法都有着各自的弊端：
1. 在组件中直接维护对服务实例的引用，会造成组件与服务之间的关联依赖，当需要替换服务的具体实现时，
  不得不修改组件中调用服务的部分并重新编译解决方案；即使采用工厂模式来根据配置信息动态地获得服务的实例，
  也无法针对不同的服务类型向组件提供一个管理服务实例的中心位置；
2. 由于组件与服务之间的这种关联依赖，使得项目的开发过程受到约束。在实际项目中，开发过程往往是并行的，但又不是完全同步的，
  比如组件的开发跟其所需要的服务的开发同时进行，但很有可能当组件需要调用服务时，服务却还没完成开发和单体测试。
  遇到这种问题时，通常会将组件调用服务的部分暂时空缺，待到服务完成开发和单体测试之后，将其集成到组件的代码中。
  但这种做法不仅费时，而且增大了出错的风险；
3. 针对组件的单体测试变得复杂。每当对组件进行单体测试时，不得不为其配置并运行所需要的服务，
  而无法使用Service Stub来解决组件与服务之间的依赖；
4. 在组件中可能存在多个地方需要引用服务的实例，在这种情况下，直接创建服务实例的代码会散布到整个程序中，
  造成一段程序存在多个副本，大大增加维护和排错成本；
5. 当组件需要调用多个服务时，不同服务初始化各自实例的方式又可能存在差异。
  开发人员不得不了解所有服务初始化的API，以便在程序中能够正确地使用这些服务；
6. 某些服务的初始化过程需要耗费大量资源，因此多次重复地初始化服务会大大增加系统的资源占用和性能损耗。
  程序中需要有一个管理服务初始化过程的机制，在统一初始化接口的同时，还需要为程序提供部分缓存功能。

要解决以上问题，我们可以在应用程序中引入服务定位器（Service Locator）模式。 
服务定位器（Service Locator）模式是一种企业级应用程序体系结构模式，它能够为应用程序中服务的创建和初始化提供一个中心位置，
并解决了上文中所提到的各种设计和开发问题。 服务定位器模式和依赖注入模式都是控制反转（IoC）模式的实现。
我们在服务定位器中注册给定接口的服务实例，然后通过接口获取服务并在应用代码中使用而不需要关心其具体实现。
我们可以在启动时配置并注入服务提供者。 如果你了解 Laravel 框架，你对这一流程会很熟悉，没错，这就是 Laravel 框架的核心机制，
我们在服务提供者中绑定接口及其实现，将服务实例注册到服务容器中，然后在使用时可以通过依赖注入或者通过服务接口/别名获取服务实例的方式调用服务。

* UML类图

![]({{site.baseurl}}/images/UML/Service-Locator.png)

* 示例代码

ServiceLocatorInterface.php
```php
<?php
namespace DesignPatterns\More\ServiceLocator;

interface ServiceLocatorInterface
{
    /**
     * Checks if a service is registered.
     *
     * @param string $interface
     *
     * @return bool
     */
    public function has($interface);

    /**
     * Gets the service registered for the interface.
     *
     * @param string $interface
     *
     * @return mixed
     */
    public function get($interface);
}
```

ServiceLocator.php
```php
<?php
namespace DesignPatterns\More\ServiceLocator;

class ServiceLocator implements ServiceLocatorInterface
{
    /**
     * All services.
     *
     * @var array
     */
    private $services;

    /**
     * The services which have an instance.
     *
     * @var array
     */
    private $instantiated;

    /**
     * True if a service can be shared.
     *
     * @var array
     */
    private $shared;

    public function __construct()
    {
        $this->services     = array();
        $this->instantiated = array();
        $this->shared       = array();
    }

    /**
     * Registers a service with specific interface.
     *
     * @param string $interface
     * @param string|object $service
     * @param bool $share
     */
    public function add($interface, $service, $share = true)
    {
        /**
         * When you add a service, you should register it
         * with its interface or with a string that you can use
         * in the future even if you will change the service implementation.
         */

        if (is_object($service) && $share) {
            $this->instantiated[$interface] = $service;
        }
        $this->services[$interface] = (is_object($service) ? get_class($service) : $service);
        $this->shared[$interface]   = $share;
    }

    /**
     * Checks if a service is registered.
     *
     * @param string $interface
     *
     * @return bool
     */
    public function has($interface)
    {
        return (isset($this->services[$interface]) || isset($this->instantiated[$interface]));
    }

    /**
     * Gets the service registered for the interface.
     *
     * @param string $interface
     *
     * @return mixed
     */
    public function get($interface)
    {
        // Retrieves the instance if it exists and it is shared
        if (isset($this->instantiated[$interface]) && $this->shared[$interface]) {
            return $this->instantiated[$interface];
        }

        // otherwise gets the service registered.
        $service = $this->services[$interface];

        // You should check if the service class exists and
        // the class is instantiable.

        // This example is a simple implementation, but
        // when you create a service, you can decide
        // if $service is a factory or a class.
        // By registering a factory you can create your services
        // using the DependencyInjection pattern.

        // ...

        // Creates the service object
        $object = new $service();

        // and saves it if the service must be shared.
        if ($this->shared[$interface]) {
            $this->instantiated[$interface] = $object;
        }
        return $object;
    }
}
```

LogServiceInterface.php
```php
<?php
namespace DesignPatterns\More\ServiceLocator;

interface LogServiceInterface
{
}
```

LogService.php
```php
<?php
namespace DesignPatterns\More\ServiceLocator;

class LogService implements LogServiceInterface
{
}
```

DatabaseServiceInterface.php
```php
<?php
namespace DesignPatterns\More\ServiceLocator;

interface DatabaseServiceInterface
{
}
```

DatabaseService.php
```php
<?php
namespace DesignPatterns\More\ServiceLocator;

class DatabaseService implements DatabaseServiceInterface
{
}
```

* 测试代码

Tests/ServiceLocatorTest.php
```php
<?php
namespace DesignPatterns\More\ServiceLocator\Tests;

use DesignPatterns\More\ServiceLocator\DatabaseService;
use DesignPatterns\More\ServiceLocator\LogService;
use DesignPatterns\More\ServiceLocator\ServiceLocator;
use \PHPUnit_Framework_TestCase as TestCase;

class ServiceLocatorTest extends TestCase
{
    /**
     * @var LogService
     */
    private $logService;

    /**
     * @var DatabaseService
     */
    private $databaseService;

    /**
     * @var ServiceLocator
     */
    private $serviceLocator;

    public function setUp()
    {
        $this->serviceLocator  = new ServiceLocator();
        $this->logService      = new LogService();
        $this->databaseService = new DatabaseService();
    }

    public function testHasServices()
    {
        $this->serviceLocator->add(
            'DesignPatterns\More\ServiceLocator\LogServiceInterface',
            $this->logService
        );

        $this->serviceLocator->add(
            'DesignPatterns\More\ServiceLocator\DatabaseServiceInterface',
            $this->databaseService
        );

        $this->assertTrue($this->serviceLocator->has('DesignPatterns\More\ServiceLocator\LogServiceInterface'));
        $this->assertTrue($this->serviceLocator->has('DesignPatterns\More\ServiceLocator\DatabaseServiceInterface'));

        $this->assertFalse($this->serviceLocator->has('DesignPatterns\More\ServiceLocator\FakeServiceInterface'));
    }

    public function testServicesWithObject()
    {
        $this->serviceLocator->add(
            'DesignPatterns\More\ServiceLocator\LogServiceInterface',
            $this->logService
        );

        $this->serviceLocator->add(
            'DesignPatterns\More\ServiceLocator\DatabaseServiceInterface',
            $this->databaseService
        );

        $this->assertSame(
            $this->logService,
            $this->serviceLocator->get('DesignPatterns\More\ServiceLocator\LogServiceInterface')
        );

        $this->assertSame(
            $this->databaseService,
            $this->serviceLocator->get('DesignPatterns\More\ServiceLocator\DatabaseServiceInterface')
        );
    }

    public function testServicesWithClass()
    {
        $this->serviceLocator->add(
            'DesignPatterns\More\ServiceLocator\LogServiceInterface',
            get_class($this->logService)
        );

        $this->serviceLocator->add(
            'DesignPatterns\More\ServiceLocator\DatabaseServiceInterface',
            get_class($this->databaseService)
        );

        $this->assertNotSame(
            $this->logService,
            $this->serviceLocator->get('DesignPatterns\More\ServiceLocator\LogServiceInterface')
        );

        $this->assertInstanceOf(
            'DesignPatterns\More\ServiceLocator\LogServiceInterface',
            $this->serviceLocator->get('DesignPatterns\More\ServiceLocator\LogServiceInterface')
        );

        $this->assertNotSame(
            $this->databaseService,
            $this->serviceLocator->get('DesignPatterns\More\ServiceLocator\DatabaseServiceInterface')
        );

        $this->assertInstanceOf(
            'DesignPatterns\More\ServiceLocator\DatabaseServiceInterface',
            $this->serviceLocator->get('DesignPatterns\More\ServiceLocator\DatabaseServiceInterface')
        );
    }

    public function testServicesNotShared()
    {
        $this->serviceLocator->add(
            'DesignPatterns\More\ServiceLocator\LogServiceInterface',
            $this->logService,
            false
        );

        $this->serviceLocator->add(
            'DesignPatterns\More\ServiceLocator\DatabaseServiceInterface',
            $this->databaseService,
            false
        );

        $this->assertNotSame(
            $this->logService,
            $this->serviceLocator->get('DesignPatterns\More\ServiceLocator\LogServiceInterface')
        );

        $this->assertInstanceOf(
            'DesignPatterns\More\ServiceLocator\LogServiceInterface',
            $this->serviceLocator->get('DesignPatterns\More\ServiceLocator\LogServiceInterface')
        );

        $this->assertNotSame(
            $this->databaseService,
            $this->serviceLocator->get('DesignPatterns\More\ServiceLocator\DatabaseServiceInterface')
        );

        $this->assertInstanceOf(
            'DesignPatterns\More\ServiceLocator\DatabaseServiceInterface',
            $this->serviceLocator->get('DesignPatterns\More\ServiceLocator\DatabaseServiceInterface')
        );
    }
}
```

* 拓展

服务定位器(Service Locator)是IoC的另一种实现方式， 其核心是把所有可能用到的依赖单元交由Service Locator进行实例化和创建、配置， 
把类对依赖单元的依赖，转换成类对Service Locator的依赖。 DI 与 Service Locator并不冲突，两者可以结合使用。 
目前，Yii2.0把这DI和Service Locator这两个东西结合起来使用，或者说通过DI容器，实现了Service Locator。

具体实例，可以看一下 [深入理解Yii2.0 服务定位器](https://ibaiyang.github.io/blog/yii2/2019/06/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Yii2.0-%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%BD%8D%E5%99%A8.html) 。

#### 事件模式（Event）

使用事件，可以在特定的时点，触发执行预先设定的一段代码，事件既是代码解耦的一种方式，也是设计业务流程的一种模式。

具体实例，可以看一下 [深入理解Yii2.0 事件](https://ibaiyang.github.io/blog/yii2/2019/06/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Yii2.0-%E4%BA%8B%E4%BB%B6.html) 。

#### 行为模式（Behavior）

使用行为（behavior）可以在不修改现有类的情况下，对类的功能进行扩充。 通过将行为绑定到一个类，可以使类具有行为本身所定义的属性和方法， 
就好像类本来就有这些属性和方法一样。 而且不需要写一个新的类去继承或包含现有类。

具体实例，可以看一下 [深入理解Yii2.0 行为](https://ibaiyang.github.io/blog/yii2/2019/06/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Yii2.0-%E8%A1%8C%E4%B8%BA.html) 。

<br/><br/><br/><br/><br/>

### 参考资料

常见软件架构模式 <https://ibaiyang.github.io/blog/php/2019/07/30/%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F.html>

DesignPatternsPHP <https://github.com/domnikl/DesignPatternsPHP>

PHP 设计模式系列 <https://laravelacademy.org/books/php-design-pattern>

PHP 设计模式(Design Pattern For PHP) <https://www.cnblogs.com/wilburxu/category/910011.html> 

php-the-right-way 设计模式 <http://laravel-china.github.io/php-the-right-way/pages/Design-Patterns.html>

DesignPatternsPHP <https://designpatternsphp.readthedocs.io/en/latest/>

DesignPatternsPHP(PHP设计模式范例) <https://designpatternsphp.readthedocs.io/zh_CN/latest/README.html>

PHP 设计模式概述 <https://segmentfault.com/a/1190000016629282>

PHP八大设计模式 <https://blog.csdn.net/flitrue/article/details/52614599>

php各种设计模式简单实践思考 <https://www.cnblogs.com/aksir/p/6777595.html>

