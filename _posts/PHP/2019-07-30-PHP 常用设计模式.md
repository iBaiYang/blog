---
layout: post
categories: PHP
title: PHP 常用设计模式
meta: PHP 常用设计模式
---
* content
{:toc}

### 正文

设计模式（Design pattern）是什么：设计模式是一套被反复使用、多数人知晓、经过分类编目的代码设计的经验总结。
使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。

为什么会有设计模式：在软件开发过程中，一个功能的实现方式多种多样，不同方法的可扩展性、可维护性以及复用性都是不一样的。
随着一个人对自己项目代码的要求增加，他会逐渐思考和实践出自己的一套方法或者思想，这种方法或思想决定了他设计出的架构或者编写出的代码的质量优劣。
设计模式就属于这样一种经验的积累，是由大量优秀的工程师或者架构师总结和提炼的精华，学习好设计模式等于让我们站在了巨人的肩膀上，
从一个高的起点出发，可以避免走很多弯路。

**设计模式六大原则**

单一职责原则：

    对象不应承担太多功能，正如一心不能而用，比如太多的工作(种类)会使人崩溃。唯有专注才能保证对象的高内聚；唯有唯一，才能保证对象的细粒度。

接口隔离原则：

    1、客户端不应依赖它不需要的接口；
    2、类间的依赖关系应该建立在最小的接口上。 

依赖倒置原则：　　

    1、高层模块不应该依赖底层模块，二者都应该依赖抽象。
    2、抽象不应该依赖细节，细节应该依赖抽象。
    3、依赖倒置的中心思想是面向接口编程。
    4、依赖倒置原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础搭建的架构要稳定的多。
    5、使用接口或抽象类的目的是指定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类来完成。

里氏替换原则：

    子类应当可以替换父类并出现在父类能够出现的地方。

迪米特法则(LOD)：

    也叫最少知识原则。迪米特法则的定义是只与你的直接朋友交谈，不与"陌生人"说话。
    如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该应用。
    其目的是降低类之间的耦合度，提高模块的相对独立性。

开闭原则(OCP)：

    软件对象（类、模块、方法等）应该对于扩展是开放的，对修改是关闭的。

**设计模式的分类**

一般情况下，我们把设计模式分成了三大类：

**创建型模式（Creational patterns）**

在软件工程中，创建型设计模式用于处理对象的实例化。

创建型模式是为了解决创建对象时候遇到的问题。因为基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度，
创建型设计模式有两个主导思想：一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合方式。

* 简单工厂模式（Simple Factory） 
* 静态工厂模式（Static Factory）
* 工厂方法模式（Factory method）
* 抽象工厂模式（Abstract factory）
* 建造者模式（Builder）
* 单例模式（Singleton）
* 多例模式（Multiton）
* 原型模式（Prototype）
* 对象池模式（Pool）

GOF在《设计模式》一书中将工厂模式分为两类：工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）。
将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。

[创建型模式解说地址](https://ibaiyang.github.io/blog/php/2019/07/30/PHP-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F.html)

**结构型模式（Structural pattern）**

结构型设计模式用于处理类和对象的组合。

结构型模式是通过定义一个简单方法来实现和了解实体间关系，从而简化设计。

* 适配器模式（Adapter）
* 桥梁模式（Bridge）
* 组合模式（Composite）
* 数据映射模式（Data Mapper）
* 装饰模式（Decorator）
* 依赖注入模式（Dependency Injection）
* 门面模式（Facade）
* 流接口模式（Fluent Interface）
* 代理模式（Proxy）
* 注册模式（Registry）
* 享元模式（Flyweight）

[结构型模式解说地址](https://ibaiyang.github.io/blog/php/2019/07/30/PHP-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F.html)

**行为型模式（Behavioral pattern）**

行为型设计模式用于处理类的对象间通信。

行为型模式是用来识别对象之间的常用交流模式并加以实现，使得交流变得更加灵活。

* 责任链模式（Chain Of Responsibilities）
* 命令行模式（Command）
* 迭代器模式（Iterator）
* 中介者模式（Mediator）
* 备忘录模式（Memento）
* 空对象模式（Null Object）
* 观察者模式（Observer）
* 规格模式（Specification）
* 状态模式（State）
* 策略模式（Strategy）
* 模板方法模式（Template Method）
* 访问者模式（Visitor）
* 解释器模式（Interpreter）

[行为型模式解说地址](https://ibaiyang.github.io/blog/php/2019/07/30/PHP-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F.html)

**其它**

* 委托模式（Delegation）
* 资源库模式（Repository）
* 服务定位器模式（Service Locator）
* 事件模式（Event）
* 行为模式（Behavior）

**各个设计模式之间的关系**

![]({{site.baseurl}}/images/20190813/20190813142514.png)

#### 委托模式（Delegation）

* 模式定义

委托是对一个类的功能进行扩展和复用的方法。它的做法是：写一个附加的类提供附加的功能，并使用原来的类的实例提供原有的功能。 
假设我们有一个 TeamLead 类，将其既定任务委托给一个关联辅助对象 JuniorDeveloper 来完成：
本来 TeamLead 处理 writeCode 方法，Usage 调用 TeamLead 的该方法，
但现在 TeamLead 将 writeCode 的实现委托给 JuniorDeveloper 的 writeBadCode 来实现，
但 Usage 并没有感知在执行 writeBadCode 方法。 

* UML类图

![]({{site.baseurl}}/images/UML/Delegation.png)

* 示例代码

Usage.php
```php
<?php
namespace DesignPatterns\More\Delegation;

// 初始化 TeamLead 并委托辅助者 JuniorDeveloper
$teamLead = new TeamLead(new JuniorDeveloper());

// TeamLead 将编写代码的任务委托给 JuniorDeveloper
echo $teamLead->writeCode();
```

TeamLead.php
```php
<?php
namespace DesignPatterns\More\Delegation;

/**
 * TeamLead类
 * @package DesignPatterns\Delegation
 * `TeamLead` 类将工作委托给 `JuniorDeveloper`
 */
class TeamLead
{
    /** @var JuniorDeveloper */
    protected $slave;

    /**
     * 在构造函数中注入初级开发者JuniorDeveloper
     * @param JuniorDeveloper $junior
     */
    public function __construct(JuniorDeveloper $junior)
    {
        $this->slave = $junior;
    }

    /**
     * TeamLead 喝咖啡, JuniorDeveloper 工作
     * @return mixed
     */
    public function writeCode()
    {
        return $this->slave->writeBadCode();
    }
}
```

JuniorDeveloper.php
```php
<?php
namespace DesignPatterns\More\Delegation;

/**
 * JuniorDeveloper 类
 * @package DesignPatterns\Delegation
 */
class JuniorDeveloper
{
    public function writeBadCode()
    {
        return "Some junior developer generated code...";
    }
}
```

* 测试代码

Tests/DelegationTest.php
```php
<?php
namespace DesignPatterns\More\Delegation\Tests;

use DesignPatterns\More\Delegation;

/**
 * DelegationTest 用于测试委托模式
 */
class DelegationTest extends \PHPUnit_Framework_TestCase
{
    public function testHowTeamLeadWriteCode()
    {
        $junior = new Delegation\JuniorDeveloper();
        $teamLead = new Delegation\TeamLead($junior);
        $this->assertEquals($junior->writeBadCode(), $teamLead->writeCode());
    }
}
```

* 总结

委托模式 —— 被委托类和委托类无继承关系，在委托类中依赖注入被委托类，访问者与委托类进行交互。

与类似接口的区别：
1. 代理模式 —— 代理类继承自被代理类，提供了与被代理类相同的接口，访问者与代理类进行交互。

#### 资源库模式（Repository）

* 模式定义

Repository 是一个独立的层，介于领域层与数据映射层（数据访问层）之间。
它的存在让领域层感觉不到数据访问层的存在，它提供一个类似集合的接口提供给领域层进行领域对象的访问。
Repository 是仓库管理员，领域层需要什么东西只需告诉仓库管理员，由仓库管理员把东西拿给它，并不需要知道东西实际放在哪。 
Repository 模式是架构模式，在设计架构时，才有参考价值。
应用 Repository 模式所带来的好处，远高于实现这个模式所增加的代码。只要项目分层，都应当使用这个模式。 

* UML类图

![]({{site.baseurl}}/images/UML/Repository.png)

* 示例代码

Post.php
```php
<?php
namespace DesignPatterns\More\Repository;

/**
 * Post 类
 * @package DesignPatterns\Repository
 */
class Post
{
    /**
     * @var int
     */
    private $id;

    /**
     * @var string
     */
    private $title;

    /**
     * @var string
     */
    private $text;

    /**
     * @var string
     */
    private $author;

    /**
     * @var \DateTime
     */
    private $created;

    /**
     * @param int $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }

    /**
     * @return int
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * @param string $author
     */
    public function setAuthor($author)
    {
        $this->author = $author;
    }

    /**
     * @return string
     */
    public function getAuthor()
    {
        return $this->author;
    }

    /**
     * @param \DateTime $created
     */
    public function setCreated($created)
    {
        $this->created = $created;
    }

    /**
     * @return \DateTime
     */
    public function getCreated()
    {
        return $this->created;
    }

    /**
     * @param string $text
     */
    public function setText($text)
    {
        $this->text = $text;
    }

    /**
     * @return string
     */
    public function getText()
    {
        return $this->text;
    }

    /**
     * @param string $title
     */
    public function setTitle($title)
    {
        $this->title = $title;
    }

    /**
     * @return string
     */
    public function getTitle()
    {
        return $this->title;
    }
}
```

PostRepository.php
```php
<?php
namespace DesignPatterns\More\Repository;

use DesignPatterns\More\Repository\Storage;

/**
 * Post 对应的 Repository
 * 该类介于数据实体层(Post) 和访问对象层(Storage)之间
 *
 * Repository 封装了持久化对象到数据存储器以及在展示层显示面向对象的视图操作
 *
 * Repository 还实现了领域层和数据映射层的分离和单向依赖
 *
 * PostRepository 类
 * @package DesignPatterns\Repository
 */
class PostRepository
{
    private $persistence;

    public function __construct(Storage $persistence)
    {
        $this->persistence = $persistence;
    }

    /**
     * 通过指定id返回Post对象
     *
     * @param int $id
     * @return Post|null
     */
    public function getById($id)
    {
        $arrayData = $this->persistence->retrieve($id);
        if (is_null($arrayData)) {
            return null;
        }

        $post = new Post();
        $post->setId($arrayData['id']);
        $post->setAuthor($arrayData['author']);
        $post->setCreated($arrayData['created']);
        $post->setText($arrayData['text']);
        $post->setTitle($arrayData['title']);

        return $post;
    }

    /**
     * 保存指定对象并返回
     *
     * @param Post $post
     * @return Post
     */
    public function save(Post $post)
    {
        $id = $this->persistence->persist(array(
            'author' => $post->getAuthor(),
            'created' => $post->getCreated(),
            'text' => $post->getText(),
            'title' => $post->getTitle()
        ));

        $post->setId($id);
        return $post;
    }

    /**
     * 删除指定的 Post 对象
     *
     * @param Post $post
     * @return bool
     */
    public function delete(Post $post)
    {
        return $this->persistence->delete($post->getId());
    }
}
```

Storage.php
```php
<?php
namespace DesignPatterns\More\Repository;

/**
 * Storage接口
 *
 * 该接口定义了访问数据存储器的方法
 * 具体的实现可以是多样化的，比如内存、关系型数据库、NoSQL数据库等等
 *
 * @package DesignPatterns\Repository
 */
interface Storage
{
    /**
     * 持久化数据方法
     * 返回新创建的对象ID
     *
     * @param array() $data
     * @return int
     */
    public function persist($data);

    /**
     * 通过指定id返回数据
     * 如果为空返回null
     *
     * @param int $id
     * @return array|null
     */
    public function retrieve($id);

    /**
     * 通过指定id删除数据
     * 如果数据不存在返回false，否则如果删除成功返回true
     *
     * @param int $id
     * @return bool
     */
    public function delete($id);
}
```

MemoryStorage.php
```php
<?php
namespace DesignPatterns\More\Repository;

use DesignPatterns\More\Repository\Storage;

/**
 * MemoryStorage类
 * @package DesignPatterns\Repository
 */
class MemoryStorage implements Storage
{

    private $data;
    private $lastId;

    public function __construct()
    {
        $this->data = array();
        $this->lastId = 0;
    }

    /**
     * {@inheritdoc}
     */
    public function persist($data)
    {
        $this->data[++$this->lastId] = $data;
        return $this->lastId;
    }

    /**
     * {@inheritdoc}
     */
    public function retrieve($id)
    {
        return isset($this->data[$id]) ? $this->data[$id] : null;
    }

    /**
     * {@inheritdoc}
     */
    public function delete($id)
    {
        if (!isset($this->data[$id])) {
            return false;
        }

        $this->data[$id] = null;
        unset($this->data[$id]);

        return true;
    }
}
```

* 测试代码

* 总结

资源库 Repository 是仓库管理员，仓库中可以有多种资源的数据映射，
而数据映射是持久化数据存储层（通常是关系型数据库）和驻于内存的数据表现层之间的数据访问层，
领域层需要什么东西只需告诉仓库管理员，由仓库管理员把东西拿给它，并不需要关心东西实际放在哪、怎么加工处理。
这也可以说是资源库模式（Repository）与数据映射模式（Data Mapper）的区别。
这是一种架构模式，可以用于软件架构中。

Mediates between the domain and data mapping layers using a collection-like interface for accessing domain objects. 
Repository encapsulates the set of objects persisted in a data store and the operations performed over them, 
providing a more object-oriented view of the persistence layer. 
Repository also supports the objective of achieving a clean separation and one-way dependency 
between the domain and data mapping layers.

使用类似集合的接口在域和数据映射层之间进行中介，以访问域对象。
Repository封装了数据存储中持久化的对象集以及对这些对象执行的操作，
提供了持久化层更面向对象的视图。
存储库还支持在域和数据映射层之间实现干净分离和单向依赖的目标。

与类似接口的区别：
1. 资源库模式 —— 是仓库管理员，仓库中可以有多种资源的数据映射。
2. 数据映射模式 —— 是持久化数据存储层（通常是关系型数据库）和驻于内存的数据表现层之间的数据访问层。

#### EAV模式

* 模式定义

The Entity–attribute–value (EAV) model is a data model to describe entities
where the number of attributes (properties, parameters) that can be used to describe them is potentially vast, 
but the number that will actually apply to a given entity is relatively modest.

实体-属性-值（Entity-attribute-value，EAV）模型是一种数据模型，用于描述实体，其中可用于描述它们的属性（属性、参数）的数量可能很大，
但实际应用于给定实体的数量相对较少。

* UML类图

![]({{site.baseurl}}/images/UML/EAV.png)

* 示例代码

Entity.php
```php
<?php 
namespace DesignPatterns\More\EAV;

use SplObjectStorage;

class Entity
{
    /**
     * @var SplObjectStorage<Value,Value>
     */
    private $values;

    /**
     * @var string
     */
    private string $name;

    /**
     * @param string $name
     * @param Value[] $values
     */
    public function __construct(string $name, $values)
    {
        /** @var SplObjectStorage<Value,Value> values */
        $this->values = new SplObjectStorage();
        $this->name = $name;

        foreach ($values as $value) {
            $this->values->attach($value);
        }
    }

    public function __toString(): string
    {
        $text = [$this->name];

        foreach ($this->values as $value) {
            $text[] = (string) $value;
        }

        return join(', ', $text);
    }
}
```

Attribute.php
```php
<?php 
namespace DesignPatterns\More\EAV;

use SplObjectStorage;

class Attribute
{
    private SplObjectStorage $values;
    private string $name;

    public function __construct(string $name)
    {
        $this->values = new SplObjectStorage();
        $this->name = $name;
    }

    public function addValue(Value $value)
    {
        $this->values->attach($value);
    }

    public function getValues(): SplObjectStorage
    {
        return $this->values;
    }

    public function __toString(): string
    {
        return $this->name;
    }
}
```

Value.php
```php
<?php
namespace DesignPatterns\More\EAV;

class Value
{
    private Attribute $attribute;
    private string $name;

    public function __construct(Attribute $attribute, string $name)
    {
        $this->name = $name;
        $this->attribute = $attribute;

        $attribute->addValue($this);
    }

    public function __toString(): string
    {
        return sprintf('%s: %s', (string) $this->attribute, $this->name);
    }
}
```

* 测试代码

EAVTest.php
```php
<?php
namespace DesignPatterns\More\EAV\Tests;

use DesignPatterns\More\EAV\Attribute;
use DesignPatterns\More\EAV\Entity;
use DesignPatterns\More\EAV\Value;
use PHPUnit\Framework\TestCase;

class EAVTest extends TestCase
{
    public function testCanAddAttributeToEntity()
    {
        $colorAttribute = new Attribute('color');
        $colorSilver = new Value($colorAttribute, 'silver');
        $colorBlack = new Value($colorAttribute, 'black');

        $memoryAttribute = new Attribute('memory');
        $memory8Gb = new Value($memoryAttribute, '8GB');

        $entity = new Entity('MacBook Pro', [$colorSilver, $colorBlack, $memory8Gb]);

        $this->assertEquals('MacBook Pro, color: silver, color: black, memory: 8GB', (string) $entity);
    }
}
```

#### 服务定位器模式(Service Locator)

* 模式定义

当系统中的组件需要调用某一服务来完成特定的任务时，通常最简单的做法是使用 new 关键字来创建该服务的实例，
或者通过工厂模式来解耦该组件与服务的具体实现部分，以便通过配置信息等更为灵活的方式获得该服务的实例。然而，这些做法都有着各自的弊端：
1. 在组件中直接维护对服务实例的引用，会造成组件与服务之间的关联依赖，当需要替换服务的具体实现时，
  不得不修改组件中调用服务的部分并重新编译解决方案；即使采用工厂模式来根据配置信息动态地获得服务的实例，
  也无法针对不同的服务类型向组件提供一个管理服务实例的中心位置；
2. 由于组件与服务之间的这种关联依赖，使得项目的开发过程受到约束。在实际项目中，开发过程往往是并行的，但又不是完全同步的，
  比如组件的开发跟其所需要的服务的开发同时进行，但很有可能当组件需要调用服务时，服务却还没完成开发和单体测试。
  遇到这种问题时，通常会将组件调用服务的部分暂时空缺，待到服务完成开发和单体测试之后，将其集成到组件的代码中。
  但这种做法不仅费时，而且增大了出错的风险；
3. 针对组件的单体测试变得复杂。每当对组件进行单体测试时，不得不为其配置并运行所需要的服务，
  而无法使用Service Stub来解决组件与服务之间的依赖；
4. 在组件中可能存在多个地方需要引用服务的实例，在这种情况下，直接创建服务实例的代码会散布到整个程序中，
  造成一段程序存在多个副本，大大增加维护和排错成本；
5. 当组件需要调用多个服务时，不同服务初始化各自实例的方式又可能存在差异。
  开发人员不得不了解所有服务初始化的API，以便在程序中能够正确地使用这些服务；
6. 某些服务的初始化过程需要耗费大量资源，因此多次重复地初始化服务会大大增加系统的资源占用和性能损耗。
  程序中需要有一个管理服务初始化过程的机制，在统一初始化接口的同时，还需要为程序提供部分缓存功能。

要解决以上问题，我们可以在应用程序中引入服务定位器（Service Locator）模式。 
服务定位器（Service Locator）模式是一种企业级应用程序体系结构模式，它能够为应用程序中服务的创建和初始化提供一个中心位置，
并解决了上文中所提到的各种设计和开发问题。 服务定位器模式和依赖注入模式都是控制反转（IoC）模式的实现。
我们在服务定位器中注册给定接口的服务实例，然后通过接口获取服务并在应用代码中使用而不需要关心其具体实现。
我们可以在启动时配置并注入服务提供者。 如果你了解 Laravel 框架，你对这一流程会很熟悉，没错，这就是 Laravel 框架的核心机制，
我们在服务提供者中绑定接口及其实现，将服务实例注册到服务容器中，然后在使用时可以通过依赖注入或者通过服务接口/别名获取服务实例的方式调用服务。

* UML类图

![]({{site.baseurl}}/images/UML/Service-Locator.png)

* 示例代码

ServiceLocatorInterface.php
```php
<?php
namespace DesignPatterns\More\ServiceLocator;

interface ServiceLocatorInterface
{
    /**
     * Checks if a service is registered.
     *
     * @param string $interface
     *
     * @return bool
     */
    public function has($interface);

    /**
     * Gets the service registered for the interface.
     *
     * @param string $interface
     *
     * @return mixed
     */
    public function get($interface);
}
```

ServiceLocator.php
```php
<?php
namespace DesignPatterns\More\ServiceLocator;

class ServiceLocator implements ServiceLocatorInterface
{
    /**
     * All services.
     *
     * @var array
     */
    private $services;

    /**
     * The services which have an instance.
     *
     * @var array
     */
    private $instantiated;

    /**
     * True if a service can be shared.
     *
     * @var array
     */
    private $shared;

    public function __construct()
    {
        $this->services     = array();
        $this->instantiated = array();
        $this->shared       = array();
    }

    /**
     * Registers a service with specific interface.
     *
     * @param string $interface
     * @param string|object $service
     * @param bool $share
     */
    public function add($interface, $service, $share = true)
    {
        /**
         * When you add a service, you should register it
         * with its interface or with a string that you can use
         * in the future even if you will change the service implementation.
         */

        if (is_object($service) && $share) {
            $this->instantiated[$interface] = $service;
        }
        $this->services[$interface] = (is_object($service) ? get_class($service) : $service);
        $this->shared[$interface]   = $share;
    }

    /**
     * Checks if a service is registered.
     *
     * @param string $interface
     *
     * @return bool
     */
    public function has($interface)
    {
        return (isset($this->services[$interface]) || isset($this->instantiated[$interface]));
    }

    /**
     * Gets the service registered for the interface.
     *
     * @param string $interface
     *
     * @return mixed
     */
    public function get($interface)
    {
        // Retrieves the instance if it exists and it is shared
        if (isset($this->instantiated[$interface]) && $this->shared[$interface]) {
            return $this->instantiated[$interface];
        }

        // otherwise gets the service registered.
        $service = $this->services[$interface];

        // You should check if the service class exists and
        // the class is instantiable.

        // This example is a simple implementation, but
        // when you create a service, you can decide
        // if $service is a factory or a class.
        // By registering a factory you can create your services
        // using the DependencyInjection pattern.

        // ...

        // Creates the service object
        $object = new $service();

        // and saves it if the service must be shared.
        if ($this->shared[$interface]) {
            $this->instantiated[$interface] = $object;
        }
        return $object;
    }
}
```

LogServiceInterface.php
```php
<?php
namespace DesignPatterns\More\ServiceLocator;

interface LogServiceInterface
{
}
```

LogService.php
```php
<?php
namespace DesignPatterns\More\ServiceLocator;

class LogService implements LogServiceInterface
{
}
```

DatabaseServiceInterface.php
```php
<?php
namespace DesignPatterns\More\ServiceLocator;

interface DatabaseServiceInterface
{
}
```

DatabaseService.php
```php
<?php
namespace DesignPatterns\More\ServiceLocator;

class DatabaseService implements DatabaseServiceInterface
{
}
```

* 测试代码

Tests/ServiceLocatorTest.php
```php
<?php
namespace DesignPatterns\More\ServiceLocator\Tests;

use DesignPatterns\More\ServiceLocator\DatabaseService;
use DesignPatterns\More\ServiceLocator\LogService;
use DesignPatterns\More\ServiceLocator\ServiceLocator;
use \PHPUnit_Framework_TestCase as TestCase;

class ServiceLocatorTest extends TestCase
{
    /**
     * @var LogService
     */
    private $logService;

    /**
     * @var DatabaseService
     */
    private $databaseService;

    /**
     * @var ServiceLocator
     */
    private $serviceLocator;

    public function setUp()
    {
        $this->serviceLocator  = new ServiceLocator();
        $this->logService      = new LogService();
        $this->databaseService = new DatabaseService();
    }

    public function testHasServices()
    {
        $this->serviceLocator->add(
            'DesignPatterns\More\ServiceLocator\LogServiceInterface',
            $this->logService
        );

        $this->serviceLocator->add(
            'DesignPatterns\More\ServiceLocator\DatabaseServiceInterface',
            $this->databaseService
        );

        $this->assertTrue($this->serviceLocator->has('DesignPatterns\More\ServiceLocator\LogServiceInterface'));
        $this->assertTrue($this->serviceLocator->has('DesignPatterns\More\ServiceLocator\DatabaseServiceInterface'));

        $this->assertFalse($this->serviceLocator->has('DesignPatterns\More\ServiceLocator\FakeServiceInterface'));
    }

    public function testServicesWithObject()
    {
        $this->serviceLocator->add(
            'DesignPatterns\More\ServiceLocator\LogServiceInterface',
            $this->logService
        );

        $this->serviceLocator->add(
            'DesignPatterns\More\ServiceLocator\DatabaseServiceInterface',
            $this->databaseService
        );

        $this->assertSame(
            $this->logService,
            $this->serviceLocator->get('DesignPatterns\More\ServiceLocator\LogServiceInterface')
        );

        $this->assertSame(
            $this->databaseService,
            $this->serviceLocator->get('DesignPatterns\More\ServiceLocator\DatabaseServiceInterface')
        );
    }

    public function testServicesWithClass()
    {
        $this->serviceLocator->add(
            'DesignPatterns\More\ServiceLocator\LogServiceInterface',
            get_class($this->logService)
        );

        $this->serviceLocator->add(
            'DesignPatterns\More\ServiceLocator\DatabaseServiceInterface',
            get_class($this->databaseService)
        );

        $this->assertNotSame(
            $this->logService,
            $this->serviceLocator->get('DesignPatterns\More\ServiceLocator\LogServiceInterface')
        );

        $this->assertInstanceOf(
            'DesignPatterns\More\ServiceLocator\LogServiceInterface',
            $this->serviceLocator->get('DesignPatterns\More\ServiceLocator\LogServiceInterface')
        );

        $this->assertNotSame(
            $this->databaseService,
            $this->serviceLocator->get('DesignPatterns\More\ServiceLocator\DatabaseServiceInterface')
        );

        $this->assertInstanceOf(
            'DesignPatterns\More\ServiceLocator\DatabaseServiceInterface',
            $this->serviceLocator->get('DesignPatterns\More\ServiceLocator\DatabaseServiceInterface')
        );
    }

    public function testServicesNotShared()
    {
        $this->serviceLocator->add(
            'DesignPatterns\More\ServiceLocator\LogServiceInterface',
            $this->logService,
            false
        );

        $this->serviceLocator->add(
            'DesignPatterns\More\ServiceLocator\DatabaseServiceInterface',
            $this->databaseService,
            false
        );

        $this->assertNotSame(
            $this->logService,
            $this->serviceLocator->get('DesignPatterns\More\ServiceLocator\LogServiceInterface')
        );

        $this->assertInstanceOf(
            'DesignPatterns\More\ServiceLocator\LogServiceInterface',
            $this->serviceLocator->get('DesignPatterns\More\ServiceLocator\LogServiceInterface')
        );

        $this->assertNotSame(
            $this->databaseService,
            $this->serviceLocator->get('DesignPatterns\More\ServiceLocator\DatabaseServiceInterface')
        );

        $this->assertInstanceOf(
            'DesignPatterns\More\ServiceLocator\DatabaseServiceInterface',
            $this->serviceLocator->get('DesignPatterns\More\ServiceLocator\DatabaseServiceInterface')
        );
    }
}
```

* 总结

与类似接口的区别：
1. 服务定位器模式 —— 把服务在服务定位器中注册好，使用时可以由服务定位器或返回新的实例、或返回实例化好的实例。
2. 注册模式 —— 把实例化好的类放在一个注册的容器中，使用时从容器中获取。
3. 享元模式 —— 没有注册这一步，使用时直接从Factory类获取，Factory类决定怎么创建对象和返回。
4. 单例模式 —— 单例模式的作用就是保证在整个应用程序的生命周期中，任何一个时刻，单例类的实例都只存在一个。
5. 对象池模式 —— 对象池是一组已经初始化过且可以直接使用的对象集合，使用对象时可以从对象池中获取对象并进行操作，在不需要时归还给对象池。

* 拓展

服务定位器(Service Locator)是IoC的另一种实现方式， 其核心是把所有可能用到的依赖单元交由Service Locator进行实例化和创建、配置， 
把类对依赖单元的依赖，转换成类对Service Locator的依赖。 DI 与 Service Locator并不冲突，两者可以结合使用。 
目前，Yii2.0把这DI和Service Locator这两个东西结合起来使用，或者说通过DI容器，实现了Service Locator。

具体实例，可以看一下 [深入理解Yii2.0 服务定位器](https://ibaiyang.github.io/blog/yii2/2019/06/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Yii2.0-%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%BD%8D%E5%99%A8.html) 。

#### 事件模式（Event）

使用事件，可以在特定的时点，触发执行预先设定的一段代码，事件既是代码解耦的一种方式，也是设计业务流程的一种模式。

具体实例，可以看一下 [深入理解Yii2.0 事件](https://ibaiyang.github.io/blog/yii2/2019/06/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Yii2.0-%E4%BA%8B%E4%BB%B6.html) 。

#### 行为模式（Behavior）

使用行为（behavior）可以在不修改现有类的情况下，对类的功能进行扩充。 通过将行为绑定到一个类，可以使类具有行为本身所定义的属性和方法， 
就好像类本来就有这些属性和方法一样。 而且不需要写一个新的类去继承或包含现有类。

具体实例，可以看一下 [深入理解Yii2.0 行为](https://ibaiyang.github.io/blog/yii2/2019/06/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Yii2.0-%E8%A1%8C%E4%B8%BA.html) 。

<br/><br/><br/><br/><br/>

### 参考资料

常见软件架构模式 <https://ibaiyang.github.io/blog/php/2019/07/30/%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F.html>

DesignPatternsPHP <https://github.com/domnikl/DesignPatternsPHP>

PHP 设计模式系列 <https://laravelacademy.org/books/php-design-pattern>

设计模式六大原则：单一职责原则 <https://www.cnblogs.com/az4215/p/11462818.html>

设计模式（Design pattern） <https://www.runoob.com/design-pattern/design-pattern-tutorial.html>

PHP 设计模式(Design Pattern For PHP) <https://www.cnblogs.com/wilburxu/category/910011.html> 

php-the-right-way 设计模式 <http://laravel-china.github.io/php-the-right-way/pages/Design-Patterns.html>

DesignPatternsPHP <https://designpatternsphp.readthedocs.io/en/latest/>

DesignPatternsPHP(PHP设计模式范例) <https://designpatternsphp.readthedocs.io/zh_CN/latest/README.html>

PHP 设计模式概述 <https://segmentfault.com/a/1190000016629282>

PHP八大设计模式 <https://blog.csdn.net/flitrue/article/details/52614599>

php各种设计模式简单实践思考 <https://www.cnblogs.com/aksir/p/6777595.html>

