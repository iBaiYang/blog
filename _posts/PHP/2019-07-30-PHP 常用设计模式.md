---
layout: post
categories: PHP
title: PHP 常用设计模式
meta: PHP 常用设计模式
---
* content
{:toc}

### 正文

设计模式（Design pattern）是什么：设计模式是一套被反复使用、多数人知晓、经过分类编目的代码设计的经验总结。
使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。

为什么会有设计模式：在软件开发过程中，一个功能的实现方式多种多样，不同方法的可扩展性、可维护性以及复用性都是不一样的。
随着一个人对自己项目代码的要求增加，他会逐渐思考和实践出自己的一套方法或者思想，这种方法或思想决定了他设计出的架构或者编写出的代码的质量优劣。
设计模式就属于这样一种经验的积累，是由大量优秀的工程师或者架构师总结和提炼的精华，学习好设计模式等于让我们站在了巨人的肩膀上，
从一个高的起点出发，可以避免走很多弯路。

**设计模式的分类**

一般情况下，我们把设计模式分成了三大类：

**创建型模式（Creational patterns）**

在软件工程中，创建型设计模式用于处理对象的实例化。

创建型模式是为了解决创建对象时候遇到的问题。因为基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度，
创建型设计模式有两个主导思想：一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合方式。

* 简单工厂模式（Simple Factory） 
* 静态工厂模式（Static Factory）
* 工厂方法模式（Factory method）
* 抽象工厂模式（Abstract factory）
* 建造者模式（Builder）
* 单例模式（Singleton）
* 多例模式（Multiton）
* 原型模式（Prototype）
* 对象池模式（Pool）

GOF在《设计模式》一书中将工厂模式分为两类：工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）。
将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。

**结构型模式（Structural pattern）**

结构型设计模式用于处理类和对象的组合。

结构型模式是通过定义一个简单方法来实现和了解实体间关系，从而简化设计。

* 适配器模式（Adapter）
* 桥梁模式（Bridge）
* 组合模式（Composite）
* 数据映射模式（Data Mapper）
* 装饰模式（Decorator）
* 依赖注入模式（Dependency Injection）
* 门面模式（Facade）
* 流接口模式（Fluent Interface）
* 代理模式（Proxy）
* 注册模式（Registry）
* 享元模式（Flyweight）

![]({{site.baseurl}}/blog/php/2019/07/30/PHP-创建型模式.html)

**行为型模式（Behavioral pattern）**

行为型设计模式用于处理类的对象间通信。

行为型模式是用来识别对象之间的常用交流模式并加以实现，使得交流变得更加灵活。

* 责任链模式（Chain Of Responsibilities）
* 命令行模式（Command）
* 迭代器模式（Iterator）
* 中介者模式（Mediator）
* 备忘录模式（Memento）
* 空对象模式（Null Object）
* 观察者模式（Observer）
* 规格模式（Specification）
* 状态模式（State）
* 策略模式（Strategy）
* 模板方法模式（Template Method）
* 访问者模式（Visitor）
* 解释器模式（Interpreter）

**其它**

* 委托模式（Delegation）
* 资源库模式（Repository）
* 服务定位器模式（Service Locator）
* 事件模式（Event）
* 行为模式（Behavior）

**各个设计模式之间的关系**

![]({{site.baseurl}}/images/20190813/20190813142514.png)

#### 适配器模式(Adapter)

适配器模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。

// 设置书的接口
```
// 书接口
interface BookInterface
{
    // 翻页方法
    public function turnPage();

    // 打开书方法
    public function open();
}
```

```
// 纸质书实现类
class Book implements BookInterface
{
    public function turnPage()
    {
        echo "纸质书翻页". "<br>";
    }

    public function open()
    {
        echo "纸质书打开". "<br>";
    }
}
```

客户端测试：
```
// 客户端测试
$book = new Book();
$book->open();
$book->turnPage();
```

输出结果：
```
纸质书打开
纸质书翻页
```

这时候，你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。

如下：
```
// 待适配对象
class Kindle
{
    public function turnPage()
    {
        echo "电子书翻页". "<br>";
    }

    public function open()
    {
        echo "电子书打开". "<br>";
    }
}
```

// 适配器
```
class KindleAdapter implements BookInterface
{
    protected $_kindle;

    public function __construct($obj)
    {
        $this->_kindle = $obj;
    }


    public function turnPage()
    {
        $this->_kindle->turnPage();
    }

    public function open()
    {
        $this->_kindle->open();
    }
}
```

// 客户端测试
```
$kindle = new KindleAdapter(new Kindle());
$kindle->open();
$kindle->turnPage();
```

// 输出结果
```
电子书打开
电子书翻页
```

#### 桥接模式(Bridge)

桥接模式：将两个原本不相关的类结合在一起，然后利用两个类中的方法和属性，输出一份新的结果。

案例1. 模拟毛笔

需求：现在需要准备三种粗细（大中小），并且有五种颜色的笔

如果使用蜡笔，我们需要准备3*5=15支蜡笔，也就是说必须准备15个具体的蜡笔类。而如果使用毛笔的话，只需要3种型号的毛笔，
外加5个颜料盒，用3+5=8个类就可以实现15支蜡笔的功能。

实际上，蜡笔和毛笔的关键一个区别就在于笔和颜色是否能够分离。即将抽象化(Abstraction)与实现化(Implementation)脱耦，
使得二者可以独立地变化"。关键就在于能否脱耦。蜡笔由于无法将笔与颜色分离，造成笔与颜色两个自由度无法单独变化，
使得只有创建15种对象才能完成任务。而毛笔与颜料能够很好的脱耦（笔和颜色是分开的），抽象层面的概念是："毛笔用颜料作画"，
每个参与者（毛笔与颜料）都可以在自己的自由度上随意转换。

Bridge模式将继承关系转换为组合关系，从而降低了系统间的耦合，减少了代码编写量。

案例2. 模拟企业分组发短信

需求：公司现在需要按分组（临时工、正式工、管理层等）以多种形式（QQ、Email、微博等）给员工发送通知。


**适用性**：
1. 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。通过使用Bridge模式对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。
2. 不希望在抽象和它的实现部分之间有一个固定的绑定关系。
3. 一个构件有多于一个的抽象化角色和实现化角色，系统需要它们之间进行动态耦合。

**效果**：
1. Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。
2. 所谓抽象和实现沿着各自维度的变化，即“子类化”它们，得到各个子类之后，便可以任意它们，从而获得不同员工组和不同信息发送模式。
3. Bridge模式的应用一般在“两个非常强的变化维度”，有时候即使有两个变化的维度，
   但是某个方向的变化维度并不剧烈——换言之两个变化不会导致纵横交错的结果，并不一定要使用Bridge模式。


看一下示例实现

员工分组：
```
abstract class Staff
{
    abstract public function staffData();
}

class CommonStaff extends Staff
{
    public function staffData()
    {
        return "小名，小红，小黑";
    }
}

class VipStaff extends Staff
{
    public function staffData()
    {
        return '小星、小龙';
    }
}
```

发送形式：
```
// 抽象父类
abstract class SendType
{
    abstract public function send($to, $content);
}

class QQSend extends SendType
{
    public function __construct()
    {
        // 与QQ接口连接方式
    }

    public function send($to, $content)
    {
        return $content. '（To '. $to . ' From QQ）<br>';
    }
}
```

桥接容器：
```
class SendInfo
{
    protected $_level;
    protected $_method;

    public function __construct($level, $method)
    {
        //  这里可以使用单例控制资源的消耗
        $this->_level = $level;
        $this->_method = $method;
    }

    public function sending($content)
    {
        $staffArr = $this->_level->staffData();
        $result = $this->_method->send($staffArr, $content);
        echo $result;
    }
}
```

客户端调用：
```
$info = new SendInfo(new VipStaff(), new QQSend());
$info->sending( '回家吃饭');

$info = new SendInfo(new CommonStaff(), new QQSend());
$info->sending( '继续上班');
```

输出结果：
```
回家吃饭（To 小星、小龙 From QQ）
继续上班（To 小名，小红，小黑 From QQ）
```

从上面可以看出，如果增加分组或者是发送信息的类型，都可以直接创建一个类，来拓展，十分方便。

但是Bridge模式虽然是一个非常有用的模式，也非常复杂，它很好的符合了开放-封闭原则和优先使用对象，而不是继承这两个面向对象原则。

#### 组合模式（Composite）

* 模式定义

组合模式（Composite Pattern）有时候又叫做部分-整体模式，用于将对象组合成树形结构以表示“部分-整体”的层次关系。
组合模式使得用户对单个对象和组合对象的使用具有一致性。

常见使用场景：如树形菜单、文件夹菜单、部门组织架构图等。

* UML类图

![]({{site.baseurl}}/images/UML/Composite.png)

* 示例代码

FormElement.php
```php
<?php
namespace DesignPatterns\Structural\Composite;

/**
 * FormElement类
 */
abstract class FormElement
{
    /**
     * renders the elements' code
     *
     * @param int $indent
     *
     * @return mixed
     */
    abstract public function render($indent = 0);
}
```

Form.php
```php
<?php
namespace DesignPatterns\Structural\Composite;

/**
 * 组合节点必须实现组件接口，这对构建组件树而言是强制的
 */
class Form extends FormElement
{
    /**
     * @var array|FormElement[]
     */
    protected $elements;

    /**
     * 遍历所有元素并调用它们的render()方法, 然后返回返回完整的表单显示
     *
     * 但是从外部来看, 并没有看见组合过程, 就像是单个表单实例一样
     *
     * @param int $indent
     *
     * @return string
     */
    public function render($indent = 0)
    {
        $formCode = '';

        foreach ($this->elements as $element) {
            $formCode .= $element->render($indent + 1) . PHP_EOL;
        }

        return $formCode;
    }

    /**
     * @param FormElement $element
     */
    public function addElement(FormElement $element)
    {
        $this->elements[] = $element;
    }
}
```

InputElement.php
```php
<?php
namespace DesignPatterns\Structural\Composite;

/**
 * InputElement类
 */
class InputElement extends FormElement
{
    /**
     * 渲染input元素HTML
     *
     * @param int $indent
     *
     * @return mixed|string
     */
    public function render($indent = 0)
    {
        return str_repeat('  ', $indent) . '<input type="text" />';
    }
}
```

TextElement.php
```php
<?php
namespace DesignPatterns\Structural\Composite;

/**
 * TextElement类
 */
class TextElement extends FormElement
{
    /**
     * 渲染文本元素
     *
     * @param int $indent
     *
     * @return mixed|string
     */
    public function render($indent = 0)
    {
        return str_repeat('  ', $indent) . 'this is a text element';
    }
}
```

* 测试代码

Tests/CompositeTest.php
```php
<?php
namespace DesignPatterns\Structural\Composite\Tests;

use DesignPatterns\Structural\Composite;

/**
 * FormTest用于测试表单的组合模式
 */
class CompositeTest extends \PHPUnit_Framework_TestCase
{
    public function testRender()
    {
        $form = new Composite\Form();
        $form->addElement(new Composite\TextElement());
        $form->addElement(new Composite\InputElement());
        $embed = new Composite\Form();
        $embed->addElement(new Composite\TextElement());
        $embed->addElement(new Composite\InputElement());
        $form->addElement($embed);  // 这里我们添加一个嵌套树到表单

        $this->assertRegExp('#^\s{4}#m', $form->render());
    }

    /**
     * 组合模式最关键之处在于如果你想要构建组件树每个组件必须实现组件接口
     */
    public function testFormImplementsFormElement()
    {
        $className = 'DesignPatterns\Structural\Composite\Form';
        $abstractName = 'DesignPatterns\Structural\Composite\FormElement';
        $this->assertTrue(is_subclass_of($className, $abstractName));
    }
}
```

#### 数据映射模式（Data Mapper）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 装饰模式（Decorator）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 依赖注入(Dependence Injection)


**依赖倒置原则（Dependence Inversion Principle, DIP）**

DIP是一种软件设计的指导思想。传统软件设计中，上层代码依赖于下层代码，当下层出现变动时， 上层代码也要相应变化，维护成本较高。 
而DIP的核心思想是上层定义接口，下层实现这个接口， 从而使得下层依赖于上层，降低耦合度，提高整个系统的弹性。这是一种经实践证明的有效策略。

**控制反转（Inversion of Control, IoC）**

IoC就是DIP的一种具体思路，DIP只是一种理念、思想，而IoC是一种实现DIP的方法。 
IoC的核心是将类（上层）所依赖的单元（下层）的实例化过程交由第三方来实现。 
一个简单的特征， 就是类中不对所依赖的单元有诸如 `$component = new yii\component\SomeClass()` 的实例化语句。

**依赖注入（Dependence Injection, DI）**

DI是IoC的一种设计模式，是一种套路，按照DI的套路，就可以实现IoC，就能符合DIP原则。 
DI的核心是把类所依赖的单元的实例化过程，放到类的外面去实现。

**控制反转容器（IoC Container）**

当项目比较大时，依赖关系可能会很复杂。 而IoC Container提供了动态地创建、注入依赖单元，
映射依赖关系等功能，减少了许多代码量。 Yii 设计了一个 yii\di\Container 来实现了 DI Container。

具体实例，可以看一下 [深入理解Yii2.0 依赖注入和依赖注入容器](https://ibaiyang.github.io/blog/yii2/2019/06/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Yii2.0-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%B9%E5%99%A8.html) 。

#### 门面模式（Facade）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 流接口模式（Fluent Interface）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 代理模式（Proxy）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 注册模式（Registry）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 享元模式（Flyweight）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 责任链模式（Chain Of Responsibilities）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 命令行模式（Command）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 迭代器模式（Iterator）

* 模式定义

迭代器模式（Iterator），又叫做游标（Cursor）模式。提供一种方法访问一个容器（Container）对象中各个元素，而又不需暴露该对象的内部细节。 
当你需要访问一个聚合对象，而且不管这些对象是什么都需要遍历的时候，就应该考虑使用迭代器模式。
另外，当需要对聚集有多种方式遍历时，可以考虑去使用迭代器模式。
迭代器模式为遍历不同的聚集结构提供如开始、下一个、是否结束、当前哪一项等统一的接口。 
PHP标准库（SPL）中提供了迭代器接口 Iterator，要实现迭代器模式，实现该接口即可。

* UML类图

![]({{site.baseurl}}/images/UML/Iterator.png)

* 示例代码

Book.php
```php
<?php
namespace DesignPatterns\Behavioral\Iterator;

class Book
{
    private $author;

    private $title;

    public function __construct($title, $author)
    {
        $this->author = $author;
        $this->title = $title;
    }

    public function getAuthor()
    {
        return $this->author;
    }

    public function getTitle()
    {
        return $this->title;
    }

    public function getAuthorAndTitle()
    {
        return $this->getTitle() . ' by ' . $this->getAuthor();
    }
}
```

BookList.php
```php
<?php
namespace DesignPatterns\Behavioral\Iterator;

class BookList implements \Countable
{
    private $books;

    public function getBook($bookNumberToGet)
    {
        if (isset($this->books[$bookNumberToGet])) {
            return $this->books[$bookNumberToGet];
        }

        return null;
    }

    public function addBook(Book $book)
    {
        $this->books[] = $book;
    }

    public function removeBook(Book $bookToRemove)
    {
        foreach ($this->books as $key => $book) {
            /** @var Book $book */
            if ($book->getAuthorAndTitle() === $bookToRemove->getAuthorAndTitle()) {
                unset($this->books[$key]);
            }
        }
    }

    public function count()
    {
        return count($this->books);
    }
}
```

BookListIterator.php
```php
<?php
namespace DesignPatterns\Behavioral\Iterator;

class BookListIterator implements \Iterator
{
    /**
     * @var BookList
     */
    private $bookList;

    /**
     * @var int
     */
    protected $currentBook = 0;

    public function __construct(BookList $bookList)
    {
        $this->bookList = $bookList;
    }

    /**
     * Return the current book
     * @link http://php.net/manual/en/iterator.current.php
     * @return Book Can return any type.
     */
    public function current()
    {
        return $this->bookList->getBook($this->currentBook);
    }

    /**
     * (PHP 5 >= 5.0.0)
     *
     * Move forward to next element
     * @link http://php.net/manual/en/iterator.next.php
     * @return void Any returned value is ignored.
     */
    public function next()
    {
        $this->currentBook++;
    }

    /**
     * (PHP 5 >= 5.0.0)
     *
     * Return the key of the current element
     * @link http://php.net/manual/en/iterator.key.php
     * @return mixed scalar on success, or null on failure.
     */
    public function key()
    {
        return $this->currentBook;
    }

    /**
     * (PHP 5 >= 5.0.0)
     *
     * Checks if current position is valid
     * @link http://php.net/manual/en/iterator.valid.php
     * @return boolean The return value will be casted to boolean and then evaluated.
     *       Returns true on success or false on failure.
     */
    public function valid()
    {
        return null !== $this->bookList->getBook($this->currentBook);
    }

    /**
     * (PHP 5 >= 5.0.0)
     *
     * Rewind the Iterator to the first element
     * @link http://php.net/manual/en/iterator.rewind.php
     * @return void Any returned value is ignored.
     */
    public function rewind()
    {
        $this->currentBook = 0;
    }
}
```

BookListReverseIterator.php
```php
<?php
namespace DesignPatterns\Behavioral\Iterator;

class BookListReverseIterator implements \Iterator
{
    /**
     * @var BookList
     */
    private $bookList;

    /**
     * @var int
     */
    protected $currentBook = 0;

    public function __construct(BookList $bookList)
    {
        $this->bookList = $bookList;
        $this->currentBook = $this->bookList->count() - 1;
    }

    /**
     * Return the current book
     * @link http://php.net/manual/en/iterator.current.php
     * @return Book Can return any type.
     */
    public function current()
    {
        return $this->bookList->getBook($this->currentBook);
    }

    /**
     * (PHP 5 >= 5.0.0)
     *
     * Move forward to next element
     * @link http://php.net/manual/en/iterator.next.php
     * @return void Any returned value is ignored.
     */
    public function next()
    {
        $this->currentBook--;
    }

    /**
     * (PHP 5 >= 5.0.0)
     *
     * Return the key of the current element
     * @link http://php.net/manual/en/iterator.key.php
     * @return mixed scalar on success, or null on failure.
     */
    public function key()
    {
        return $this->currentBook;
    }

    /**
     * (PHP 5 >= 5.0.0)
     *
     * Checks if current position is valid
     * @link http://php.net/manual/en/iterator.valid.php
     * @return boolean The return value will be casted to boolean and then evaluated.
     *       Returns true on success or false on failure.
     */
    public function valid()
    {
        return null !== $this->bookList->getBook($this->currentBook);
    }

    /**
     * (PHP 5 >= 5.0.0)
     *
     * Rewind the Iterator to the first element
     * @link http://php.net/manual/en/iterator.rewind.php
     * @return void Any returned value is ignored.
     */
    public function rewind()
    {
        $this->currentBook = $this->bookList->count() - 1;
    }
}
```

* 测试代码

Tests/IteratorTest.php
```php
<?php
namespace DesignPatterns\Behavioral\Iterator\Tests;

use DesignPatterns\Behavioral\Iterator\Book;
use DesignPatterns\Behavioral\Iterator\BookList;
use DesignPatterns\Behavioral\Iterator\BookListIterator;
use DesignPatterns\Behavioral\Iterator\BookListReverseIterator;

class IteratorTest extends \PHPUnit_Framework_TestCase
{
    /**
     * @var BookList
     */
    protected $bookList;

    protected function setUp()
    {
        $this->bookList = new BookList();
        $this->bookList->addBook(new Book('Learning PHP Design Patterns', 'William Sanders'));
        $this->bookList->addBook(new Book('Professional Php Design Patterns', 'Aaron Saray'));
        $this->bookList->addBook(new Book('Clean Code', 'Robert C. Martin'));
    }

    public function expectedAuthors()
    {
        return array(
            array(
                array(
                    'Learning PHP Design Patterns by William Sanders',
                    'Professional Php Design Patterns by Aaron Saray',
                    'Clean Code by Robert C. Martin'
                )
            ),
        );
    }

    /**
     * @dataProvider expectedAuthors
     */
    public function testUseAIteratorAndValidateAuthors($expected)
    {
        $iterator = new BookListIterator($this->bookList);

        while ($iterator->valid()) {
            $expectedBook = array_shift($expected);
            $this->assertEquals($expectedBook, $iterator->current()->getAuthorAndTitle());
            $iterator->next();
        }
    }

    /**
     * @dataProvider expectedAuthors
     */
    public function testUseAReverseIteratorAndValidateAuthors($expected)
    {
        $iterator = new BookListReverseIterator($this->bookList);

        while ($iterator->valid()) {
            $expectedBook = array_pop($expected);
            $this->assertEquals($expectedBook, $iterator->current()->getAuthorAndTitle());
            $iterator->next();
        }
    }

    /**
     * Test BookList Remove
     */
    public function testBookRemove()
    {
        $this->bookList->removeBook($this->bookList->getBook(0));
        $this->assertEquals($this->bookList->count(), 2);
    }
}
```

#### 中介者模式（Mediator）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 备忘录模式（Memento）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 空对象模式（Null Object）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 观察者模式（Observer）

* 模式定义

观察者模式有时也被称作发布/订阅模式，该模式用于为对象实现发布/订阅功能：
一旦主体对象状态发生改变，与之关联的观察者对象会收到通知，并进行相应操作。 
将一个系统分割成一个一些类相互协作的类有一个不好的副作用，那就是需要维护相关对象间的一致性。
我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。观察者就是解决这类的耦合关系的。 
消息队列系统、事件都使用了观察者模式。 PHP 为观察者模式定义了两个接口：SplSubject 和 SplObserver。
SplSubject 可以看做主体对象的抽象，SplObserver 可以看做观察者对象的抽象，
要实现观察者模式，只需让主体对象实现 SplSubject ，观察者对象实现 SplObserver，并实现相应方法即可。

* UML类图

![]({{site.baseurl}}/images/UML/Observer.png)

* 示例代码

User.php
```php
<?php
namespace DesignPatterns\Behavioral\Observer;

/**
 * 观察者模式 : 被观察对象 (主体对象)
 *
 * 主体对象维护观察者列表并发送通知
 *
 */
class User implements \SplSubject
{
    /**
     * user data
     *
     * @var array
     */
    protected $data = array();

    /**
     * observers
     *
     * @var \SplObjectStorage
     */
    protected $observers;
    
    public function __construct()
    {
        $this->observers = new \SplObjectStorage();
    }

    /**
     * 附加观察者
     *
     * @param \SplObserver $observer
     *
     * @return void
     */
    public function attach(\SplObserver $observer)
    {
        $this->observers->attach($observer);
    }

    /**
     * 取消观察者
     *
     * @param \SplObserver $observer
     *
     * @return void
     */
    public function detach(\SplObserver $observer)
    {
        $this->observers->detach($observer);
    }

    /**
     * 通知观察者方法
     *
     * @return void
     */
    public function notify()
    {
        /** @var \SplObserver $observer */
        foreach ($this->observers as $observer) {
            $observer->update($this);
        }
    }

    /**
     *
     * @param string $name
     * @param mixed  $value
     *
     * @return void
     */
    public function __set($name, $value)
    {
        $this->data[$name] = $value;

        // 通知观察者用户被改变
        $this->notify();
    }
}
```

UserObserver.php
```php
<?php
namespace DesignPatterns\Behavioral\Observer;

/**
 * UserObserver 类（观察者对象）
 */
class UserObserver implements \SplObserver
{
    /**
     * 观察者要实现的唯一方法
     * 也是被 Subject 调用的方法
     *
     * @param \SplSubject $subject
     */
    public function update(\SplSubject $subject)
    {
        echo get_class($subject) . ' has been updated';
    }
}
```

* 测试代码

Tests/ObserverTest.php
```php
<?php

namespace DesignPatterns\Behavioral\Observer\Tests;

use DesignPatterns\Behavioral\Observer\UserObserver;
use DesignPatterns\Behavioral\Observer\User;

/**
 * ObserverTest 测试观察者模式
 */
class ObserverTest extends \PHPUnit_Framework_TestCase
{
    protected $observer;

    protected function setUp()
    {
        $this->observer = new UserObserver();
    }

    /**
     * 测试通知
     */
    public function testNotify()
    {
        $this->expectOutputString('DesignPatterns\Behavioral\Observer\User has been updated');
        $subject = new User();

        $subject->attach($this->observer);
        $subject->property = 123;
    }

    /**
     * 测试订阅
     */
    public function testAttachDetach()
    {
        $subject = new User();
        $reflection = new \ReflectionProperty($subject, 'observers');

        $reflection->setAccessible(true);
        /** @var \SplObjectStorage $observers */
        $observers = $reflection->getValue($subject);

        $this->assertInstanceOf('SplObjectStorage', $observers);
        $this->assertFalse($observers->contains($this->observer));

        $subject->attach($this->observer);
        $this->assertTrue($observers->contains($this->observer));

        $subject->detach($this->observer);
        $this->assertFalse($observers->contains($this->observer));
    }

    /**
     * 测试 update() 调用
     */
    public function testUpdateCalling()
    {
        $subject = new User();
        $observer = $this->getMock('SplObserver');
        $subject->attach($observer);

        $observer->expects($this->once())
            ->method('update')
            ->with($subject);

        $subject->notify();
    }
}
```

* 总结

观察者模式解除了主体和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖具体。从而使得各自的变化都不会影响另一边的变化。

* 拓展

Spl标准类
```
/**
 * The <b>SplObserver</b> interface is used alongside
 * <b>SplSubject</b> to implement the Observer Design Pattern.
 * @link https://php.net/manual/en/class.splobserver.php
 */
interface SplObserver  {

        /**
         * Receive update from subject
         * @link https://php.net/manual/en/splobserver.update.php
         * @param SplSubject $subject <p>
	 * The <b>SplSubject</b> notifying the observer of an update.
         * </p>
         * @return void
         */
        public function update (SplSubject $subject);

}

/**
 * The <b>SplSubject</b> interface is used alongside
 * <b>SplObserver</b> to implement the Observer Design Pattern.
 * @link https://php.net/manual/en/class.splsubject.php
 */
interface SplSubject  {

        /**
         * Attach an SplObserver
         * @link https://php.net/manual/en/splsubject.attach.php
         * @param SplObserver $observer <p>
	 * The <b>SplObserver</b> to attach.
         * </p>
         * @return void
         */
        public function attach (SplObserver $observer);

        /**
         * Detach an observer
         * @link https://php.net/manual/en/splsubject.detach.php
         * @param SplObserver $observer <p>
	 * The <b>SplObserver</b> to detach.
         * </p>
         * @return void
         */
        public function detach (SplObserver $observer);

        /**
         * Notify an observer
         * @link https://php.net/manual/en/splsubject.notify.php
         * @return void
         */
        public function notify ();

}

/**
 * The SplObjectStorage class provides a map from objects to data or, by
 * ignoring data, an object set. This dual purpose can be useful in many
 * cases involving the need to uniquely identify objects.
 * @link https://php.net/manual/en/class.splobjectstorage.php
 */
class SplObjectStorage implements Countable, Iterator, Serializable, ArrayAccess {

        /**
         * Adds an object in the storage
         * @link https://php.net/manual/en/splobjectstorage.attach.php
         * @param object $object <p>
         * The object to add.
         * </p>
         * @param mixed $info [optional] <p>
         * The data to associate with the object.
         * </p>
         * @return void
         */
        public function attach ($object, $info = null) {}

        /**
	 * Removes an object from the storage
         * @link https://php.net/manual/en/splobjectstorage.detach.php
         * @param object $object <p>
         * The object to remove.
         * </p>
         * @return void
         */
        public function detach ($object) {}

        /**
         * Checks if the storage contains a specific object
         * @link https://php.net/manual/en/splobjectstorage.contains.php
         * @param object $object <p>
         * The object to look for.
         * </p>
	 * @return bool true if the object is in the storage, false otherwise.
         */
        public function contains ($object) {}

        /**
         * Adds all objects from another storage
         * @link https://php.net/manual/en/splobjectstorage.addall.php
         * @param SplObjectStorage $storage <p>
         * The storage you want to import.
         * </p>
         * @return void
         */
	public function addAll ($storage) {}

        /**
         * Removes objects contained in another storage from the current storage
         * @link https://php.net/manual/en/splobjectstorage.removeall.php
         * @param SplObjectStorage $storage <p>
         * The storage containing the elements to remove.
         * </p>
         * @return void
         */
	public function removeAll ($storage) {}

        /**
	 * Removes all objects except for those contained in another storage from the current storage
	 * @link https://php.net/manual/en/splobjectstorage.removeallexcept.php
	 * @param SplObjectStorage $storage <p>
	 * The storage containing the elements to retain in the current storage.
	 * </p>
	 * @return void
	 * @since 5.3.6
	 */
	public function removeAllExcept ($storage) {}

	/**
         * Returns the data associated with the current iterator entry
         * @link https://php.net/manual/en/splobjectstorage.getinfo.php
         * @return mixed The data associated with the current iterator position.
         */
        public function getInfo () {}

        /**
         * Sets the data associated with the current iterator entry
         * @link https://php.net/manual/en/splobjectstorage.setinfo.php
         * @param mixed $info <p>
         * The data to associate with the current iterator entry.
         * </p>
         * @return void
         */
        public function setInfo ($info) {}

        /**
         * Returns the number of objects in the storage
         * @link https://php.net/manual/en/splobjectstorage.count.php
         * @param int $mode [optional]
         * @return int The number of objects in the storage.
         */
        public function count ($mode = COUNT_NORMAL) {}

        /**
         * Rewind the iterator to the first storage element
         * @link https://php.net/manual/en/splobjectstorage.rewind.php
         * @return void
         */
        public function rewind () {}

        /**
         * Returns if the current iterator entry is valid
         * @link https://php.net/manual/en/splobjectstorage.valid.php
	 * @return bool true if the iterator entry is valid, false otherwise.
         */
        public function valid () {}

        /**
         * Returns the index at which the iterator currently is
         * @link https://php.net/manual/en/splobjectstorage.key.php
         * @return int The index corresponding to the position of the iterator.
         */
        public function key () {}

        /**
         * Returns the current storage entry
         * @link https://php.net/manual/en/splobjectstorage.current.php
         * @return object The object at the current iterator position.
         */
        public function current () {}

        /**
         * Move to the next entry
         * @link https://php.net/manual/en/splobjectstorage.next.php
         * @return void
         */
        public function next () {}

        /**
         * Unserializes a storage from its string representation
         * @link https://php.net/manual/en/splobjectstorage.unserialize.php
         * @param string $data <p>
         * The serialized representation of a storage.
         * </p>
         * @return void
         * @since 5.2.2
         */
        public function unserialize ($data) {}

        /**
         * Serializes the storage
         * @link https://php.net/manual/en/splobjectstorage.serialize.php
         * @return string A string representing the storage.
         * @since 5.2.2
         */
        public function serialize () {}

        /**
         * Checks whether an object exists in the storage
         * @link https://php.net/manual/en/splobjectstorage.offsetexists.php
         * @param object $object <p>
         * The object to look for.
         * </p>
	 * @return bool true if the object exists in the storage,
         * and false otherwise.
         */
        public function offsetExists ($object) {}

        /**
         * Associates data to an object in the storage
         * @link https://php.net/manual/en/splobjectstorage.offsetset.php
         * @param object $object <p>
         * The object to associate data with.
         * </p>
	 * @param mixed $info [optional] <p>
         * The data to associate with the object.
         * </p>
         * @return void
         */
	public function offsetSet ($object, $info = null) {}

        /**
         * Removes an object from the storage
         * @link https://php.net/manual/en/splobjectstorage.offsetunset.php
         * @param object $object <p>
         * The object to remove.
         * </p>
         * @return void
         */
        public function offsetUnset ($object) {}

        /**
         * Returns the data associated with an <type>object</type>
         * @link https://php.net/manual/en/splobjectstorage.offsetget.php
         * @param object $object <p>
         * The object to look for.
         * </p>
         * @return mixed The data previously associated with the object in the storage.
         */
        public function offsetGet ($object) {}

        /**
         * Calculate a unique identifier for the contained objects
         * @link https://php.net/manual/en/splobjectstorage.gethash.php
         * @param object $object  <p>
         * object whose identifier is to be calculated.
         * @return string A string with the calculated identifier.
         * @since 5.4
        */
        public function getHash($object) {}

        /**
         * @return array
         * @since 7.4
         */
        public function __serialize(): array {}

        /**
         * @param array $data
         * @since 7.4
         */
        public function __unserialize(array $data): void {}

        /**
         * @return array
         * @since 7.4
         */
        public function __debugInfo(){}

}
```

关于 观察者模式 与 发布/订阅模式 。 1.观察者模式是松耦合，而发布订阅模式是完全解耦的。
2.观察者模式里，只有两个角色：观察者、被观察者，而发布的订阅模式却不仅仅只有发布者和订阅者两个角色，还有一个经常被我们忽略的：经纪人Broker。

在《大话设计模式》一书，把 subject 看作发布者，observer 看作订阅者，反过来，可以把发布订阅模式看作松耦合的观察者模式实现；
在 GoF 的《设计模式》一书中，对观察者模式的定义只是一个基本概念，没有对这些细节做定义，
在 23 种设计模式中没有发布订阅模式，发布/订阅模式其实是从消息系统中作为架构模式迁移而来，
在 Windows 系统中也将这两个模式视作同义词，可以参考[维基百科](https://en.wikipedia.org/wiki/Observer_pattern#Coupling_and_typical_pub-sub_implementations) 中的介绍，
从宽松的角度来说，把它们看作一个模式没什么问题，发布/订阅模式只是观察者模式的一种松耦合实现，
从严格角度来说，也可以把它们看作不同的模式，比如 《JavaScript 设计模式》一书中就做了这样的[区分](https://www.oreilly.com/library/view/learning-javascript-design/9781449334840/ch09s05.html) ，
看具体的理解角度，比如微服务和服务化，有些人认为它们就是一个东西，有些人则要严格区分它们。

#### 规格模式（Specification）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 状态模式（State）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 策略模式(Strategy)

使用策略模式，你可以把一族不同的算法（业务）封装到不同的类中，使 client 类可以在不知道具体实现的情况下选择实例化其中一个算法。
策略模式有几种不同的变体，最简单的是下面这种：

第一段代码展示了一族输出算法，分别具体实现了 OutputInterface 的 load 方法，返回序列化结果，json 和数组：
```
<?php
interface OutputInterface
{
    public function load();
}

class SerializedArrayOutput implements OutputInterface
{
    public function load()
    {
        return serialize($arrayOfData);
    }
}

class JsonStringOutput implements OutputInterface
{
    public function load()
    {
        return json_encode($arrayOfData);
    }
}

class ArrayOutput implements OutputInterface
{
    public function load()
    {
        return $arrayOfData;
    }
}
```

通过像上面这样把不同类型的输出算法封装起来，其他的开发者可以很容易地在不影响 client 代码的情况下添加新的输出类型。

每个具体的输出类实现了 OutputInterface —— 这有两个目的，第一是它提供了一个所有输出类都必须遵守的契约，
第二，你将会在本文后面的部分看到，通过实现公共的接口，你可以利用类型约束保证 client 中使用的输出类必须是实现了 OutputInterface 的类。

接下来的一小段代码展示了一个 client 类如何使用其中一个输出算法，并可以在运行时根据需要选用不同的算法。
```
<?php
class SomeClient
{
    private $output;

    public function setOutput(OutputInterface $outputType)
    {
        $this->output = $outputType;
    }

    public function loadOutput()
    {
        return $this->output->load();
    }
}
```

上面的 client类有一个必须在运行时设置的私有属性，并且是“OutputInterface”类型的。 一旦这个属性被设置为具体的实例（三个输出类中之一的实例），
并且 loadOutput 方法被调用，那么它的 load 方法就会被调用，返回回序列化结果或 json 或数组。

```
<?php
$client = new SomeClient();

// Want an array?
$client->setOutput(new ArrayOutput());
$data = $client->loadOutput();

// Want some JSON?
$client->setOutput(new JsonStringOutput());
$data = $client->loadOutput();
```
  
#### 模板方法模式（Template Method）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 访问者模式（Visitor）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 解释器模式（Interpreter）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 委托模式（Delegation）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 资源库模式（Repository）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 服务定位器模式(Service Locator)

**服务定位器（Service Locator）**

Service Locator是IoC的另一种实现方式， 其核心是把所有可能用到的依赖单元交由Service Locator进行实例化和创建、配置， 
把类对依赖单元的依赖，转换成类对Service Locator的依赖。 DI 与 Service Locator并不冲突，两者可以结合使用。 
目前，Yii2.0把这DI和Service Locator这两个东西结合起来使用，或者说通过DI容器，实现了Service Locator。

具体实例，可以看一下 [深入理解Yii2.0 服务定位器](https://ibaiyang.github.io/blog/yii2/2019/06/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Yii2.0-%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%BD%8D%E5%99%A8.html) 。

#### 事件模式（Event）

使用事件，可以在特定的时点，触发执行预先设定的一段代码，事件既是代码解耦的一种方式，也是设计业务流程的一种模式。

具体实例，可以看一下 [深入理解Yii2.0 事件](https://ibaiyang.github.io/blog/yii2/2019/06/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Yii2.0-%E4%BA%8B%E4%BB%B6.html) 。

#### 行为模式（Behavior）

使用行为（behavior）可以在不修改现有类的情况下，对类的功能进行扩充。 通过将行为绑定到一个类，可以使类具有行为本身所定义的属性和方法， 
就好像类本来就有这些属性和方法一样。 而且不需要写一个新的类去继承或包含现有类。

具体实例，可以看一下 [深入理解Yii2.0 行为](https://ibaiyang.github.io/blog/yii2/2019/06/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Yii2.0-%E8%A1%8C%E4%B8%BA.html) 。

<br/><br/><br/><br/><br/>

### 参考资料

常见软件架构模式 <https://ibaiyang.github.io/blog/php/2019/07/30/%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F.html>

DesignPatternsPHP <https://github.com/domnikl/DesignPatternsPHP>

PHP 设计模式系列 <https://laravelacademy.org/books/php-design-pattern>

PHP 设计模式(Design Pattern For PHP) <https://www.cnblogs.com/wilburxu/category/910011.html> 

php-the-right-way 设计模式 <http://laravel-china.github.io/php-the-right-way/pages/Design-Patterns.html>

DesignPatternsPHP <https://designpatternsphp.readthedocs.io/en/latest/>

DesignPatternsPHP(PHP设计模式范例) <https://designpatternsphp.readthedocs.io/zh_CN/latest/README.html>

PHP 设计模式概述 <https://segmentfault.com/a/1190000016629282>

PHP设计模式（一）简单工厂模式 （Simple Factory For PHP） <https://segmentfault.com/a/1190000016635395>

PHP设计模式（二）工厂方法模式（Factory Method） <https://segmentfault.com/a/1190000016646401>

PHP设计模式（三）抽象工厂模式（Abstract Factory） <https://segmentfault.com/a/1190000016659904>

PHP设计模式（四）单例模式（Singleton） <https://segmentfault.com/a/1190000016670292>

PHP设计模式（五）建造者模式（Builder For PHP） <https://www.cnblogs.com/wilburxu/p/6179363.html>

PHP设计模式（六）原型模式（Prototype For PHP） <https://www.cnblogs.com/wilburxu/p/6188437.html>

PHP设计模式（七）适配器模式（Adapter For PHP） <https://www.cnblogs.com/wilburxu/p/6200570.html>

PHP设计模式（八）桥接模式（Bridge For PHP） <https://www.cnblogs.com/wilburxu/p/6202097.html>

PHP八大设计模式 <https://blog.csdn.net/flitrue/article/details/52614599>

php各种设计模式简单实践思考 <https://www.cnblogs.com/aksir/p/6777595.html>

工厂方法模式（Factory Method） <https://learnku.com/docs/php-design-patterns/2018/FactoryMethod/1489>

抽象工厂模式（Abstract Factory） <https://www.jianshu.com/p/7deb64f902db>

PHP设计模式-单例模式 <https://www.cnblogs.com/yangjinjin/archive/2013/01/31/2887492.html>

PHP中“简单工厂模式”实例讲解 <https://www.cnblogs.com/hongfei/archive/2012/07/07/2580776.html>

PHP设计模式之迭代器模式 <https://blog.csdn.net/bujidexinq/article/details/104956869>

