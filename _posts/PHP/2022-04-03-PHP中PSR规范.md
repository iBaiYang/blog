---
layout: post
categories: PHP
title: PHP中PSR规范
meta: PHP中PSR规范
---
* content
{:toc}

## 正文

PSR 是由 PHP FIG 组织制定的 PHP 规范，是 PHP 开发的实践标准。 

**PHP FIG**

PSR 是 PHP Standard Recommendations （PHP 推荐标准）的简写，由 PHP FIG 组织制定的 PHP 规范，是 PHP 开发的实践标准。

PHP FIG，FIG 是 Framework Interoperability Group（框架可互用性小组）的缩写，由几位开源框架的开发者成立于 2009 年，
从那开始也选取了很多其他成员进来（包括但不限于 Laravel, Joomla, Drupal, Composer, Phalcon, Slim, Symfony, Zend Framework 等），
虽然不是「官方」组织，但也代表了大部分的 PHP 社区。

项目的目的在于：通过框架作者或者框架的代表之间讨论，以最低程度的限制，制定一个协作标准，各个框架遵循统一的编码规范，
避免各家自行发展的风格阻碍了 PHP 的发展，解决这个程序设计师由来已久的困扰。

目前已表决通过了不少套标准，已经得到大部分 PHP 框架的支持和认可。

本项目的主要面向对象是所有参与的各个成员（也就是各自框架的社区），这里是完整的 成员列表，当然，同时也欢迎其它 PHP 社区采用本规范。

**状态说明**

在本文档的文章列表中，文章标题会有规范状态的标示。所有的规范分为以下几个状态：

    已通过（ACCEPTED）—— 文章标题将不会有所显示
    起草中（DRAFT）—— 暂不翻译
    未通过（ABANDONED）—— 简单说明，暂不翻译
    已弃用（DEPRECATED）—— 会有说明，暂不翻译

**规范目录**

    PSR-0 自动加载规范（已弃用）
    PSR-1 基础编码规范 已完成
    PSR-2 编码风格规范（已弃用） 已完成
    PSR-3 日志接口规范 已完成
    PSR-4 自动加载规范 已完成
    PSR-4 自动加载规范 - 示例文档 已完成
    PSR-4 自动加载规范 - 说明文档 已完成
    PSR-5 PHPDoc 标准（未通过）
    PSR-6 缓存接口规范 已完成
    PSR-6 缓存接口规范 - 说明文档 已完成
    PSR-7 HTTP 消息接口规范 已完成
    PSR-8 Huggable 接口（未通过）
    PSR-9 项目安全问题公示（未通过）
    PSR-10 项目安全上报方法（未通过）
    PSR-11 容器接口 已完成
    PSR-11 容器接口 - 说明文档 已完成
    PSR-12 编码规范扩充
    PSR-13 超媒体链接 已完成
    PSR-13 超媒体链接 - 说明文档 已完成
    PSR-14 事件分发器
    PSR-15 HTTP 请求处理器 已完成
    PSR-16 缓存接口 已完成
    PSR-16 缓存接口 - 说明文档 已完成
    PSR-17 HTTP 工厂 已完成
    PSR-18 HTTP 客户端 已完成 

### PSR-1 基础编码规范 

本篇规范制定了代码基本元素的相关标准，以确保共享的 PHP 代码间具有较高程度的技术互通性。

本文件中的 必须，不得，需要，应，不应，应该，不应该，推荐，可能 和 可选 等能愿动词按照 RFC 2119 中的描述进行解释。

1. 概览

PHP 代码文件 必须 以 `<?php` 或 `<?=` 标签开始；

PHP 代码文件 必须 以 不带 BOM 的 UTF-8 编码；

PHP 代码中 应该 声明任一标志（类、函数、常量等），或引起副作用（如果一个函数修改了自己范围之外的资源，
那就叫做有副作用，如：生成输出以及修改 .ini 配置文件等），但是不应该二者都有；

命名空间以及类 必须 符合 PSR 的自动加载规范： [PSR-0（已废弃）或 PSR-4] 中的一个。

类的命名 必须 遵循 StudlyCaps 大写开头的驼峰命名规范；

类中的常量所有字母都 必须 大写，单词间用下划线分隔；

方法名称 必须 符合 camelCase 式的小写开头驼峰命名规范。

2. 文件

2.1. PHP 标签

PHP 代码 必须 使用 <?php ?> 长标签 或 <?= ?> 短输出标签；

一定不可 使用其它自定义标签。

2.2. 字符集编码

PHP 代码 必须 且只可使用 不带 BOM 的 UTF-8 编码。

2.3. 副作用

一份 PHP 文件中 应该 要不就只定义新的声明，如类、函数或常量等不产生 副作用 的操作，
要不就只执行会产生 副作用 的逻辑操作，但 不该 同时具有两者。

「副作用」(side effects) 一词的意思是，仅仅通过包含文件，不直接声明类、函数和常量等，而执行的逻辑操作。

「副作用」包含却不仅限于：生成输出，明确使用 require 或 include，连接到外部服务，
修改 ini 设置，发出错误或异常，修改全局或静态变量，读取或写入一个文件，等等。

以下是一个 反例，一份包含「函数声明」以及产生「副作用」的代码：
```php
<?php
// 「副作用」：修改 ini 配置
ini_set('error_reporting', E_ALL);

// 「副作用」：引入文件
include "file.php";

// 「副作用」：生成输出
echo "<html>\n";

// 声明函数
function foo()
{
    // function body
}
```

下面是一个范例，一份只包含声明不产生「副作用」的代码：
```php
<?php
// 声明函数
function foo()
{
    // 函数主体部分
}

// 条件声明 **不** 属于「副作用」
if (! function_exists('bar')) {
    function bar()
    {
        // 函数主体部分
    }
}
```

3. 命名空间和类名

命名空间和类名 必须 遵循『自动加载』规范： [PSR-0， PSR-4]。

这意味着每个类都独立为一个文件，并且至少在一个层次的命名空间内，那就是：顶级组织名（vendor name）。

类名 必须 以类似 StudlyCaps 形式的大写开头的驼峰命名方式声明。

PHP 5.3 及更高版本的代码 必须 使用正式的命名空间。

举个例子：
```php
<?php
// PHP 5.3 及更高版本：
namespace Vendor\Model;

class Foo
{
}
```

PHP 5.2 及更低版本 应该 使用伪命名空间，约定俗成，以顶级组织名称 Vendor_ 为类名前缀：
```php
<?php
// PHP 5.2.x 及更低版本：
class Vendor_Model_Foo
{
}
```

4. 类的常量、属性和方法

此处的「类」指代所有的类、接口以及可复用代码块（traits）。

4.1. 常量

类的常量中所有字母都 必须 大写，词间以下划线分隔。例如：
```php
<?php
namespace Vendor\Model;

class Foo
{
    const VERSION = '1.0';
    const DATE_APPROVED = '2012-06-01';
}
```

4.2. 属性

类的属性命名 可以 遵循：

    大写开头的驼峰式 ($StudlyCaps)
    小写开头的驼峰式 ($camelCase)
    下划线分隔式 ($under_score)

本规范不做强制要求，但无论遵循哪种命名方式，都 应该 在一定的范围内保持一致。这个范围可以是整个团队、整个包、整个类或整个方法。

4.3. 方法

方法名称 必须 符合 camelCase() 式的小写开头驼峰命名规范。

### PSR-3 日志接口规范

**日志接口**

本文制定了日志类库的通用接口规范。

本规范的主要目的，是为了让日志类库以简单通用的方式，通过接收一个 Psr\Log\LoggerInterface 对象，来记录日志信息。 
框架以及 CMS 内容管理系统如有需要，可以 对此接口进行扩展，但需遵循本规范，

这才能保证在使用第三方的类库文件时，日志接口仍能正常对接。

为了避免歧义，文档大量使用了「能愿动词」，对应的解释如下：

    必须 (MUST)：绝对，严格遵循，请照做，无条件遵守；
    一定不可 (MUST NOT)：禁令，严令禁止；
    应该 (SHOULD) ：强烈建议这样做，但是不强求；
    不该 (SHOULD NOT)：强烈不建议这样做，但是不强求；
    可以 (MAY) 和 可选 (OPTIONAL) ：选择性高一点，在这个文档内，此词语使用较少；
    参见  RFC 2119 .

本文档中的 implementor 一词应理解为在日志的库中实现  LoggerInterface  的人。记录器的调用者称为 user

**1. 规范**

1.1 基本规范

* LoggerInterface 接口对外定义了八个方法，分别用来记录 RFC 5424 中定义的八个等级的日志：
debug、 info、 notice、 warning、 error、 critical、 alert 以及 emergency 。

* 第九个方法 —— log，其第一个参数为记录的等级。可使用一个预先定义的等级常量作为参数来调用此方法，
必须 与直接调用以上八个方法具有相同的效果。如果传入的等级常量参数没有预先定义，
则 必须 抛出 Psr\Log\InvalidArgumentException 类型的异常。
在不确定的情况下，使用者 不该 使用未支持的等级常量来调用此方法。

1.2 消息

* 以上每个方法都接受一个字符串类型或者是有 __toString() 方法的对象作为记录信息参数，
这样，实现者就能把它当成字符串来处理，否则实现者 必须 自己把它转换成字符串。

* 记录信息参数 可以 携带占位符，实现者 可以 根据上下文将其它替换成相应的值。

其中占位符 必须 与上下文数组中的键名保持一致。

占位符的名称 必须 由一个左花括号 `{` 以及一个右括号 `}` 包含。但花括号与名称之间 一定不可有空格符。

占位符的名称 应该 只由 A-Z、a-z、0-9、下划线 `_`、以及英文的句号 `.` 组成，其它字符作为将来占位符规范的保留。

实现者 可以 通过对占位符采用不同的转义和转换策略，来生成最终的日志。
而使用者在不知道上下文的前提下，不该 提前转义占位符。

以下是一个占位符使用的例子：
```php
<?php

/**
 * 用上下文信息替换记录信息中的占位符
 */
function interpolate($message, array $context = array())
{
    // 构建一个花括号包含的键名的替换数组
    $replace = array();
    foreach ($context as $key => $val) {
        // 检查该值是否可以转换为字符串
        if (!is_array($val) && (!is_object($val) || method_exists($val, '__toString'))) {
            $replace['{' . $key . '}'] = $val;
        }
    }

    // 替换记录信息中的占位符，最后返回修改后的记录信息。
    return strtr($message, $replace);
}

// 含有带花括号占位符的记录信息。
$message = "User {username} created";

// 带有替换信息的上下文数组，键名为占位符名称，键值为替换值。
$context = array('username' => 'bolivar');

// 输出 "User bolivar created"
echo interpolate($message, $context);
```

1.3 上下文

* 每个记录函数都接受一个上下文数组参数，用来装载字符串类型无法表示的信息。
它 可以 装载任何信息，所以实现者 必须 确保能正确处理其装载的信息，对于其装载的数据， 
一定不可 抛出异常，或产生 PHP 出错、警告或提醒信息（error、warning、notice）。

* 如需通过上下文参数传入了一个 Exception 对象，必须 以 exception 作为键名。
记录异常信息是很普遍的，所以如果它能够在记录类库的底层实现，就能够让实现者从异常信息中抽丝剥茧。
当然，实现者在使用它时，必须 确保键名为 exception 的键值是否真的是一个 Exception，毕竟它 可以 装载任何信息。

1.4 助手类和接口

* Psr\Log\AbstractLogger 类使得只需继承它和实现其中的 log 方法，就能够很轻易地实现 LoggerInterface 接口，
而另外八个方法就能够把记录信息和上下文信息传给它。

* 同样地，使用 Psr\Log\LoggerTrait 也只需实现其中的 log 方法。不过，需要特别注意的是，
在 traits 可复用代码块还不能实现接口前，还需要 implement LoggerInterface。

* 在没有可用的日志记录器时，Psr\Log\NullLogger 接口 可以 为使用者提供一个备用的日志「黑洞」。
不过，当上下文的构建非常消耗资源时，带条件检查的日志记录或许是更好的办法。

* Psr\Log\LoggerAwareInterface 接口仅包括一个 setLogger(LoggerInterface $logger) 方法，框架可以使用它实现自动连接任意的日志记录实例。

* Psr\Log\LoggerAwareTrait trait 可复用代码块可以在任何的类里面使用，只需通过它提供的 $this->logger，就可以轻松地实现等同的接口。

* Psr\Log\LogLevel 类装载了八个记录等级常量。

**2. 包**

接口和类的描述、相关的异常类以及用于验证你所写代码的测试套件都将作为 psr/log 包的一部分提供。

3. Psr\Log\LoggerInterface

```php
<?php

namespace Psr\Log;

/**
 * 描述一个日志记录器实例
 *
 * 该消息必须实现一个__toString()的字符串或者对象.
 *
 * 该消息可能包含以下形式的占位符: {foo}  
 * foo 将会被关键词 "foo"中的上下文数据替换.
 *
 * 上下文数组可以包含任意数据, 我们只能假设代码实现者
 * 如果给出一个生成堆栈跟踪的异常实例, 那么它的键名
 * 必须为 "exception"。
 *
 * 请前往 https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md
 * 查看完整的接口规范.
 */
interface LoggerInterface
{
    /**
     * 系统无法使用。
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function emergency($message, array $context = array());

    /**
     * 必须立即采取行动。
     *
     * 例如: 整个网站宕机了，数据库挂了，等等。 这应该
     * 发送短信通知警告你.
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function alert($message, array $context = array());

    /**
     * 临界条件。
     *
     * 例如: 应用组件不可用，意外的异常。
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function critical($message, array $context = array());

    /**
     * 运行时错误不需要马上处理，
     * 但通常应该被记录和监控。
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function error($message, array $context = array());

    /**
     * 例外事件不是错误。
     *
     * 例如: 使用过时的API，API使用不当，不合理的东西不一定是错误。
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function warning($message, array $context = array());

    /**
     * 正常但重要的事件.
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function notice($message, array $context = array());

    /**
     * 有趣的事件.
     *
     * 例如: 用户登录，SQL日志。
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function info($message, array $context = array());

    /**
     * 详细的调试信息。
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function debug($message, array $context = array());

    /**
     * 可任意级别记录日志。
     *
     * @param mixed $level
     * @param string $message
     * @param array $context
     * @return void
     */
    public function log($level, $message, array $context = array());
}
```

**4. Psr\Log\LoggerAwareInterface**

```php
<?php

namespace Psr\Log;

/**
 * logger-aware 定义实例
 */
interface LoggerAwareInterface
{
    /**
     * 设置一个日志记录实例
     *
     * @param LoggerInterface $logger
     * @return void
     */
    public function setLogger(LoggerInterface $logger);
}
```

**5. Psr\Log\LogLevel**

```php
<?php

namespace Psr\Log;

/**
 * 日志等级常量定义
 */
class LogLevel
{
    const EMERGENCY = 'emergency';
    const ALERT     = 'alert';
    const CRITICAL  = 'critical';
    const ERROR     = 'error';
    const WARNING   = 'warning';
    const NOTICE    = 'notice';
    const INFO      = 'info';
    const DEBUG     = 'debug';
}
```






## 参考资料

PHP PSR 标准规范 <https://learnku.com/docs/psr>

PSR-0: Autoloading Standard <https://www.php-fig.org/psr/psr-0/>

PSR-1 基础编码规范 <https://laravel-china.org/topics/2078>

PEAR 编码准则 <https://pear.php.net/manual/en/standards.php>

Symfony 编码准则 <https://symfony.com/doc/current/contributing/code/standards.html>

PHP中PSR-[0-4]规范：<http://m.blog.csdn.net/article/details?id=42844391>

PHP中PSR-[0-4]规范：<https://www.zybuluo.com/phper/note/65033>

