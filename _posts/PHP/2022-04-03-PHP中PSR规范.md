---
layout: post
categories: PHP
title: PHP中PSR规范
meta: PHP中PSR规范
---
* content
{:toc}

## 正文

PSR 是由 PHP FIG 组织制定的 PHP 规范，是 PHP 开发的实践标准。 

**PHP FIG**

PSR 是 PHP Standard Recommendations （PHP 推荐标准）的简写，由 PHP FIG 组织制定的 PHP 规范，是 PHP 开发的实践标准。

PHP FIG，FIG 是 Framework Interoperability Group（框架可互用性小组）的缩写，由几位开源框架的开发者成立于 2009 年，
从那开始也选取了很多其他成员进来（包括但不限于 Laravel, Joomla, Drupal, Composer, Phalcon, Slim, Symfony, Zend Framework 等），
虽然不是「官方」组织，但也代表了大部分的 PHP 社区。

项目的目的在于：通过框架作者或者框架的代表之间讨论，以最低程度的限制，制定一个协作标准，各个框架遵循统一的编码规范，
避免各家自行发展的风格阻碍了 PHP 的发展，解决这个程序设计师由来已久的困扰。

目前已表决通过了不少套标准，已经得到大部分 PHP 框架的支持和认可。

本项目的主要面向对象是所有参与的各个成员（也就是各自框架的社区），这里是完整的 成员列表，当然，同时也欢迎其它 PHP 社区采用本规范。

**状态说明**

在本文档的文章列表中，文章标题会有规范状态的标示。所有的规范分为以下几个状态：

    已通过（ACCEPTED）—— 文章标题将不会有所显示
    起草中（DRAFT）—— 暂不翻译
    未通过（ABANDONED）—— 简单说明，暂不翻译
    已弃用（DEPRECATED）—— 会有说明，暂不翻译

**规范目录**

    PSR-0 自动加载规范（已弃用）
    PSR-1 基础编码规范 已完成
    PSR-2 编码风格规范（已弃用） 已完成
    PSR-3 日志接口规范 已完成
    PSR-4 自动加载规范 已完成
    PSR-4 自动加载规范 - 示例文档 已完成
    PSR-4 自动加载规范 - 说明文档 已完成
    PSR-5 PHPDoc 标准（未通过）
    PSR-6 缓存接口规范 已完成
    PSR-6 缓存接口规范 - 说明文档 已完成
    PSR-7 HTTP 消息接口规范 已完成
    PSR-8 Huggable 接口（未通过）
    PSR-9 项目安全问题公示（未通过）
    PSR-10 项目安全上报方法（未通过）
    PSR-11 容器接口 已完成
    PSR-11 容器接口 - 说明文档 已完成
    PSR-12 编码规范扩充
    PSR-13 超媒体链接 已完成
    PSR-13 超媒体链接 - 说明文档 已完成
    PSR-14 事件分发器
    PSR-15 HTTP 请求处理器 已完成
    PSR-16 缓存接口 已完成
    PSR-16 缓存接口 - 说明文档 已完成
    PSR-17 HTTP 工厂 已完成
    PSR-18 HTTP 客户端 已完成 

### PSR-1 基础编码规范 

**基本代码规范**

本篇规范制定了代码基本元素的相关标准，以确保共享的 PHP 代码间具有较高程度的技术互通性。

本文件中的 必须，不得，需要，应，不应，应该，不应该，推荐，可能 和 可选 等能愿动词按照 RFC 2119 中的描述进行解释。

**1、 概览**

* PHP 代码文件 必须 以 `<?php` 或 `<?=` 标签开始；

* PHP 代码文件 必须 以 `不带 BOM 的 UTF-8` 编码；

* PHP 代码中 应该 声明任一标志（类、函数、常量等），或引起`副作用`（如果一个函数修改了自己范围之外的资源，
那就叫做有副作用，如：生成输出以及修改 .ini 配置文件等），但是不应该二者都有；

* 命名空间以及类 必须 符合 PSR 的自动加载规范： [PSR-0（已废弃）或 PSR-4] 中的一个。

* 类的命名 必须 遵循 `StudlyCaps` 大写开头的驼峰命名规范；

* 类中的常量所有字母都 必须 大写，单词间用下划线分隔；

* 方法名称 必须 符合 `camelCase` 式的小写开头驼峰命名规范。

**2、 文件**

2.1. PHP 标签

PHP 代码 必须 使用 `<?php ?>` 长标签 或 `<?= ?>` 短输出标签；

一定不可 使用其它自定义标签。

2.2. 字符集编码

PHP 代码 必须 且只可使用 `不带 BOM 的 UTF-8` 编码。

2.3. 副作用

一份 PHP 文件中 应该 要不就只定义新的声明，如类、函数或常量等不产生 副作用 的操作，
要不就只执行会产生 副作用 的逻辑操作，但 不该 同时具有两者。

「副作用」(side effects) 一词的意思是，仅仅通过包含文件，不直接声明类、函数和常量等，而执行的逻辑操作。

「副作用」包含却不仅限于：生成输出，明确使用 require 或 include，连接到外部服务，
修改 ini 设置，发出错误或异常，修改全局或静态变量，读取或写入一个文件，等等。

以下是一个 反例，一份包含「函数声明」以及产生「副作用」的代码：
```php
<?php
// 「副作用」：修改 ini 配置
ini_set('error_reporting', E_ALL);

// 「副作用」：引入文件
include "file.php";

// 「副作用」：生成输出
echo "<html>\n";

// 声明函数
function foo()
{
    // function body
}
```

下面是一个范例，一份只包含声明不产生「副作用」的代码：
```php
<?php
// 声明函数
function foo()
{
    // 函数主体部分
}

// 条件声明 **不** 属于「副作用」
if (! function_exists('bar')) {
    function bar()
    {
        // 函数主体部分
    }
}
```

**3、 命名空间和类名**

命名空间和类名 必须 遵循『自动加载』规范： [PSR-0， PSR-4]。

这意味着每个类都独立为一个文件，并且至少在一个层次的命名空间内，那就是：顶级组织名（vendor name）。

类名 必须 以类似 StudlyCaps 形式的大写开头的驼峰命名方式声明。

PHP 5.3 及更高版本的代码 必须 使用正式的命名空间。

举个例子：
```php
<?php
// PHP 5.3 及更高版本：
namespace Vendor\Model;

class Foo
{
}
```

PHP 5.2 及更低版本 应该 使用伪命名空间，约定俗成，以顶级组织名称 Vendor_ 为类名前缀：
```php
<?php
// PHP 5.2.x 及更低版本：
class Vendor_Model_Foo
{
}
```

**4、 类的常量、属性和方法**

此处的「类」指代所有的类、接口以及可复用代码块（traits）。

4.1. 常量

类的常量中所有字母都 必须 大写，词间以下划线分隔。例如：
```php
<?php
namespace Vendor\Model;

class Foo
{
    const VERSION = '1.0';
    const DATE_APPROVED = '2012-06-01';
}
```

4.2. 属性

类的属性命名 可以 遵循：

    大写开头的驼峰式 ($StudlyCaps)
    小写开头的驼峰式 ($camelCase)
    下划线分隔式 ($under_score)

本规范不做强制要求，但无论遵循哪种命名方式，都 应该 在一定的范围内保持一致。这个范围可以是整个团队、整个包、整个类或整个方法。

4.3. 方法

方法名称 必须 符合 camelCase() 式的小写开头驼峰命名规范。

### PSR-3 日志接口规范

**日志接口**

本文制定了日志类库的通用接口规范。

本规范的主要目的，是为了让日志类库以简单通用的方式，通过接收一个 `Psr\Log\LoggerInterface` 对象，来记录日志信息。 
框架以及 CMS 内容管理系统如有需要，可以 对此接口进行扩展，但需遵循本规范，
这才能保证在使用第三方的类库文件时，日志接口仍能正常对接。

为了避免歧义，文档大量使用了「能愿动词」，对应的解释如下：

    必须 (MUST)：绝对，严格遵循，请照做，无条件遵守；
    一定不可 (MUST NOT)：禁令，严令禁止；
    应该 (SHOULD) ：强烈建议这样做，但是不强求；
    不该 (SHOULD NOT)：强烈不建议这样做，但是不强求；
    可以 (MAY) 和 可选 (OPTIONAL) ：选择性高一点，在这个文档内，此词语使用较少；
    参见  RFC 2119 .

本文档中的 implementor 一词应理解为在日志的库中实现  `LoggerInterface`  的人。记录器的调用者称为 user

**1. 规范**

1.1 基本规范

* `LoggerInterface` 接口对外定义了八个方法，分别用来记录 RFC 5424 中定义的八个等级的日志：
debug、 info、 notice、 warning、 error、 critical、 alert 以及 emergency 。

* 第九个方法 —— `log`，其第一个参数为记录的等级。可使用一个预先定义的等级常量作为参数来调用此方法，
必须 与直接调用以上八个方法具有相同的效果。如果传入的等级常量参数没有预先定义，
则 必须 抛出 `Psr\Log\InvalidArgumentException` 类型的异常。
在不确定的情况下，使用者 不该 使用未支持的等级常量来调用此方法。

1.2 消息

* 以上每个方法都接受一个字符串类型或者是有 `__toString()` 方法的对象作为记录信息参数，
这样，实现者就能把它当成字符串来处理，否则实现者 必须 自己把它转换成字符串。

* 记录信息参数 可以 携带占位符，实现者 可以 根据上下文将其它替换成相应的值。

其中占位符 必须 与上下文数组中的键名保持一致。

占位符的名称 必须 由一个左花括号 `{` 以及一个右括号 `}` 包含。但花括号与名称之间 一定不可有空格符。

占位符的名称 应该 只由 A-Z、a-z、0-9、下划线 `_`、以及英文的句号 `.` 组成，其它字符作为将来占位符规范的保留。

实现者 可以 通过对占位符采用不同的转义和转换策略，来生成最终的日志。
而使用者在不知道上下文的前提下，不该 提前转义占位符。

以下是一个占位符使用的例子：
```php
<?php

/**
 * 用上下文信息替换记录信息中的占位符
 */
function interpolate($message, array $context = array())
{
    // 构建一个花括号包含的键名的替换数组
    $replace = array();
    foreach ($context as $key => $val) {
        // 检查该值是否可以转换为字符串
        if (!is_array($val) && (!is_object($val) || method_exists($val, '__toString'))) {
            $replace['{' . $key . '}'] = $val;
        }
    }

    // 替换记录信息中的占位符，最后返回修改后的记录信息。
    return strtr($message, $replace);
}

// 含有带花括号占位符的记录信息。
$message = "User {username} created";

// 带有替换信息的上下文数组，键名为占位符名称，键值为替换值。
$context = array('username' => 'bolivar');

// 输出 "User bolivar created"
echo interpolate($message, $context);
```

1.3 上下文

* 每个记录函数都接受一个上下文数组参数，用来装载字符串类型无法表示的信息。
它 可以 装载任何信息，所以实现者 必须 确保能正确处理其装载的信息，对于其装载的数据， 
一定不可 抛出异常，或产生 PHP 出错、警告或提醒信息（error、warning、notice）。

* 如需通过上下文参数传入了一个 `Exception` 对象，必须 以 `exception` 作为键名。
记录异常信息是很普遍的，所以如果它能够在记录类库的底层实现，就能够让实现者从异常信息中抽丝剥茧。
当然，实现者在使用它时，必须 确保键名为 `exception` 的键值是否真的是一个 `Exception`，毕竟它 可以 装载任何信息。

1.4 助手类和接口

* `Psr\Log\AbstractLogger` 类使得只需继承它和实现其中的 `log` 方法，就能够很轻易地实现 `LoggerInterface` 接口，
而另外八个方法就能够把记录信息和上下文信息传给它。

* 同样地，使用 `Psr\Log\LoggerTrait` 也只需实现其中的 `log` 方法。不过，需要特别注意的是，
在 traits 可复用代码块还不能实现接口前，还需要 `implement LoggerInterface`。

* 在没有可用的日志记录器时，`Psr\Log\NullLogger` 接口 可以 为使用者提供一个备用的日志「黑洞」。
不过，当上下文的构建非常消耗资源时，带条件检查的日志记录或许是更好的办法。

* `Psr\Log\LoggerAwareInterface` 接口仅包括一个 `setLogger(LoggerInterface $logger)` 方法，框架可以使用它实现自动连接任意的日志记录实例。

* `Psr\Log\LoggerAwareTrait` trait 可复用代码块可以在任何的类里面使用，只需通过它提供的 `$this->logger`，就可以轻松地实现等同的接口。

* `Psr\Log\LogLevel` 类装载了八个记录等级常量。

**2. 包**

接口和类的描述、相关的异常类以及用于验证你所写代码的测试套件都将作为 psr/log 包的一部分提供。

**3. `Psr\Log\LoggerInterface`**

```php
<?php

namespace Psr\Log;

/**
 * 描述一个日志记录器实例
 *
 * 该消息必须实现一个__toString()的字符串或者对象.
 *
 * 该消息可能包含以下形式的占位符: {foo}  
 * foo 将会被关键词 "foo"中的上下文数据替换.
 *
 * 上下文数组可以包含任意数据, 我们只能假设代码实现者如果给出一个生成堆栈跟踪的异常实例, 
 * 那么它的键名必须为 "exception"。
 *
 * 请前往 https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md
 * 查看完整的接口规范.
 */
interface LoggerInterface
{
    /**
     * 系统无法使用。
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function emergency($message, array $context = array());

    /**
     * 必须立即采取行动。
     *
     * 例如: 整个网站宕机了，数据库挂了，等等。 这应该发送短信通知警告你.
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function alert($message, array $context = array());

    /**
     * 临界条件。
     *
     * 例如: 应用组件不可用，意外的异常。
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function critical($message, array $context = array());

    /**
     * 运行时错误不需要马上处理，但通常应该被记录和监控。
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function error($message, array $context = array());

    /**
     * 例外事件不是错误。
     *
     * 例如: 使用过时的API，API使用不当，不合理的东西不一定是错误。
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function warning($message, array $context = array());

    /**
     * 正常但重要的事件.
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function notice($message, array $context = array());

    /**
     * 有趣的事件.
     *
     * 例如: 用户登录，SQL日志。
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function info($message, array $context = array());

    /**
     * 详细的调试信息。
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function debug($message, array $context = array());

    /**
     * 可任意级别记录日志。
     *
     * @param mixed $level
     * @param string $message
     * @param array $context
     * @return void
     */
    public function log($level, $message, array $context = array());
}
```

**4. `Psr\Log\LoggerAwareInterface`**

```php
<?php

namespace Psr\Log;

/**
 * logger-aware 定义实例
 */
interface LoggerAwareInterface
{
    /**
     * 设置一个日志记录实例
     *
     * @param LoggerInterface $logger
     * @return void
     */
    public function setLogger(LoggerInterface $logger);
}
```

**5. `Psr\Log\LogLevel`**

```php
<?php

namespace Psr\Log;

/**
 * 日志等级常量定义
 */
class LogLevel
{
    const EMERGENCY = 'emergency';
    const ALERT     = 'alert';
    const CRITICAL  = 'critical';
    const ERROR     = 'error';
    const WARNING   = 'warning';
    const NOTICE    = 'notice';
    const INFO      = 'info';
    const DEBUG     = 'debug';
}
```

### PSR-4 自动加载规范 

**自动加载**

为了避免歧义，文档大量使用了「能愿动词」，对应的解释如下：

    必须 (MUST)：绝对，严格遵循，请照做，无条件遵守；
    一定不可 (MUST NOT)：禁令，严令禁止；
    应该 (SHOULD) ：强烈建议这样做，但是不强求；
    不该 (SHOULD NOT)：强烈不建议这样做，但是不强求；
    可以 (MAY) 和 可选 (OPTIONAL) ：选择性高一点，在这个文档内，此词语使用较少；

参见：RFC 2119

**1. 总览**

PSR-4 描述了从文件路径中 自动加载 类的规范。 它拥有非常好的兼容性，并且可以在任何自动加载规范中使用，
包括 PSR-0。 PSR-4 规范也描述了放置 autoload 文件（就是我们经常引入的 `vendor/autoload.php`）的位置。

**2. 规范**

1、术语「class」指的是类（classes）、接口（interfaces）、特征（traits）和其他类似的结构。

2、全限定类名具有以下形式：

`\<NamespaceName>(\<SubNamespaceNames>)*\<ClassName>`

* 全限定类名必须拥有一个顶级命名空间名称，也称为供应商命名空间（vendor namespace）。
* 全限定类名可以有一个或者多个子命名空间名称。
* 全限定类名必须有一个最终的类名（我想意思应该是你不能这样 `\<NamespaceName>(\<SubNamespaceNames>)*\` 来表示一个完整的类）。
* 下划线在全限定类名中没有任何特殊含义（在 PSR-0 中下划是有含义的）。
* 全限定类名可以是任意大小写字母的组合。
* 所有类名的引用必须区分大小写。

3、全限定类名的加载过程

* 在全限定的类名（一个「命名空间前缀」）中，一个或多个前导命名空间和子命名空间组成的连续命名空间，
不包括前导命名空间的分隔符，至少对应一个「根目录」。
* 「命名空间前缀」后面的相邻子命名空间与根目录下的目录名称相对应（且必须区分大小写），
其中命名空间的分隔符表示目录分隔符。
* 最终的类名与以`.php` 结尾的文件名保持一致，这个文件的名字必须和最终的类名相匹配（
意思就是如果类名是 `FooController`，那么这个类所在的文件名必须是 `FooController.php`）。

4、自动加载文件禁止抛出异常，禁止出现任何级别的错误，也不建议有返回值。

**3. 范例**

下表显示了与给定的全限定类名、命名空间前缀和根目录相对应的文件的路径。
```
Fully Qualified Class Name    Namespace Prefix   Base Directory           Resulting File Path
\Acme\Log\Writer\File_Writer  Acme\Log\Writer    ./acme-log-writer/lib/   ./acme-log-writer/lib/File_Writer.php
\Aura\Web\Response\Status     Aura\Web           /path/to/aura-web/src/   /path/to/aura-web/src/Response/Status.php
\Symfony\Core\Request         Symfony\Core       ./vendor/Symfony/Core/   ./vendor/Symfony/Core/Request.php
\Zend\Acl                     Zend               /usr/includes/Zend/      /usr/includes/Zend/Acl.php
```

想要了解一个符合规范的自动加载器的实现可以查看示例文件。示例中的自动加载器禁止被视为规范的一部分，它随时都可能发生改变。

### PSR-4 自动加载规范 - 示例文档 

**PSR-4 的实现示例**

下面的示例说明了符合 PSR-4 的代码：

**闭包示例**

```php
<?php
/**
 * 一个具体项目实现的示例。
 *
 * 在注册自动加载函数后，
 * 下面这行代码将引发程序尝试从 /path/to/project/src/Baz/Qux.php 加载 \Foo\Bar\Baz\Qux 类：
 *
 *      new \Foo\Bar\Baz\Qux;
 *
 * @param string $class 完全标准的类名。
 * @return void
 */
spl_autoload_register(function ($class) {

    // 具体项目的命名空间前缀
    $prefix = 'Foo\\Bar\\';

    // 命名空间前缀对应的基础目录
    $base_dir = __DIR__ . '/src/';

    // 该类使用了此命名空间前缀？
    $len = strlen($prefix);
    if (strncmp($prefix, $class, $len) !== 0) {
        // 否，交给下一个已注册的自动加载函数
        return;
    }

    // 获取相对类名
    $relative_class = substr($class, $len);

    // 命名空间前缀替换为基础目录，
    // 将相对类名中命名空间分隔符替换为目录分隔符，
    // 附加 .php
    $file = $base_dir . str_replace('\\', '/', $relative_class) . '.php';

    // 如果文件存在，加载它
    if (file_exists($file)) {
        require $file;
    }
});
```

**类示例**

以下是一个可处理多命名空间的类实现示例：
```php
<?php
namespace Example;

/**
 * 一个多用途的示例实现，包括了允许多个基本目录用于单个命名空间前缀的可选功能
 *
 * 下述示例给出了一个 foo-bar 类包，系统中路径结构如下……
 *
 *     /path/to/packages/foo-bar/
 *         src/
 *             Baz.php             # Foo\Bar\Baz
 *             Qux/
 *                 Quux.php        # Foo\Bar\Qux\Quux
 *         tests/
 *             BazTest.php         # Foo\Bar\BazTest
 *             Qux/
 *                 QuuxTest.php    # Foo\Bar\Qux\QuuxTest
 *
 * ……添加路径到  \Foo\Bar\  命名空间前缀的类文件中
 * 如下所示：
 *
 *      <?php
 *      // 实例化加载器
 *      $loader = new \Example\Psr4AutoloaderClass;
 *
 *      // 注册加载器
 *      $loader->register();
 *
 *      // 为命名空间前缀注册基本路径
 *      $loader->addNamespace('Foo\Bar', '/path/to/packages/foo-bar/src');
 *      $loader->addNamespace('Foo\Bar', '/path/to/packages/foo-bar/tests');
 *
 * 下述语句会让自动加载器尝试从 
 * /path/to/packages/foo-bar/src/Qux/Quux.php 
 * 中加载  \Foo\Bar\Qux\Quux 类
 *
 *      <?php
 *      new \Foo\Bar\Qux\Quux;
 *
 *  下述语句会让自动加载器尝试从 
 *   /path/to/packages/foo-bar/tests/Qux/QuuxTest.php
 * 中加载 \Foo\Bar\Qux\QuuxTest 类：
 *
 *      <?php
 *      new \Foo\Bar\Qux\QuuxTest;
 */
class Psr4AutoloaderClass
{
    /**
     * 关联数组，键名为命名空间前缀，键值为一个基本目录数组。
     *
     * @var array
     */
    protected $prefixes = array();

    /**
     * 通过 SPL 自动加载器栈注册加载器
     *
     * @return void
     */
    public function register()
    {
        spl_autoload_register(array($this, 'loadClass'));
    }

    /**
     * 为命名空间前缀添加一个基本目录
     *
     * @param string $prefix 命名空间前缀。
     * @param string $base_dir 命名空间下类文件的基本目录
     * @param bool $prepend 如果为真，预先将基本目录入栈而不是后续追加；这将使得它会被首先搜索到。
     * @return void
     */
    public function addNamespace($prefix, $base_dir, $prepend = false)
    {
        // 规范化命名空间前缀
        $prefix = trim($prefix, '\\') . '\\';

        // 规范化尾部文件分隔符
        $base_dir = rtrim($base_dir, DIRECTORY_SEPARATOR) . '/';

        // 初始化命名空间前缀数组
        if (isset($this->prefixes[$prefix]) === false) {
            $this->prefixes[$prefix] = array();
        }

        // 保留命名空间前缀的基本目录
        if ($prepend) {
            array_unshift($this->prefixes[$prefix], $base_dir);
        } else {
            array_push($this->prefixes[$prefix], $base_dir);
        }
    }

    /**
     * 加载给定类名的类文件
     *
     * @param string $class 合法类名
     * @return mixed 成功时为已映射文件名，失败则为 false
     */
    public function loadClass($class)
    {
        // 当前命名空间前缀
        $prefix = $class;

        // 通过完整的命名空间类名反向映射文件名
        while (false !== $pos = strrpos($prefix, '\\')) {

            // 在前缀中保留命名空间分隔符
            $prefix = substr($class, 0, $pos + 1);

            // 其余的是相关类名
            $relative_class = substr($class, $pos + 1);

            // 尝试为前缀和相关类加载映射文件
            $mapped_file = $this->loadMappedFile($prefix, $relative_class);
            if ($mapped_file) {
                return $mapped_file;
            }

            // 删除 strrpos() 下一次迭代的尾部命名空间分隔符
            $prefix = rtrim($prefix, '\\');
        }

        // 找不到映射文件
        return false;
    }

    /**
     * 为命名空间前缀和相关类加载映射文件。
     *
     * @param string $prefix 命名空间前缀
     * @param string $relative_class 相关类
     * @return mixed Boolean 无映射文件则为false，否则加载映射文件
     */
    protected function loadMappedFile($prefix, $relative_class)
    {
        // 命名空间前缀是否存在任何基本目录
        if (isset($this->prefixes[$prefix]) === false) {
            return false;
        }

        // 通过基本目录查找命名空间前缀
        foreach ($this->prefixes[$prefix] as $base_dir) {

            // 用基本目录替换命名空间前缀
            // 用目录分隔符替换命名空间分隔符
            // 给相关的类名增加 .php 后缀
            $file = $base_dir
                  . str_replace('\\', '/', $relative_class)
                  . '.php';

            // 如果映射文件存在，则引入
            if ($this->requireFile($file)) {
                // 搞定了
                return $file;
            }
        }

        // 找不到
        return false;
    }

    /**
     * 如果文件存在从系统中引入进来
     *
     * @param string $file 引入文件
     * @return bool 文件存在则 true 否则 false
     */
    protected function requireFile($file)
    {
        if (file_exists($file)) {
            require $file;
            return true;
        }
        return false;
    }
}
```

**单元测试**

以下示例是上述类加载器的单元测试方式之一：
```php
<?php
namespace Example\Tests;

class MockPsr4AutoloaderClass extends Psr4AutoloaderClass
{
    protected $files = array();

    public function setFiles(array $files)
    {
        $this->files = $files;
    }

    protected function requireFile($file)
    {
        return in_array($file, $this->files);
    }
}

class Psr4AutoloaderClassTest extends \PHPUnit\Framework\TestCase
{
    protected $loader;

    protected function setUp(): void
    {
        $this->loader = new MockPsr4AutoloaderClass;

        $this->loader->setFiles(array(
            '/vendor/foo.bar/src/ClassName.php',
            '/vendor/foo.bar/src/DoomClassName.php',
            '/vendor/foo.bar/tests/ClassNameTest.php',
            '/vendor/foo.bardoom/src/ClassName.php',
            '/vendor/foo.bar.baz.dib/src/ClassName.php',
            '/vendor/foo.bar.baz.dib.zim.gir/src/ClassName.php',
        ));

        $this->loader->addNamespace(
            'Foo\Bar',
            '/vendor/foo.bar/src'
        );

        $this->loader->addNamespace(
            'Foo\Bar',
            '/vendor/foo.bar/tests'
        );

        $this->loader->addNamespace(
            'Foo\BarDoom',
            '/vendor/foo.bardoom/src'
        );

        $this->loader->addNamespace(
            'Foo\Bar\Baz\Dib',
            '/vendor/foo.bar.baz.dib/src'
        );

        $this->loader->addNamespace(
            'Foo\Bar\Baz\Dib\Zim\Gir',
            '/vendor/foo.bar.baz.dib.zim.gir/src'
        );
    }

    public function testExistingFile()
    {
        $actual = $this->loader->loadClass('Foo\Bar\ClassName');
        $expect = '/vendor/foo.bar/src/ClassName.php';
        $this->assertSame($expect, $actual);

        $actual = $this->loader->loadClass('Foo\Bar\ClassNameTest');
        $expect = '/vendor/foo.bar/tests/ClassNameTest.php';
        $this->assertSame($expect, $actual);
    }

    public function testMissingFile()
    {
        $actual = $this->loader->loadClass('No_Vendor\No_Package\NoClass');
        $this->assertFalse($actual);
    }

    public function testDeepFile()
    {
        $actual = $this->loader->loadClass('Foo\Bar\Baz\Dib\Zim\Gir\ClassName');
        $expect = '/vendor/foo.bar.baz.dib.zim.gir/src/ClassName.php';
        $this->assertSame($expect, $actual);
    }

    public function testConfusion()
    {
        $actual = $this->loader->loadClass('Foo\Bar\DoomClassName');
        $expect = '/vendor/foo.bar/src/DoomClassName.php';
        $this->assertSame($expect, $actual);

        $actual = $this->loader->loadClass('Foo\BarDoom\ClassName');
        $expect = '/vendor/foo.bardoom/src/ClassName.php';
        $this->assertSame($expect, $actual);
    }
}
```

### PSR-4 自动加载规范 - 说明文档 

PSR-4 说明文档

**1. 概述**

PSR-4 是为了给可交互的 PHP 自动加载器指定一个将命名空间映射到文件系统的规则，
并且可以与其他 SPL 注册的自动加载器共存。PSR-4 不是 PSR-0 的替代品，而是对它的补充。

**2. 为什么需要它？**

**PSR-0 的发展史**

在 PHP 5.2 之前，PSR-0 的类命名标准和自动加载标准是以被广泛使用的 Horde/PEAR 约定为准。
这个约定里要求将所有的 PHP 类文件放在一个主目录中，并使用下划线连接的字符串来表示命名空间，如下所示：
```
/path/to/src/
    VendorFoo/
        Bar/
            Baz.php     # VendorFoo_Bar_Baz
    VendorDib/
        Zim/
            Gir.php     # VendorDib_Zim_Gir
```

随着 PHP 5.3 的发布以及新命名空间的广泛使用，现在 PSR-0 已经可以使用 Horde/PEAR 约定的下划线表示法或者新命名空间表示法。 
它让下划线表示法作为新命名空间表示法的一个过渡，从而得到更好的兼容。
```
/path/to/src/
    VendorFoo/
        Bar/
            Baz.php     # VendorFoo_Bar_Baz
    VendorDib/
        Zim/
            Gir.php     # VendorDib_Zim_Gir
    Irk_Operation/
        Impending_Doom/
            V1.php
            V2.php      # Irk_Operation\Impending_Doom\V2
```

这种目录结构很大程度影响了 PEAR 安装器将源文件从 PEAR 包中迁移到一个主目录中。

**因 Composer 而来**

在 Composer 中，包资源不再拷贝到某个单一的全局目录。从它们安装的位置引用它们，不需要移动。
这就意味着使用 Composer 时 PHP 资源不像 PEAR 一样有「单一主目录」。取而代之的是多个目录；每个项目的每个包都在单独目录中。

为了符合 PSR-0 的需要，导致每个 Composer 包都类似下面这样：
```
vendor/
    vendor_name/
        package_name/
            src/
                Vendor_Name/
                    Package_Name/
                        ClassName.php       # Vendor_Name\Package_Name\ClassName
            tests/
                Vendor_Name/
                    Package_Name/
                        ClassNameTest.php   # Vendor_Name\Package_Name\ClassNameTest
```

「src」和「tests」目录必须包含开发商和包目录名。这是遵守 PSR-0 带来的结构。

许多人认为这种结构比需要的更深更重复。这一提议建议一个额外的或替代性的 PSR 将会更有益，所以我们有了类似以下的包结构：
```
vendor/
    vendor_name/
        package_name/
            src/
                ClassName.php       # Vendor_Name\Package_Name\ClassName
            tests/
                ClassNameTest.php   # Vendor_Name\Package_Name\ClassNameTest
```

这就需要将最初称为「基于包的自动加载」实现（对应于传统的「类 - 文件自动加载」）。

**面向 - 包的自动加载**

通过扩展或修订 PSR-0 实现面向 - 包的自动加载非常困难，因为 PSR-0 不允许修改类名路径之间的任何部分。
这意味着实现面向 - 包的自动加载要比 PSR-0 复杂的多，但是从另一方面来讲，它将使扩展包更加简洁。

在一开始的时候，以下规则是建议的:

1. 实现者必须使用两个以上的命名空间层级：一个 vendor 名，和该 vendor 内的包名。
(这两个顶级名称组合被简称为 vendor-package 或 vendor-package namespace。)
2. 实现者必须允许 vendor-package namespace 与完全限定类名的其余部分之间的路径中缀。
3. vendor-package namespace 可以映射到任意目录。完全限定类名的其余部分，
必须映射命名空间名称到同名目录，类名必须映射到 .php 结尾的同名文件。

注意这意味着结束了在类名中下划线作为目录分隔符的做法。有人可能认为下划线应该被遵从因为它们出现在 PSR-0 规范当中，
但是在该文档中它们作为 PHP 5.2 或者更旧的版本的伪命名空间过渡的做法，所以此处删除他们也是可以接受的。

**3. 范围（Scope）**

3.1 目标

* 保留实现者必须使用两个以上的命名空间层级的 PSR-0 规则：一个 vendor 名，和该 vendor 内的 包名。
* 允许 vendor-package namespace 与完全限定类名的其余部分的路径中缀。
* 允许 vendor-package namespace 可以映射到任何目录，也可能是多个目录。
* 结束遵从类名中下划线作为目录分隔符的做法。

3.2 非目标

* 为非类资源提供通用的转换规则

**4. 方案选择**

4.1 被选中的方案

本方案保留了 PSR-0 关键特性，同时消除了更深层次的目录结构。此外，指定了一些附加规则，使得操作起来更明确。

尽管不涉及目录映射，最终草案还是规定了自动加载器应该如何处理错误。具体来说，它禁止抛出异常和错误，主要有这两方面考虑：
1. PHP 中自动加载器设计是可堆叠的，如果一个自动加载器不能加载，则其他的仍有机会继续加载。
若有其中一个自动加载器发生错误此过程将不会进行下去；
2. `class_exists()` 和 `interface_exists()` 允许『在尝试自动加载后仍然找不到类』的存在，
一个用例是：若自动加载器抛出异常将使得 `class_exists()` 不可用，从互操作性的角度来看这是无法接受的。
自动加载器在找不到类的情况下最好通过日志记录提供附加的调试信息，日志可以使用 PSR-3 兼容日志记录或类似的方案。

优点:

    较浅的目录结构；
    文件位置更加固定；
    不再使用类名中下划线作为目录分隔符；
    更明确的互操作性实现

缺点:

    不能像 PSR-0 仅仅通过类名就能确定它在文件系统的具体位置 (这种 “类 - 到 - 文件” 约定继承自 Horde/PEAR)。
    
4.2 替代方案：只使用 PSR-0

保留 PSR-0 虽然很合理，但确实给我们留下了相对较深的目录结构。

优点：

    无需改变任何人的习惯或者实现方式

缺点：

    相对较深的目录结构
    类名中的下划线被识别为目录分隔符

4.3 替代方案：拆分自动加载以及转换

Beau Simensen 跟其他人建议，转换算法可以从自动加载提案中分离出来以便转换规则可以被其他的提案引用。
在完成分离它们的工作之后，会进行民意调查跟一些相关讨论。通过后，合并版本（即带转换规则的自动加载提案）会被显示为首选项。

优点：

    转换规则可以被其他提案引用

缺点：

    不符合某民意调查的受访者跟合作者的意愿（就是要修改老代码，有些人怕麻烦）

4.4 替代方案：使用更多命令式和叙事性语言

在多个 +1 选民听到他们支持这个想法但未同意（或理解）该提案的措辞后，赞助商撤回了第二次投票后，
有一段时间，投票通过的提案得到了扩展。更大的叙事和更有必要的语言。少数参与者谴责这种方法。
一段时间后，Beau Simensen 开始进行实验性修订，着眼于 PSR-0 。编辑和赞助商赞成采用这种更简洁的方法，
并指导现在正在考虑的版本，由 Paul M. Jones 编写并为许多人做出贡献。

**与 PHP 5.3.2 及更低版本的兼容性说明**

5.3.3 之前的 PHP 版本不会删除前导命名空间分隔符，因此需要注意实施过程。无法删除前导命名空间分隔符可能会导致意外行为。

**5. 参与人员**

5.1 编辑

    Paul M. Jones, Solar/Aura

5.2 赞助者

    Phil Sturgeon, PyroCMS (Coordinator)
    Larry Garfield, Drupal

5.3 贡献者

    Andreas Hennings
    Bernhard Schussek
    Beau Simensen
    Donald Gilbert
    Mike van Riel
    Paul Dragoonis
    Too many others to name and count

**6. 投票情况**

入选投票 : https://groups.google.com/d/msg/php-fig/_LYBgfcEoFE/ZwFTvVTIl4AJ

接受投票:
* 第一次尝试: https://groups.google.com/forum/#!topic/php-fig/Ua46E344_Ls, 
presented prior to new workflow; aborted due to accidental proposal modification
* 第二次尝试: https://groups.google.com/forum/#!topic/php-fig/NWfyAeF7Psk, 
cancelled at the discretion of the sponsor https://groups.google.com/forum/#!topic/php-fig/t4mW2TQF7iE
* 第三次尝试：暂时没有信息

**7. 相关链接**

    Autoloader, round 4
    POLL: Autoloader: Split or Combined?
    PSR-X autoloader spec: Loopholes, ambiguities
    Autoloader: Combine Proposals?
    Package-Oriented Autoloader, Round 2
    Autoloader: looking again at namespace
    DISCUSSION: Package-Oriented Autoloader - vote against
    VOTE: Package-Oriented Autoloader
    Proposal: Package-Oriented Autoloader
    Towards a Package Oriented Autoloader
    List of Alternative PSR-4 Proposals
    Summary of [post-Acceptance Vote pull] PSR-4 discussions



### PSR-12 编码规范扩充

**编码风格扩充指南**

文章中的关键词 MUST ， MUST NOT ， REQUIRED ， SHALL ， SHALL NOT ， SHOULD ，
SHOULD NOT ， RECOMMENDED ， MAY ，和 OPTIONAL 都在 RFC 2119 中进行来解释。

**摘要**

此规范起到继承，扩展和替换 [PSR-2][] 的作用， 同时编码风格遵守 [PSR-1][] 这个基础编码标准。

和 [PSR-2][] 一样， 此规范的目的是减少不同人在阅读代码时认知冲突。
它通过列举一套如何格式化 PHP 代码的公共的规则和期望来实现这个目标。 
PSR 力图提供一套方法，编码风格工具可以利用，项目可以遵守，开发人员可以方便的在不同的项目中使用。
当各个的开发人员在进行多项目合作的时候，它可以帮助在这些项目中提供一套通用的指导。
所以，本指南的价值不是规则本身，而是这些规则的共享。

[PSR-2][] 在 2012 年被接受，随后 PHP 经历了很多变化，影响了编码风格。
同时 [PSR-2] 是 PHP 编码时候的基础功能，被广泛的采用。
因此，PSR 力图通过一种更加现代的方式说明 PSR-2 的内容和新功能，并对 PSR-2 进行更正。

**以前的语言版本**

在整个文档中，任何说明都可以被忽略，如果它们不存在于你项目所支持的 PHP 版本中。

**例如**

此示例包含以下一些规则作为快速概述：
```php
<?php

declare(strict_types=1);

namespace Vendor\Package;

use Vendor\Package\{ClassA as A, ClassB, ClassC as C};
use Vendor\Package\SomeNamespace\ClassD as D;

use function Vendor\Package\{functionA, functionB, functionC};

use const Vendor\Package\{ConstantA, ConstantB, ConstantC};

class Foo extends Bar implements FooInterface
{
    public function sampleFunction(int $a, int $b = null): array
    {
        if ($a === $b) {
            bar();
        } elseif ($a > $b) {
            $foo->bar($arg1);
        } else {
            BazClass::bar($arg2, $arg3);
        }
    }

    final public static function bar()
    {
        // 方法内容
    }
}
```

**2. 总则**

**2.1 基本编码标准**

代码必须遵循 [PSR-1] 中列出的所有规则。

PSR-1 中的术语 ‘StudlyCaps’ 必须解释为 PascalCase （帕斯卡命名法：大驼峰式命名法），
其中每个单词的第一个字母大写，包括第一个字母。

**2.2 文件**

所有 PHP 文件只能使用 Unix LF (换行符) 结尾。

所有的 PHP 文件都必须以非空行结尾，以一个 LF 结尾。

在仅包含 PHP 代码的文件中，必须省略结尾的 `?>` 标记。

**2.3 代码行**

行长度不得有硬限制。

行长度的软限制必须为 120 个字符。

行的长度不应超过 80 个字符；超过该长度的行应拆分为多个后续行，每个行的长度不应超过 80 个字符。

行尾不能有尾随空格。

可以添加空行以提高可读性并指示相关的代码块，除非明确禁止。

每行不能有多个语句。

**2.4 缩进**

代码必须为每个缩进级别使用 4 个空格的缩进，并且不能使用缩进标签。

**2.5 关键词和类型**

PHP 的所有关键字和类型 都必须使用小写。

PHP 未来版本中新加的所有关键字和类型也都必须使用小写。

类型关键字必须使用缩写。使用 `bool` 而不是 `boolean`，使用 `int` 而不是 `integer` 等等。

**3. 声明、命名空间以及导入**

一个 PHP 文件的头部可能会包含多个块。如果包含多个块，则每个块都必须用空白行和其他块分隔，并且块内不能包含空白行。
所有的块都必须按照下面的顺序排列，如果不存在该块则忽略。

* PHP 文件开始标签： <?php。
* 文件级文档块。
* 一个或多个声明语句。
* 命名空间声明语句。
* 一个或多个基于类的 use 声明语句。
* 一个或多个基于方法的 use 声明语句。
* 一个或多个基于常量的 use 声明语句。
* 其余代码。

当文件包含 HTML 和 PHP 的混合代码时，可以使用上面列出的任何部分。如果是这种情况的话，
即时代码的其他部分包含有 PHP 结束符，然后再包含 HTML 和 PHP 代码，声明、命名空间和导入语句块也必须放在文件的顶部。

什么时候开始 `<？php` 标签位于文件的第一行，它必须位于自己的行，没有其他语句，
除非它是一个包含 PHP 之外的标记的文件打开和关闭标记。

import 语句不能以前导反斜杠开头，因为它们必须始终完全合格。

以下示例演示了所有块的完整列表：
```php
<?php

/**
 * This file contains an example of coding styles.
 */

declare(strict_types=1);

namespace Vendor\Package;

use Vendor\Package\{ClassA as A, ClassB, ClassC as C};
use Vendor\Package\SomeNamespace\ClassD as D;
use Vendor\Package\AnotherNamespace\ClassE as E;

use function Vendor\Package\{functionA, functionB, functionC};
use function Another\Vendor\functionD;

use const Vendor\Package\{CONSTANT_A, CONSTANT_B, CONSTANT_C};
use const Another\Vendor\CONSTANT_D;

/**
 * FooBar is an example class.
 */
class FooBar
{
    // ... 其他php代码 ...
}
```

深度不能超过两层的复合名称空间，因此以下展示了允许的最大复合深度。
```php
<?php

use Vendor\Package\SomeNamespace\{
    SubnamespaceOne\ClassA,
    SubnamespaceOne\ClassB,
    SubnamespaceTwo\ClassY,
    ClassZ,
};
```

并且不允许以下内容:
```php
<?php

use Vendor\Package\SomeNamespace\{
    SubnamespaceOne\AnotherNamespace\ClassA,
    SubnamespaceOne\ClassB,
    ClassZ,
};
```

当希望在 PHP 外部包含标记的文件中声明严格类型时打开和关闭标签，
声明必须写在文件的第一行并且包含在一个开始的 PHP 标签，以及严格的类型声明和结束标签。

例如:
```php
<?php declare(strict_types=1) ?>
<html>
<body>
    <?php
        // ... 其他 PHP 代码  ...
    ?>
</body>
</html>
```

声明语句不能包含空格，并且必须完全是 `declare(strict_types=1)` (带有可选的分号终止符)。

允许使用块声明语句，并且必须按照以下的格式设置。注意的位置括号和间距：
```
declare(ticks=1) {
    // 一些代码
}
```

**4. 类，属性，和方法**

这里的『类』指的是所有类，接口，以及 trait 。

任何注释和语句 不得 跟在其右花括号后的同一行。

当实例化一个类时，后面的圆括号 必须 写出来，即使没有参数传进其构造函数。

```
new Foo();
```

**4.1 继承和实现**

关键字 继承 和 实现 必须 在类名的同一行声明。

类的左花括号 必须 另起一行；右花括号 必须 跟在类主体的下一行。

类的左花括号 必须 独自成行，且 不得 在其上一行或下一行存在空行。

右花括号 必须 独自成行，且 不得 在其上一行存在空行。

```php
<?php

namespace Vendor\Package;

use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;

class ClassName extends ParentClass implements \ArrayAccess, \Countable
{
    // 常量，属性，方法
}
```

如果有接口， 实现 接口和 继承父类 可以 分为多行，前者每行需缩进一次。
当这么做时，第一个接口 必须 写在下一行，且每行 必须 只能写一个接口。

```php
<?php

namespace Vendor\Package;

use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;

class ClassName extends ParentClass implements
    \ArrayAccess,
    \Countable,
    \Serializable
{
    // 常量，属性，方法
}
```

**4.2 使用 trait**

在类里面用于实现 trait 的关键字 use 必须 在左花括号的下一行声明。

```php
<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;

class ClassName
{
    use FirstTrait;
}
```

每个导入类的 trait 必须 每行一个包含声明，且每个包含声明 必须 有其 use 导入语句。

```php
<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;
use Vendor\Package\SecondTrait;
use Vendor\Package\ThirdTrait;

class ClassName
{
    use FirstTrait;
    use SecondTrait;
    use ThirdTrait;
}
```

在类文件中，如果在使用 'use Trait' 之后没有其他内容了 ，类名右大括号必须另起一行。

```php
<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;

class ClassName
{
    use FirstTrait;
}
```

如有其他内容，两者之间需空一行。

```php
<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;

class ClassName
{
    use FirstTrait;

    private $property;
}
```

当使用 `insteadof` 和 `as` 运算符时，它们必须如图所示使用，注意缩进、间距和另起一行。

```php
<?php

class Talker
{
    use A, B, C {
        B::smallTalk insteadof A;
        A::bigTalk insteadof C;
        C::mediumTalk as FooBar;
    }
}
```

**4.3 属性和常量**

所有属性 必须 声明可见性。

如果你的项目 PHP 最小版本支持常量可见性（ PHP 7.1 或以上），所有常量 必须 声明可见性。

关键字 var 不得 用于声明属性。

每条声明语句 不得 声明多于一个属性。

属性名 不得 用单个下划线开头表明其受保护的或私有的可见性。也就是说，一个下划线开头显然是没有意义的。

类型声明和属性名之间 必须 有一个空格。

一个属性声明看上去如下所示：
```php
<?php

namespace Vendor\Package;

class ClassName
{
    public $foo = null;
    public static int $bar = 0;
}
```

**4.4 方法和函数**

所有的方法 必须 事先声明类型。

方法命名 一定不可 用单个下划线来区分是 protected 或 private 类型。也就是说，不要用一个没有意义的下划线开头。

方法和函数名称中，方法命名后面 一定不可 使用空格。方法开始的花括号 必须 写在方法声明后自成一行， 
结束花括号也 必须 写在方法后面自成一行。开始左括号后和结束右括号前，都 一定不可 有空格符。

一个方法的声明应该如下所示。注意括号，逗号，空格和花括号的位置：
```php
<?php

namespace Vendor\Package;

class ClassName
{
    public function fooBarBaz($arg1, &$arg2, $arg3 = [])
    {
        // 方法主体
    }
}
```

一个函数的声明应该如下所示。注意括号，逗号，空格和花括号的位置：
```php
<?php

function fooBarBaz($arg1, &$arg2, $arg3 = [])
{
    // 函数主体
}
```

**4.5 方法和函数参数**

在参数列表中， 不得 在每个逗号前存在空格，且 必须 在每个逗号后有一个空格。

方法和函数中带有默认值的参数 必须 放在参数列表的最后。

```php
<?php

namespace Vendor\Package;

class ClassName
{
    public function foo(int $arg1, &$arg2, $arg3 = [])
    {
        // 方法主体
    }
}
```

参数列表 可以 分为多行，每行参数缩进一次。当这么做时，第一个参数 必须 放在下一行，且每行 必须 只能有一个参数。

当参数列表分成多行时，右圆括号和左花括号 必须 放在同一行且单独成行，两者之间存在一个空格。

```php
<?php

namespace Vendor\Package;

class ClassName
{
    public function aVeryLongMethodName(
        ClassTypeHint $arg1,
        &$arg2,
        array $arg3 = []
    ) {
        // 方法主体
    }
}
```

当你定义一个返回值类型声明时，冒号后面的类型声明 必须 用空格符隔开。
冒号和声明 必须 在同一行，且跟参数列表后的结束括号之间没有空格。

```php
<?php

declare(strict_types=1);

namespace Vendor\Package;

class ReturnTypeVariations
{
    public function functionName(int $arg1, $arg2): string
    {
        return 'foo';
    }

    public function anotherFunction(
        string $foo,
        string $bar,
        int $baz
    ): string {
        return 'foo';
    }
}
```

在可空类型声明中，问号和类型声明之间不能有空格。

```php
<?php

declare(strict_types=1);

namespace Vendor\Package;

class ReturnTypeVariations
{
    public function functionName(?string $arg1, ?int &$arg2): ?string
    {
        return 'foo';
    }
}
```

当在参数之前使用引用运算符 `&` 时，引用运算符之后不能有空格，例如上面的示例。

可变参数声明的三个点和参数名称之间不能有空格：
```
public function process(string $algorithm, ...$parts)
{
    // 函数体
}
```

当同时使用引用运算符和可变参数运算符时，它们之间不能有任何空格：
```
public function process(string $algorithm, &...$parts)
{
    // 函数体
}
```

**4.6 abstract, final, and static**

如果是 `abstract` and `final` ，那么申明的时候必须是可见性声明。

如果是 `static` ，声明必须位于可见性声明之后。

```php
<?php

namespace Vendor\Package;

abstract class ClassName
{
    protected static $foo;

    abstract protected function zim();

    final public static function bar()
    {
        // 请求体
    }
}
```

**4.7 方法和函数的调用**

当我们在进行方法或者函数调用的时候，方法名或函数名与左括号之间不能出现空格，在右括号之后也不能出现空格，
并且在右括号之前也不能有空格。在参数列表中，每个逗号前面不能有空格，每个逗号后面必须有一个空格。

```php
<?php

bar();
$foo->bar($arg1);
Foo::bar($arg2, $arg3);
```

参数列表可以分为多行，每行后面缩进一次。这样做时，列表中的第一项必须位于下一行，并且每一行必须只有一个参数。
跨多个行拆分单个参数 (就像匿名函数或者数组那样) 并不构成拆分参数列表本身。

```php
<?php

$foo->bar(
    $longArgument,
    $longerArgument,
    $muchLongerArgument
);
```

```php
<?php

somefunction($foo, $bar, [
  // ...
], $baz);

$app->get('/hello/{name}', function ($name) use ($app) {
    return 'Hello ' . $app->escape($name);
});
```

**5. 流程控制**

如下是主要的流程控制风格规则：

    流程控制关键词之后 必须 要有一个空格
    左括号后面 不能 有空格
    右括号前面 不能 有空格
    右括号与左大括号之间 必须 要有一个空格
    流程主体 必须 要缩进一次
    流程主体 必须 在左大括号之后另起一行
    右大括号 必须 在流程主体之后另起一行

每个流程控制主体 必须 以封闭的括号结束。这将标准化流程结构，同时减少由于流程中添加新的内容而引入错误的可能性。

**5.1 if, elseif, else**

`if` 结构如下。注意括号，空格，和大括号的位置；`else` 和 `elseif` 都在同一行，和右大括号一样在主体的前面。

```php
<?php

if ($expr1) {
    // if body
} elseif ($expr2) {
    // elseif body
} else {
    // else body;
}
```

应该 使用关键词 `elseif` 替换 `else if`，这样所有的控制关键词看起来都像单个词。

括号中的表达式 可能 会被分开为多行，每一行至少缩进一次。如果这样做，第一个条件 必须 在新的一行。
右括号和左大括号 必须 在同一行，而且中间有一个空格。条件中间的布尔控制符 必须 在每一行的开头或者结尾，而不是混在一起。

```php
<?php

if (
    $expr1
    && $expr2
) {
    // if body
} elseif (
    $expr3
    && $expr4
) {
    // elseif body
}
```

**5.2 switch, case**

`switch` 结构如下。注意括号，空格和大括号的位置。
`case` 必须 缩进一次，从 `switch` 开始， `break` 关键词 (或者其他终止关键词) 必须 缩进和 `case` 主体保持一致。
必须 要有一个像 `// no break` 这样的注释在不为空且不需要中断的 `case` 主体之中。

```php
<?php

switch ($expr) {
    case 0:
        echo 'First case, with a break';
        break;
    case 1:
        echo 'Second case, which falls through';
        // no break
    case 2:
    case 3:
    case 4:
        echo 'Third case, return instead of break';
        return;
    default:
        echo 'Default case';
        break;
}
```

括号中的表达式 可能 会被分开多行，每一行至少要缩进一次。如果这样做，第一个条件 必须 在新的一行。
右括号和左大括号 必须 在同一行，而且中间有一个空格。条件中间的布尔控制符 必须 在一行的开头或者结尾，而不是混在一起。

```php
<?php

switch (
    $expr1
    && $expr2
) {
    // structure body
}
```

5.3 while, do while

`while` 结构如下。注意括号，空格和大括号的位置。

```php
<?php

while ($expr) {
    // structure body
}
```

括号中的表达式 可能 会被分开多行，每一行至少要缩进一次。如果这样做，第一个条件 必须 在新的一行。
右括号和左大括号 必须 在同一行，而且中间有一个空格。条件中间的布尔控制符 必须 在每一行的开头或者结尾，而不是混在一起。

```php
<?php

while (
    $expr1
    && $expr2
) {
    // structure body
}
```

同样的， `do while` 申明如下。注意括号，空格和大括号的位置。

```php
<?php

do {
    // structure body;
} while ($expr);
```

括号中的表达式 可能 会被分开多行，每一行至少要缩进一次。如果这样做，第一个条件 必须 在新的一行。
条件中间的布尔控制符 必须 在每一行的开头或者结尾，而不是混在一起。

```php
<?php

do {
    // structure body;
} while (
    $expr1
    && $expr2
);
```

**5.4 for**

`for` 申明如下。注意括号，空格和大括号的位置。

```php
<?php

for ($i = 0; $i < 10; $i++) {
    // for body
}
```

括号中的表达式 可能 会被分开多行，每一行至少要缩进一次。如果这样做，第一个条件 必须 在新的一行。
右括号和左大括号 必须 在同一行，而且中间有一个空格。

```php
<?php

for (
    $i = 0;
    $i < 10;
    $i++
) {
    // for body
}
```

**5.5 foreach**

`foreach` 语句的写法如下所示。请注意它的圆括号、空格和花括号。

```php
<?php

foreach ($iterable as $key => $value) {
    // 迭代主体
}
```

**5.6 try ， catch ， finally**

一个 try-catch-finally 模块包含下面这些内容。请注意它的圆括号、空格和花括号。

```php
<?php

try {
    // try 主体
} catch (FirstThrowableType $e) {
    // 捕获异常主体
} catch (OtherThrowableType | AnotherThrowableType $e) {
    // 捕获异常主体
} finally {
    // finally 主体
}
```

**6. 运算符**

运算符的样式规则按元数分组（其接受的操作数个数）。

当运算符周围允许出现空格时， 可以 出于可读性目的打多个空格。

所有这里没描述的运算符暂不作限定。

**6.1. 一元运算符**

递增 / 递减运算符和操作数之间 不得 有任何空格。

```
$i++;
++$j;
```

类型转换运算符的圆括号内部 不得 有任何空格：
```
$intValue = (int) $input;
```

**6.2. 二元运算符**

所有二进制 算术，比较，赋值，按位，逻辑、字符串和类型运算符必须在前后跟至少一个空格：
```
if ($a === $b) {
    $foo = $bar ?? $a ?? $b;
} elseif ($a > $b) {
    $foo = $a + $b * $c;
}
```

**6.3. 三元运算符**

条件运算符，也称为三元运算符，必须在 `?` 和 `:` 这两个字符之间：
```
$variable = $foo ? 'foo' : 'bar';
```

如果省略条件运算符的中间操作数，运算符必须遵循与其他二进制比较运算符相同的样式规则：
```
$variable = $foo ?: 'bar';
```

**7. 闭包（Closures）**

闭包声明时必须在 `function` 关键字后留有 1 个空格，并且在 `use` 关键字前后各留有 1 个空格。

左花括号必须跟随前文写在同一行，右花括号必须在函数体后换行放置。

不能在参数和变量的左括号后和右括号前放置空格。

不能在参数和变量的逗号前放置空格，但必须在逗号后放置 1 个空格。

闭包参数如果有默认值，该参数必须放在参数列表末尾。

如果声明了返回类型，它必须遵循普通函数和方法相同的规则；如果使用 `use` 关键字，冒号必须在 `use` 右括号后，且冒号前不能有空格。

闭包的声明方式如下，留意括号，逗号，空格和花括号：
```php
<?php

$closureWithArgs = function ($arg1, $arg2) {
    // 函数体
};

$closureWithArgsAndVars = function ($arg1, $arg2) use ($var1, $var2) {
    // 函数体
};

$closureWithArgsVarsAndReturn = function ($arg1, $arg2) use ($var1, $var2): bool {
    // 函数体
};
```

参数和变量可以分多行放置，每个后续行缩进一次。执行此操作时，列表中的第一项必须放在下一行，并且每行只能有一个参数或变量。

结束多行列表（或者参数，变量）的时候，右括号和左大括号 必须 要放在一行，而且中间有一个空格。

下面是有和没有多行参数列表与变量列表的闭包示例。
```php
<?php

$longArgs_noVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) {
   // body
};

$noArgs_longVars = function () use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // body
};

$longArgs_longVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // body
};

$longArgs_shortVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) use ($var1) {
   // body
};

$shortArgs_longVars = function ($arg) use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // body
};
```

注意格式化规则也适用一个闭包在一个方法或者操作中作为参数被直接引用。

```php
<?php

$foo->bar(
    $arg1,
    function ($arg2) use ($var1) {
        // body
    },
    $arg3
);
```

**8. 匿名类**

匿名类 必须 遵循上面章节中和闭包一样的方针和准则。

```php
<?php

$instance = new class {};
```

只要 `implements` 接口列表不换行，左花括号 可以 和关键字 `class` 在同一行。
如果接口列表换行，花括号 必须 放在最后一个接口的下一行。

```php
<?php

// 花括号在同一行
$instance = new class extends \Foo implements \HandleableInterface {
    // 类内容
};

// 花括号在下一行
$instance = new class extends \Foo implements
    \ArrayAccess,
    \Countable,
    \Serializable
{
    // 类内容
};
```



## 参考资料

PHP PSR 标准规范 <https://learnku.com/docs/psr>

PSR-0: Autoloading Standard <https://www.php-fig.org/psr/psr-0/>

PSR-1 基础编码规范 <https://laravel-china.org/topics/2078>

PEAR 编码准则 <https://pear.php.net/manual/en/standards.php>

Symfony 编码准则 <https://symfony.com/doc/current/contributing/code/standards.html>

PHP中PSR-[0-4]规范：<http://m.blog.csdn.net/article/details?id=42844391>

PHP中PSR-[0-4]规范：<https://www.zybuluo.com/phper/note/65033>

php trait 冲突的解决 insteadof <https://blog.csdn.net/zmzwll1314/article/details/91417628>

