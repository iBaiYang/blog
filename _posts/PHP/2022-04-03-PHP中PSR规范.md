---
layout: post
categories: PHP
title: PHP中PSR规范
meta: PHP中PSR规范
---
* content
{:toc}

## 正文

PSR 是由 PHP FIG 组织制定的 PHP 规范，是 PHP 开发的实践标准。 

**PHP FIG**

PSR 是 PHP Standard Recommendations （PHP 推荐标准）的简写，由 PHP FIG 组织制定的 PHP 规范，是 PHP 开发的实践标准。

PHP FIG，FIG 是 Framework Interoperability Group（框架可互用性小组）的缩写，由几位开源框架的开发者成立于 2009 年，
从那开始也选取了很多其他成员进来（包括但不限于 Laravel, Joomla, Drupal, Composer, Phalcon, Slim, Symfony, Zend Framework 等），
虽然不是「官方」组织，但也代表了大部分的 PHP 社区。

项目的目的在于：通过框架作者或者框架的代表之间讨论，以最低程度的限制，制定一个协作标准，各个框架遵循统一的编码规范，
避免各家自行发展的风格阻碍了 PHP 的发展，解决这个程序设计师由来已久的困扰。

目前已表决通过了不少套标准，已经得到大部分 PHP 框架的支持和认可。

本项目的主要面向对象是所有参与的各个成员（也就是各自框架的社区），这里是完整的 成员列表，当然，同时也欢迎其它 PHP 社区采用本规范。

**状态说明**

在本文档的文章列表中，文章标题会有规范状态的标示。所有的规范分为以下几个状态：

    已通过（ACCEPTED）—— 文章标题将不会有所显示
    起草中（DRAFT）—— 暂不翻译
    未通过（ABANDONED）—— 简单说明，暂不翻译
    已弃用（DEPRECATED）—— 会有说明，暂不翻译

**规范目录**

    PSR-0 自动加载规范（已弃用）
    PSR-1 基础编码规范 已完成
    PSR-2 编码风格规范（已弃用） 已完成
    PSR-3 日志接口规范 已完成
    PSR-4 自动加载规范 已完成
    PSR-4 自动加载规范 - 示例文档 已完成
    PSR-4 自动加载规范 - 说明文档 已完成
    PSR-5 PHPDoc 标准（未通过）
    PSR-6 缓存接口规范 已完成
    PSR-6 缓存接口规范 - 说明文档 已完成
    PSR-7 HTTP 消息接口规范 已完成
    PSR-8 Huggable 接口（未通过）
    PSR-9 项目安全问题公示（未通过）
    PSR-10 项目安全上报方法（未通过）
    PSR-11 容器接口 已完成
    PSR-11 容器接口 - 说明文档 已完成
    PSR-12 编码规范扩充
    PSR-13 超媒体链接 已完成
    PSR-13 超媒体链接 - 说明文档 已完成
    PSR-14 事件分发器
    PSR-15 HTTP 请求处理器 已完成
    PSR-16 缓存接口 已完成
    PSR-16 缓存接口 - 说明文档 已完成
    PSR-17 HTTP 工厂 已完成
    PSR-18 HTTP 客户端 已完成 

### PSR-1 基础编码规范 

**基本代码规范**

本篇规范制定了代码基本元素的相关标准，以确保共享的 PHP 代码间具有较高程度的技术互通性。

本文件中的 必须，不得，需要，应，不应，应该，不应该，推荐，可能 和 可选 等能愿动词按照 RFC 2119 中的描述进行解释。

**1、 概览**

* PHP 代码文件 必须 以 `<?php` 或 `<?=` 标签开始；

* PHP 代码文件 必须 以 `不带 BOM 的 UTF-8` 编码；

* PHP 代码中 应该 声明任一标志（类、函数、常量等），或引起`副作用`（如果一个函数修改了自己范围之外的资源，
那就叫做有副作用，如：生成输出以及修改 .ini 配置文件等），但是不应该二者都有；

* 命名空间以及类 必须 符合 PSR 的自动加载规范： [PSR-0（已废弃）或 PSR-4] 中的一个。

* 类的命名 必须 遵循 `StudlyCaps` 大写开头的驼峰命名规范；

* 类中的常量所有字母都 必须 大写，单词间用下划线分隔；

* 方法名称 必须 符合 `camelCase` 式的小写开头驼峰命名规范。

**2、 文件**

2.1. PHP 标签

PHP 代码 必须 使用 `<?php ?>` 长标签 或 `<?= ?>` 短输出标签；

一定不可 使用其它自定义标签。

2.2. 字符集编码

PHP 代码 必须 且只可使用 `不带 BOM 的 UTF-8` 编码。

2.3. 副作用

一份 PHP 文件中 应该 要不就只定义新的声明，如类、函数或常量等不产生 副作用 的操作，
要不就只执行会产生 副作用 的逻辑操作，但 不该 同时具有两者。

「副作用」(side effects) 一词的意思是，仅仅通过包含文件，不直接声明类、函数和常量等，而执行的逻辑操作。

「副作用」包含却不仅限于：生成输出，明确使用 require 或 include，连接到外部服务，
修改 ini 设置，发出错误或异常，修改全局或静态变量，读取或写入一个文件，等等。

以下是一个 反例，一份包含「函数声明」以及产生「副作用」的代码：
```php
<?php
// 「副作用」：修改 ini 配置
ini_set('error_reporting', E_ALL);

// 「副作用」：引入文件
include "file.php";

// 「副作用」：生成输出
echo "<html>\n";

// 声明函数
function foo()
{
    // function body
}
```

下面是一个范例，一份只包含声明不产生「副作用」的代码：
```php
<?php
// 声明函数
function foo()
{
    // 函数主体部分
}

// 条件声明 **不** 属于「副作用」
if (! function_exists('bar')) {
    function bar()
    {
        // 函数主体部分
    }
}
```

**3、 命名空间和类名**

命名空间和类名 必须 遵循『自动加载』规范： [PSR-0， PSR-4]。

这意味着每个类都独立为一个文件，并且至少在一个层次的命名空间内，那就是：顶级组织名（vendor name）。

类名 必须 以类似 StudlyCaps 形式的大写开头的驼峰命名方式声明。

PHP 5.3 及更高版本的代码 必须 使用正式的命名空间。

举个例子：
```php
<?php
// PHP 5.3 及更高版本：
namespace Vendor\Model;

class Foo
{
}
```

PHP 5.2 及更低版本 应该 使用伪命名空间，约定俗成，以顶级组织名称 Vendor_ 为类名前缀：
```php
<?php
// PHP 5.2.x 及更低版本：
class Vendor_Model_Foo
{
}
```

**4、 类的常量、属性和方法**

此处的「类」指代所有的类、接口以及可复用代码块（traits）。

4.1. 常量

类的常量中所有字母都 必须 大写，词间以下划线分隔。例如：
```php
<?php
namespace Vendor\Model;

class Foo
{
    const VERSION = '1.0';
    const DATE_APPROVED = '2012-06-01';
}
```

4.2. 属性

类的属性命名 可以 遵循：

    大写开头的驼峰式 ($StudlyCaps)
    小写开头的驼峰式 ($camelCase)
    下划线分隔式 ($under_score)

本规范不做强制要求，但无论遵循哪种命名方式，都 应该 在一定的范围内保持一致。这个范围可以是整个团队、整个包、整个类或整个方法。

4.3. 方法

方法名称 必须 符合 camelCase() 式的小写开头驼峰命名规范。

### PSR-3 日志接口规范

**日志接口**

本文制定了日志类库的通用接口规范。

本规范的主要目的，是为了让日志类库以简单通用的方式，通过接收一个 `Psr\Log\LoggerInterface` 对象，来记录日志信息。 
框架以及 CMS 内容管理系统如有需要，可以 对此接口进行扩展，但需遵循本规范，
这才能保证在使用第三方的类库文件时，日志接口仍能正常对接。

为了避免歧义，文档大量使用了「能愿动词」，对应的解释如下：

    必须 (MUST)：绝对，严格遵循，请照做，无条件遵守；
    一定不可 (MUST NOT)：禁令，严令禁止；
    应该 (SHOULD) ：强烈建议这样做，但是不强求；
    不该 (SHOULD NOT)：强烈不建议这样做，但是不强求；
    可以 (MAY) 和 可选 (OPTIONAL) ：选择性高一点，在这个文档内，此词语使用较少；
    参见  RFC 2119 .

本文档中的 implementor 一词应理解为在日志的库中实现  `LoggerInterface`  的人。记录器的调用者称为 user

**1. 规范**

1.1 基本规范

* `LoggerInterface` 接口对外定义了八个方法，分别用来记录 RFC 5424 中定义的八个等级的日志：
debug、 info、 notice、 warning、 error、 critical、 alert 以及 emergency 。

* 第九个方法 —— `log`，其第一个参数为记录的等级。可使用一个预先定义的等级常量作为参数来调用此方法，
必须 与直接调用以上八个方法具有相同的效果。如果传入的等级常量参数没有预先定义，
则 必须 抛出 `Psr\Log\InvalidArgumentException` 类型的异常。
在不确定的情况下，使用者 不该 使用未支持的等级常量来调用此方法。

1.2 消息

* 以上每个方法都接受一个字符串类型或者是有 `__toString()` 方法的对象作为记录信息参数，
这样，实现者就能把它当成字符串来处理，否则实现者 必须 自己把它转换成字符串。

* 记录信息参数 可以 携带占位符，实现者 可以 根据上下文将其它替换成相应的值。

其中占位符 必须 与上下文数组中的键名保持一致。

占位符的名称 必须 由一个左花括号 `{` 以及一个右括号 `}` 包含。但花括号与名称之间 一定不可有空格符。

占位符的名称 应该 只由 A-Z、a-z、0-9、下划线 `_`、以及英文的句号 `.` 组成，其它字符作为将来占位符规范的保留。

实现者 可以 通过对占位符采用不同的转义和转换策略，来生成最终的日志。
而使用者在不知道上下文的前提下，不该 提前转义占位符。

以下是一个占位符使用的例子：
```php
<?php

/**
 * 用上下文信息替换记录信息中的占位符
 */
function interpolate($message, array $context = array())
{
    // 构建一个花括号包含的键名的替换数组
    $replace = array();
    foreach ($context as $key => $val) {
        // 检查该值是否可以转换为字符串
        if (!is_array($val) && (!is_object($val) || method_exists($val, '__toString'))) {
            $replace['{' . $key . '}'] = $val;
        }
    }

    // 替换记录信息中的占位符，最后返回修改后的记录信息。
    return strtr($message, $replace);
}

// 含有带花括号占位符的记录信息。
$message = "User {username} created";

// 带有替换信息的上下文数组，键名为占位符名称，键值为替换值。
$context = array('username' => 'bolivar');

// 输出 "User bolivar created"
echo interpolate($message, $context);
```

1.3 上下文

* 每个记录函数都接受一个上下文数组参数，用来装载字符串类型无法表示的信息。
它 可以 装载任何信息，所以实现者 必须 确保能正确处理其装载的信息，对于其装载的数据， 
一定不可 抛出异常，或产生 PHP 出错、警告或提醒信息（error、warning、notice）。

* 如需通过上下文参数传入了一个 `Exception` 对象，必须 以 `exception` 作为键名。
记录异常信息是很普遍的，所以如果它能够在记录类库的底层实现，就能够让实现者从异常信息中抽丝剥茧。
当然，实现者在使用它时，必须 确保键名为 `exception` 的键值是否真的是一个 `Exception`，毕竟它 可以 装载任何信息。

1.4 助手类和接口

* `Psr\Log\AbstractLogger` 类使得只需继承它和实现其中的 `log` 方法，就能够很轻易地实现 `LoggerInterface` 接口，
而另外八个方法就能够把记录信息和上下文信息传给它。

* 同样地，使用 `Psr\Log\LoggerTrait` 也只需实现其中的 `log` 方法。不过，需要特别注意的是，
在 traits 可复用代码块还不能实现接口前，还需要 `implement LoggerInterface`。

* 在没有可用的日志记录器时，`Psr\Log\NullLogger` 接口 可以 为使用者提供一个备用的日志「黑洞」。
不过，当上下文的构建非常消耗资源时，带条件检查的日志记录或许是更好的办法。

* `Psr\Log\LoggerAwareInterface` 接口仅包括一个 `setLogger(LoggerInterface $logger)` 方法，框架可以使用它实现自动连接任意的日志记录实例。

* `Psr\Log\LoggerAwareTrait` trait 可复用代码块可以在任何的类里面使用，只需通过它提供的 `$this->logger`，就可以轻松地实现等同的接口。

* `Psr\Log\LogLevel` 类装载了八个记录等级常量。

**2. 包**

接口和类的描述、相关的异常类以及用于验证你所写代码的测试套件都将作为 psr/log 包的一部分提供。

**3. `Psr\Log\LoggerInterface`**

```php
<?php

namespace Psr\Log;

/**
 * 描述一个日志记录器实例
 *
 * 该消息必须实现一个__toString()的字符串或者对象.
 *
 * 该消息可能包含以下形式的占位符: {foo}  
 * foo 将会被关键词 "foo"中的上下文数据替换.
 *
 * 上下文数组可以包含任意数据, 我们只能假设代码实现者如果给出一个生成堆栈跟踪的异常实例, 
 * 那么它的键名必须为 "exception"。
 *
 * 请前往 https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md
 * 查看完整的接口规范.
 */
interface LoggerInterface
{
    /**
     * 系统无法使用。
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function emergency($message, array $context = array());

    /**
     * 必须立即采取行动。
     *
     * 例如: 整个网站宕机了，数据库挂了，等等。 这应该发送短信通知警告你.
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function alert($message, array $context = array());

    /**
     * 临界条件。
     *
     * 例如: 应用组件不可用，意外的异常。
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function critical($message, array $context = array());

    /**
     * 运行时错误不需要马上处理，但通常应该被记录和监控。
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function error($message, array $context = array());

    /**
     * 例外事件不是错误。
     *
     * 例如: 使用过时的API，API使用不当，不合理的东西不一定是错误。
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function warning($message, array $context = array());

    /**
     * 正常但重要的事件.
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function notice($message, array $context = array());

    /**
     * 有趣的事件.
     *
     * 例如: 用户登录，SQL日志。
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function info($message, array $context = array());

    /**
     * 详细的调试信息。
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function debug($message, array $context = array());

    /**
     * 可任意级别记录日志。
     *
     * @param mixed $level
     * @param string $message
     * @param array $context
     * @return void
     */
    public function log($level, $message, array $context = array());
}
```

**4. `Psr\Log\LoggerAwareInterface`**

```php
<?php

namespace Psr\Log;

/**
 * logger-aware 定义实例
 */
interface LoggerAwareInterface
{
    /**
     * 设置一个日志记录实例
     *
     * @param LoggerInterface $logger
     * @return void
     */
    public function setLogger(LoggerInterface $logger);
}
```

**5. `Psr\Log\LogLevel`**

```php
<?php

namespace Psr\Log;

/**
 * 日志等级常量定义
 */
class LogLevel
{
    const EMERGENCY = 'emergency';
    const ALERT     = 'alert';
    const CRITICAL  = 'critical';
    const ERROR     = 'error';
    const WARNING   = 'warning';
    const NOTICE    = 'notice';
    const INFO      = 'info';
    const DEBUG     = 'debug';
}
```

### PSR-4 自动加载规范 

**自动加载**

为了避免歧义，文档大量使用了「能愿动词」，对应的解释如下：

    必须 (MUST)：绝对，严格遵循，请照做，无条件遵守；
    一定不可 (MUST NOT)：禁令，严令禁止；
    应该 (SHOULD) ：强烈建议这样做，但是不强求；
    不该 (SHOULD NOT)：强烈不建议这样做，但是不强求；
    可以 (MAY) 和 可选 (OPTIONAL) ：选择性高一点，在这个文档内，此词语使用较少；

参见：RFC 2119

**1. 总览**

PSR-4 描述了从文件路径中 自动加载 类的规范。 它拥有非常好的兼容性，并且可以在任何自动加载规范中使用，
包括 PSR-0。 PSR-4 规范也描述了放置 autoload 文件（就是我们经常引入的 `vendor/autoload.php`）的位置。

**2. 规范**

1、术语「class」指的是类（classes）、接口（interfaces）、特征（traits）和其他类似的结构。

2、全限定类名具有以下形式：

`\<NamespaceName>(\<SubNamespaceNames>)*\<ClassName>`

* 全限定类名必须拥有一个顶级命名空间名称，也称为供应商命名空间（vendor namespace）。
* 全限定类名可以有一个或者多个子命名空间名称。
* 全限定类名必须有一个最终的类名（我想意思应该是你不能这样 `\<NamespaceName>(\<SubNamespaceNames>)*\` 来表示一个完整的类）。
* 下划线在全限定类名中没有任何特殊含义（在 PSR-0 中下划是有含义的）。
* 全限定类名可以是任意大小写字母的组合。
* 所有类名的引用必须区分大小写。

3、全限定类名的加载过程

* 在全限定的类名（一个「命名空间前缀」）中，一个或多个前导命名空间和子命名空间组成的连续命名空间，
不包括前导命名空间的分隔符，至少对应一个「根目录」。
* 「命名空间前缀」后面的相邻子命名空间与根目录下的目录名称相对应（且必须区分大小写），
其中命名空间的分隔符表示目录分隔符。
* 最终的类名与以`.php` 结尾的文件名保持一致，这个文件的名字必须和最终的类名相匹配（
意思就是如果类名是 `FooController`，那么这个类所在的文件名必须是 `FooController.php`）。

4、自动加载文件禁止抛出异常，禁止出现任何级别的错误，也不建议有返回值。

**3. 范例**

下表显示了与给定的全限定类名、命名空间前缀和根目录相对应的文件的路径。
```
Fully Qualified Class Name    Namespace Prefix   Base Directory           Resulting File Path
\Acme\Log\Writer\File_Writer  Acme\Log\Writer    ./acme-log-writer/lib/   ./acme-log-writer/lib/File_Writer.php
\Aura\Web\Response\Status     Aura\Web           /path/to/aura-web/src/   /path/to/aura-web/src/Response/Status.php
\Symfony\Core\Request         Symfony\Core       ./vendor/Symfony/Core/   ./vendor/Symfony/Core/Request.php
\Zend\Acl                     Zend               /usr/includes/Zend/      /usr/includes/Zend/Acl.php
```

想要了解一个符合规范的自动加载器的实现可以查看示例文件。示例中的自动加载器禁止被视为规范的一部分，它随时都可能发生改变。

### PSR-4 自动加载规范 - 示例文档 

**PSR-4 的实现示例**

下面的示例说明了符合 PSR-4 的代码：

**闭包示例**

```php
<?php
/**
 * 一个具体项目实现的示例。
 *
 * 在注册自动加载函数后，
 * 下面这行代码将引发程序尝试从 /path/to/project/src/Baz/Qux.php 加载 \Foo\Bar\Baz\Qux 类：
 *
 *      new \Foo\Bar\Baz\Qux;
 *
 * @param string $class 完全标准的类名。
 * @return void
 */
spl_autoload_register(function ($class) {

    // 具体项目的命名空间前缀
    $prefix = 'Foo\\Bar\\';

    // 命名空间前缀对应的基础目录
    $base_dir = __DIR__ . '/src/';

    // 该类使用了此命名空间前缀？
    $len = strlen($prefix);
    if (strncmp($prefix, $class, $len) !== 0) {
        // 否，交给下一个已注册的自动加载函数
        return;
    }

    // 获取相对类名
    $relative_class = substr($class, $len);

    // 命名空间前缀替换为基础目录，
    // 将相对类名中命名空间分隔符替换为目录分隔符，
    // 附加 .php
    $file = $base_dir . str_replace('\\', '/', $relative_class) . '.php';

    // 如果文件存在，加载它
    if (file_exists($file)) {
        require $file;
    }
});
```

**类示例**

以下是一个可处理多命名空间的类实现示例：
```php
<?php
namespace Example;

/**
 * 一个多用途的示例实现，包括了允许多个基本目录用于单个命名空间前缀的可选功能
 *
 * 下述示例给出了一个 foo-bar 类包，系统中路径结构如下……
 *
 *     /path/to/packages/foo-bar/
 *         src/
 *             Baz.php             # Foo\Bar\Baz
 *             Qux/
 *                 Quux.php        # Foo\Bar\Qux\Quux
 *         tests/
 *             BazTest.php         # Foo\Bar\BazTest
 *             Qux/
 *                 QuuxTest.php    # Foo\Bar\Qux\QuuxTest
 *
 * ……添加路径到  \Foo\Bar\  命名空间前缀的类文件中
 * 如下所示：
 *
 *      <?php
 *      // 实例化加载器
 *      $loader = new \Example\Psr4AutoloaderClass;
 *
 *      // 注册加载器
 *      $loader->register();
 *
 *      // 为命名空间前缀注册基本路径
 *      $loader->addNamespace('Foo\Bar', '/path/to/packages/foo-bar/src');
 *      $loader->addNamespace('Foo\Bar', '/path/to/packages/foo-bar/tests');
 *
 * 下述语句会让自动加载器尝试从 
 * /path/to/packages/foo-bar/src/Qux/Quux.php 
 * 中加载  \Foo\Bar\Qux\Quux 类
 *
 *      <?php
 *      new \Foo\Bar\Qux\Quux;
 *
 *  下述语句会让自动加载器尝试从 
 *   /path/to/packages/foo-bar/tests/Qux/QuuxTest.php
 * 中加载 \Foo\Bar\Qux\QuuxTest 类：
 *
 *      <?php
 *      new \Foo\Bar\Qux\QuuxTest;
 */
class Psr4AutoloaderClass
{
    /**
     * 关联数组，键名为命名空间前缀，键值为一个基本目录数组。
     *
     * @var array
     */
    protected $prefixes = array();

    /**
     * 通过 SPL 自动加载器栈注册加载器
     *
     * @return void
     */
    public function register()
    {
        spl_autoload_register(array($this, 'loadClass'));
    }

    /**
     * 为命名空间前缀添加一个基本目录
     *
     * @param string $prefix 命名空间前缀。
     * @param string $base_dir 命名空间下类文件的基本目录
     * @param bool $prepend 如果为真，预先将基本目录入栈而不是后续追加；这将使得它会被首先搜索到。
     * @return void
     */
    public function addNamespace($prefix, $base_dir, $prepend = false)
    {
        // 规范化命名空间前缀
        $prefix = trim($prefix, '\\') . '\\';

        // 规范化尾部文件分隔符
        $base_dir = rtrim($base_dir, DIRECTORY_SEPARATOR) . '/';

        // 初始化命名空间前缀数组
        if (isset($this->prefixes[$prefix]) === false) {
            $this->prefixes[$prefix] = array();
        }

        // 保留命名空间前缀的基本目录
        if ($prepend) {
            array_unshift($this->prefixes[$prefix], $base_dir);
        } else {
            array_push($this->prefixes[$prefix], $base_dir);
        }
    }

    /**
     * 加载给定类名的类文件
     *
     * @param string $class 合法类名
     * @return mixed 成功时为已映射文件名，失败则为 false
     */
    public function loadClass($class)
    {
        // 当前命名空间前缀
        $prefix = $class;

        // 通过完整的命名空间类名反向映射文件名
        while (false !== $pos = strrpos($prefix, '\\')) {

            // 在前缀中保留命名空间分隔符
            $prefix = substr($class, 0, $pos + 1);

            // 其余的是相关类名
            $relative_class = substr($class, $pos + 1);

            // 尝试为前缀和相关类加载映射文件
            $mapped_file = $this->loadMappedFile($prefix, $relative_class);
            if ($mapped_file) {
                return $mapped_file;
            }

            // 删除 strrpos() 下一次迭代的尾部命名空间分隔符
            $prefix = rtrim($prefix, '\\');
        }

        // 找不到映射文件
        return false;
    }

    /**
     * 为命名空间前缀和相关类加载映射文件。
     *
     * @param string $prefix 命名空间前缀
     * @param string $relative_class 相关类
     * @return mixed Boolean 无映射文件则为false，否则加载映射文件
     */
    protected function loadMappedFile($prefix, $relative_class)
    {
        // 命名空间前缀是否存在任何基本目录
        if (isset($this->prefixes[$prefix]) === false) {
            return false;
        }

        // 通过基本目录查找命名空间前缀
        foreach ($this->prefixes[$prefix] as $base_dir) {

            // 用基本目录替换命名空间前缀
            // 用目录分隔符替换命名空间分隔符
            // 给相关的类名增加 .php 后缀
            $file = $base_dir
                  . str_replace('\\', '/', $relative_class)
                  . '.php';

            // 如果映射文件存在，则引入
            if ($this->requireFile($file)) {
                // 搞定了
                return $file;
            }
        }

        // 找不到
        return false;
    }

    /**
     * 如果文件存在从系统中引入进来
     *
     * @param string $file 引入文件
     * @return bool 文件存在则 true 否则 false
     */
    protected function requireFile($file)
    {
        if (file_exists($file)) {
            require $file;
            return true;
        }
        return false;
    }
}
```

**单元测试**

以下示例是上述类加载器的单元测试方式之一：
```php
<?php
namespace Example\Tests;

class MockPsr4AutoloaderClass extends Psr4AutoloaderClass
{
    protected $files = array();

    public function setFiles(array $files)
    {
        $this->files = $files;
    }

    protected function requireFile($file)
    {
        return in_array($file, $this->files);
    }
}

class Psr4AutoloaderClassTest extends \PHPUnit\Framework\TestCase
{
    protected $loader;

    protected function setUp(): void
    {
        $this->loader = new MockPsr4AutoloaderClass;

        $this->loader->setFiles(array(
            '/vendor/foo.bar/src/ClassName.php',
            '/vendor/foo.bar/src/DoomClassName.php',
            '/vendor/foo.bar/tests/ClassNameTest.php',
            '/vendor/foo.bardoom/src/ClassName.php',
            '/vendor/foo.bar.baz.dib/src/ClassName.php',
            '/vendor/foo.bar.baz.dib.zim.gir/src/ClassName.php',
        ));

        $this->loader->addNamespace(
            'Foo\Bar',
            '/vendor/foo.bar/src'
        );

        $this->loader->addNamespace(
            'Foo\Bar',
            '/vendor/foo.bar/tests'
        );

        $this->loader->addNamespace(
            'Foo\BarDoom',
            '/vendor/foo.bardoom/src'
        );

        $this->loader->addNamespace(
            'Foo\Bar\Baz\Dib',
            '/vendor/foo.bar.baz.dib/src'
        );

        $this->loader->addNamespace(
            'Foo\Bar\Baz\Dib\Zim\Gir',
            '/vendor/foo.bar.baz.dib.zim.gir/src'
        );
    }

    public function testExistingFile()
    {
        $actual = $this->loader->loadClass('Foo\Bar\ClassName');
        $expect = '/vendor/foo.bar/src/ClassName.php';
        $this->assertSame($expect, $actual);

        $actual = $this->loader->loadClass('Foo\Bar\ClassNameTest');
        $expect = '/vendor/foo.bar/tests/ClassNameTest.php';
        $this->assertSame($expect, $actual);
    }

    public function testMissingFile()
    {
        $actual = $this->loader->loadClass('No_Vendor\No_Package\NoClass');
        $this->assertFalse($actual);
    }

    public function testDeepFile()
    {
        $actual = $this->loader->loadClass('Foo\Bar\Baz\Dib\Zim\Gir\ClassName');
        $expect = '/vendor/foo.bar.baz.dib.zim.gir/src/ClassName.php';
        $this->assertSame($expect, $actual);
    }

    public function testConfusion()
    {
        $actual = $this->loader->loadClass('Foo\Bar\DoomClassName');
        $expect = '/vendor/foo.bar/src/DoomClassName.php';
        $this->assertSame($expect, $actual);

        $actual = $this->loader->loadClass('Foo\BarDoom\ClassName');
        $expect = '/vendor/foo.bardoom/src/ClassName.php';
        $this->assertSame($expect, $actual);
    }
}
```

### PSR-4 自动加载规范 - 说明文档 

PSR-4 说明文档

**1. 概述**

PSR-4 是为了给可交互的 PHP 自动加载器指定一个将命名空间映射到文件系统的规则，
并且可以与其他 SPL 注册的自动加载器共存。PSR-4 不是 PSR-0 的替代品，而是对它的补充。

**2. 为什么需要它？**

**PSR-0 的发展史**

在 PHP 5.2 之前，PSR-0 的类命名标准和自动加载标准是以被广泛使用的 Horde/PEAR 约定为准。
这个约定里要求将所有的 PHP 类文件放在一个主目录中，并使用下划线连接的字符串来表示命名空间，如下所示：
```
/path/to/src/
    VendorFoo/
        Bar/
            Baz.php     # VendorFoo_Bar_Baz
    VendorDib/
        Zim/
            Gir.php     # VendorDib_Zim_Gir
```

随着 PHP 5.3 的发布以及新命名空间的广泛使用，现在 PSR-0 已经可以使用 Horde/PEAR 约定的下划线表示法或者新命名空间表示法。 
它让下划线表示法作为新命名空间表示法的一个过渡，从而得到更好的兼容。
```
/path/to/src/
    VendorFoo/
        Bar/
            Baz.php     # VendorFoo_Bar_Baz
    VendorDib/
        Zim/
            Gir.php     # VendorDib_Zim_Gir
    Irk_Operation/
        Impending_Doom/
            V1.php
            V2.php      # Irk_Operation\Impending_Doom\V2
```

这种目录结构很大程度影响了 PEAR 安装器将源文件从 PEAR 包中迁移到一个主目录中。

**因 Composer 而来**

在 Composer 中，包资源不再拷贝到某个单一的全局目录。从它们安装的位置引用它们，不需要移动。
这就意味着使用 Composer 时 PHP 资源不像 PEAR 一样有「单一主目录」。取而代之的是多个目录；每个项目的每个包都在单独目录中。

为了符合 PSR-0 的需要，导致每个 Composer 包都类似下面这样：
```
vendor/
    vendor_name/
        package_name/
            src/
                Vendor_Name/
                    Package_Name/
                        ClassName.php       # Vendor_Name\Package_Name\ClassName
            tests/
                Vendor_Name/
                    Package_Name/
                        ClassNameTest.php   # Vendor_Name\Package_Name\ClassNameTest
```

「src」和「tests」目录必须包含开发商和包目录名。这是遵守 PSR-0 带来的结构。

许多人认为这种结构比需要的更深更重复。这一提议建议一个额外的或替代性的 PSR 将会更有益，所以我们有了类似以下的包结构：
```
vendor/
    vendor_name/
        package_name/
            src/
                ClassName.php       # Vendor_Name\Package_Name\ClassName
            tests/
                ClassNameTest.php   # Vendor_Name\Package_Name\ClassNameTest
```

这就需要将最初称为「基于包的自动加载」实现（对应于传统的「类 - 文件自动加载」）。

**面向 - 包的自动加载**

通过扩展或修订 PSR-0 实现面向 - 包的自动加载非常困难，因为 PSR-0 不允许修改类名路径之间的任何部分。
这意味着实现面向 - 包的自动加载要比 PSR-0 复杂的多，但是从另一方面来讲，它将使扩展包更加简洁。

在一开始的时候，以下规则是建议的:

1. 实现者必须使用两个以上的命名空间层级：一个 vendor 名，和该 vendor 内的包名。
(这两个顶级名称组合被简称为 vendor-package 或 vendor-package namespace。)
2. 实现者必须允许 vendor-package namespace 与完全限定类名的其余部分之间的路径中缀。
3. vendor-package namespace 可以映射到任意目录。完全限定类名的其余部分，
必须映射命名空间名称到同名目录，类名必须映射到 .php 结尾的同名文件。

注意这意味着结束了在类名中下划线作为目录分隔符的做法。有人可能认为下划线应该被遵从因为它们出现在 PSR-0 规范当中，
但是在该文档中它们作为 PHP 5.2 或者更旧的版本的伪命名空间过渡的做法，所以此处删除他们也是可以接受的。

**3. 范围（Scope）**

3.1 目标

* 保留实现者必须使用两个以上的命名空间层级的 PSR-0 规则：一个 vendor 名，和该 vendor 内的 包名。
* 允许 vendor-package namespace 与完全限定类名的其余部分的路径中缀。
* 允许 vendor-package namespace 可以映射到任何目录，也可能是多个目录。
* 结束遵从类名中下划线作为目录分隔符的做法。

3.2 非目标

* 为非类资源提供通用的转换规则

**4. 方案选择**

4.1 被选中的方案

本方案保留了 PSR-0 关键特性，同时消除了更深层次的目录结构。此外，指定了一些附加规则，使得操作起来更明确。

尽管不涉及目录映射，最终草案还是规定了自动加载器应该如何处理错误。具体来说，它禁止抛出异常和错误，主要有这两方面考虑：
1. PHP 中自动加载器设计是可堆叠的，如果一个自动加载器不能加载，则其他的仍有机会继续加载。
若有其中一个自动加载器发生错误此过程将不会进行下去；
2. `class_exists()` 和 `interface_exists()` 允许『在尝试自动加载后仍然找不到类』的存在，
一个用例是：若自动加载器抛出异常将使得 `class_exists()` 不可用，从互操作性的角度来看这是无法接受的。
自动加载器在找不到类的情况下最好通过日志记录提供附加的调试信息，日志可以使用 PSR-3 兼容日志记录或类似的方案。

优点:

    较浅的目录结构；
    文件位置更加固定；
    不再使用类名中下划线作为目录分隔符；
    更明确的互操作性实现

缺点:

    不能像 PSR-0 仅仅通过类名就能确定它在文件系统的具体位置 (这种 “类 - 到 - 文件” 约定继承自 Horde/PEAR)。
    
4.2 替代方案：只使用 PSR-0

保留 PSR-0 虽然很合理，但确实给我们留下了相对较深的目录结构。

优点：

    无需改变任何人的习惯或者实现方式

缺点：

    相对较深的目录结构
    类名中的下划线被识别为目录分隔符

4.3 替代方案：拆分自动加载以及转换

Beau Simensen 跟其他人建议，转换算法可以从自动加载提案中分离出来以便转换规则可以被其他的提案引用。
在完成分离它们的工作之后，会进行民意调查跟一些相关讨论。通过后，合并版本（即带转换规则的自动加载提案）会被显示为首选项。

优点：

    转换规则可以被其他提案引用

缺点：

    不符合某民意调查的受访者跟合作者的意愿（就是要修改老代码，有些人怕麻烦）

4.4 替代方案：使用更多命令式和叙事性语言

在多个 +1 选民听到他们支持这个想法但未同意（或理解）该提案的措辞后，赞助商撤回了第二次投票后，
有一段时间，投票通过的提案得到了扩展。更大的叙事和更有必要的语言。少数参与者谴责这种方法。
一段时间后，Beau Simensen 开始进行实验性修订，着眼于 PSR-0 。编辑和赞助商赞成采用这种更简洁的方法，
并指导现在正在考虑的版本，由 Paul M. Jones 编写并为许多人做出贡献。

**与 PHP 5.3.2 及更低版本的兼容性说明**

5.3.3 之前的 PHP 版本不会删除前导命名空间分隔符，因此需要注意实施过程。无法删除前导命名空间分隔符可能会导致意外行为。

**5. 参与人员**

5.1 编辑

    Paul M. Jones, Solar/Aura

5.2 赞助者

    Phil Sturgeon, PyroCMS (Coordinator)
    Larry Garfield, Drupal

5.3 贡献者

    Andreas Hennings
    Bernhard Schussek
    Beau Simensen
    Donald Gilbert
    Mike van Riel
    Paul Dragoonis
    Too many others to name and count

**6. 投票情况**

入选投票 : https://groups.google.com/d/msg/php-fig/_LYBgfcEoFE/ZwFTvVTIl4AJ

接受投票:
* 第一次尝试: https://groups.google.com/forum/#!topic/php-fig/Ua46E344_Ls, 
presented prior to new workflow; aborted due to accidental proposal modification
* 第二次尝试: https://groups.google.com/forum/#!topic/php-fig/NWfyAeF7Psk, 
cancelled at the discretion of the sponsor https://groups.google.com/forum/#!topic/php-fig/t4mW2TQF7iE
* 第三次尝试：暂时没有信息

**7. 相关链接**

    Autoloader, round 4
    POLL: Autoloader: Split or Combined?
    PSR-X autoloader spec: Loopholes, ambiguities
    Autoloader: Combine Proposals?
    Package-Oriented Autoloader, Round 2
    Autoloader: looking again at namespace
    DISCUSSION: Package-Oriented Autoloader - vote against
    VOTE: Package-Oriented Autoloader
    Proposal: Package-Oriented Autoloader
    Towards a Package Oriented Autoloader
    List of Alternative PSR-4 Proposals
    Summary of [post-Acceptance Vote pull] PSR-4 discussions

### PSR-6 缓存接口规范 

#### 缓存接口

缓存是提升应用性能的常用手段，为框架中最通用的功能，每个框架也都推出专属的、功能多样的缓存库。
这些差别使得开发人员不得不学习多种系统，而很多可能是他们并不需要的功能。
此外，缓存库的开发者同样面临着一个窘境，是只支持有限数量的几个框架还是创建一堆庞大的适配器类。

一个通用的缓存系统接口可以解决掉这些问题。库和框架的开发人员能够知道缓存系统会按照他们所预期的方式工作，
缓存系统的开发人员只需要实现单一的接口，而不用去开发各种各样的适配器。

本文件中的 必须，不得，需要，应，不应，应该，不应该，推荐，可能 和 可选 等能愿动词按照 RFC 2119 中的描述进行解释。

#### 目标

本 PSR 的目标是：创建一套通用的接口规范，能够让开发人员整合到现有框架和系统，而不需要去开发框架专属的适配器类。

#### 定义

**调用类库 (Calling Library)** - 调用者，使用缓存服务的类库，这个类库调用缓存服务，
调用的是此缓存接口规范的具体「实现类库」，调用者不需要知道任何「缓存服务」的具体实现。

**实现类库 (Implementing Library)** - 此类库是对「缓存接口规范」的具体实现，封装起来的缓存服务，供「调用类库」使用。
实现类库 必须 提供 PHP 类来实现 `Cache\CacheItemPoolInterface` 和 `Cache\CacheItemInterface` 接口。
实现类库 必须 支持最小的如下描述的 TTL 功能，秒级别的精准度。

**生存时间值 (TTL - Time To Live)** - 定义了缓存可以存活的时间，以秒为单位的整数值。

**过期时间 (Expiration)** - 定义准确的过期时间点，一般为缓存存储发生的时间点加上 TTL 时间值，
也可以指定一个 DateTime 对象。假如一个缓存项的 TTL 设置为 300 秒，保存于 1:30:00 ，那么缓存项的过期时间为 1:35:00。
实现类库 可以 让缓存项提前过期，但是 必须 在到达过期时间时立即把缓存项标示为过期。
如果调用类库在保存一个缓存项的时候未设置「过期时间」、或者设置了 `null` 作为过期时间（或者 TTL 设置为 null），
实现类库 可以 使用默认自行配置的一个时间。如果没有默认时间，实现类库 必须把存储时间当做 永久性 存储，
或者按照底层驱动能支持的最长时间作为保持时间。

**键 (KEY)** - 长度大于 1 的字串，用作缓存项在缓存系统里的唯一标识符。
实现类库 必须 支持「键」规则 `A-Z`, `a-z`, `0-9`, `_`, 和 `.` 任何顺序的 UTF-8 编码，长度小于 64 位。
实现类库 可以 支持更多的编码或者更长的长度，不过 必须 支持至少以上指定
的编码和长度。实现类库可自行实现对「键」的转义，但是 必须 保证能够无损的返回「键」字串。
以下的字串作为系统保留: `{}()/\@:`，一定不可 作为「键」的命名支持。

**命中 (Hit)** - 一个缓存的命中，指的是当调用类库使用「键」在请求一个缓存项的时候，
在缓存池里能找到对应的缓存项，并且此缓存项还未过期，并且此数据不会因为任何原因出现错误。
调用类库 应该 确保先验证下 `isHit()` 有命中后才调用 `get()` 获取数据。

**未命中 (Miss)** - 一个缓存未命中，是完全的上面描述的「命中」的相反。
指的是当调用类库使用「键」在请求一个缓存项的时候，在缓存池里未能找到对应的缓存项，或者此缓存项已经过期，
或者此数据因为任何原因出现错误。一个过期的缓存项，必须 被当做 未命中 来对待。

**延迟 (Deferred)** - 一个延迟的缓存，指的是这个缓存项可能不会立刻被存储到物理缓存池里。
一个缓存池对象 可以 对一个指定延迟的缓存项进行延迟存储，这样做的好处是可以利用一些缓存服务器提供的批量插入功能。
缓存池 必须 能对所有延迟缓存最终能持久化，并且不会丢失。可以 在调用类库还未发起保存请求之前就做持久化。
当调用类库调用 `commit()` 方法时，所有的延迟缓存都 必须 做持久化。
实现类库 可以 自行决定使用什么逻辑来触发数据持久化，如对象的 析构方法 (`destructor`) 内、
调用 `save()` 时持久化、倒计时保存或者触及最大数量时保存等。
当请求一个延迟缓存项时，必须 返回一个延迟，未持久化的缓存项对象。

#### 数据

实现类库必须支持序列化 PHP 的所有数据类型，包含以下类型：

* Strings - PHP 兼容编码中任意长度的字符串。
* Integers - PHP 支持的所有大小的整数，最大为 64 位有符号整数。
* Floats - 有符号的浮点值。
* Boolean - True 和 False 。
* Null - 实际的空值。
* Arrays - 可索引，关联，任意深度的数组。
* Object - 所有对象支持无损的序列化和反序列化，比如 `$o == unserialize(serialize($o))`。
对象可以使用 PHP 的原生序列化接口， `__sleep()` 、 `__wakeup()` 等魔术方法，或者其他可用的类似语法。

所有数据传入实现类库 必须 准确返回传入的值，并且返回变量的类型一致。非法示例：传入 (int) 5 返回 (string) 5。
实现类库 可以 使用 PHP 中 serialize ()/unserialize () 方法进行序列化和反序列化，当然也不强制要求这样做。
兼容这些的一个基本准线就是接受对象类型。

如果由于某些技术原因不能准确保存，实现类库 必须 返回缓存未命中，而不是损坏的数据。

#### 主要概念

* 缓存池 Pool

缓存池包含缓存系统里所有缓存数据的集合。缓存池逻辑上是所有缓存项存储的仓库，所有存储进去的数据，
都能从缓存池里取出来，所有的对缓存的操作，都发生在缓存池子里。

* 缓存项 Items

一条缓存项在缓存池里代表了一对「键 / 值」对应的数据，「键」被视为每一个缓存项主键，
是缓存项的唯一标识符，必须 是不可变更的，当然，「值」可以 任意变更。

#### 错误处理

缓存对应用性能起着至关重要的作用，但是，无论在任何情况下，缓存 一定不可 作为应用程序不可或缺的核心功能。
缓存系统里的错误 一定不可 导致应用程序故障，所以，实现类库 一定不可 抛出任何除了此接口规范定义的以外的异常，
并且 必须 捕捉包括底层存储驱动抛出的异常，不让其冒泡至超出缓存系统内。

实现类库 应该 对此类错误进行记录，或者以任何形式通知管理员。

调用类库发起删除缓存项的请求，或者清空整个缓冲池子的请求，「键」不存在的话 必须 不能当成是有错误发生。
后置条件是一样的，如果取数据时，「键」不存在的话 必须 不能当成是有错误发生。

#### 接口

* CacheItemInterface

`CacheItemInterface` 定义了缓存系统里的一个缓存项。每一个缓存项 必须 有一个「键」与之相关联，
此「键」通常是通过 Cache\CacheItemPoolInterface 来设置。

Cache\CacheItemInterface 对象把缓存项的存储进行了封装，
每一个 Cache\CacheItemInterface 由一个 Cache\CacheItemPoolInterface 对象生成，
CacheItemPoolInterface 负责一些必须的设置，并且给对象设置具有 唯一性 的「键」。

Cache\CacheItemInterface 对象 必须 能够存储和取出任何类型的，在「数据」章节定义的 PHP 数值。

调用类库 一定不可 擅自初始化「CacheItemInterface」对象，
「缓存项」只能使用「CacheItemPoolInterface」对象的 getItem() 方法来获取。
调用类库 一定不可 假设由一个实现类库创建的「缓存项」能被另一个实现类库完全兼容。

```php
<?php

namespace Psr\Cache;

/**
 * CacheItemInterface 定了缓存系统里对缓存项操作的接口
 */
interface CacheItemInterface
{
    /**
     * 返回当前缓存项的「键」
     *
     * 「键」由实现类库来加载，并且高层的调用者（如：CacheItemPoolInterface）
     * **应该** 能使用此方法来获取到「键」的信息。
     *
     * @return string
     *  当前缓存项的「键」
     */
    public function getKey();

    /**
     * 凭借此缓存项的「键」从缓存系统里面取出缓存项。
     *
     * 取出的数据 **必须** 跟使用 `set()` 存进去的数据是一模一样的。
     *
     * 如果 `isHit()` 返回 false 的话，此方法必须返回 `null`，
     * 需要注意的是 `null` 本来就是一个合法的缓存数据，
     * 所以你 **应该** 使用 `isHit()` 方法来辨别到底是"返回 null 数据" 还是 "缓存里没有此数据"
     *
     * @return mixed
     *   此缓存项的「键」对应的「值」，如果找不到的话，返回 `null`
     */
    public function get();

    /**
     * 确认缓存项的检查是否命中。
     *
     * 注意: 调用此方法和调用 `get()` 时 **一定不可** 有先后顺序之分。
     *
     * @return bool
     * 如果缓冲池里有命中的话，返回 `true`，反之返回 `false`
     */
    public function isHit();

    /**
     * 为此缓存项设置「值」。
     *
     * 参数 $value 可以是所有能被 PHP 序列化的数据，
     * 序列化的逻辑需要在实现类库里书写。
     *
     * @param mixed $value
     * 将被存储的可序列化的数据。
     *
     * @return static
     * 返回当前对象。
     */
    public function set($value);

    /**
     * 设置缓存项的准确过期时间点。
     *
     * @param \DateTimeInterface|null $expiration
     * 过期的准确时间点，过了这个时间点后，缓存项就 **必须** 被认为是过期了的。
     * 如果明确的传参 `null` 的话，**可以** 使用一个默认的时间。
     * 如果没有设置的话，缓存 **应该** 存储到底层实现的最大允许时间。
     *
     * @return static
     * 返回当前对象
     */
    public function expiresAt($expiration);

    /**
     * 设置缓存项的过期时间
     *
     * @param int|\DateInterval|null $time
     * 以秒为单位的过期时长，过了这段时间后，缓存项就 **必须** 被认为是过期了的。
     * 如果明确的传参 `null` 的话，**可以** 使用一个默认的时间。
     * 如果没有设置的话，缓存 **应该** 存储到底层实现的最大允许时间。
     *
     * @return static
     * 返回当前对象
     */
    public function expiresAfter($time);

}
```

* CacheItemPoolInterface

Cache\CacheItemPoolInterface 的主要目的是从调用类库接收「键」，然后返回对应的 Cache\CacheItemInterface 对象。

此接口也是作为主要的，与整个缓存集合交互的方式。所有的配置和初始化由实现类库自行实现。

```php
<?php

namespace Psr\Cache;

/**
 * CacheItemPoolInterface 生成 CacheItemInterface 对象
 */
interface CacheItemPoolInterface
{
    /**
     * 返回「键」对应的一个缓存项。
     *
     * 此方法 **必须** 返回一个 CacheItemInterface 对象，
     * 即使是找不到对应的缓存项也 **一定不可** 返回 `null`。
     *
     * @param string $key
     * 用来搜索缓存项的「键」。
     *
     * @throws InvalidArgumentException
     *   如果 $key 不是合法的值，\Psr\Cache\InvalidArgumentException 异常会被抛出。
     *
     * @return CacheItemInterface
     *  对应的缓存项。
     */
    public function getItem($key);

    /**
     * 返回一个可供遍历的缓存项集合。
     *
     * @param string[] $keys
     * 由一个或者多个「键」组成的数组。
     *
     * @throws InvalidArgumentException
     * 如果 $keys 里面有哪个「键」不是合法，\Psr\Cache\InvalidArgumentException 异常会被抛出。
     *   
     *
     * @return array|\Traversable
     * 返回一个可供遍历的缓存项集合，集合里每个元素的标识符由「键」组成，即使即使是找不到对的缓存项，
     * 也要返回一个「CacheItemInterface」对象到对应的「键」中。
     * 如果传参的数组为空，也需要返回一个空的可遍历的集合。
     */
    public function getItems(array $keys = array());

    /**
     * 检查缓存系统中是否有「键」对应的缓存项。
     *
     * 注意: 此方法应该调用 `CacheItemInterface::isHit()` 来做检查操作，而不是 `CacheItemInterface::get()`
     *
     * @param string $key
     * 用来搜索缓存项的「键」。
     *
     * @throws InvalidArgumentException
     *   如果 $key 不是合法的值，\Psr\Cache\InvalidArgumentException 异常会被抛出。
     *
     * @return bool
     *   如果存在「键」对应的缓存项即返回 true，否则 false
     */
    public function hasItem($key);

    /**
     * 清空缓冲池
     *
     * @return bool
     *   成功返回 true，有错误发生返回 false
     */
    public function clear();

    /**
     * 从缓冲池里移除某个缓存项
     *
     * @param string $key
     *   用来搜索缓存项的「键」。
     *
     * @throws InvalidArgumentException
     * 如果 $key 不是合法的值，\Psr\Cache\InvalidArgumentException 异常会被抛出。
     *
     * @return bool
     *   成功返回 true，有错误发生返回 false
     */
    public function deleteItem($key);

    /**
     * 从缓冲池里移除多个缓存项
     *
     * @param string[] $keys
     * 由一个或者多个「键」组成的数组。
     * 
     * @throws InvalidArgumentException
     * 如果 $keys 里面有哪个「键」不是合法，\Psr\Cache\InvalidArgumentException 异常会被抛出。
     *
     * @return bool
     * 成功返回 true，有错误发生返回 false
     */
    public function deleteItems(array $keys);

    /**
     * 立刻为「CacheItemInterface」对象做数据持久化。
     *
     * @param CacheItemInterface $item
     * 将要被存储的缓存项
     *
     * @return bool
     * 成功返回 true，有错误发生返回 false
     */
    public function save(CacheItemInterface $item);

    /**
     * 稍后为「CacheItemInterface」对象做数据持久化。
     *
     * @param CacheItemInterface $item
     * 将要被存储的缓存项
     *
     * @return bool
     * 成功返回 true，有错误发生返回 false
     */
    public function saveDeferred(CacheItemInterface $item);

    /**
     * 提交所有的正在队列里等待的请求到数据持久层，配合 `saveDeferred()` 使用
     *
     * @return bool
     * 成功返回 true，有错误发生返回 false
     */
    public function commit();
}
```

* CacheException

异常接口用于严重错误发生的时候，包括但不限于缓存设置错误，例如：无法连接到缓存服务器、提供了无效的凭证。

库抛出的任何异常都必须实现此接口。

```php
<?php

namespace Psr\Cache;

/**
 * 异常接口，针对库抛出的所有异常。
 */
interface CacheException
{
}
```

* InvalidArgumentException

```php
<?php

namespace Psr\Cache;

/**
 * 无效缓存参数的异常接口。
 *
 * 任何时候，一个无效参数传递到方法时，
 * 必须抛出一个实现了 Psr\Cache\InvalidArgumentException 的异常类。
 */
interface InvalidArgumentException extends CacheException
{
}
```

### PSR-6 缓存接口规范 - 说明文档 

1、 概述

使用缓存是一种常用的提高性能的方法，并适用于任何项目，这使得缓存库成为许多框架和库最常见的特性之一。
最后导致了许多库都有自己的缓存库，并且具有不同级别的功能。这些差异导致开发人员不得不学习多个缓存系统，
而他们所需要的功能可能在有的系统里并没有提供。此外，缓存库本身的开发人员只能选择要么支持少量框架，要么创建大量的适配器类。

2、 为什么有必要？

通用的缓存接口会解决这些问题。库和框架开发者可以期望缓存系统能正常工作，
与此同时，缓存系统的开发者只用实现一部分接口而不是做一大堆适配工作。

而且，这里的实现也是为了方便未来扩展，它提供了许多本质上不同但是却又兼容 API 的实现，
而且也为后面 PSRs 规范或者特定的实现提供了清晰的路径规划。

正方:

    一个标准的缓存接口能提供独立的库来让我们轻松缓存中间数据；他们可以简单的依赖和使用这些标准接口而不用关心具体的实现细节。
    由多个项目共享的常见开发的缓存系统，即使他们扩展了这个接口，也比单独开发的实现要健壮

反方:

    任何接口标准化会被认为扼杀了未来创新，被认为不应该这样实现。但是我们相信缓存是一个足够商业化的问题场景，缓存接口在这里提供的扩展能力降低了任何潜在的停滞风险。

3、 范围

3.1 目标

    一种通用的底层和中间级缓存需求接口。
    一种清晰的机制，用于扩展规范以支持高级功能，包括将来的 PSRs 或单个实现。 此机制必须允许多个独立扩展而不会发生冲突。

3.2 非目标

    与所有现有缓存的实现体系结构兼容。
    像命名空间或标记这样由少数用户使用的高级缓存特性。

4、 方法

4.1 选择的方法

该规范采用『存储模型』或『数据映射』模型进行缓存，而不是传统可『可过期键 - 值』模型。
主要原因是灵活性。简单的键 / 值模型更加难以扩展。

这里的模型要求用 CacheItem 对象和 Pool 对象，CacheItem 对象表示缓存条目，Pool 对象是缓存数据给定缓存。
从池中检索项目，交互并返回到项目。有时候有些冗长，但是它提供了一个良好、稳健、灵活的缓存方法，
尤其是在缓存比简单的保存在字符串更复杂的情况下。

大多数方法名称是根据成员项目和其他流行的非成员系统调查中的通用实践和方法名来选择的。

优点:

    灵活并且可扩展
    允许在不违反接口的情况下实现大量的变化
    不会将对象构造函数的隐式暴露为伪接口

缺点:

    比简单的方法更冗长

示例:

下面是一些常用的使用模式。这些是非规范的，但是可以说明一些设计决策的应用。

```
/**
 * 获取可用控件列表。
 *
 * 在这种情况下，我们假设小部件列表很少改动 
 * 列表一直缓存到显式清除为止。
 */
function get_widget_list()
{
    $pool = get_cache_pool('widgets');
    $item = $pool->getItem('widget_list');
    if (!$item->isHit()) {
        $value = compute_expensive_widget_list();
        $item->set($value);
        $pool->save($item);
    }
    return $item->get();
}
```

```
/**
 * 可用控件缓存列表。.
 *
 * 在这种情况下，我们假设已经计算了一个小部件列表，
 * 缓存它，无论缓存的是什么。
 */
function save_widget_list($list)
{
    $pool = get_cache_pool('widgets');
    $item = $pool->getItem('widget_list');
    $item->set($list);
    $pool->save($item);
}
```

```
/**
 * 清除缓存小部件列表。
 *
 * 在这种情况下，我们只想从缓存中删除小部件。
 * 我们不在意他是否已被设置；POST的条件是『不再设置』 。
 */
function clear_widget_list()
{
    $pool = get_cache_pool('widgets');
    $pool->deleteItems(['widget_list']);
}
```

```
/**
 * 清除所有的小部件。
 *
 * 在这种情况下，我们只想清空池中所有的小部件。 
 * 应用中其他的池可能不会受到影响。
 */
function clear_widget_cache()
{
    $pool = get_cache_pool('widgets');
    $pool->clear();
}
```

```
/**
 * 加载小部件.
 *
 * 我们想要获取一个小部件的列表，其中一些是缓存 一些不是。
 * 这里假设从缓存中加载比在非缓存加载机制中更快。
 *
 * 在这种情况下， 假设窗口小部件需要经常更改因此我们仅设置缓存的时间为一小时 (3600 秒)。
 * 我们也将新缓存的对象返回到池中。
 *
 * 还需要注意在实际实现中还需要对小部件窗口进行多次加载操作，
 * 但是这与本次演示无关。
 */
function load_widgets(array $ids)
{
    $pool = get_cache_pool('widgets');
    $keys = array_map(function($id) { return 'widget.' . $id; }, $ids);
    $items = $pool->getItems($keys);

    $widgets = array();
    foreach ($items as $key => $item) {
        if ($item->isHit()) {
            $value = $item->get();
        } else {
            $value = expensive_widget_load($id);
            $item->set($value);
            $item->expiresAfter(3600);
            $pool->saveDeferred($item, true);
        }
        $widget[$value->id()] = $value;
    }
    $pool->commit(); // 如果没有延期的项目这里无操作。

    return $widgets;
}
```

```
/**
 * 这个示例反应了此规范未包含的功能，
 * 但是显示为如何通过扩展来实现添加此类功能的示例。
 */

interface TaggablePoolInterface extends Psr\Cache\CachePoolInterface
{
    /**
     * 只清除池中指定标记的项目。
     */
    clearByTag($tag);
}

interface TaggableItemInterface extends Psr\Cache\CacheItemInterface
{
    public function setTags(array $tags);
}

/**
 * 标记缓存小部件。
 */
function set_widget(TaggablePoolInterface $pool, Widget $widget)
{
    $key = 'widget.' . $widget->id();
    $item = $pool->getItem($key);

    $item->setTags($widget->tags());
    $item->set($widget);
    $pool->save($item);
}
```

4.2 替代方案: "弱项" 方法

许多早起的草案采用了一种更简单的「带过期时间的键值对」的方法，同时也被称之为 「弱项」 方法。
在这种模型中，「缓存项」 对象只是一个不能使用的数组方法对象。用户可以直接实例化它，然后将它们扔进缓存池。
虽然这种方法更为常见，但它有效的防止了缓存项的任何有意义的扩展。
它有效的使缓存项的构造函数成为隐式接口的一部分，从而严重的降低了缓存项在实际灵活应用中的可扩展能力。

在 2013 年的一次调研中，大多数参与者都表现出明显的偏好，如果不大传统的 「强项」存储库方法更为健壮，
那么它将被采用作为未来发展的方向。

正方:

    更加传统的方法.

反方:

    较差的扩展及灵活性.

4.3 选择: "Naked value" 方法

一些早期的缓存规范讨论建议跳过 “缓存项” 概念，而只是读取 / 写入要缓存的原始值。 
尽管更简单，但需要指出的是，这使得无法分辨出缓存未命中与已缓存的原始值之间的区别。 
也就是说，如果缓存查找返回 NULL，则无法判断是否没有缓存的值或 NULL 是否为已缓存的值。 (在很多情况下，NULL 是已缓存的值。)

我们审查过的最健壮的缓存实现 - 尤其是 Stash 缓存库和 Drupal 使用的本地缓存系统 - 至少在 `get` 上使用某种结构化对象，
以避免混淆未命中值和标记值。 Based on that prior experience FIG decided that a naked value on `get` was impossible. 
根据先前的经验，FIG 认为在 `get` 上 Naked value 是不可能的。

4.4 选择: ArrayAccess Pool

有人建议让 Pool 实现 ArrayAccess，这将允许缓存获取 / 设置操作使用数组语法。 
由于应用有限而被拒绝，该方法的灵活性有限（使用默认控制信息进行简单的获取和设置就可以实现），如果需要，将特定实现包含为附加组件很简单。

5、 参与者

5.1 文档

    Larry Garfield

5.2 赞助商

    Paul Dragoonis, PPI Framework (Coordinator)
    Robert Hafner, Stash

6、 投票详情

Acceptance vote on the mailing list

7、 链接

Note: Order descending chronologically.

    Survey of existing cache implementations, by @dragoonis
    Strong vs. Weak informal poll, by @Crell
    Implementation details informal poll, by @Crell

8、 其他

8.1 在 expiresAt () 中处理不正确的 DateTime 值

在接口中  `CacheItemInterface::expiresAt()` 方法的 `$expiration` 参数中我们未做类型提示，
但在文档块中将其指定为 `\DateTimeInterface`。 目的是允许使用  `\DateTime` 或 `\DateTimeImmutable` 对象。 
但是，在 PHP 5.5 中添加了 `\DateTimeInterface` 和  `\DateTimeImmutable`，并且作者选择不在规范上强加 PHP 5.5 的严格语法要求。

尽管如此，实现者必须只接受  `\DateTimeInterface`  或兼容的类型（例如 `\DateTime` 和 `\DateTimeImmutable`），
就好像该方法已做类型提示一样。 （请注意，在不同的语言版本之间，类型化参数的差异规则可能会有所不同。）

模拟失败的类型检查在 PHP 不同版本之间会有所不同，因此不建议这样做。 
相反，实现者应该抛出  `\Psr\Cache\InvalidArgumentException` 的实例。

建议使用以下示例代码，以便对 expiresAt（）方法执行类型检查：

```
class ExpiresAtInvalidParameterException implements Psr\Cache\InvalidArgumentException {}

// ...

if (! (
        null === $expiration
        || $expiration instanceof \DateTime
        || $expiration instanceof \DateTimeInterface
)) {
    throw new ExpiresAtInvalidParameterException(sprintf(
        'Argument 1 passed to %s::expiresAt() must be an instance of DateTime or DateTimeImmutable; %s given',
        get_class($this),
        is_object($expiration) ? get_class($expiration) : gettype($expiration)
    ));
}
```









### PSR-12 编码规范扩充

**编码风格扩充指南**

文章中的关键词 MUST ， MUST NOT ， REQUIRED ， SHALL ， SHALL NOT ， SHOULD ，
SHOULD NOT ， RECOMMENDED ， MAY ，和 OPTIONAL 都在 RFC 2119 中进行来解释。

**摘要**

此规范起到继承，扩展和替换 [PSR-2][] 的作用， 同时编码风格遵守 [PSR-1][] 这个基础编码标准。

和 [PSR-2][] 一样， 此规范的目的是减少不同人在阅读代码时认知冲突。
它通过列举一套如何格式化 PHP 代码的公共的规则和期望来实现这个目标。 
PSR 力图提供一套方法，编码风格工具可以利用，项目可以遵守，开发人员可以方便的在不同的项目中使用。
当各个的开发人员在进行多项目合作的时候，它可以帮助在这些项目中提供一套通用的指导。
所以，本指南的价值不是规则本身，而是这些规则的共享。

[PSR-2][] 在 2012 年被接受，随后 PHP 经历了很多变化，影响了编码风格。
同时 [PSR-2] 是 PHP 编码时候的基础功能，被广泛的采用。
因此，PSR 力图通过一种更加现代的方式说明 PSR-2 的内容和新功能，并对 PSR-2 进行更正。

**以前的语言版本**

在整个文档中，任何说明都可以被忽略，如果它们不存在于你项目所支持的 PHP 版本中。

**例如**

此示例包含以下一些规则作为快速概述：
```php
<?php

declare(strict_types=1);

namespace Vendor\Package;

use Vendor\Package\{ClassA as A, ClassB, ClassC as C};
use Vendor\Package\SomeNamespace\ClassD as D;

use function Vendor\Package\{functionA, functionB, functionC};

use const Vendor\Package\{ConstantA, ConstantB, ConstantC};

class Foo extends Bar implements FooInterface
{
    public function sampleFunction(int $a, int $b = null): array
    {
        if ($a === $b) {
            bar();
        } elseif ($a > $b) {
            $foo->bar($arg1);
        } else {
            BazClass::bar($arg2, $arg3);
        }
    }

    final public static function bar()
    {
        // 方法内容
    }
}
```

**2. 总则**

**2.1 基本编码标准**

代码必须遵循 [PSR-1] 中列出的所有规则。

PSR-1 中的术语 ‘StudlyCaps’ 必须解释为 PascalCase （帕斯卡命名法：大驼峰式命名法），
其中每个单词的第一个字母大写，包括第一个字母。

**2.2 文件**

所有 PHP 文件只能使用 Unix LF (换行符) 结尾。

所有的 PHP 文件都必须以非空行结尾，以一个 LF 结尾。

在仅包含 PHP 代码的文件中，必须省略结尾的 `?>` 标记。

**2.3 代码行**

行长度不得有硬限制。

行长度的软限制必须为 120 个字符。

行的长度不应超过 80 个字符；超过该长度的行应拆分为多个后续行，每个行的长度不应超过 80 个字符。

行尾不能有尾随空格。

可以添加空行以提高可读性并指示相关的代码块，除非明确禁止。

每行不能有多个语句。

**2.4 缩进**

代码必须为每个缩进级别使用 4 个空格的缩进，并且不能使用缩进标签。

**2.5 关键词和类型**

PHP 的所有关键字和类型 都必须使用小写。

PHP 未来版本中新加的所有关键字和类型也都必须使用小写。

类型关键字必须使用缩写。使用 `bool` 而不是 `boolean`，使用 `int` 而不是 `integer` 等等。

**3. 声明、命名空间以及导入**

一个 PHP 文件的头部可能会包含多个块。如果包含多个块，则每个块都必须用空白行和其他块分隔，并且块内不能包含空白行。
所有的块都必须按照下面的顺序排列，如果不存在该块则忽略。

* PHP 文件开始标签： <?php。
* 文件级文档块。
* 一个或多个声明语句。
* 命名空间声明语句。
* 一个或多个基于类的 use 声明语句。
* 一个或多个基于方法的 use 声明语句。
* 一个或多个基于常量的 use 声明语句。
* 其余代码。

当文件包含 HTML 和 PHP 的混合代码时，可以使用上面列出的任何部分。如果是这种情况的话，
即时代码的其他部分包含有 PHP 结束符，然后再包含 HTML 和 PHP 代码，声明、命名空间和导入语句块也必须放在文件的顶部。

什么时候开始 `<？php` 标签位于文件的第一行，它必须位于自己的行，没有其他语句，
除非它是一个包含 PHP 之外的标记的文件打开和关闭标记。

import 语句不能以前导反斜杠开头，因为它们必须始终完全合格。

以下示例演示了所有块的完整列表：
```php
<?php

/**
 * This file contains an example of coding styles.
 */

declare(strict_types=1);

namespace Vendor\Package;

use Vendor\Package\{ClassA as A, ClassB, ClassC as C};
use Vendor\Package\SomeNamespace\ClassD as D;
use Vendor\Package\AnotherNamespace\ClassE as E;

use function Vendor\Package\{functionA, functionB, functionC};
use function Another\Vendor\functionD;

use const Vendor\Package\{CONSTANT_A, CONSTANT_B, CONSTANT_C};
use const Another\Vendor\CONSTANT_D;

/**
 * FooBar is an example class.
 */
class FooBar
{
    // ... 其他php代码 ...
}
```

深度不能超过两层的复合名称空间，因此以下展示了允许的最大复合深度。
```php
<?php

use Vendor\Package\SomeNamespace\{
    SubnamespaceOne\ClassA,
    SubnamespaceOne\ClassB,
    SubnamespaceTwo\ClassY,
    ClassZ,
};
```

并且不允许以下内容:
```php
<?php

use Vendor\Package\SomeNamespace\{
    SubnamespaceOne\AnotherNamespace\ClassA,
    SubnamespaceOne\ClassB,
    ClassZ,
};
```

当希望在 PHP 外部包含标记的文件中声明严格类型时打开和关闭标签，
声明必须写在文件的第一行并且包含在一个开始的 PHP 标签，以及严格的类型声明和结束标签。

例如:
```php
<?php declare(strict_types=1) ?>
<html>
<body>
    <?php
        // ... 其他 PHP 代码  ...
    ?>
</body>
</html>
```

声明语句不能包含空格，并且必须完全是 `declare(strict_types=1)` (带有可选的分号终止符)。

允许使用块声明语句，并且必须按照以下的格式设置。注意的位置括号和间距：
```
declare(ticks=1) {
    // 一些代码
}
```

**4. 类，属性，和方法**

这里的『类』指的是所有类，接口，以及 trait 。

任何注释和语句 不得 跟在其右花括号后的同一行。

当实例化一个类时，后面的圆括号 必须 写出来，即使没有参数传进其构造函数。

```
new Foo();
```

**4.1 继承和实现**

关键字 继承 和 实现 必须 在类名的同一行声明。

类的左花括号 必须 另起一行；右花括号 必须 跟在类主体的下一行。

类的左花括号 必须 独自成行，且 不得 在其上一行或下一行存在空行。

右花括号 必须 独自成行，且 不得 在其上一行存在空行。

```php
<?php

namespace Vendor\Package;

use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;

class ClassName extends ParentClass implements \ArrayAccess, \Countable
{
    // 常量，属性，方法
}
```

如果有接口， 实现 接口和 继承父类 可以 分为多行，前者每行需缩进一次。
当这么做时，第一个接口 必须 写在下一行，且每行 必须 只能写一个接口。

```php
<?php

namespace Vendor\Package;

use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;

class ClassName extends ParentClass implements
    \ArrayAccess,
    \Countable,
    \Serializable
{
    // 常量，属性，方法
}
```

**4.2 使用 trait**

在类里面用于实现 trait 的关键字 use 必须 在左花括号的下一行声明。

```php
<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;

class ClassName
{
    use FirstTrait;
}
```

每个导入类的 trait 必须 每行一个包含声明，且每个包含声明 必须 有其 use 导入语句。

```php
<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;
use Vendor\Package\SecondTrait;
use Vendor\Package\ThirdTrait;

class ClassName
{
    use FirstTrait;
    use SecondTrait;
    use ThirdTrait;
}
```

在类文件中，如果在使用 'use Trait' 之后没有其他内容了 ，类名右大括号必须另起一行。

```php
<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;

class ClassName
{
    use FirstTrait;
}
```

如有其他内容，两者之间需空一行。

```php
<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;

class ClassName
{
    use FirstTrait;

    private $property;
}
```

当使用 `insteadof` 和 `as` 运算符时，它们必须如图所示使用，注意缩进、间距和另起一行。

```php
<?php

class Talker
{
    use A, B, C {
        B::smallTalk insteadof A;
        A::bigTalk insteadof C;
        C::mediumTalk as FooBar;
    }
}
```

**4.3 属性和常量**

所有属性 必须 声明可见性。

如果你的项目 PHP 最小版本支持常量可见性（ PHP 7.1 或以上），所有常量 必须 声明可见性。

关键字 var 不得 用于声明属性。

每条声明语句 不得 声明多于一个属性。

属性名 不得 用单个下划线开头表明其受保护的或私有的可见性。也就是说，一个下划线开头显然是没有意义的。

类型声明和属性名之间 必须 有一个空格。

一个属性声明看上去如下所示：
```php
<?php

namespace Vendor\Package;

class ClassName
{
    public $foo = null;
    public static int $bar = 0;
}
```

**4.4 方法和函数**

所有的方法 必须 事先声明类型。

方法命名 一定不可 用单个下划线来区分是 protected 或 private 类型。也就是说，不要用一个没有意义的下划线开头。

方法和函数名称中，方法命名后面 一定不可 使用空格。方法开始的花括号 必须 写在方法声明后自成一行， 
结束花括号也 必须 写在方法后面自成一行。开始左括号后和结束右括号前，都 一定不可 有空格符。

一个方法的声明应该如下所示。注意括号，逗号，空格和花括号的位置：
```php
<?php

namespace Vendor\Package;

class ClassName
{
    public function fooBarBaz($arg1, &$arg2, $arg3 = [])
    {
        // 方法主体
    }
}
```

一个函数的声明应该如下所示。注意括号，逗号，空格和花括号的位置：
```php
<?php

function fooBarBaz($arg1, &$arg2, $arg3 = [])
{
    // 函数主体
}
```

**4.5 方法和函数参数**

在参数列表中， 不得 在每个逗号前存在空格，且 必须 在每个逗号后有一个空格。

方法和函数中带有默认值的参数 必须 放在参数列表的最后。

```php
<?php

namespace Vendor\Package;

class ClassName
{
    public function foo(int $arg1, &$arg2, $arg3 = [])
    {
        // 方法主体
    }
}
```

参数列表 可以 分为多行，每行参数缩进一次。当这么做时，第一个参数 必须 放在下一行，且每行 必须 只能有一个参数。

当参数列表分成多行时，右圆括号和左花括号 必须 放在同一行且单独成行，两者之间存在一个空格。

```php
<?php

namespace Vendor\Package;

class ClassName
{
    public function aVeryLongMethodName(
        ClassTypeHint $arg1,
        &$arg2,
        array $arg3 = []
    ) {
        // 方法主体
    }
}
```

当你定义一个返回值类型声明时，冒号后面的类型声明 必须 用空格符隔开。
冒号和声明 必须 在同一行，且跟参数列表后的结束括号之间没有空格。

```php
<?php

declare(strict_types=1);

namespace Vendor\Package;

class ReturnTypeVariations
{
    public function functionName(int $arg1, $arg2): string
    {
        return 'foo';
    }

    public function anotherFunction(
        string $foo,
        string $bar,
        int $baz
    ): string {
        return 'foo';
    }
}
```

在可空类型声明中，问号和类型声明之间不能有空格。

```php
<?php

declare(strict_types=1);

namespace Vendor\Package;

class ReturnTypeVariations
{
    public function functionName(?string $arg1, ?int &$arg2): ?string
    {
        return 'foo';
    }
}
```

当在参数之前使用引用运算符 `&` 时，引用运算符之后不能有空格，例如上面的示例。

可变参数声明的三个点和参数名称之间不能有空格：
```
public function process(string $algorithm, ...$parts)
{
    // 函数体
}
```

当同时使用引用运算符和可变参数运算符时，它们之间不能有任何空格：
```
public function process(string $algorithm, &...$parts)
{
    // 函数体
}
```

**4.6 abstract, final, and static**

如果是 `abstract` and `final` ，那么申明的时候必须是可见性声明。

如果是 `static` ，声明必须位于可见性声明之后。

```php
<?php

namespace Vendor\Package;

abstract class ClassName
{
    protected static $foo;

    abstract protected function zim();

    final public static function bar()
    {
        // 请求体
    }
}
```

**4.7 方法和函数的调用**

当我们在进行方法或者函数调用的时候，方法名或函数名与左括号之间不能出现空格，在右括号之后也不能出现空格，
并且在右括号之前也不能有空格。在参数列表中，每个逗号前面不能有空格，每个逗号后面必须有一个空格。

```php
<?php

bar();
$foo->bar($arg1);
Foo::bar($arg2, $arg3);
```

参数列表可以分为多行，每行后面缩进一次。这样做时，列表中的第一项必须位于下一行，并且每一行必须只有一个参数。
跨多个行拆分单个参数 (就像匿名函数或者数组那样) 并不构成拆分参数列表本身。

```php
<?php

$foo->bar(
    $longArgument,
    $longerArgument,
    $muchLongerArgument
);
```

```php
<?php

somefunction($foo, $bar, [
  // ...
], $baz);

$app->get('/hello/{name}', function ($name) use ($app) {
    return 'Hello ' . $app->escape($name);
});
```

**5. 流程控制**

如下是主要的流程控制风格规则：

    流程控制关键词之后 必须 要有一个空格
    左括号后面 不能 有空格
    右括号前面 不能 有空格
    右括号与左大括号之间 必须 要有一个空格
    流程主体 必须 要缩进一次
    流程主体 必须 在左大括号之后另起一行
    右大括号 必须 在流程主体之后另起一行

每个流程控制主体 必须 以封闭的括号结束。这将标准化流程结构，同时减少由于流程中添加新的内容而引入错误的可能性。

**5.1 if, elseif, else**

`if` 结构如下。注意括号，空格，和大括号的位置；`else` 和 `elseif` 都在同一行，和右大括号一样在主体的前面。

```php
<?php

if ($expr1) {
    // if body
} elseif ($expr2) {
    // elseif body
} else {
    // else body;
}
```

应该 使用关键词 `elseif` 替换 `else if`，这样所有的控制关键词看起来都像单个词。

括号中的表达式 可能 会被分开为多行，每一行至少缩进一次。如果这样做，第一个条件 必须 在新的一行。
右括号和左大括号 必须 在同一行，而且中间有一个空格。条件中间的布尔控制符 必须 在每一行的开头或者结尾，而不是混在一起。

```php
<?php

if (
    $expr1
    && $expr2
) {
    // if body
} elseif (
    $expr3
    && $expr4
) {
    // elseif body
}
```

**5.2 switch, case**

`switch` 结构如下。注意括号，空格和大括号的位置。
`case` 必须 缩进一次，从 `switch` 开始， `break` 关键词 (或者其他终止关键词) 必须 缩进和 `case` 主体保持一致。
必须 要有一个像 `// no break` 这样的注释在不为空且不需要中断的 `case` 主体之中。

```php
<?php

switch ($expr) {
    case 0:
        echo 'First case, with a break';
        break;
    case 1:
        echo 'Second case, which falls through';
        // no break
    case 2:
    case 3:
    case 4:
        echo 'Third case, return instead of break';
        return;
    default:
        echo 'Default case';
        break;
}
```

括号中的表达式 可能 会被分开多行，每一行至少要缩进一次。如果这样做，第一个条件 必须 在新的一行。
右括号和左大括号 必须 在同一行，而且中间有一个空格。条件中间的布尔控制符 必须 在一行的开头或者结尾，而不是混在一起。

```php
<?php

switch (
    $expr1
    && $expr2
) {
    // structure body
}
```

5.3 while, do while

`while` 结构如下。注意括号，空格和大括号的位置。

```php
<?php

while ($expr) {
    // structure body
}
```

括号中的表达式 可能 会被分开多行，每一行至少要缩进一次。如果这样做，第一个条件 必须 在新的一行。
右括号和左大括号 必须 在同一行，而且中间有一个空格。条件中间的布尔控制符 必须 在每一行的开头或者结尾，而不是混在一起。

```php
<?php

while (
    $expr1
    && $expr2
) {
    // structure body
}
```

同样的， `do while` 申明如下。注意括号，空格和大括号的位置。

```php
<?php

do {
    // structure body;
} while ($expr);
```

括号中的表达式 可能 会被分开多行，每一行至少要缩进一次。如果这样做，第一个条件 必须 在新的一行。
条件中间的布尔控制符 必须 在每一行的开头或者结尾，而不是混在一起。

```php
<?php

do {
    // structure body;
} while (
    $expr1
    && $expr2
);
```

**5.4 for**

`for` 申明如下。注意括号，空格和大括号的位置。

```php
<?php

for ($i = 0; $i < 10; $i++) {
    // for body
}
```

括号中的表达式 可能 会被分开多行，每一行至少要缩进一次。如果这样做，第一个条件 必须 在新的一行。
右括号和左大括号 必须 在同一行，而且中间有一个空格。

```php
<?php

for (
    $i = 0;
    $i < 10;
    $i++
) {
    // for body
}
```

**5.5 foreach**

`foreach` 语句的写法如下所示。请注意它的圆括号、空格和花括号。

```php
<?php

foreach ($iterable as $key => $value) {
    // 迭代主体
}
```

**5.6 try ， catch ， finally**

一个 try-catch-finally 模块包含下面这些内容。请注意它的圆括号、空格和花括号。

```php
<?php

try {
    // try 主体
} catch (FirstThrowableType $e) {
    // 捕获异常主体
} catch (OtherThrowableType | AnotherThrowableType $e) {
    // 捕获异常主体
} finally {
    // finally 主体
}
```

**6. 运算符**

运算符的样式规则按元数分组（其接受的操作数个数）。

当运算符周围允许出现空格时， 可以 出于可读性目的打多个空格。

所有这里没描述的运算符暂不作限定。

**6.1. 一元运算符**

递增 / 递减运算符和操作数之间 不得 有任何空格。

```
$i++;
++$j;
```

类型转换运算符的圆括号内部 不得 有任何空格：
```
$intValue = (int) $input;
```

**6.2. 二元运算符**

所有二进制 算术，比较，赋值，按位，逻辑、字符串和类型运算符必须在前后跟至少一个空格：
```
if ($a === $b) {
    $foo = $bar ?? $a ?? $b;
} elseif ($a > $b) {
    $foo = $a + $b * $c;
}
```

**6.3. 三元运算符**

条件运算符，也称为三元运算符，必须在 `?` 和 `:` 这两个字符之间：
```
$variable = $foo ? 'foo' : 'bar';
```

如果省略条件运算符的中间操作数，运算符必须遵循与其他二进制比较运算符相同的样式规则：
```
$variable = $foo ?: 'bar';
```

**7. 闭包（Closures）**

闭包声明时必须在 `function` 关键字后留有 1 个空格，并且在 `use` 关键字前后各留有 1 个空格。

左花括号必须跟随前文写在同一行，右花括号必须在函数体后换行放置。

不能在参数和变量的左括号后和右括号前放置空格。

不能在参数和变量的逗号前放置空格，但必须在逗号后放置 1 个空格。

闭包参数如果有默认值，该参数必须放在参数列表末尾。

如果声明了返回类型，它必须遵循普通函数和方法相同的规则；如果使用 `use` 关键字，冒号必须在 `use` 右括号后，且冒号前不能有空格。

闭包的声明方式如下，留意括号，逗号，空格和花括号：
```php
<?php

$closureWithArgs = function ($arg1, $arg2) {
    // 函数体
};

$closureWithArgsAndVars = function ($arg1, $arg2) use ($var1, $var2) {
    // 函数体
};

$closureWithArgsVarsAndReturn = function ($arg1, $arg2) use ($var1, $var2): bool {
    // 函数体
};
```

参数和变量可以分多行放置，每个后续行缩进一次。执行此操作时，列表中的第一项必须放在下一行，并且每行只能有一个参数或变量。

结束多行列表（或者参数，变量）的时候，右括号和左大括号 必须 要放在一行，而且中间有一个空格。

下面是有和没有多行参数列表与变量列表的闭包示例。
```php
<?php

$longArgs_noVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) {
   // body
};

$noArgs_longVars = function () use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // body
};

$longArgs_longVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // body
};

$longArgs_shortVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) use ($var1) {
   // body
};

$shortArgs_longVars = function ($arg) use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // body
};
```

注意格式化规则也适用一个闭包在一个方法或者操作中作为参数被直接引用。

```php
<?php

$foo->bar(
    $arg1,
    function ($arg2) use ($var1) {
        // body
    },
    $arg3
);
```

**8. 匿名类**

匿名类 必须 遵循上面章节中和闭包一样的方针和准则。

```php
<?php

$instance = new class {};
```

只要 `implements` 接口列表不换行，左花括号 可以 和关键字 `class` 在同一行。
如果接口列表换行，花括号 必须 放在最后一个接口的下一行。

```php
<?php

// 花括号在同一行
$instance = new class extends \Foo implements \HandleableInterface {
    // 类内容
};

// 花括号在下一行
$instance = new class extends \Foo implements
    \ArrayAccess,
    \Countable,
    \Serializable
{
    // 类内容
};
```



### PSR-16 缓存接口 

缓存库公共接口

本文档描述了一个简单也易扩展的接口，针对缓存项目和缓存驱动。

本文档中的关键字「必须」、「不得」、「要求」、「应」、「不应」、「应该」、「不应该」、「推荐」、「可能」、「可选」，
使用 RFC 2119 中的描述进行解释。

最终的实现相比本提议可能会有更多功能，当然它们必须首先实现指明的接口、功能。

1、 规范

1.1 简介

使用缓存是提升项目性能的通用方法，这使得缓存功能成为许多框架和库最常见的功能之一。
如果各个缓存库提供相同的使用接口，意味着库可以丢弃他们自己的缓存实现方式，
然后方便的使用框架中的缓存功能，或者使用其他专门的缓存库。

PSR-6 已经解决了这个问题，但是在一些简单的用例中显得过于繁琐。这个标准为大部分情况构建更加简单的接口标准。
它独立于 PSR-6，但尽可能的兼容 PSR-6。

1.2 定义

* 调用库，实现库，TTL，过期和 Key 都是从 PSR-6 复制而来，因为他们意义相同。

* 调用库 - 需要使用缓存服务的库或者代码。调用库会使用实现了该标准（PSR-16）接口的缓存服务，但不必知道这些缓存服务的具体实现方式。

* 实现库 - 实现库负责实现这个标准（PSR-16），以便为调用库提供缓存服务。
实现库 必须 提供实现了 `Psr\SimpleCache\CacheInterface` 接口的类。实现库 必须 以整数秒（s）作为缓存有效时长（TTL）的最小粒度。

* 有效时长（TTL）- 有效时长 (TTL) 是指一个缓存项从存储到过期的时间长度。TTL 一般用以秒为单位的整数或者 `DateInterval` 实例对象表示。

* 过期（Expiration） - 过期是指一个缓存项过期的具体时间。它通过缓存项保存时指定的有效时长（TTL）计算得到。
如果一个存储项在 1:30:00 存储，有效时长（TTL）为 300 秒，那么这个存储项会在 1:35:00 过期（Expiration）。

实现库 可以 让一个缓存项提前过期，但缓存项一旦到了过期时间就 必须 作为已过期处理。
如果调用库存储一个缓存项时没有设置过期时间或者有效时长，或者设置为了 null，实现库 可以 指定默认值。
如果没有设置默认值，实现库 必须 把该缓存项设置为永不过期，或者过期时长设置为系统所支持的最大长度。

如果有效时长（TTL）被设置为负数或者 0，该缓存项 必须 从缓存中删除使之失效。

* Key - 用于指定缓存项唯一性的字符串，至少一个字符长度。实现库 必须 支持由 `A-Z`，`a-z`，`0-9`，`_` 和 `.` 
以任意顺序并使用 UTF-8 编码组成的字符串作为 Key，支持的长度需要达到 64 个字符长度。
实现库 可以 支持额外的字符和字符编码，或者支持更长的字符长度，但上面所说的必须支持。
实现库存储时允许根据需要对 Key 的字符进行转义处理，但 必须 能够返回未经处理过的原始 Key 字符串。
以下字符作为保留字段，实现库 必须不能 使用它们：`{}()/\@:`

* 缓存（Cache）- 实现了 `Psr\SimpleCache\CacheInterface` 接口的对象。

* 缓存未命中（Cache Misses） - 缓存未命中时会返回 `null`，因此检查一个缓存项保存的值是否为 `null` 是不可能的。
这是跟 PSR-6 主要的不同点。

1.3 缓存

如果对一个特定的缓存条目没有指定一个默认的 TTL，实现 可以 提供一个用户指定的机制。
如果未提供用户指定的默认值，则实现 必须 默认为底层实现提供一个允许的最大合法值。
如果底层实现不支持 TTL，则用户指定的 TTL 必须 静默忽略。

1.4 数据

实现库 必须 支持所有序列化的 PHP 数据类型，包括：

* Strings - 任何 PHP 兼容编码中的任意大小的字符串。
* Integers - PHP 支持的任何大小的所有整数，高达 64 位的签名。
* Floats - 所有签名的浮点值。
* Boolean - True 和 False。
* Null - 空值（尽管它当从一个未命中的缓存中读取时不能区分）。
* Arrays - 索引，关联和任意深度的的多维数组。
* Object - 任何支持像这样 `$o == unserialize(serialize($o))` 无损序列化和反序列化的对象。
对象 可以 利用 PHP 的可序列化接口，`__sleep()` 和 `__wakeup()` 魔术方法，或者相似语言的功能，如果合适的话。

传递到实现库中的所有数据 必须 完全按照传递的方式返回。这包括变量类型。
也就是说，如果 (int)5 是要保存的值，返回 (string)5 的将是错误的。
实现库 可以 使用 PHP 内置的 serialize ()/unserialize () 方法，但不需要这么做。
与它们兼容被简单用作可接受对象值的基线。

如果由于任何原因无法返回确切要保存的值，实现库 必须 响应缓存未命名而不是损坏的数据。

2、 接口列表

2.1 CacheInterface 接口

缓存接口定义了基于缓存实体的最基本的操作，其包括读写和删除单个缓存项目。

另外该接口还定义了处理多个缓存项目的方法，如：一次性写入，读取，删除多个项目的操作。
当你需要执行大量的读 / 写操作时很有用，仅仅一个单次访问缓存服务器便可执行操作多个项目，从而显著的减少延迟时间。

一个 CacheInterface 实例对应一个拥有单个键命令空间的缓存集合，其等价于在 PSR-6 中的 “Pool”，
不同的 CacheInterface 实例可以被相同的 datastore 支持，但必须有在逻辑上是独立的。

```php
<?php

namespace Psr\SimpleCache;

interface CacheInterface
{
    /**
     * 从缓存中取出值
     *
     * @param string $key     该项在缓存中唯一的key值
     * @param mixed  $default key不存在时，返回的默认值
     *
     * @return mixed 从缓存中返回的值，或者是不存在时的默认值
     *
     * @throws \Psr\SimpleCache\InvalidArgumentException
     *   如果给定的key不是一个合法的字符串时，抛出该异常
     */
    public function get($key, $default = null);

    /**
     * 存储值在cache中，唯一关键到一个key及一个可选的存在时间
     *
     * @param string                 $key   存储项目的key.
     * @param mixed                  $value 存储的值，必须可以被序列化的
     * @param null|int|\DateInterval $ttl   可选项.项目的存在时间，如果该值没有设置，且驱动支持生存时间时，将设置一个默认值，或者驱自行处理。
     *
     * @return bool true 存储成功  false 存储失败
     *
     * @throws \Psr\SimpleCache\InvalidArgumentException
     *  如果给定的key不是一个合法的字符串时，抛出该异常。
     */
    public function set($key, $value, $ttl = null);

    /**
     * 删除指定键值的缓存项
     *
     * @param string $key 指定的唯一缓存key对应的项目将会被删除
     *
     * @return bool 成功删除时返回ture，有其它错误时时返回false
     *
     * @throws \Psr\SimpleCache\InvalidArgumentException
     *   如果给定的key不是一个合法的字符串时，抛出该异常。
     */
    public function delete($key);

    /**
     * 清除所有缓存中的key
     *
     * @return bool 成功返回True.失败返回False
     */
    public function clear();

    /**
     * 根据指定的缓存键值列表获取得多个缓存项目
     *
     * @param iterable $keys   在单次操作中可被获取的键值项
     * @param mixed    $default 如果key不存在时，返回的默认值
     *
     * @return iterable  返回键值对（key=>value形式）列表。如果key不存在，或者已经过期时，返回默认值。
     *
     * @throws \Psr\SimpleCache\InvalidArgumentException
     *  如果给定的keys既不是合法的数组，也不可以被转成数组，或者给得的任何一个key不是一个合法的值时，拖出该异常。
     */
    public function getMultiple($keys, $default = null);

    /**
     * 存储一个键值对形式的集合到缓存中。
     *
     * @param iterable               $values 一系列操作的键值对列表
     * @param null|int|\DateInterval $ttl     可选项.项目的存在时间，如果该值没有设置，且驱动支持生存时间时，将设置一个默认值，或者驱自行处理。
     *
     * @return bool 成功返回True.失败返回False.
     *
     * @throws \Psr\SimpleCache\InvalidArgumentException
     *   如果给定的keys既不是合法的数组，也不可以被转成数组，或者给得的任何一个key不是一个合法的值时，拖出该异常.
     */
    public function setMultiple($values, $ttl = null);

    /**
     *  单次操作删除多个缓存项目.
     *
     * @param iterable $keys 一个基于字符串键列表会被删除
     *
     * @return bool True 所有项目都成功被删除时回true,有任何错误时返回false
     *
     * @throws \Psr\SimpleCache\InvalidArgumentException
     *   如果给定的keys既不是合法的数组，也不可以被转成数组，或者给得的任何一个key不是一个合法的值时，拖出该异常.
     */
    public function deleteMultiple($keys);

    /**
     * 判断一个项目在缓存中是否存在
     *
     * 注意: has()方法仅仅在缓存预热的场景被推荐使用且不允许的活跃     * 的应用中场景中对get/set方法使用, 因为方法受竞态条件的限制，当     * 你调用has()方法时会立即返回true。另一个脚本可以删除它，使应     * 用状态过期。
     * @param string $key 缓存键值
     *
     * @return bool  
     *
     * @throws \Psr\SimpleCache\InvalidArgumentException
     *    如果给定的key不是一个合法的字符串时，抛出该异常.
     */
    public function has($key);
}
```

2.2 CacheException

```php
<?php

namespace Psr\SimpleCache;

/**
 * 库抛出异常的接口，用于所有类型异常。
 */
interface CacheException
{
}
```

2.3 InvalidArgumentException

```php
<?php

namespace Psr\SimpleCache;

/**
 * 无效缓存参数异常的接口。
 *
 * 当传递一个无效参数时，必须抛出一个实现了此接口的异常。
 */
interface InvalidArgumentException extends CacheException
{
}
```

###  PSR-16 缓存接口 - 说明文档 

1、 概要

使用缓存是提升项目性能的通用方法，这使得缓存功能成为许多框架和库最常见的功能之一。
如果各个缓存库提供相同的使用接口，意味着库可以丢弃他们自己的缓存实现方式，
然后方便的使用框架中的缓存功能，或者使用其他专门的缓存库。

2、 为什么要这么麻烦？

PSR-6 已经解决了这个问题，但是在一些简单的用例中显得过于繁琐。这个标准在 PSR-6 基础上构建更加简单的接口标准。

3、 范围

3.1 目标

    一个简单的缓存操作接口.
    提供有关性能 (往返时间) 原因的多键操作的基本支持.
    提供一个能将 PSR-6 实现转换为 PSR 简单缓存的适配器模式.
    很有可能将所有的缓存 PSRs 从缓存库公开.

3.2 非目标

    解决了所有可能的极端情况，PSR-6 已经做得很好了.

4、 方法

在设计上，实现的方法是贫乏的，因为它只在最简单的场景中使用。它无需被所有的缓冲后端实现，也无需在所有的场景中使用。
它只是在 PSR-6 的基础上提供了简便的封装。

5、 人物

5.1 编辑

    Paul Dragoonis (@dragoonis)

5.2 赞助商

    Jordi Boggiano (@seldaek) - Composer (Coordinator)
    Fabien Potencier (@fabpot) - Symfony

5.3 贡献者

以下名单编写了这个 PSR 缓存标准的草案：

    Evert Pot (@evert)
    Florin Pățan (@dlsniper)

以下名单是早期的审稿人

    Daniel Messenger (@dannym87)

6、 投票

    投票入口: groups.google.com/d/topic/php-fig/...
    接受投票: groups.google.com/d/msg/php-fig/A8...

7、 相关链接

    现存各种缓存实现方案调查 , by @dragoonis








## 参考资料

PHP PSR 标准规范 <https://learnku.com/docs/psr>

PSR-0: Autoloading Standard <https://www.php-fig.org/psr/psr-0/>

PSR-1 基础编码规范 <https://laravel-china.org/topics/2078>

PEAR 编码准则 <https://pear.php.net/manual/en/standards.php>

Symfony 编码准则 <https://symfony.com/doc/current/contributing/code/standards.html>

PHP中PSR-[0-4]规范：<http://m.blog.csdn.net/article/details?id=42844391>

PHP中PSR-[0-4]规范：<https://www.zybuluo.com/phper/note/65033>

php trait 冲突的解决 insteadof <https://blog.csdn.net/zmzwll1314/article/details/91417628>

