---
layout: post
categories: PHP
title: PHP 基本数据结构和算法
meta: PHP 基本数据结构和算法
---
* content
{:toc}

### 正文

#### 1、二分查找

```php
/**
 * 二分查找（数组里查找某个值的键），也叫半分法
 * @param $array 给定数组
 * @param $low 最小键，开始位置
 * @param $high 最大键，结束位置
 * @param $value 要查找的值
 * @return int
 */
function binary_search($array, $low, $high, $value)
{
     if ( $low <= $high ) {
          $mid = intval( ($low+$high)/2 );
          if ( $array[$mid] == $value ) {
               return $mid;
          } elseif ( $value < $array[$mid] ) {
               return binary_search ( $array, $low, $mid-1, $value );
          } else {
               return binary_search ( $array, $mid+1, $high, $value );
          }
     }
     
     return -1;
}
```

举例：

```php
$array = array(2, 4, 6, 8, 10, 12, 14);
$key = binary_search($array, 2, 7 , 8);
echo $key;     // 输出 3 
```

特别说明，$value必须在数组$low与$high的值之间存在，否则都返回-1。

这里看到数组要是排好序的，如果是乱序的，可以用下面的函数排序（除了数字，也可对字符排序）：
```
sort() - 对数组进行升序排列
rsort() - 对数组进行降序排列
```

#### 2、顺序查找

```php
/**
 * 顺序查找（数组里查找某个值的键）
 * @param $array 给定数组
 * @param $high 最大键，结束位置
 * @param $value 要查找的值
 * @return int
 */
function sequence_search($array, $high, $value)
{
     $array[$high] = $value;
     for( $i=0; $i < $high; $i++)
     {
          if ($array[$i] == $value) {
               break;
          }
     }
     if ($i < $high) {
          return $i;
     } else {
          return -1;
     }
} 
```

举例：

```php
$array = array(2, 4, 6, 8, 10);
$key = sequence_search($array, 3, 6);
echo $key;   // 输出 2 
```

特别说明，在数组的$n键之前找到$value 。

#### 3、线性表的删除

```php
/**
 * 线性表的删除（数组中实现）,删除数组中指定的键的值
 * @param $array
 * @param $i
 * @return mixed
 */
function delete_array_element($array, $i)
{
    $len = count($array);
    for ( $j = $i; $j < $len; $j++ )
    {
        $array[ $j ] = $array [ $j + 1 ];
    }
    array_pop($array);

    return $array;
}
```

举例：

```php
$array = array(2, 4, 6, 8, 10);
$array = delete_array_element($array, 2);
print_r($array); // 输出 Array ( [0] => 2 [1] => 4 [2] => 8 [3] => 10 ) 
```

#### 4、冒泡排序

```
/**
 * 冒泡排序（数组排序）
 * @param $array
 * @return bool
 */
function bubble_sort($array)
{
    $count = count($array);
    if ($count <= 0) {
        return false;
    }
    for ($i = 0 ; $i < $count; $i++)
    {
        for ($j = $count - 1; $j > $i; $j--)
        {
            if ($array[$j] < $array[$j - 1]) {
                $tmp = $array[$j];
                $array[$j] = $array[$j - 1];
                $array[$j - 1] = $tmp;
            }
        }
    }

    return $array;
}
```

举例：

```php
$array = array(8, 4, 10, 2, 6);
$array = bubble_sort ( $array );
print_r($array); // 输出 Array ( [0] => 2 [1] => 4 [2] => 6 [3] => 8 [4] => 10 ) 

/**打印一下过程**/ 
0  1  2  3  4  -> 0  1  2  3  4  
// $i = 0
8, 4, 10, 2, 6 -> 8, 4, 10, 2, 6  // $j = 4
8, 4, 10, 2, 6 -> 8, 4, 2, 10, 6  // $j = 3
8, 4, 2, 10, 6 -> 8, 2, 4, 10, 6  // $j = 2
8, 2, 4, 10, 6 -> 2, 8, 4, 10, 6  // $j = 1

// $i = 1
2, 8, 4, 10, 6 -> 2, 8, 4, 6, 10  // $j = 4
2, 8, 4, 6, 10 -> 2, 8, 4, 6, 10  // $j = 3
2, 8, 4, 6, 10 -> 2, 4, 8, 6, 10  // $j = 2

// $i = 2
2, 4, 8, 6, 10 -> 2, 4, 8, 6, 10  // $j = 4
2, 4, 8, 6, 10 -> 2, 4, 6, 8, 10  // $j = 3

// $i = 3
2, 4, 6, 8, 10 -> 2, 4, 6, 8, 10  // $j = 4

// $i = 4
// $j = 4 for循环不进入

// $i = 5 for循环不进入


总结可以看出，就是小的不断往前排，最小的先到最前面。大的数，每次i循环，向后走一步。
```

特别说明，里面有两次循环，内层循环的目的是把最小的数向最前面互换，外层循环的目的是把最前面最小的数跳过，然后用内层循环选择后面最小的数。

还有下面这种思路，从前往后开始排序：
```
/**
 * 冒泡排序（数组排序）
 * @param $array
 * @return bool
 */
function bubble_sort($array)
{
    $count = count($array);
    if ($count <= 0) {
        return false;
    }
    for($i = 0 ; $i < $count; $i++)
    {
        $j = $i;
        while($j > 0)
        {
            if ($array[$j] < $array[$j - 1]) {
                $tmp = $array[$j];
                $array[$j] = $array[$j - 1];
                $array[$j - 1] = $tmp;
                $j--;
            } else {
                break;
            }
        }
    }

    return $array;
}
```

同样的原理，只是把while换成了for：
```
function bubble_sort($array)
{
    $count = count($array);
    if ($count <= 0) {
        return false;
    }
    for($i = 0 ; $i < $count; $i++)
    {
        for($j = $i; $j > 0; $j--)
        {
            if ($array[$j] < $array[$j - 1]) {
                $tmp = $array[$j];
                $array[$j] = $array[$j - 1];
                $array[$j - 1] = $tmp;
            } else {
                break;
            }
        }
    }

    return $array;
}
```

#### 5、快速排序

```php
// 快速排序（数组排序）
function quick_sort ( $array )
{
     if ( count($array) <= 1 ) {
          return $array;
     }
     $key = $array [0];
     $left_arr = array();
     $right_arr = array();
     for ( $i= 1; $i < count($array); $i++ )
     {
          if ( $array[$i] <= $key ) {
               $left_arr[] = $array[$i];
          } else {
               $right_arr[] = $array[$i];
          }
     }
     $left_arr = quick_sort( $left_arr );
     $right_arr = quick_sort( $right_arr );
     return array_merge( $left_arr, array($key), $right_arr );
} 
```

举例：

```php
$array = array(8, 4, 10, 2, 6);
$array = quick_sort ( $array );
print_r($array); // 输出 Array ( [0] => 2 [1] => 4 [2] => 6 [3] => 8 [4] => 10 ) 
```

特别说明，里面用到了递归，核心思想是取一个数，划分左右，不断缩小，不断合并，然后排序完成。

#### 典型面试题

1、使对象可以像数组一样进行foreach循环，要求属性必须是私有。(Iterator模式的PHP5实现，写一类实现Iterator接口)。

```php
class Test implements Iterator
{
     private $item = array('id'=>1, 'name'=>'php');

     public function rewind ()
     {
          reset($this->item);
     }

     public function current ()
     {
          return current($this->item);
     }

     public function key ()
     {
          return key($this->item);
     }

     public function next ()
     {
          return next($this->item);
     }

     public function valid ()
     {
          return($this->current()!==false);
     }
}

//测试
$t = new Test;
foreach ( $t as $k => $v )
{
     echo $k,'--->',$v,'';
} 
```

输出：

id--->1

name--->php

2、用PHP实现一个双向队列。

```php
class Deque
{
     private $queue = array();

     public function addFirst ( $item )
     {
          return array_unshift( $this->queue, $item );
     }

     public function addLast ( $item )
     {
          return array_push( $this->queue, $item );
     }

     public function removeFirst ()
     {
          return array_shift( $this->queue );
     }

     public function removeLast ()
     {
          return array_pop( $this->queue );
     }
} 
```

<br/><br/><br/><br/><br/>
### 参考资料

<http://www.cnblogs.com/hellohell/p/5718175.html>

<http://m.blog.csdn.net/article/details?id=51174725>
