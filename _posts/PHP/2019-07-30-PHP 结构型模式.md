---
layout: post
categories: PHP
title: PHP 结构型模式
meta: PHP 结构型模式
---
* content
{:toc}

### 正文

结构型设计模式用于处理类和对象的组合。

#### 适配器模式(Adapter)

适配器模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。

// 设置书的接口
```
// 书接口
interface BookInterface
{
    // 翻页方法
    public function turnPage();

    // 打开书方法
    public function open();
}
```

```
// 纸质书实现类
class Book implements BookInterface
{
    public function turnPage()
    {
        echo "纸质书翻页". "<br>";
    }

    public function open()
    {
        echo "纸质书打开". "<br>";
    }
}
```

客户端测试：
```
// 客户端测试
$book = new Book();
$book->open();
$book->turnPage();
```

输出结果：
```
纸质书打开
纸质书翻页
```

这时候，你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。

如下：
```
// 待适配对象
class Kindle
{
    public function turnPage()
    {
        echo "电子书翻页". "<br>";
    }

    public function open()
    {
        echo "电子书打开". "<br>";
    }
}
```

// 适配器
```
class KindleAdapter implements BookInterface
{
    protected $_kindle;

    public function __construct($obj)
    {
        $this->_kindle = $obj;
    }


    public function turnPage()
    {
        $this->_kindle->turnPage();
    }

    public function open()
    {
        $this->_kindle->open();
    }
}
```

// 客户端测试
```
$kindle = new KindleAdapter(new Kindle());
$kindle->open();
$kindle->turnPage();
```

// 输出结果
```
电子书打开
电子书翻页
```

#### 桥接模式(Bridge)

桥接模式：将两个原本不相关的类结合在一起，然后利用两个类中的方法和属性，输出一份新的结果。

案例1. 模拟毛笔

需求：现在需要准备三种粗细（大中小），并且有五种颜色的笔

如果使用蜡笔，我们需要准备3*5=15支蜡笔，也就是说必须准备15个具体的蜡笔类。而如果使用毛笔的话，只需要3种型号的毛笔，
外加5个颜料盒，用3+5=8个类就可以实现15支蜡笔的功能。

实际上，蜡笔和毛笔的关键一个区别就在于笔和颜色是否能够分离。即将抽象化(Abstraction)与实现化(Implementation)脱耦，
使得二者可以独立地变化"。关键就在于能否脱耦。蜡笔由于无法将笔与颜色分离，造成笔与颜色两个自由度无法单独变化，
使得只有创建15种对象才能完成任务。而毛笔与颜料能够很好的脱耦（笔和颜色是分开的），抽象层面的概念是："毛笔用颜料作画"，
每个参与者（毛笔与颜料）都可以在自己的自由度上随意转换。

Bridge模式将继承关系转换为组合关系，从而降低了系统间的耦合，减少了代码编写量。

案例2. 模拟企业分组发短信

需求：公司现在需要按分组（临时工、正式工、管理层等）以多种形式（QQ、Email、微博等）给员工发送通知。


**适用性**：
1. 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。通过使用Bridge模式对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。
2. 不希望在抽象和它的实现部分之间有一个固定的绑定关系。
3. 一个构件有多于一个的抽象化角色和实现化角色，系统需要它们之间进行动态耦合。

**效果**：
1. Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。
2. 所谓抽象和实现沿着各自维度的变化，即“子类化”它们，得到各个子类之后，便可以任意它们，从而获得不同员工组和不同信息发送模式。
3. Bridge模式的应用一般在“两个非常强的变化维度”，有时候即使有两个变化的维度，
   但是某个方向的变化维度并不剧烈——换言之两个变化不会导致纵横交错的结果，并不一定要使用Bridge模式。


看一下示例实现

员工分组：
```
abstract class Staff
{
    abstract public function staffData();
}

class CommonStaff extends Staff
{
    public function staffData()
    {
        return "小名，小红，小黑";
    }
}

class VipStaff extends Staff
{
    public function staffData()
    {
        return '小星、小龙';
    }
}
```

发送形式：
```
// 抽象父类
abstract class SendType
{
    abstract public function send($to, $content);
}

class QQSend extends SendType
{
    public function __construct()
    {
        // 与QQ接口连接方式
    }

    public function send($to, $content)
    {
        return $content. '（To '. $to . ' From QQ）<br>';
    }
}
```

桥接容器：
```
class SendInfo
{
    protected $_level;
    protected $_method;

    public function __construct($level, $method)
    {
        //  这里可以使用单例控制资源的消耗
        $this->_level = $level;
        $this->_method = $method;
    }

    public function sending($content)
    {
        $staffArr = $this->_level->staffData();
        $result = $this->_method->send($staffArr, $content);
        echo $result;
    }
}
```

客户端调用：
```
$info = new SendInfo(new VipStaff(), new QQSend());
$info->sending( '回家吃饭');

$info = new SendInfo(new CommonStaff(), new QQSend());
$info->sending( '继续上班');
```

输出结果：
```
回家吃饭（To 小星、小龙 From QQ）
继续上班（To 小名，小红，小黑 From QQ）
```

从上面可以看出，如果增加分组或者是发送信息的类型，都可以直接创建一个类，来拓展，十分方便。

但是Bridge模式虽然是一个非常有用的模式，也非常复杂，它很好的符合了开放-封闭原则和优先使用对象，而不是继承这两个面向对象原则。

#### 组合模式（Composite）

* 模式定义

组合模式（Composite Pattern）有时候又叫做部分-整体模式，用于将对象组合成树形结构以表示“部分-整体”的层次关系。
组合模式使得用户对单个对象和组合对象的使用具有一致性。

常见使用场景：如树形菜单、文件夹菜单、部门组织架构图等。

* UML类图

![]({{site.baseurl}}/images/UML/Composite.png)

* 示例代码

FormElement.php
```php
<?php
namespace DesignPatterns\Structural\Composite;

/**
 * FormElement类
 */
abstract class FormElement
{
    /**
     * renders the elements' code
     *
     * @param int $indent
     *
     * @return mixed
     */
    abstract public function render($indent = 0);
}
```

Form.php
```php
<?php
namespace DesignPatterns\Structural\Composite;

/**
 * 组合节点必须实现组件接口，这对构建组件树而言是强制的
 */
class Form extends FormElement
{
    /**
     * @var array|FormElement[]
     */
    protected $elements;

    /**
     * 遍历所有元素并调用它们的render()方法, 然后返回返回完整的表单显示
     *
     * 但是从外部来看, 并没有看见组合过程, 就像是单个表单实例一样
     *
     * @param int $indent
     *
     * @return string
     */
    public function render($indent = 0)
    {
        $formCode = '';

        foreach ($this->elements as $element) {
            $formCode .= $element->render($indent + 1) . PHP_EOL;
        }

        return $formCode;
    }

    /**
     * @param FormElement $element
     */
    public function addElement(FormElement $element)
    {
        $this->elements[] = $element;
    }
}
```

InputElement.php
```php
<?php
namespace DesignPatterns\Structural\Composite;

/**
 * InputElement类
 */
class InputElement extends FormElement
{
    /**
     * 渲染input元素HTML
     *
     * @param int $indent
     *
     * @return mixed|string
     */
    public function render($indent = 0)
    {
        return str_repeat('  ', $indent) . '<input type="text" />';
    }
}
```

TextElement.php
```php
<?php
namespace DesignPatterns\Structural\Composite;

/**
 * TextElement类
 */
class TextElement extends FormElement
{
    /**
     * 渲染文本元素
     *
     * @param int $indent
     *
     * @return mixed|string
     */
    public function render($indent = 0)
    {
        return str_repeat('  ', $indent) . 'this is a text element';
    }
}
```

* 测试代码

Tests/CompositeTest.php
```php
<?php
namespace DesignPatterns\Structural\Composite\Tests;

use DesignPatterns\Structural\Composite;

/**
 * FormTest用于测试表单的组合模式
 */
class CompositeTest extends \PHPUnit_Framework_TestCase
{
    public function testRender()
    {
        $form = new Composite\Form();
        $form->addElement(new Composite\TextElement());
        $form->addElement(new Composite\InputElement());
        $embed = new Composite\Form();
        $embed->addElement(new Composite\TextElement());
        $embed->addElement(new Composite\InputElement());
        $form->addElement($embed);  // 这里我们添加一个嵌套树到表单

        $this->assertRegExp('#^\s{4}#m', $form->render());
    }

    /**
     * 组合模式最关键之处在于如果你想要构建组件树每个组件必须实现组件接口
     */
    public function testFormImplementsFormElement()
    {
        $className = 'DesignPatterns\Structural\Composite\Form';
        $abstractName = 'DesignPatterns\Structural\Composite\FormElement';
        $this->assertTrue(is_subclass_of($className, $abstractName));
    }
}
```

#### 数据映射模式（Data Mapper）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 装饰模式（Decorator）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 依赖注入(Dependence Injection)


**依赖倒置原则（Dependence Inversion Principle, DIP）**

DIP是一种软件设计的指导思想。传统软件设计中，上层代码依赖于下层代码，当下层出现变动时， 上层代码也要相应变化，维护成本较高。 
而DIP的核心思想是上层定义接口，下层实现这个接口， 从而使得下层依赖于上层，降低耦合度，提高整个系统的弹性。这是一种经实践证明的有效策略。

**控制反转（Inversion of Control, IoC）**

IoC就是DIP的一种具体思路，DIP只是一种理念、思想，而IoC是一种实现DIP的方法。 
IoC的核心是将类（上层）所依赖的单元（下层）的实例化过程交由第三方来实现。 
一个简单的特征， 就是类中不对所依赖的单元有诸如 `$component = new yii\component\SomeClass()` 的实例化语句。

**依赖注入（Dependence Injection, DI）**

DI是IoC的一种设计模式，是一种套路，按照DI的套路，就可以实现IoC，就能符合DIP原则。 
DI的核心是把类所依赖的单元的实例化过程，放到类的外面去实现。

**控制反转容器（IoC Container）**

当项目比较大时，依赖关系可能会很复杂。 而IoC Container提供了动态地创建、注入依赖单元，
映射依赖关系等功能，减少了许多代码量。 Yii 设计了一个 yii\di\Container 来实现了 DI Container。

具体实例，可以看一下 [深入理解Yii2.0 依赖注入和依赖注入容器](https://ibaiyang.github.io/blog/yii2/2019/06/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Yii2.0-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%B9%E5%99%A8.html) 。

#### 门面模式（Facade）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 流接口模式（Fluent Interface）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 代理模式（Proxy）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 注册模式（Registry）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 享元模式（Flyweight）

* 模式定义

* UML类图

* 示例代码

* 测试代码



<br/><br/><br/><br/><br/>
### 参考资料

常见软件架构模式 <https://ibaiyang.github.io/blog/php/2019/07/30/%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F.html>

DesignPatternsPHP <https://github.com/domnikl/DesignPatternsPHP>

PHP 设计模式系列 <https://laravelacademy.org/books/php-design-pattern>

PHP 设计模式(Design Pattern For PHP) <https://www.cnblogs.com/wilburxu/category/910011.html> 

php-the-right-way 设计模式 <http://laravel-china.github.io/php-the-right-way/pages/Design-Patterns.html>

DesignPatternsPHP <https://designpatternsphp.readthedocs.io/en/latest/>

DesignPatternsPHP(PHP设计模式范例) <https://designpatternsphp.readthedocs.io/zh_CN/latest/README.html>

PHP 设计模式概述 <https://segmentfault.com/a/1190000016629282>

PHP设计模式（七）适配器模式（Adapter For PHP） <https://www.cnblogs.com/wilburxu/p/6200570.html>

PHP设计模式（八）桥接模式（Bridge For PHP） <https://www.cnblogs.com/wilburxu/p/6202097.html>

PHP八大设计模式 <https://blog.csdn.net/flitrue/article/details/52614599>

php各种设计模式简单实践思考 <https://www.cnblogs.com/aksir/p/6777595.html>


