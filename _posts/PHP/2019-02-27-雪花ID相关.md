---
layout: post
categories: PHP
title: 雪花ID相关
meta: Twitter的分布式雪花算法 SnowFlake 每秒自增生成26个万个可排序的ID，SnowFlake算法生成id的结果是一个64bit大小的整数。
---
* content
{:toc}

### 正文

雪花ID使用场景比较适合多服务器生成唯一ID，一般我们数据库中都是用自增ID，但如果分库就会导致ID可能重复，
所以需要服务器生成唯一ID，然后存入数据库。

snowflake的结构如下(每部分用-分开):
```
0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000
```

第一位为未使用，接下来的41位为毫秒级时间(41位的长度可以使用69年)，
然后是5位datacenterId和5位workerId(10位的长度最多支持部署1024个节点），
最后12位是毫秒内的计数（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号）一共加起来刚好64位，
为一个Long型。(转换成字符串后长度最多19)。

如：4912539910600137909

snowflake生成的ID整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞
（由datacenter和workerId作区分），并且效率较高。
经测试snowflake每秒能够产生26万个ID。

```
/**
 *  分布式 id 生成类     组成: <毫秒级时间戳+机器id+序列号>
 *  默认情况下41bit的时间戳可以支持该算法使用到2082年，10bit的工作机器id可以支持1023台机器，序列号支持1毫秒产生4095个自增序列id
 *  @author zhangqi
 */ 
class IdCreate
{ 
    const EPOCH = 1514736000000; //开始时间,固定一个小于当前时间的毫秒数， 如 2018-01-01 00:00:00
    const max12bit = 4095; 
    const max41bit = 1099511627775; 

    static $machineId = null; // 机器id 

    public static function init($mId = 0)
    { 
        self::$machineId = $mId; 
    } 

    public static function createOnlyId($mId = 0)
    { 
        if (!is_null($mId)) {
            self::init($mId);
        }
        
        // 时间戳 42字节 
        $time = floor(microtime(true) * 1000); 
        // 当前时间 与 开始时间 差值 
        $time -= self::EPOCH; 
        // 二进制的 毫秒级时间戳 
        $base = decbin(self::max41bit + $time); 
        // 机器id  10 字节 
        if(!self::$machineId) { 
            $machineid = self::$machineId; 
        } else { 
            $machineid = str_pad(decbin(self::$machineId), 10, "0", STR_PAD_LEFT); 
        } 
        // 序列数 12字节 
        $random = str_pad(decbin(mt_rand(0, self::max12bit)), 12, "0", STR_PAD_LEFT); 
        // 拼接 
        $base = $base.$machineid.$random; 
    
        // 转化为 十进制 返回 
        return bindec($base); 
    }
}


$machineId = 1;

$cast_id = IdCreate::createOnlyId($machineId);  
```


看一个新例子：
```
class IdGenerator
{
    const EPOCH = 1288834974657;//2010/11/4 9:42:54
    const NODE_SHIFT = 7; //机器
    const DC_SHIFT = 3;//data center
    const SEQ_SHIFT = 12;
    const TIME_SHIFT = 41;  //时间戳精确到毫秒
    public static  $nodeId;
    public static  $dcId;
    static $randCounter;
    static $counter = 0;
    static $lastTimestamp;

    // public function __construct($nodeId = 8, $dcId = 1)
    // {
    //     $this->init($nodeId, $dcId);
    // }

    public static function init($nodeId, $dcId)
    {
        //机器ID范围判断
        $maxWorkerId = -1 ^ (-1 << self::NODE_SHIFT);
        if($nodeId > $maxWorkerId || $nodeId < 0){
            throw new \Exception("nodeId can't be greater than ".$maxWorkerId." or less than 0");
        }
        //数据中心ID范围判断
        $maxDCId = -1 ^ (-1 << self::DC_SHIFT);
        if ($dcId > $maxDCId || $dcId < 0) {
            throw new \Exception("dcId can't be greater than ".$maxDCId." or less than 0");
        }

        self::$nodeId = $nodeId;
        self::$dcId = $dcId;
    }

    //生成一个ID
    public static function nextId($nodeId = 8, $dcId = 1){
        self::init($nodeId, $dcId);
        $timestamp = self::timeGen();

        //时间毫秒/数据中心ID/机器ID,要左移的位数
        $timestampLeftShift = self::SEQ_SHIFT + self::NODE_SHIFT + self::DC_SHIFT;
        $dcIdShift = self::SEQ_SHIFT + self::NODE_SHIFT;
        $nodeIdShift = self::SEQ_SHIFT;

        if ($timestamp == static::$lastTimestamp) {
            static::$randCounter++;
            static::$randCounter %= pow(2, self::SEQ_SHIFT);
            static::$counter++;
            static::$counter %= pow(2, self::SEQ_SHIFT);
            if (static::$counter == 0) {
                usleep(1);
                static::$randCounter = NULL;
                $timestamp = self::timeGen();
            }
        } else {
            static::$randCounter = NULL;
        }

        if (static::$randCounter === NULL) {
            static::$randCounter = rand(0, pow(2, self::SEQ_SHIFT) -1);
        }

        static::$lastTimestamp = $timestamp;

        //组合4段数据返回: 时间戳.数据标识.工作机器.序列
        $nextId = (($timestamp - self::EPOCH) << $timestampLeftShift) |
            (self::$dcId  << $dcIdShift) |
            (self::$nodeId << $nodeIdShift) | static::$randCounter;
        if ($nextId <= 0) return time() . mt_rand(10000, 99999);
        return $nextId;
    }

    //取当前时间毫秒
    protected static  function timeGen(){
        $timestamp = (float)sprintf("%.0f", microtime(true) * 1000);
        return  $timestamp;
    }

    //精确到毫秒
    public static function getTimeByIdGen($idGen)
    {
        //组合4段数据返回: 时间戳.数据标识.工作机器.序列
        $timestamp = $idGen >> self::DC_SHIFT >>  self::NODE_SHIFT >> self::SEQ_SHIFT;
        return $timestamp + self::EPOCH;
    }

    public static function random_int($min = 0, $max)
    {
        $range = $max - $min;
        if ($range < 1) return $min; // not so random...
        $log    = ceil(log($range, 2));
        $bytes  = (int) ($log / 8) + 1; // length in bytes
        $bits   = (int) $log + 1; // length in bits
        $filter = (int) (1 << $bits) - 1; // set all lower bits to 1
        do {
            $rnd = hexdec(bin2hex(openssl_random_pseudo_bytes($bytes)));
            $rnd = $rnd & $filter; // discard irrelevant bits
        } while ($rnd >= $range);
        return $min + $rnd;
    }
}
```

<br/><br/><br/><br/><br/>
### 参考资料

<https://blog.csdn.net/cj2580/article/details/80980459>

<https://blog.csdn.net/jerryyang_2017/article/details/80334580>

<https://www.jianshu.com/p/d3881a6a895e>



