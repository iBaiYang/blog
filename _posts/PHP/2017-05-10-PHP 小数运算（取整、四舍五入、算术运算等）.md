---
layout: post
categories: PHP
title: PHP 小数运算（取整、四舍五入、算术运算等）
meta: PHP 小数运算有向上取整、向下取整、四舍五入、丢弃小数等，还有加减乘除等基本运算
---
* content
{:toc}

### 正文

#### 取整

1、向上取整，有小数位就整数部分加1： 

```php
ceil(5/2); // 输出 3
ceil(-2.9); // 输出 -2
```

2、向下取整：

```php
floor(5/2); // 输出 2
floor(-2.1); // 输出 -3
```

3、丢弃小数部分：

```php
intval(5/2); // 输出2 
(int)2.5  // 输出2 
```

#### 四舍五入

```php
round(2.5); // 输出 3
round(2.4); // 输出 2
round(-2.4); // 输出 -2
round(-2.5); // 输出 -3
round(1.955, 2); // 输出 1.96
round(1.954, 2); // 输出 1.95
round(-1.955, 2); // 输出 -1.96
round(-1.954, 2); // 输出 -1.95
round(1.9545, 2); // 输出 1.95
round(-1.9545, 2); // 输出 -1.95 
```

#### BCMath任意精度数学运算

bcsub ( string $left_operand , string $right_operand [, int $scale = 0 ] ) : string

bcadd ( string $left_operand , string $right_operand [, int $scale = 0 ] ) : string

这两个都属于BCMath数学拓展函数。

使用BCMath函数，需要给php安装BCMath拓展库。

##### 引导

因为一次减法操作38.4-30，发现出现了8.399999999999999这样的结果，感觉问题出现的还挺意外的，
所以需要研究解决是怎么回事、怎么解决。

php的bug？不是，这是所有计算机语言基本上都会遇到的问题，所以基本上大部分语言都提供了精准计算的类库或函数库。

要搞明白这个原因, 首先我们要知道浮点数的表示(IEEE 754 :是IEEE二进位浮点数算数标准的编号):

浮点数, 以64位的长度(双精度)为例, 会采用1位符号位(E), 11指数位(Q), 52位尾数(M)表示(一共64位).

符号位：最高位表示数据的正负，0表示正数，1表示负数。

指数位：表示数据以2为底的幂，指数采用偏移码表示

尾数：表示数据小数点后的有效数字。

这里的关键点就在于, 小数在二进制的表示, 小数如何转化为二进制呢？

算法是乘以2直到没有了小数为止。这里举个例子，0.9表示成二进制数：

0.9*2=1.8 取整数部分 1

0.8(1.8的小数部分)*2=1.6 取整数部分 1

0.6*2=1.2 取整数部分 1

0.2*2=0.4 取整数部分 0

0.4*2=0.8 取整数部分 0

0.8*2=1.6 取整数部分 1

0.6*2=1.2 取整数部分 0

.........

0.9二进制表示为(从上往下): 11100100100100......

注意：上面的计算过程循环了，也就是说*2永远不可能消灭小数部分，这样算法将无限下去。
很显然，小数的二进制表示有时是不可能精确的 。
其实道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10。
这也就解释了为什么浮点型减法出现了"减不尽"的精度丢失问题。

0.58的二进制表示基本上(52位)是:0010100011110101110000101000111101011100001010001111；

0.57的二进制表示基本上(52位)是:0010001111010111000010100011110101110000101000111101;

而两者的二进制, 如果只是通过这52位计算的话,分别是:

0.58->0.57999999999999996

0.57->0.56999999999999995

至于0.58*100的具体浮点数乘法, 我们模糊的以心算来看… 0.58 * 100 = 57.999999999,那么intval后，就是57了。

换句话说：我们看到十进制小数，在计算机内存储的不是一个精确的数字，
也不可能精确。所以在数字加减乘除后出现意想不到的结果。

基于以上原因，所以永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。
如果确实需要更高的精度，应该使用BCMath任意精度数学函数或者 gmp 函数。

##### 可用方法

1、通过乘100的方式转化为整数加减，然后在除以100转化回来……

2、使用number_format转化成字符串，然后在使用（float）强转回来……

3、php提供了高精度计算的函数库，实际上就是为了解决这个浮点数计算问题而生的。

##### BCMath主要函数

BCMath 主要函数有：

bcadd — 将两个高精度数字相加

bccomp — 比较两个高精度数字，返回-1, 0, 1

bcdiv — 将两个高精度数字相除

bcmod — 求高精度数字余数

bcmul — 将两个高精度数字相乘

bcpow — 求高精度数字乘方

bcpowmod — 求高精度数字乘方求模，数论里非常常用

bcscale — 配置默认小数点位数，相当于就是Linux bc中的”scale=”

bcsqrt — 求高精度数字平方根

bcsub — 将两个高精度数字相减

##### 举例

echo bcsub(38.4, 30, 6);  // 8.400000

有关BCMath相关内容，看这里 <https://www.php.net/manual/zh/book.bc.php>


<br/><br/><br/><br/><br/>
### 参考资料

PHP 手册 函数参考 数学扩展 <https://www.php.net/manual/zh/refs.math.php>

PHP 手册 函数参考 数学扩展 Math Math 函数 <https://www.php.net/manual/zh/ref.math.php>

PHP 手册 函数参考 数学扩展 BCMath 任意精度数学 <https://www.php.net/manual/zh/book.bc.php>

bcsub <https://www.php.net/manual/en/function.bcsub.php>

bcadd <https://www.php.net/manual/en/function.bcadd.php>

<http://blog.csdn.net/nsrainbow/article/details/7065399>

[ceil](http://www.w3school.com.cn/php/func_math_ceil.asp)

[floor](http://www.w3school.com.cn/php/func_math_floor.asp)

[round](http://www.w3school.com.cn/php/func_math_round.asp)

[intval](http://php.net/manual/zh/function.intval.php)

[Math 函数](http://www.w3school.com.cn/php/php_ref_math.asp)

BCMath 任意精度数学 <https://www.php.net/manual/en/reserved.constants.php>

浮点数计算 <https://www.cnblogs.com/phpfensi/p/8143367.html>

php对于浮点数的精确运算 <https://blog.csdn.net/weihuiblog/article/details/79134771>

