---
layout: post
categories: PHP
title: webman使用引导
meta: webman使用引导
---
* content
{:toc}

## 正文

webman是一款基于[workerman](https://www.workerman.net/doc/workerman/)开发的高性能HTTP服务框架。
webman用于替代传统的php-fpm架构，提供超高性能可扩展的HTTP服务。
可以用webman开发网站，也可以开发HTTP接口或者微服务。

除此之外，webman还支持自定义进程，可以做workerman能做的任何事情，
例如websocket服务、物联网、游戏、TCP服务、UDP服务、unix socket服务等等。

webman 简单易用，学习成本极低，代码书写与传统框架没有区别。
可以 参考手册 [webman手册](https://www.workerman.net/doc/webman/) 进行开发。

### 数据库

webman数据库默认采用的是 illuminate/database，也就是[laravel的数据库](https://learnku.com/docs/laravel/8.x/eloquent/9400)，用法与laravel相同。

### 用户身份验证

webman 中用户身份验证可以使用自带[中间件](https://www.workerman.net/doc/webman/middleware.html)实现。

### 日志

webman使用 monolog/monolog 处理[日志](https://www.workerman.net/doc/webman/log.html)。

### 队列

队列可以用Redis实现，webman 中可以使用 [Redis消息队列插件 redis-queue](https://www.workerman.net/doc/webman/queue/redis.html) 。

### Socket服务

webman 中可以使用 [webman/push](https://www.workerman.net/doc/webman/plugin/push.html) 。
webman/push 是一个推送插件，客户端基于订阅模式，兼容 pusher，拥有众多客户端如JS、安卓(java)、IOS(swift)、IOS(Obj-C)、uniapp。
后端推送SDK支持PHP、Node、Ruby、Asp、Java、Python、Go等。使用起来非常简单稳定。适用于消息推送、聊天等诸多即时通讯场景。

### 自定义进程

webman 中 [自定义进程](https://www.workerman.net/doc/webman/process.html) 可以创建定制化进程。

#### 自定义非监听进程例子

新建 `process/FindUserAuthInfo.php`：
```php
<?php
namespace process;

use Workerman\Timer;
use support\Db;

class FindUserAuthInfo
{

    public function onWorkerStart()
    {
        // 每隔10秒检查一次数据库是否有新用户注册
        Timer::add(10, function(){
            Db::table('users')->where('regist_timestamp', '>', time()-10)->get();
        });
    }

}
```

在`config/process.php`中添加如下配置
```
return [
    // ... 其它进程配置省略

    'find_user_auth_info' => [
        'handler'  => process\FindUserAuthInfo::class
    ],
];
```

注意：listen省略则不监听任何端口，count省略则进程数默认为1。

#### 自定义监听例子

新建 `process/Pusher.php`：
```php
<?php
namespace process;

use Workerman\Connection\TcpConnection;

class Pusher
{
    public function onConnect(TcpConnection $connection)
    {
        echo "onConnect\n";
    }

    public function onWebSocketConnect(TcpConnection $connection, $http_buffer)
    {
        echo "onWebSocketConnect\n";
    }

    public function onMessage(TcpConnection $connection, $data)
    {
        $connection->send($data);
    }

    public function onClose(TcpConnection $connection)
    {
        echo "onClose\n";
    }
}
```

注意：所有onXXX属性均为public

在`config/process.php`中添加如下配置：
```
return [
    // ... 其它进程配置省略

    // websocket_test 为进程名称
    'websocket_test' => [
        // 这里指定进程类，就是上面定义的Pusher类
        'handler' => process\Pusher::class,
        'listen'  => 'websocket://0.0.0.0:8888',
        'count'   => 1,
    ],
];
```

#### 配置文件说明

一个进程完整的配置定义如下：
```
return [
    // ... 

    // websocket_test 为进程名称
    'websocket_test' => [
        // 这里指定进程类
        'handler' => process\Pusher::class,
        // 监听的协议 ip 及端口 （可选）
        'listen'  => 'websocket://0.0.0.0:8888',
        // 进程数 （可选，默认1）
        'count'   => 2,
        // 进程运行用户 （可选，默认当前用户）
        'user'    => '',
        // 进程运行用户组 （可选，默认当前用户组）
        'group'   => '',
        // 当前进程是否支持reload （可选，默认true）
        'reloadable' => true,
        // 是否开启reusePort （可选，此选项需要php>=7.0，默认为true）
        'reusePort'  => true,
        // transport (可选，当需要开启ssl时设置为ssl，默认为tcp)
        'transport'  => 'tcp',
        // context （可选，当transport为是ssl时，需要传递证书路径）
        'context'    => [], 
        // 进程类构造函数参数，这里为 process\Pusher::class 类的构造函数参数 （可选）
        'constructor' => [],
    ],
];
```

#### 总结

webman的自定义进程实际上就是workerman的一个简单封装，它将配置与业务分离，
并且将workerman的onXXX回调通过类的方法来实现，其它用法与workerman完全相同。

## 问题汇总

**A facade root has not been set**

文档中说 webman数据库默认采用的是 illuminate/database，但使用 `\Illuminate\Support\Facades\DB` 进行查询时却总是报错：
```
RuntimeException: A facade root has not been set. /vendor/laravel/framework/src/Illuminate/Support/Facades/Facade.php:258
```

最后查下来webman文档中使用的是自带的 `support\Db`，挺坑的。

## 参考资料

webman手册 <https://www.workerman.net/doc/webman/>

Laravel 8 中文文档  <https://learnku.com/docs/laravel/8.x>

workerman手册 <https://www.workerman.net/doc/workerman/>
