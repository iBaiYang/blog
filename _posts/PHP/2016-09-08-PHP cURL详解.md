---
layout: post
categories: PHP
title: PHP cURL详解
meta: PHP cURL详解
---
* content
{:toc}

### 正文

cURL 是一个利用URL语法规定来传输文件和数据的工具，支持很多协议，如HTTP、FTP、TELNET等。最爽的是，PHP也支持 cURL 库。
这个库是由Daniel Stenberg创建的libcurl库，它允许你与各种的服务器使用各种类型的协议进行连接和通讯。
libcurl目前支持http、https、ftp、gopher、telnet、dict、file和ldap协议。libcurl同时也支持HTTPS认证、
HTTP POST、HTTP PUT、 FTP 上传(这个也能通过PHP的FTP扩展完成)、HTTP 基于表单的上传、代理、cookies和用户名+密码的认证。
它还可以根据URL前缀是“HTTP” 还是“HTTPS”自动选择是否加密发送内容，非常灵活。

本文将介绍如何在PHP中如何运用 cURL 拓展。

使用cURL的PHP扩展完成一个HTTP请求的发送一般有以下几个步骤：     
1. 初始化连接句柄；    
2. 设置cURL选项；   
3. 执行并获取结果；
4. 释放cURL连接句柄。

使用cURL发送HTTP的典型过程举例：

```php
// 1. 初始化
$ch = curl_init();
// 2. 设置选项，包括URL
curl_setopt($ch, CURLOPT_URL, "http://www.123.com");
curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
curl_setopt($ch, CURLOPT_HEADER, 0);
// 3. 执行并获取HTML文档内容
$output = curl_exec($ch);
if ($output === FALSE ) {
     echo "cURL Error:".curl_error($ch);
}
// 4. 释放curl句柄
curl_close($ch); 
```

上述代码中使用到了四个函数

* curl_init() 和 curl_close() 分别是初始化cURL连接和关闭cURL连接，都比较简单。
* curl_exec() 执行cURL请求，如果没有错误发生，该函数的返回是对应URL返回的数据，以字符串表示满意；如果发生错误，该函数返回 FALSE。需要注意的是，判断输出是否为FALSE用的是全等号，这是为了区分返回空串和出错的情况。
* cURL函数库里最重要的函数是curl_setopt(),它可以通过设定cURL函数库定义的选项来定制HTTP请求。上述代码片段中使用了三个重要的选项：
    + CURLOPT_URL 指定请求的URL；
    + CURLOPT_RETURNTRANSFER 设置为1表示稍后执行的curl_exec函数的返回是URL的返回字符串，而不是表示成功的TRUE；
    + CURLLOPT_HEADER设置为0表示不返回HTTP头部信息。

上面可以说是一个典型的GET请求，下面举一个POST的例子：

```php
function doCurlPostRequest($url, $requestString, $timeout = 5){
    if($url == '' || $requestString == '' || $timeout <=0){
        return false;
    }
    $con = curl_init((string)$url);
    curl_setopt($con, CURLOPT_HEADER, false);
    curl_setopt($con, CURLOPT_POSTFIELDS, $requestString);
    curl_setopt($con, CURLOPT_POST, true);
    curl_setopt($con, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($con, CURLOPT_TIMEOUT, (int)$timeout);
    
    return curl_exec($con);
} 
```

值得说明的是curl_setopt($con, CURLOPT_POSTFIELDS, $params); 这里params可以是string，也可以是array。
当是array时，就是传统的post的数组。当是string时，就有可能是数组http_build_query()后的字符串，
也有可能是json()格式化后的字符串。看具体的使用。

一般都是在系统中封装，然后调用，上面那个GET的也可以封装一下，方便以后调用。

上面是标准的使用案例，一般的例子也举一下：

```php
public static function Get ($url) {
    $ch = curl_init ();
    curl_setopt ( $ch, CURLOPT_URL, $url );
    curl_setopt ( $ch, CURLOPT_HEADER, 0 );
    curl_setopt ( $ch, CURLOPT_RETURNTRANSFER, true );
    $result = curl_exec ( $ch );
    curl_close ( $ch );
    
    return $result;
}

public static function Post ($url, $postData = array()) {
    $ch = curl_init ();
    curl_setopt ( $ch, CURLOPT_URL, $url );
    curl_setopt ( $ch, CURLOPT_HEADER, 0 );
    curl_setopt ( $ch, CURLOPT_POST, 1 );
    curl_setopt ( $ch, CURLOPT_POSTFIELDS, http_build_query ($postData) );
    curl_setopt ( $ch, CURLOPT_RETURNTRANSFER, true );
    $result = curl_exec ( $ch );
    curl_close ( $ch );
    
    return $result;
} 
```

其中http_build_query()函数 使用给出的数组生成一个 url-encoded 请求字符串。

我个人的使用习惯是，调用完接口，随时以日志形式储存接口访问相关信息。具体封装示例：
    
```php
class Url{
     //日志类型
     const CATAGORY = 'curl';

     public static function Get ( $url )
     {
          $ch = curl_init ();
          curl_setopt ( $ch, CURLOPT_HEADER, 0 );
          curl_setopt ( $ch, CURLOPT_URL, $url );
          curl_setopt ( $ch, CURLOPT_RETURNTRANSFER, true );
          $result = curl_exec ( $ch );
          $result = self::resolveResult ($url, array(), $result, $ch);
          curl_close ( $ch );
          return $result;
     }   

     public static function Post ($url, $postData = array())
     {
          $ch = curl_init ();
          curl_setopt ( $ch, CURLOPT_POST, 1 );
          curl_setopt ( $ch, CURLOPT_HEADER, 0 );
          curl_setopt ( $ch, CURLOPT_URL, $url );
          curl_setopt ( $ch, CURLOPT_RETURNTRANSFER, true );
          curl_setopt ( $ch, CURLOPT_POSTFIELDS, http_build_query ( $postData ) );
          $result = curl_exec ( $ch );
          $result = self::resolveResult ($url, $postData, $result, $ch);
          curl_close ( $ch );
          return $result;
     }

    
     private static function resolveResult ( $url, $params = array(), $result = '', $ch = null )
     {
          $return = array(
               'flag' => 'success', //结果标志
               'data' => $result, //返回数据
               'errno'=> 0, //错误码
               'errmsg'=>'', //错误信息
          );

          if ( !$ch ) {
               return $return;
          }

          $errNo = curl_errno($ch);
          $errMsg= curl_error($ch);
          $curlInfo = curl_getinfo($ch);

          $return['curlinfo'] = $curlInfo;

          if ( $errNo > 0 ) {
               $return['flag'] = 'fail';
               $return['errno'] = $errNo;
               $return['errmsg'] = $errMsg;
          } elseif ( !empty($curlInfo) && intval($curlInfo['http_code']) != 200 ) {
               $return['flag'] = 'fail';
               $return['errno'] = $curlInfo['http_code'];
               $return['errmsg'] = 'http response error code : '.$curlInfo['http_code'];
          }

          $temp = $return;
          if (strlen($return['data']) > 4000) { //返回内容长度大于4000的截取后记录日志
               $temp['data'] = substr($temp['data'], 0, 500) . '......';
          }
          $logData = self::logFormat(array_merge(array('url' => $url, 'params'=> $params), $temp));
          Yii::log( $logData, $return['flag'] == 'success' ? CLogger::LEVEL_INFO : CLogger::LEVEL_WARNING, self::CATAGORY);

          if ($return['flag'] == 'fail') {
               Y::alarm(5, '接口访问错误', "{$return['errno']}: {$return['errmsg']}");
          }
          return $return;
     }

    
     private static function logFormat ( $logData = array() ) {
          $result = '';
          if ( is_array($logData) && !empty($logData) ) {
               foreach ( $logData as $key => $val ) {
                    if ( is_array($val) ) {
                         $val = json_encode($val);
                    }
                    $result .= "【". $key ." : " . $val . "】，";
               }
          }
          return rtrim($result,'，');
     }

}
```

:） 可以看出我用的是Yii框架，Yii::log()具体要看你的配置文件是怎么写的，关于接口我是这样写的：

```php
'log' => array (
     'class' => 'CLogRouter',
     'routes' => array (
          array(
               'class' => 'CDbLogRoute',
               'levels' => 'info,warning',
               'connectionID' => 'db',
               'logTableName' => '0000_api_log',
               'categories' => 'curl',
          ),
          // 以及其他
     )
),
```

用的数据表储存，表结构:

```mysql
 CREATE TABLE `0000_api_log` (
     `id` int(11) NOT NULL AUTO_INCREMENT,
     `level` varchar(128) DEFAULT NULL,
     `category` varchar(128) DEFAULT NULL,
     `logtime` int(11) DEFAULT NULL,
     `message` text,
     PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 
```

数据一览：

![](http://s8.sinaimg.cn/mw690/001XbchKzy77AWYqs6j27&690)


既然在数据表中写了，那肯定要写查看接口访问日志的方法，这样才算是完全把握程序运行。把它当成一般的表数据访问来写就好，很快的。

另外看到一个写的比较好的curl封装方法，这里记一下，以后使用时可以参考：

```php
function curl($url, $type='GET', $data='', $Async=true)
{
     $ch = curl_init();
     if ( $Async ) {
          // Asynchronous：异步请求
          curl_setopt($ch, CURLOPT_NOSIGNAL, true); // 注意，毫秒超时一定要设置这个
          curl_setopt($ch, CURLOPT_TIMEOUT_MS, 500); // 超时毫秒，小于500时不稳定，测试在600以上可以
     }
     curl_setopt($ch, CURLOPT_URL, $url);
     curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);
     curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);
     curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (compatible; MSIE 5.01; Windows NT 5.0)');
     curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);
     curl_setopt($ch, CURLOPT_AUTOREFERER, 1);
     curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $type);
     curl_setopt($ch, CURLOPT_POSTFIELDS, $data);
     curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
     $info = curl_exec($ch);
     if ( curl_errno($ch) ) {
          return 'Errno'.curl_error($ch);
     }
     curl_close($ch);
     return $info;
} 
```

或者如下：

```
/**
 * CURL
 * @param $url 请求地址
 * @param string $type 请求类型，GET或POST
 * @param string $data 请求内容
 * @param int $Async 是否异步
 * @return bool|mixed
 */
function curl($url, $type = 'GET', $data = '', $Async = 500)
{
    $ch = curl_init();
    if ($Async) {
        // $Asynchronous：异步请求
        curl_setopt($ch, CURLOPT_NOSIGNAL, true); // 注意，毫秒超时一定要设置这个
        curl_setopt($ch, CURLOPT_TIMEOUT_MS, $Async); // 超时毫秒，根据网络情况设定
    }
    curl_setopt($ch, CURLOPT_URL, $url);
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);
    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);
    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (compatible; MSIE 5.01; Windows NT 5.0)');
    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);
    curl_setopt($ch, CURLOPT_AUTOREFERER, 1);
    curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $type);
    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    $info = curl_exec($ch);
    if (curl_errno($ch)) {
        // echo 'Errno'.curl_error($ch);
        return false;
    }
    curl_close($ch);
    return $info;
}
```

附一个完整的类：

```php
<?php
namespace common\widgets;

class Request 
{

    public static function httpGet($url, $headers = [])
    {
        $curl = curl_init();
        curl_setopt($curl, CURLOPT_URL, $url);
        curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, 0); // 对认证证书来源的检查
        curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, 2); // 从证书中检查SSL加密算法是否存在
        curl_setopt($curl, CURLOPT_USERAGENT, @$_SERVER['HTTP_USER_AGENT']); // 模拟用户使用的浏览器
        curl_setopt($curl, CURLOPT_FOLLOWLOCATION, 1); // 使用自动跳转
        curl_setopt($curl, CURLOPT_AUTOREFERER, 1); // 自动设置Referer
        curl_setopt($curl, CURLOPT_HTTPGET, 1); // 发送一个常规的Get请求
        curl_setopt($curl, CURLOPT_TIMEOUT, 30); // 设置超时限制防止死循环
        curl_setopt($curl, CURLOPT_HEADER, 0); // 显示返回的Header区域内容
        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); // 获取的信息以文件流的形式返回
        
        $tmpInfo = curl_exec($curl); // 执行操作
        if (curl_errno($curl)) {
            return false;
        }
        curl_close($curl);
        
        return $tmpInfo; // 返回数据
    }

    public static function httpPost($url, $params = [], $headerMap = [])
    {
        $headers = array();
        foreach ($headerMap as $key => $value) {
            $headers[] = $key . ': ' . $value;
        }
        $curl = curl_init(); // 启动一个CURL会话
        curl_setopt($curl, CURLOPT_URL, $url); // 要访问的地址
        curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, 0); // 对认证证书来源的检查
        curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, 2); // 从证书中检查SSL加密算法是否存在
        curl_setopt($curl, CURLOPT_USERAGENT, @$_SERVER['HTTP_USER_AGENT']); // 模拟用户使用的浏览器
        curl_setopt($curl, CURLOPT_FOLLOWLOCATION, 1); // 使用自动跳转
        curl_setopt($curl, CURLOPT_AUTOREFERER, 1); // 自动设置Referer
        curl_setopt($curl, CURLOPT_POST, TRUE); // 发送一个常规的Post请求
        curl_setopt($curl, CURLOPT_POSTFIELDS, $params); // Post提交的数据包
        curl_setopt($curl, CURLOPT_TIMEOUT, 30); // 设置超时限制防止死循环
        curl_setopt($curl, CURLOPT_HEADER, 0); // 显示返回的Header区域内容
        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); // 获取的信息以文件流的形式返回
        curl_setopt($curl, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);
        curl_setopt($curl, CURLOPT_USERPWD, "miaomiao:miao123456");
        curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);
        
        $tmpInfo = curl_exec($curl); // 执行操作
        if ( curl_errno($curl) ) {
            // curl_errno($curl) 具体错误码
            return false;
        }
        curl_close($curl); // 关键CURL会话
        
        return $tmpInfo; // 返回数据
    }
}
```

还有可以与app交互的例子：

```php
public static function Curls($type = 'GET', $url = '', $data = [])
{
    if ($type == 'GET') {
        //拼接url
        if ($data != []) {
            $url .= '?';
            foreach ($data as $key => $value) {
                $url .= $key . '=' . $value . '&';
            }
            //去掉最后一个字符
            $url = substr($url, 0, -1);
        }
        //初始化
        $ch = curl_init();
        //设置选项，包括URL
        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
        curl_setopt($ch, CURLOPT_HEADER, 0);
        //执行并获取HTML文档内容
        $output = curl_exec($ch);
        //释放curl句柄
        curl_close($ch);

        return $output;
    }

    if ($type == 'POST') {
        //初始化
        $ch = curl_init();
        //设置选项，包括URL
        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
        // post数据
        curl_setopt($ch, CURLOPT_POST, 1);
        // post的变量
        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);

        $output = curl_exec($ch);
        curl_close($ch);

        return $output;
    }

    if ($type == 'APPPOST') {
        $initTime = time();
        $headers = [
            'uid' => 0,
            'accessUser' => '',
            'version' => '2.1.2',
            'time' => $initTime,
            'role' => 0,
            'userIp' => '192.168.1.1',
            'requestId' => $initTime.rand(1000, 9999),
            'clientType' => 0,
        ];

        $key = 'abc12398709213asbnvhdsd';
        ksort($headers);
        foreach ($headers  AS $v)
        {
            $key .= $v;
        }
        $headers['token'] = md5($key);

        $header = [
            'X-Apple-Tz: 0',
            'X-Apple-Store-Front: 143444,12',
            'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Encoding: gzip, deflate',
            'Accept-Language: en-US,en;q=0.5',
            'Cache-Control: no-cache',
            'Content-Type: application/x-www-form-urlencoded; charset=utf-8',
            'uid:0',
            'accessUser:',
            'version:2.1.2',
            'time:'.$initTime,
            'role: 0',
            'userIp: 192.168.1.1',
            'requestId: '.$headers['requestId'],
            'clientType:0',
            'token:'.$headers['token']
        ];

        //初始化
        $ch = curl_init();
        //设置选项，包括URL
        if (ENV_CONFIG === 'dev' || ENV_CONFIG === 'pre')
        {
            curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0); //强制协议为1.0
            curl_setopt($ch, CURLOPT_HTTPHEADER, array('Expect: ')); //头部要送出'Expect: '
            curl_setopt($ch, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4 ); //强制使用IPV4协议解析域名
        }
        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_HTTPHEADER, $header);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
        // post数据
        curl_setopt($ch, CURLOPT_POST, 1);
        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);//这个是重点。
        // post的变量
        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);
        $output = curl_exec($ch);
        curl_close($ch);
        return $output;
    }

    return false;
}
```

这种写法也可以学习下：
```php
public static function httpPost( $url, $params = [], $headerMap = [] )
{
    // 写入开始日志
    self::$timing = microtime(true);  // 计算消耗时间
    $logId = time() . mt_rand(100000, 999999);
    $post_params['params'] = $params;
    $post_params['headerMap'] = $headerMap;
    LogService::InputApiLog( $logId, 'post', $url, $post_params );

    // 接口请求
    $headers = array();
    foreach ($headerMap as $key => $value) {
        $headers[] = $key . ': ' . $value;
    }
    $curl = curl_init(); // 启动一个CURL会话
    curl_setopt($curl, CURLOPT_URL, $url); // 要访问的地址
    curl_setopt($curl, CURLOPT_CUSTOMREQUEST, "POST");
    curl_setopt($curl, CURLOPT_POSTFIELDS, $params); // Post提交的数据包
    curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);
    curl_setopt($curl, CURLOPT_TIMEOUT, 30); // 设置超时限制防止死循环
    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); // 获取的信息以文件流的形式返回。而不是直接打印输出

    $tmpInfo = curl_exec($curl); // 执行操作
    if (curl_errno($curl)) {
        return false;
    }
    curl_close($curl); // 关闭CURL会话

    // 写入结束日志
    $time_escaped = number_format( ( microtime(true) - self::$timing ) * 1000);
    LogService::OutputApiLog( $logId, $time_escaped, $tmpInfo );

    // 返回数据
    return $tmpInfo;
}
```



<br/><br/><br/><br/><br/>
### 参考资料

<http://php.net/manual/zh/function.curl-setopt.php>

<http://www.devdo.net/php-curl.html>

<http://www.jb51.net/article/34745.htm>

[curl_errno函数](http://www.runoob.com/php/func-curl_errno.html)

[Curl 错误号](https://curl.haxx.se/libcurl/c/libcurl-errors.html) <https://blog.csdn.net/realzhi/article/details/17068085>

Postman高级应用：生成cURL和多语言代码 <https://blog.csdn.net/qq598535550/article/details/80889843>