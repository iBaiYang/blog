---
layout: post
categories: PHP
title: PHP 行为型模式
meta: PHP 行为型模式
---
* content
{:toc}

### 正文

行为型设计模式用于处理类的对象间通信。

#### 责任链模式（Chain Of Responsibilities）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 命令行模式（Command）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 迭代器模式（Iterator）

* 模式定义

迭代器模式（Iterator），又叫做游标（Cursor）模式。提供一种方法访问一个容器（Container）对象中各个元素，而又不需暴露该对象的内部细节。 
当你需要访问一个聚合对象，而且不管这些对象是什么都需要遍历的时候，就应该考虑使用迭代器模式。
另外，当需要对聚集有多种方式遍历时，可以考虑去使用迭代器模式。
迭代器模式为遍历不同的聚集结构提供如开始、下一个、是否结束、当前哪一项等统一的接口。 
PHP标准库（SPL）中提供了迭代器接口 Iterator，要实现迭代器模式，实现该接口即可。

* UML类图

![]({{site.baseurl}}/images/UML/Iterator.png)

* 示例代码

Book.php
```php
<?php
namespace DesignPatterns\Behavioral\Iterator;

class Book
{
    private $author;

    private $title;

    public function __construct($title, $author)
    {
        $this->author = $author;
        $this->title = $title;
    }

    public function getAuthor()
    {
        return $this->author;
    }

    public function getTitle()
    {
        return $this->title;
    }

    public function getAuthorAndTitle()
    {
        return $this->getTitle() . ' by ' . $this->getAuthor();
    }
}
```

BookList.php
```php
<?php
namespace DesignPatterns\Behavioral\Iterator;

class BookList implements \Countable
{
    private $books;

    public function getBook($bookNumberToGet)
    {
        if (isset($this->books[$bookNumberToGet])) {
            return $this->books[$bookNumberToGet];
        }

        return null;
    }

    public function addBook(Book $book)
    {
        $this->books[] = $book;
    }

    public function removeBook(Book $bookToRemove)
    {
        foreach ($this->books as $key => $book) {
            /** @var Book $book */
            if ($book->getAuthorAndTitle() === $bookToRemove->getAuthorAndTitle()) {
                unset($this->books[$key]);
            }
        }
    }

    public function count()
    {
        return count($this->books);
    }
}
```

BookListIterator.php
```php
<?php
namespace DesignPatterns\Behavioral\Iterator;

class BookListIterator implements \Iterator
{
    /**
     * @var BookList
     */
    private $bookList;

    /**
     * @var int
     */
    protected $currentBook = 0;

    public function __construct(BookList $bookList)
    {
        $this->bookList = $bookList;
    }

    /**
     * Return the current book
     * @link http://php.net/manual/en/iterator.current.php
     * @return Book Can return any type.
     */
    public function current()
    {
        return $this->bookList->getBook($this->currentBook);
    }

    /**
     * (PHP 5 >= 5.0.0)
     *
     * Move forward to next element
     * @link http://php.net/manual/en/iterator.next.php
     * @return void Any returned value is ignored.
     */
    public function next()
    {
        $this->currentBook++;
    }

    /**
     * (PHP 5 >= 5.0.0)
     *
     * Return the key of the current element
     * @link http://php.net/manual/en/iterator.key.php
     * @return mixed scalar on success, or null on failure.
     */
    public function key()
    {
        return $this->currentBook;
    }

    /**
     * (PHP 5 >= 5.0.0)
     *
     * Checks if current position is valid
     * @link http://php.net/manual/en/iterator.valid.php
     * @return boolean The return value will be casted to boolean and then evaluated.
     *       Returns true on success or false on failure.
     */
    public function valid()
    {
        return null !== $this->bookList->getBook($this->currentBook);
    }

    /**
     * (PHP 5 >= 5.0.0)
     *
     * Rewind the Iterator to the first element
     * @link http://php.net/manual/en/iterator.rewind.php
     * @return void Any returned value is ignored.
     */
    public function rewind()
    {
        $this->currentBook = 0;
    }
}
```

BookListReverseIterator.php
```php
<?php
namespace DesignPatterns\Behavioral\Iterator;

class BookListReverseIterator implements \Iterator
{
    /**
     * @var BookList
     */
    private $bookList;

    /**
     * @var int
     */
    protected $currentBook = 0;

    public function __construct(BookList $bookList)
    {
        $this->bookList = $bookList;
        $this->currentBook = $this->bookList->count() - 1;
    }

    /**
     * Return the current book
     * @link http://php.net/manual/en/iterator.current.php
     * @return Book Can return any type.
     */
    public function current()
    {
        return $this->bookList->getBook($this->currentBook);
    }

    /**
     * (PHP 5 >= 5.0.0)
     *
     * Move forward to next element
     * @link http://php.net/manual/en/iterator.next.php
     * @return void Any returned value is ignored.
     */
    public function next()
    {
        $this->currentBook--;
    }

    /**
     * (PHP 5 >= 5.0.0)
     *
     * Return the key of the current element
     * @link http://php.net/manual/en/iterator.key.php
     * @return mixed scalar on success, or null on failure.
     */
    public function key()
    {
        return $this->currentBook;
    }

    /**
     * (PHP 5 >= 5.0.0)
     *
     * Checks if current position is valid
     * @link http://php.net/manual/en/iterator.valid.php
     * @return boolean The return value will be casted to boolean and then evaluated.
     *       Returns true on success or false on failure.
     */
    public function valid()
    {
        return null !== $this->bookList->getBook($this->currentBook);
    }

    /**
     * (PHP 5 >= 5.0.0)
     *
     * Rewind the Iterator to the first element
     * @link http://php.net/manual/en/iterator.rewind.php
     * @return void Any returned value is ignored.
     */
    public function rewind()
    {
        $this->currentBook = $this->bookList->count() - 1;
    }
}
```

* 测试代码

Tests/IteratorTest.php
```php
<?php
namespace DesignPatterns\Behavioral\Iterator\Tests;

use DesignPatterns\Behavioral\Iterator\Book;
use DesignPatterns\Behavioral\Iterator\BookList;
use DesignPatterns\Behavioral\Iterator\BookListIterator;
use DesignPatterns\Behavioral\Iterator\BookListReverseIterator;

class IteratorTest extends \PHPUnit_Framework_TestCase
{
    /**
     * @var BookList
     */
    protected $bookList;

    protected function setUp()
    {
        $this->bookList = new BookList();
        $this->bookList->addBook(new Book('Learning PHP Design Patterns', 'William Sanders'));
        $this->bookList->addBook(new Book('Professional Php Design Patterns', 'Aaron Saray'));
        $this->bookList->addBook(new Book('Clean Code', 'Robert C. Martin'));
    }

    public function expectedAuthors()
    {
        return array(
            array(
                array(
                    'Learning PHP Design Patterns by William Sanders',
                    'Professional Php Design Patterns by Aaron Saray',
                    'Clean Code by Robert C. Martin'
                )
            ),
        );
    }

    /**
     * @dataProvider expectedAuthors
     */
    public function testUseAIteratorAndValidateAuthors($expected)
    {
        $iterator = new BookListIterator($this->bookList);

        while ($iterator->valid()) {
            $expectedBook = array_shift($expected);
            $this->assertEquals($expectedBook, $iterator->current()->getAuthorAndTitle());
            $iterator->next();
        }
    }

    /**
     * @dataProvider expectedAuthors
     */
    public function testUseAReverseIteratorAndValidateAuthors($expected)
    {
        $iterator = new BookListReverseIterator($this->bookList);

        while ($iterator->valid()) {
            $expectedBook = array_pop($expected);
            $this->assertEquals($expectedBook, $iterator->current()->getAuthorAndTitle());
            $iterator->next();
        }
    }

    /**
     * Test BookList Remove
     */
    public function testBookRemove()
    {
        $this->bookList->removeBook($this->bookList->getBook(0));
        $this->assertEquals($this->bookList->count(), 2);
    }
}
```

#### 中介者模式（Mediator）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 备忘录模式（Memento）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 空对象模式（Null Object）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 观察者模式（Observer）

* 模式定义

观察者模式有时也被称作发布/订阅模式，该模式用于为对象实现发布/订阅功能：
一旦主体对象状态发生改变，与之关联的观察者对象会收到通知，并进行相应操作。 
将一个系统分割成一个一些类相互协作的类有一个不好的副作用，那就是需要维护相关对象间的一致性。
我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。观察者就是解决这类的耦合关系的。 
消息队列系统、事件都使用了观察者模式。 PHP 为观察者模式定义了两个接口：SplSubject 和 SplObserver。
SplSubject 可以看做主体对象的抽象，SplObserver 可以看做观察者对象的抽象，
要实现观察者模式，只需让主体对象实现 SplSubject ，观察者对象实现 SplObserver，并实现相应方法即可。

* UML类图

![]({{site.baseurl}}/images/UML/Observer.png)

* 示例代码

User.php
```php
<?php
namespace DesignPatterns\Behavioral\Observer;

/**
 * 观察者模式 : 被观察对象 (主体对象)
 *
 * 主体对象维护观察者列表并发送通知
 *
 */
class User implements \SplSubject
{
    /**
     * user data
     *
     * @var array
     */
    protected $data = array();

    /**
     * observers
     *
     * @var \SplObjectStorage
     */
    protected $observers;
    
    public function __construct()
    {
        $this->observers = new \SplObjectStorage();
    }

    /**
     * 附加观察者
     *
     * @param \SplObserver $observer
     *
     * @return void
     */
    public function attach(\SplObserver $observer)
    {
        $this->observers->attach($observer);
    }

    /**
     * 取消观察者
     *
     * @param \SplObserver $observer
     *
     * @return void
     */
    public function detach(\SplObserver $observer)
    {
        $this->observers->detach($observer);
    }

    /**
     * 通知观察者方法
     *
     * @return void
     */
    public function notify()
    {
        /** @var \SplObserver $observer */
        foreach ($this->observers as $observer) {
            $observer->update($this);
        }
    }

    /**
     *
     * @param string $name
     * @param mixed  $value
     *
     * @return void
     */
    public function __set($name, $value)
    {
        $this->data[$name] = $value;

        // 通知观察者用户被改变
        $this->notify();
    }
}
```

UserObserver.php
```php
<?php
namespace DesignPatterns\Behavioral\Observer;

/**
 * UserObserver 类（观察者对象）
 */
class UserObserver implements \SplObserver
{
    /**
     * 观察者要实现的唯一方法
     * 也是被 Subject 调用的方法
     *
     * @param \SplSubject $subject
     */
    public function update(\SplSubject $subject)
    {
        echo get_class($subject) . ' has been updated';
    }
}
```

* 测试代码

Tests/ObserverTest.php
```php
<?php

namespace DesignPatterns\Behavioral\Observer\Tests;

use DesignPatterns\Behavioral\Observer\UserObserver;
use DesignPatterns\Behavioral\Observer\User;

/**
 * ObserverTest 测试观察者模式
 */
class ObserverTest extends \PHPUnit_Framework_TestCase
{
    protected $observer;

    protected function setUp()
    {
        $this->observer = new UserObserver();
    }

    /**
     * 测试通知
     */
    public function testNotify()
    {
        $this->expectOutputString('DesignPatterns\Behavioral\Observer\User has been updated');
        $subject = new User();

        $subject->attach($this->observer);
        $subject->property = 123;
    }

    /**
     * 测试订阅
     */
    public function testAttachDetach()
    {
        $subject = new User();
        $reflection = new \ReflectionProperty($subject, 'observers');

        $reflection->setAccessible(true);
        /** @var \SplObjectStorage $observers */
        $observers = $reflection->getValue($subject);

        $this->assertInstanceOf('SplObjectStorage', $observers);
        $this->assertFalse($observers->contains($this->observer));

        $subject->attach($this->observer);
        $this->assertTrue($observers->contains($this->observer));

        $subject->detach($this->observer);
        $this->assertFalse($observers->contains($this->observer));
    }

    /**
     * 测试 update() 调用
     */
    public function testUpdateCalling()
    {
        $subject = new User();
        $observer = $this->getMock('SplObserver');
        $subject->attach($observer);

        $observer->expects($this->once())
            ->method('update')
            ->with($subject);

        $subject->notify();
    }
}
```

* 总结

观察者模式解除了主体和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖具体。从而使得各自的变化都不会影响另一边的变化。

* 拓展

Spl标准类
```
/**
 * The <b>SplObserver</b> interface is used alongside
 * <b>SplSubject</b> to implement the Observer Design Pattern.
 * @link https://php.net/manual/en/class.splobserver.php
 */
interface SplObserver  {

        /**
         * Receive update from subject
         * @link https://php.net/manual/en/splobserver.update.php
         * @param SplSubject $subject <p>
	 * The <b>SplSubject</b> notifying the observer of an update.
         * </p>
         * @return void
         */
        public function update (SplSubject $subject);

}

/**
 * The <b>SplSubject</b> interface is used alongside
 * <b>SplObserver</b> to implement the Observer Design Pattern.
 * @link https://php.net/manual/en/class.splsubject.php
 */
interface SplSubject  {

        /**
         * Attach an SplObserver
         * @link https://php.net/manual/en/splsubject.attach.php
         * @param SplObserver $observer <p>
	 * The <b>SplObserver</b> to attach.
         * </p>
         * @return void
         */
        public function attach (SplObserver $observer);

        /**
         * Detach an observer
         * @link https://php.net/manual/en/splsubject.detach.php
         * @param SplObserver $observer <p>
	 * The <b>SplObserver</b> to detach.
         * </p>
         * @return void
         */
        public function detach (SplObserver $observer);

        /**
         * Notify an observer
         * @link https://php.net/manual/en/splsubject.notify.php
         * @return void
         */
        public function notify ();

}

/**
 * The SplObjectStorage class provides a map from objects to data or, by
 * ignoring data, an object set. This dual purpose can be useful in many
 * cases involving the need to uniquely identify objects.
 * @link https://php.net/manual/en/class.splobjectstorage.php
 */
class SplObjectStorage implements Countable, Iterator, Serializable, ArrayAccess {

        /**
         * Adds an object in the storage
         * @link https://php.net/manual/en/splobjectstorage.attach.php
         * @param object $object <p>
         * The object to add.
         * </p>
         * @param mixed $info [optional] <p>
         * The data to associate with the object.
         * </p>
         * @return void
         */
        public function attach ($object, $info = null) {}

        /**
	 * Removes an object from the storage
         * @link https://php.net/manual/en/splobjectstorage.detach.php
         * @param object $object <p>
         * The object to remove.
         * </p>
         * @return void
         */
        public function detach ($object) {}

        /**
         * Checks if the storage contains a specific object
         * @link https://php.net/manual/en/splobjectstorage.contains.php
         * @param object $object <p>
         * The object to look for.
         * </p>
	 * @return bool true if the object is in the storage, false otherwise.
         */
        public function contains ($object) {}

        /**
         * Adds all objects from another storage
         * @link https://php.net/manual/en/splobjectstorage.addall.php
         * @param SplObjectStorage $storage <p>
         * The storage you want to import.
         * </p>
         * @return void
         */
	public function addAll ($storage) {}

        /**
         * Removes objects contained in another storage from the current storage
         * @link https://php.net/manual/en/splobjectstorage.removeall.php
         * @param SplObjectStorage $storage <p>
         * The storage containing the elements to remove.
         * </p>
         * @return void
         */
	public function removeAll ($storage) {}

        /**
	 * Removes all objects except for those contained in another storage from the current storage
	 * @link https://php.net/manual/en/splobjectstorage.removeallexcept.php
	 * @param SplObjectStorage $storage <p>
	 * The storage containing the elements to retain in the current storage.
	 * </p>
	 * @return void
	 * @since 5.3.6
	 */
	public function removeAllExcept ($storage) {}

	/**
         * Returns the data associated with the current iterator entry
         * @link https://php.net/manual/en/splobjectstorage.getinfo.php
         * @return mixed The data associated with the current iterator position.
         */
        public function getInfo () {}

        /**
         * Sets the data associated with the current iterator entry
         * @link https://php.net/manual/en/splobjectstorage.setinfo.php
         * @param mixed $info <p>
         * The data to associate with the current iterator entry.
         * </p>
         * @return void
         */
        public function setInfo ($info) {}

        /**
         * Returns the number of objects in the storage
         * @link https://php.net/manual/en/splobjectstorage.count.php
         * @param int $mode [optional]
         * @return int The number of objects in the storage.
         */
        public function count ($mode = COUNT_NORMAL) {}

        /**
         * Rewind the iterator to the first storage element
         * @link https://php.net/manual/en/splobjectstorage.rewind.php
         * @return void
         */
        public function rewind () {}

        /**
         * Returns if the current iterator entry is valid
         * @link https://php.net/manual/en/splobjectstorage.valid.php
	 * @return bool true if the iterator entry is valid, false otherwise.
         */
        public function valid () {}

        /**
         * Returns the index at which the iterator currently is
         * @link https://php.net/manual/en/splobjectstorage.key.php
         * @return int The index corresponding to the position of the iterator.
         */
        public function key () {}

        /**
         * Returns the current storage entry
         * @link https://php.net/manual/en/splobjectstorage.current.php
         * @return object The object at the current iterator position.
         */
        public function current () {}

        /**
         * Move to the next entry
         * @link https://php.net/manual/en/splobjectstorage.next.php
         * @return void
         */
        public function next () {}

        /**
         * Unserializes a storage from its string representation
         * @link https://php.net/manual/en/splobjectstorage.unserialize.php
         * @param string $data <p>
         * The serialized representation of a storage.
         * </p>
         * @return void
         * @since 5.2.2
         */
        public function unserialize ($data) {}

        /**
         * Serializes the storage
         * @link https://php.net/manual/en/splobjectstorage.serialize.php
         * @return string A string representing the storage.
         * @since 5.2.2
         */
        public function serialize () {}

        /**
         * Checks whether an object exists in the storage
         * @link https://php.net/manual/en/splobjectstorage.offsetexists.php
         * @param object $object <p>
         * The object to look for.
         * </p>
	 * @return bool true if the object exists in the storage,
         * and false otherwise.
         */
        public function offsetExists ($object) {}

        /**
         * Associates data to an object in the storage
         * @link https://php.net/manual/en/splobjectstorage.offsetset.php
         * @param object $object <p>
         * The object to associate data with.
         * </p>
	 * @param mixed $info [optional] <p>
         * The data to associate with the object.
         * </p>
         * @return void
         */
	public function offsetSet ($object, $info = null) {}

        /**
         * Removes an object from the storage
         * @link https://php.net/manual/en/splobjectstorage.offsetunset.php
         * @param object $object <p>
         * The object to remove.
         * </p>
         * @return void
         */
        public function offsetUnset ($object) {}

        /**
         * Returns the data associated with an <type>object</type>
         * @link https://php.net/manual/en/splobjectstorage.offsetget.php
         * @param object $object <p>
         * The object to look for.
         * </p>
         * @return mixed The data previously associated with the object in the storage.
         */
        public function offsetGet ($object) {}

        /**
         * Calculate a unique identifier for the contained objects
         * @link https://php.net/manual/en/splobjectstorage.gethash.php
         * @param object $object  <p>
         * object whose identifier is to be calculated.
         * @return string A string with the calculated identifier.
         * @since 5.4
        */
        public function getHash($object) {}

        /**
         * @return array
         * @since 7.4
         */
        public function __serialize(): array {}

        /**
         * @param array $data
         * @since 7.4
         */
        public function __unserialize(array $data): void {}

        /**
         * @return array
         * @since 7.4
         */
        public function __debugInfo(){}

}
```

关于 观察者模式 与 发布/订阅模式 。 1.观察者模式是松耦合，而发布订阅模式是完全解耦的。
2.观察者模式里，只有两个角色：观察者、被观察者，而发布的订阅模式却不仅仅只有发布者和订阅者两个角色，还有一个经常被我们忽略的：经纪人Broker。

在《大话设计模式》一书，把 subject 看作发布者，observer 看作订阅者，反过来，可以把发布订阅模式看作松耦合的观察者模式实现；
在 GoF 的《设计模式》一书中，对观察者模式的定义只是一个基本概念，没有对这些细节做定义，
在 23 种设计模式中没有发布订阅模式，发布/订阅模式其实是从消息系统中作为架构模式迁移而来，
在 Windows 系统中也将这两个模式视作同义词，可以参考[维基百科](https://en.wikipedia.org/wiki/Observer_pattern#Coupling_and_typical_pub-sub_implementations) 中的介绍，
从宽松的角度来说，把它们看作一个模式没什么问题，发布/订阅模式只是观察者模式的一种松耦合实现，
从严格角度来说，也可以把它们看作不同的模式，比如 《JavaScript 设计模式》一书中就做了这样的[区分](https://www.oreilly.com/library/view/learning-javascript-design/9781449334840/ch09s05.html) ，
看具体的理解角度，比如微服务和服务化，有些人认为它们就是一个东西，有些人则要严格区分它们。

#### 规格模式（Specification）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 状态模式（State）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 策略模式(Strategy)

使用策略模式，你可以把一族不同的算法（业务）封装到不同的类中，使 client 类可以在不知道具体实现的情况下选择实例化其中一个算法。
策略模式有几种不同的变体，最简单的是下面这种：

第一段代码展示了一族输出算法，分别具体实现了 OutputInterface 的 load 方法，返回序列化结果，json 和数组：
```
<?php
interface OutputInterface
{
    public function load();
}

class SerializedArrayOutput implements OutputInterface
{
    public function load()
    {
        return serialize($arrayOfData);
    }
}

class JsonStringOutput implements OutputInterface
{
    public function load()
    {
        return json_encode($arrayOfData);
    }
}

class ArrayOutput implements OutputInterface
{
    public function load()
    {
        return $arrayOfData;
    }
}
```

通过像上面这样把不同类型的输出算法封装起来，其他的开发者可以很容易地在不影响 client 代码的情况下添加新的输出类型。

每个具体的输出类实现了 OutputInterface —— 这有两个目的，第一是它提供了一个所有输出类都必须遵守的契约，
第二，你将会在本文后面的部分看到，通过实现公共的接口，你可以利用类型约束保证 client 中使用的输出类必须是实现了 OutputInterface 的类。

接下来的一小段代码展示了一个 client 类如何使用其中一个输出算法，并可以在运行时根据需要选用不同的算法。
```
<?php
class SomeClient
{
    private $output;

    public function setOutput(OutputInterface $outputType)
    {
        $this->output = $outputType;
    }

    public function loadOutput()
    {
        return $this->output->load();
    }
}
```

上面的 client类有一个必须在运行时设置的私有属性，并且是“OutputInterface”类型的。 一旦这个属性被设置为具体的实例（三个输出类中之一的实例），
并且 loadOutput 方法被调用，那么它的 load 方法就会被调用，返回回序列化结果或 json 或数组。

```
<?php
$client = new SomeClient();

// Want an array?
$client->setOutput(new ArrayOutput());
$data = $client->loadOutput();

// Want some JSON?
$client->setOutput(new JsonStringOutput());
$data = $client->loadOutput();
```
  
#### 模板方法模式（Template Method）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 访问者模式（Visitor）

* 模式定义

* UML类图

* 示例代码

* 测试代码

#### 解释器模式（Interpreter）

* 模式定义

* UML类图

* 示例代码

* 测试代码



<br/><br/><br/><br/><br/>
### 参考资料

PHP 常用设计模式 <https://ibaiyang.github.io/blog/php/2019/07/30/PHP-%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html>

常见软件架构模式 <https://ibaiyang.github.io/blog/php/2019/07/30/%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F.html>

DesignPatternsPHP <https://github.com/domnikl/DesignPatternsPHP>

PHP 设计模式系列 <https://laravelacademy.org/books/php-design-pattern>

PHP 设计模式(Design Pattern For PHP) <https://www.cnblogs.com/wilburxu/category/910011.html> 

php-the-right-way 设计模式 <http://laravel-china.github.io/php-the-right-way/pages/Design-Patterns.html>

DesignPatternsPHP <https://designpatternsphp.readthedocs.io/en/latest/>

DesignPatternsPHP(PHP设计模式范例) <https://designpatternsphp.readthedocs.io/zh_CN/latest/README.html>

PHP 设计模式概述 <https://segmentfault.com/a/1190000016629282>

PHP八大设计模式 <https://blog.csdn.net/flitrue/article/details/52614599>

php各种设计模式简单实践思考 <https://www.cnblogs.com/aksir/p/6777595.html>

PHP设计模式之迭代器模式 <https://blog.csdn.net/bujidexinq/article/details/104956869>

