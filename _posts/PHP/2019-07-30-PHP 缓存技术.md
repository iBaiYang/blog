---
layout: post
categories: PHP
title: PHP 缓存技术
meta: 缓存技术
---
* content
{:toc}

### 正文

#### 全页面静态化缓存

关于静态化，PHP的静态化分为：纯静态和伪静态。其中纯静态又分为：局部纯静态和全部纯静态。

全页面静态化缓存，也就是将页面全部生成html静态页面，用户访问时直接访问的静态页面，而不会去走php服务器解析的流程。此种方式，在CMS内容管理型系统中比较常见。

一种比较常用的实现方式是用输出缓存：

```
ob_start()
******要运行的代码*******
$content = ob_get_contents();
****将缓存内容写入html文件*****
ob_end_clean();
```

介绍几个关于PHP缓冲区的相关函数：

ob_start     打开输出控制缓冲（要求php开启缓存，在php配置文件php.ini文件中可以设置 output_buffering = on）

ob_get_contents     返回输出缓冲区内容

ob_clean     清空（擦掉）输出缓冲区

ob_end_clean     清除缓冲区内容并且关闭

ob_get_clean     得到当前缓冲区的内容并删除当前输出缓冲区，相当于ob_get_contents()和ob_clean()

php生成文件的函数 file_put_contents('文件路径','文件内容')，还有fwrite()。


我们看一个例子，文件结构：
```
├──demo
│   ├──public
│   │    └──css
│   │        └──bootstrap.min.css
│   ├──templates
│   │    └──newlists.php
│   ├──db.php
│   └──index.php
```

db.php内容：
```
<?php
/**
 * 数据库连接封装
 */
class Db {
    // 存储类的实例的静态成员变量
    private static $_instance;
    // 数据库链接静态变量
    private static $_connectSource;
    // 连接数据库配置
    private $_dbConfig = [
            'host' => '127.0.0.1',
            'user' => 'root',
            'password' => '123456',
            'database' => 'news'
        ];

    private function __construct() {}

    /**
     * 实例化
     */
    public static function getInstance() 
    {
        // 判断是否被实例化
        if (!(self::$_instance instanceof self)) {
            self::$_instance = new self();
        }
        return self::$_instance;
    }

    /**
     * 数据库连接
     */
    public function connect() 
    {
        if (!self::$_connectSource) {
            // 数据库连接
            // @ 符号可以取消警告提示
            self::$_connectSource = @mysql_connect($this->_dbConfig['host'], $this->_dbConfig['user'], $this->_dbConfig['password']);

            if (!self::$_connectSource) {
                //抛出异常处理
                throw new Exception('mysql connect error ');
            }
            // 选择一款数据库
            mysql_select_db($this->_dbConfig['database'], self::$_connectSource);
            // 设置字符编码
            mysql_query("set names UTF8", self::$_connectSource);
        }

        // 返回资源链接
        return self::$_connectSource;
    }
}
```

index.php（根据静态文件失效的时间，判断是否重新生成静态文件 index.html）内容：
```
<?php 
if　(is_file('index.html') && (time() - filemtime('index.html')) < (60 * 5)) { 　// 缓存文件存在，并且生成时间在5分钟以内，则直接返回缓存文件
    require_once('index.html');
} else {  // 否则，生成缓存文件
    //　1、连接数据库，然后从数据库里面获取数据
    require_once('db.php');
    $connect = Db::getInstance()->connect();
    $sql = "SELECT * FROM news WHERE `category_id` = 1 AND `status` = 10 ORDER BY id DESC LIMIT 5";
    $result = mysql_query($sql, $connect);
    $news = array();
    while ($row = mysql_fetch_array($result)) {
        $news[] = $row;
    }
    
    // 2、把获取到的数据填充到模板文件里面，生成纯静态化文件
    ob_start();  // 开启输出缓存区
    require_once('templates/newlists.php');  // 引入模板文件，填充数据   newlists.php界面同样进过缓冲区
    file_put_contents('index.html', ob_get_contents());  // 获取输出缓冲区内容，生成纯静态化文件
    ob_clean();  // 清空（擦掉）输出缓冲区
    /*if(file_put_contents('index.html', ob_get_clean())) {
        echo 'success';
    } else {
        echo 'error';
    }*/
}
```

newlists.php　（使用bootstrap框架做界面）：
```
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>新闻中心</title>
	<link rel="stylesheet" href="public/css/bootstrap.min.css" type="text/css">
</head>
<body>
	<div class="container">
		<h3>新闻列表</h3>
		<ul class="list-group">
			<?php foreach ($news as $key => $value) { ?>
			    <li class="list-group-item"><a href="#"><?php echo $value['title'];?></a></li>
			<?php } ?>
		</ul>
	</div>
</body>
</html>
```

出现 index.html　：
```
├──demo
│   ├──public
│   │    └──css
│   │        └──bootstrap.min.css
│   ├──templates
│   │    └──newlists.php
│   ├──db.php
│   ├──index.php
│   └──index.html
```

当我们不超过300秒，再次访问index.php时，服务器将访问静态文件index.html给我们访问。
而当静态文件过期后，我们再次访问index.php，服务器将为我们更新index.html静态文件。

这里讲到的只是一种触发静态文件更新的方法，当然还有：手动触发更新（设置后台管理，管理员想立即更新静态文件，就点击运行生成静态文件即可）、
Linux服务器下的crontab定时扫描程序（在Linux服务器下，设置命令：

*/5 * * * * php 路径+文件名    ==>  代表 每5分钟系统将执行一次指定文件

分　时　日　月　年　　脚本　文件

<br/><br/><br/><br/><br/>
### 参考资料

PHP 中 9 大缓存技术总结 <https://www.cnblogs.com/aksir/p/6781276.html>

PHP 中 9 大缓存技术总结 <http://developer.51cto.com/art/201509/491334.htm>

PHP实现页面静态化——全部纯静态化 <https://blog.csdn.net/qq_15096707/article/details/50809197>

结合php ob函数理解缓冲机制 <https://www.cnblogs.com/DeanChopper/p/4688667.html>







