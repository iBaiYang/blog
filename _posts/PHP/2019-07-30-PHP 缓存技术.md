---
layout: post
categories: PHP
title: PHP 缓存技术
meta: 缓存技术
---
* content
{:toc}

### 正文

#### 全页面静态化缓存

关于静态化，PHP的静态化分为：纯静态和伪静态。其中纯静态又分为：局部纯静态和全部纯静态。

全页面静态化缓存，也就是将页面全部生成html静态页面，用户访问时直接访问的静态页面，而不会去走php服务器解析的流程。此种方式，在CMS内容管理型系统中比较常见。

一种比较常用的实现方式是用输出缓存：

```
ob_start()
******要运行的代码*******
$content = ob_get_contents();
****将缓存内容写入html文件*****
ob_end_clean();
```

介绍几个关于PHP缓冲区的相关函数：

ob_start     打开输出控制缓冲（要求php开启缓存，在php配置文件php.ini文件中可以设置 output_buffering = on）

ob_get_contents     返回输出缓冲区内容

ob_clean     清空（擦掉）输出缓冲区

ob_end_clean     清除缓冲区内容并且关闭

ob_get_clean     得到当前缓冲区的内容并删除当前输出缓冲区，相当于ob_get_contents()和ob_clean()

php生成文件的函数 file_put_contents('文件路径','文件内容')，还有fwrite()。


我们看一个例子，文件结构：
```
├──demo
│   ├──public
│   │    └──css
│   │        └──bootstrap.min.css
│   ├──templates
│   │    └──newlists.php
│   ├──db.php
│   └──index.php
```

db.php内容：
```
<?php
/**
 * 数据库连接封装
 */
class Db {
    // 存储类的实例的静态成员变量
    private static $_instance;
    // 数据库链接静态变量
    private static $_connectSource;
    // 连接数据库配置
    private $_dbConfig = [
            'host' => '127.0.0.1',
            'user' => 'root',
            'password' => '123456',
            'database' => 'news'
        ];

    private function __construct() {}

    /**
     * 实例化
     */
    public static function getInstance() 
    {
        // 判断是否被实例化
        if (!(self::$_instance instanceof self)) {
            self::$_instance = new self();
        }
        return self::$_instance;
    }

    /**
     * 数据库连接
     */
    public function connect() 
    {
        if (!self::$_connectSource) {
            // 数据库连接
            // @ 符号可以取消警告提示
            self::$_connectSource = @mysql_connect($this->_dbConfig['host'], $this->_dbConfig['user'], $this->_dbConfig['password']);

            if (!self::$_connectSource) {
                //抛出异常处理
                throw new Exception('mysql connect error ');
            }
            // 选择一款数据库
            mysql_select_db($this->_dbConfig['database'], self::$_connectSource);
            // 设置字符编码
            mysql_query("set names UTF8", self::$_connectSource);
        }

        // 返回资源链接
        return self::$_connectSource;
    }
}
```

index.php（根据静态文件失效的时间，判断是否重新生成静态文件 index.html）内容：
```
<?php 
if　(is_file('index.html') && (time() - filemtime('index.html')) < (60 * 5)) { 　// 缓存文件存在，并且生成时间在5分钟以内，则直接返回缓存文件
    require_once('index.html');
} else {  // 否则，生成缓存文件
    //　1、连接数据库，然后从数据库里面获取数据
    require_once('db.php');
    $connect = Db::getInstance()->connect();
    $sql = "SELECT * FROM news WHERE `category_id` = 1 AND `status` = 10 ORDER BY id DESC LIMIT 5";
    $result = mysql_query($sql, $connect);
    $news = array();
    while ($row = mysql_fetch_array($result)) {
        $news[] = $row;
    }
    
    // 2、把获取到的数据填充到模板文件里面，生成纯静态化文件
    ob_start();  // 开启输出缓存区
    require_once('templates/newlists.php');  // 引入模板文件，填充数据   newlists.php界面同样进过缓冲区
    file_put_contents('index.html', ob_get_contents());  // 获取输出缓冲区内容，生成纯静态化文件
    ob_clean();  // 清空（擦掉）输出缓冲区
    /*if(file_put_contents('index.html', ob_get_clean())) {
        echo 'success';
    } else {
        echo 'error';
    }*/
}
```

newlists.php　（使用bootstrap框架做界面）：
```
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>新闻中心</title>
	<link rel="stylesheet" href="public/css/bootstrap.min.css" type="text/css">
</head>
<body>
	<div class="container">
		<h3>新闻列表</h3>
		<ul class="list-group">
			<?php foreach ($news as $key => $value) { ?>
			    <li class="list-group-item"><a href="#"><?php echo $value['title'];?></a></li>
			<?php } ?>
		</ul>
	</div>
</body>
</html>
```

出现 index.html　：
```
├──demo
│   ├──public
│   │    └──css
│   │        └──bootstrap.min.css
│   ├──templates
│   │    └──newlists.php
│   ├──db.php
│   ├──index.php
│   └──index.html
```

当我们不超过300秒，再次访问index.php时，服务器将访问静态文件index.html给我们访问。
而当静态文件过期后，我们再次访问index.php，服务器将为我们更新index.html静态文件。

这里讲到的只是一种触发静态文件更新的方法，当然还有：手动触发更新（设置后台管理，管理员想立即更新静态文件，就点击运行生成静态文件即可）、
Linux服务器下的crontab定时扫描程序（在Linux服务器下，设置命令：

*/5 * * * * php 路径+文件名    ==>  代表 每5分钟系统将执行一次指定文件

分　时　日　月　年　　脚本　文件


#### 页面部分缓存

该种方式，是将一个页面中不经常变的部分进行静态缓存，而经常变化的块不缓存，最后组装在一起显示；可以使用类似于ob_get_contents的方式实现，
也可以利用类似ESI之类的页面片段缓存策略，使其用来做动态页面中相对静态的片段部分的缓存。

动态内容缓存技术，总体来说就是该静态化的静态化，该动态的保持动态，最后进行组合！

可行的方案大致有三种： CSI , SSI ,ESI。 具体使用中CSI的ajax使用很普遍。

一、CSI (Client Side Includes)

   含义：通过iframe、javascript、ajax  等方式将另外一个页面的内容动态包含进来。

   原理：整个页面依然可以静态化为html页面，不过在需要动态的地方则通过iframe,javascript或ajax来动态加载！

   例子：<iframe src='http://abroad.e2bo.com/index.php' border='0'></iframe>

   优点：相对比较简单，不需要服务器端做改变和配置；

   缺点：不利于搜索引擎优化(iframe方式), javascript兼容性问题，以及客户端缓存问题可能导致更新后不能及时生效！对于客户体验也不够好！
   
二、SSI（Server Side Includes）

   含义：通过注释行SSI命令加载不同模块，构建为html，实现整个网站的内容更新；

   原理：通过SSI调用各模块的对应文件，最后组装为html页面，需要服务器模块支持(具体配置本文不做详述)，比如：apache服务器需要开启mod_include模块；

   例子：
```
<!--#include virtual="header.html" -->

<!--#include virtual="login.html" -->

<!--#include virtual="footer.html" -->
```

   优点：不受具体语言限制，比较通用，只需要Web服务器或应用服务器支持即可，Ngnix、Apache、IIS等对此都有较好的支持。

   缺点：SSI只能在当前服务器上包含加载，不能够直接包含其他服务器上的文件，即不能跨域包含；
   
三、ESI（Edge Side Includes）

含义及原理：

网上通用的解释如下：通过使用简单的标记语言来对那些可以加速和不能加速的网页中的内容片断进行描述，
每个网页都被划分成不同的小部分分别赋予不同的缓存控制策略，
使Cache服务器可以根据这些策略在将完整的网页发送给用户之前将不同的小部分动态地组合在一起。通过这种控制，
可以有效地减少从服务器抓取整个页面的次数，而只用从原服务器中提取少量的不能缓存的片断，因此可以有效降低原服务器的负载，
同时提高用户访问的响应时间。与SSI不同的是，ESI多在 缓存服务器或代理服务器上执行！

例子： 
```
<html>
<head>
<title>ESI Demo</title>
</head>
<body>
    <esi:include src="login.php" />
    
    <div>
         <h3>这中间是可静态化html内容</3>
    </div>
</body>
<html> 
```

优点：可用于缓存整个页面或页面片段，比较适合用于缓存服务器上；

缺点：目前支持ESI的软件还比较少，官方更新也略显缓慢，因此使用不是很广！

#### 数据缓存

顾名思义，就是缓存数据的一种方式；比如，商城中的某个商品信息，当用商品id去请求时，就会得出包括店铺信息、商品信息等数据，
此时就可以将这些数据缓存到一个php文件中，文件名包含商品id来建一个唯一标示；下一次有人想查看这个商品时，首先就直接调这个文件里面的信息，
而不用再去数据库查询；其实缓存文件中缓存的就是一个php数组之类；现实场景中使用Redis做数据缓存的比较多。

数据缓存常用的三种方式：

![](https://raw.githubusercontent.com/iBaiYang/PictureWareroom/master/20190807/20190807110935.png)

#### 查询缓存

其实这跟数据缓存是一个思路，就是根据查询语句来缓存；将查询得到的结果数据缓存在一个文件或内存（如Redis）中，
下次遇到相同的查询时（不超过缓存有效时间），就直接先从这个文件里面调数据，不会再去查数据库；
但此处的缓存文件名可能就需要以查询语句为基点来建立唯一标示，按时间变更进行缓存。

其实，这一条不是真正的缓存方式；上面的页面部分缓存、数据缓存、查询缓存的缓存技术一般都用到了时间变更判断；就是对于缓存文件您需要设一个有效时间，
在这个有效时间内，相同的访问才会先取缓存文件的内容，但是超过设定的缓存时间，就需要重新从数据库中获取数据，并生产最新的缓存文件；
比如，我将我们查询费时的列表就是设置10分钟更新一次；

#### 按内容变更进行缓存

这个也并非独立的缓存技术，需结合着用；就是当数据库内容被修改时，即刻更新缓存文件；

比如，一个人流量很大的商城，商品很多，商品表必然比较大，这表的压力也比较重；我们就可以对商品显示页进行页面缓存；

当商家在后台修改这个商品的信息时，点击保存，我们同时就更新缓存文件；那么，买家访问这个商品信息时，实际上访问的是一个静态页面，而不需要再去访问数据库；

试想，如果对商品页不缓存，那么每次访问一个商品就要去数据库查一次，如果有10万人在线浏览商品，那服务器压力就大了；

#### 内存式缓存

提到这个，可能大家想到的首先就是Memcached；memcached是高性能的分布式内存缓存服务器。 一般的使用目的是，通过缓存数据库查询结果，
减少数据库访问次数，以提高动态Web应用的速度、 提高可扩展性。

它就是将需要缓存的信息，缓存到系统内存中，需要获取信息时，直接到内存中取；比较常用的方式就是 key–>value方式；

```
$key = 'key19080700113123';  //　缓存键名
$memcachehost = '192.168.6.191';
$memcacheport = 11211;
$memcachelife = 60;
$memcache = new Memcache;
$memcache->connect($memcachehost,$memcacheport) or die ("Could not connect");
$memcache->set($key,'缓存的内容');
$get = $memcache->get($key); //　获取信息
```

现在Redis使用的比较多了。

#### apache缓存模块

apache安装完以后，是不允许被cache的。如果外接了cache或squid服务器要求进行web加速的话，就需要在htttpd.conf里进行设置，
当然前提是在安装apache的时候要激活mod_cache的模块。

安装apache时：./configure –enable-cache –enable-disk-cache –enable-mem-cache

#### php APC缓存扩展

Php有一个APC缓存扩展，windows下面为php_apc.dll，需要先加载这个模块，然后是在php.ini里面进行配置：
```
[apc]
extension=php_apc.dll
apc.rfc1867 = on
upload_max_filesize = 100M
post_max_size = 100M
apc.max_file_size = 200M
upload_max_filesize = 1000M
post_max_size = 1000M
max_execution_time = 600 ; 每个PHP页面运行的最大时间值(秒)，默认30秒
max_input_time = 600 ; 每个PHP页面接收数据所需的最大时间，默认60
memory_limit = 128M ; 每个PHP页面所吃掉的最大内存，默认8M
```

#### Opcode缓存

我们知道，php的执行流程可以用下图来展示：

![](https://raw.githubusercontent.com/iBaiYang/PictureWareroom/master/20190807/20190807112365.png)

首先php代码被解析为Tokens，然后再编译为Opcode码，最后执行Opcode码，返回结果；

所以，对于相同的php文件，第一次运行时可以缓存其Opcode码，下次再执行这个页面时，直接会去找到缓存下的opcode码，直接执行最后一步，
而不再需要中间的步骤了。比较知名的是XCache、Turck MM Cache、PHP Accelerator等。

<br/><br/><br/><br/><br/>
### 参考资料

PHP 中 9 大缓存技术总结 <https://www.cnblogs.com/aksir/p/6781276.html>

PHP实现页面静态化——全部纯静态化 <https://blog.csdn.net/qq_15096707/article/details/50809197>

结合php ob函数理解缓冲机制 <https://www.cnblogs.com/DeanChopper/p/4688667.html>

Output Control Functions　<https://www.php.net/manual/en/ref.outcontrol.php>

动态缓存技术之CSI,SSI,ESI <https://www.cnblogs.com/Alight/p/3940651.html>

缓存的三种方式　<https://www.cnblogs.com/llzhang123/p/9037346.html>

深度理解PHP执行流程 <https://blog.csdn.net/diavid/article/details/81035188>

PHP代码执行流程 <https://www.cnblogs.com/yangjinqiang/p/10951606.html>

