---
layout: post
categories: PHP
title: PHP BCMath任意精度数学运算
meta: bcMath 数学拓展函数库使用记录
---
* content
{:toc}

### 正文

#### 引导

因为一次减法操作38.4-30，发现出现了8.399999999999999这样的结果，感觉问题出现的还挺意外的，
所以需要研究解决是怎么回事、怎么解决。

php的bug？不是，这是所有计算机语言基本上都会遇到的问题，所以基本上大部分语言都提供了精准计算的类库或函数库。

要搞明白这个原因, 首先我们要知道浮点数的表示(IEEE 754 :是IEEE二进位浮点数算数标准的编号):

浮点数, 以64位的长度(双精度)为例, 会采用1位符号位(E), 11指数位(Q), 52位尾数(M)表示(一共64位).

符号位：最高位表示数据的正负，0表示正数，1表示负数。

指数位：表示数据以2为底的幂，指数采用偏移码表示

尾数：表示数据小数点后的有效数字。

这里的关键点就在于, 小数在二进制的表示, 小数如何转化为二进制呢？

算法是乘以2直到没有了小数为止。这里举个例子，0.9表示成二进制数：

0.9*2=1.8 取整数部分 1

0.8(1.8的小数部分)*2=1.6 取整数部分 1

0.6*2=1.2 取整数部分 1

0.2*2=0.4 取整数部分 0

0.4*2=0.8 取整数部分 0

0.8*2=1.6 取整数部分 1

0.6*2=1.2 取整数部分 0

.........

0.9二进制表示为(从上往下): 11100100100100......

注意：上面的计算过程循环了，也就是说*2永远不可能消灭小数部分，这样算法将无限下去。
很显然，小数的二进制表示有时是不可能精确的 。
其实道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10。
这也就解释了为什么浮点型减法出现了"减不尽"的精度丢失问题。

0.58的二进制表示基本上(52位)是:0010100011110101110000101000111101011100001010001111；

0.57的二进制表示基本上(52位)是:0010001111010111000010100011110101110000101000111101;

而两者的二进制, 如果只是通过这52位计算的话,分别是:

0.58->0.57999999999999996

0.57->0.56999999999999995

至于0.58*100的具体浮点数乘法, 我们模糊的以心算来看… 0.58 * 100 = 57.999999999,那么intval后，就是57了。

换句话说：我们看到十进制小数，在计算机内存储的不是一个精确的数字，
也不可能精确。所以在数字加减乘除后出现意想不到的结果。

基于以上原因，所以永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。
如果确实需要更高的精度，应该使用BCMath任意精度数学函数或者 gmp 函数。

#### 可用方法

1、通过乘100的方式转化为整数加减，然后在除以100转化回来……

2、使用number_format转化成字符串，然后在使用（float）强转回来……

3、php提供了高精度计算的函数库，实际上就是为了解决这个浮点数计算问题而生的。

#### BCMath主要函数

BCMath 主要函数有：

bcadd — 将两个高精度数字相加

bccomp — 比较两个高精度数字，返回-1, 0, 1

bcdiv — 将两个高精度数字相除

bcmod — 求高精度数字余数

bcmul — 将两个高精度数字相乘

bcpow — 求高精度数字乘方

bcpowmod — 求高精度数字乘方求模，数论里非常常用

bcscale — 配置默认小数点位数，相当于就是Linux bc中的”scale=”

bcsqrt — 求高精度数字平方根

bcsub — 将两个高精度数字相减

#### 举例

echo bcsub(38.4, 30, 6);  // 8.400000

<br/><br/><br/><br/><br/>
### 参考资料

BCMath 任意精度数学 <https://www.php.net/manual/en/reserved.constants.php>

浮点数计算 <https://www.cnblogs.com/phpfensi/p/8143367.html>

php对于浮点数的精确运算 <https://blog.csdn.net/weihuiblog/article/details/79134771>
