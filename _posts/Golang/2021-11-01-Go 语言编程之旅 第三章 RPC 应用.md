---
layout: post
categories: Golang
title: Go 语言编程之旅 第三章 RPC 应用
meta: Go 语言编程之旅 第三章 RPC 应用
---
* content
{:toc}

## 第三章 RPC 应用

在上一个章节中，我们介绍了使用 Go 语言的 gin 框架来做一个基于 HTTP 服务的 Web 项目，接下来在本章节，
我们将介绍 Go 语言中最流行的 RPC 框架：gRPC（从 Github Star 数来看），并带你探索其相对应的技术栈。

首先我们将对 gRPC 和 Protobuf 进行介绍，让你形成一个基本的概念，知道 gRPC 是什么、Protobuf 又是什么，
然后会在接下来会对两者做更进一步的使用和详细介绍。

### 3.1 遨游 gRPC 和 Protobuf

3.1.1.1 什么是 RPC

RPC 代指远程过程调用（Remote Procedure Call），它的调用包含了传输协议和编码（对象序列）协议等等，
允许运行于一台计算机的程序调用另一台计算机的子程序，而开发人员无需额外地为这个交互作用编程，
因此我们也常常称 RPC 调用，就像在进行本地函数调用一样方便。

3.1.1.2 什么是 gRPC

gRPC 是一个高性能、开源和通用的 RPC 框架，面向移动和基于 HTTP/2 设计。目前提供 C、Java 和 Go 语言等等版本，
分别是：grpc、grpc-java、grpc-go，其中 C 版本支持 C、C++、Node.js、Python、Ruby、Objective-C、PHP 和 C# 支持。

gRPC 基于 HTTP/2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特性。
这些特性使得其在移动设备上表现更好，在一定的情况下更节省空间占用。

gRPC 的接口描述语言（Interface description language，缩写 IDL）使用的是 Protobuf，都是由 Google 开源的。

3.1.1.3 gRPC 调用模型

接下来我们一起看看 gRPC 的一个最简的调用模型，便于在脑海中形成一个基本调用流转，如下官方图：

![]({{site.baseurl}}/images/20211030/20211030136101.jpg)

1. 客户端（gRPC Stub）在程序中调用某方法，发起 RPC 调用。
2. 对请求信息使用 Protobuf 进行对象序列化压缩（IDL）。
3. 服务端（gRPC Server）接收到请求后，解码请求体，进行业务逻辑处理并返回。
4. 对响应结果使用 Protobuf 进行对象序列化压缩（IDL）。
5. 客户端接受到服务端响应，解码请求体。回调被调用的 A 方法，唤醒正在等待响应（阻塞）的客户端调用并返回响应结果。


3.1.3.1 什么是 Protobuf

Protocol Buffers（Protobuf）是一种与语言、平台无关，可扩展的序列化结构化数据的数据描述语言，我们常常称其为 IDL，
常用于通信协议，数据存储等等，相较于 JSON、XML，它更小、更快，因此也更受开发人员的青眯。

3.1.3.2 基本语法

```
syntax = "proto3";

package helloworld;

service Greeter {
    rpc SayHello (HelloRequest) returns (HelloReply) {}
}

message HelloRequest {
    string name = 1;
}

message HelloReply {
    string message = 1;
}
```

1. 第一行（非空的非注释行）声明使用 proto3 语法。如果不声明，将默认使用 proto2 语法。
同时建议无论是用 v2 还是 v3 版本，都应当进行显式声明。而在版本上，目前主流推荐使用 v3 版本。
2. 定义名为 Greeter 的 RPC 服务（Service），其包含 RPC 方法 SayHello，入参为 HelloRequest 消息体（message），
出参为 HelloReply 消息体。
3. 定义 HelloRequest、HelloReply 消息体，每一个消息体的字段包含三个属性：类型、字段名称、字段编号。
在消息体的定义上，除类型以外均不可重复。

在编写完.proto 文件后，我们一般会进行编译和生成对应语言的 proto 文件操作，
这个时候 Protobuf 的编译器会根据选择的语言不同、调用的插件情况，生成相应语言的 Service Interface Code 和 Stubs。

3.1.3.3 基本数据类型

在生成了对应语言的 proto 文件后，需要注意的是 protobuf 所生成出来的数据类型并非与原始的类型完全一致，
因此你需要有一个基本的了解，下面是我列举了的一些常见的类型映射，如下表：

| .proto Type     | C++ Type     | Java Type     | Go Type     | PHP Type  | 
| -------- | -------- | -------- | -------- | -------- |
| double     | double     | double     | float64     | float | 
| float     | float     | float     | float32     | float | 
| int32     | int32     | int     | int32     | integer | 
| int64     | int64     | long     | int64     | integer/string | 
| uint32     | uint32     | int     | uint32     | integer | 
| uint64     | uint64     | long     | uint64     | integer/string | 
| sint32     | int32     | int     | int32     | integer | 
| sint64     | int64     | long     | int64     | integer/string | 
| fixed32     | uint32     | int     | uint32     | integer | 
| fixed64     | uint64     | long     | uint64     | integer/string | 
| sfixed32     | int32     | int     | int32     | integer | 
| sfixed64     | int64     | long     | int64     | integer/string | 
| bool     | bool     | boolean     | bool     | boolean | 
| string     | string     | String     | string     | string | 
| bytes     | string     | ByteString     | []byte     | string | 

3.1.4 思考 gRPC

3.1.4.1 gRPC 与 RESTful API 对比

| 特性     | gRPC     | RESTful API |
| -------- | -------- | -------- |
|规范     |必须.proto     |可选 OpenAPI |
|协议     |HTTP/2     |任意版本的 HTTP 协议 |
|有效载荷     |Protobuf（小、二进制）     |JSON（大、易读） |
|浏览器支持     |否（需要 grpc-web）     |是 |
|流传输     |客户端、服务端、双向     |客户端、服务端 |
|代码生成     |是     |OpenAPI+ 第三方工具 |

3.1.4.2 gRPC 优势

3.1.4.2.1 性能

gRPC 使用的 IDL 是 Protobuf，Protobuf 在客户端和服务端上都能快速地进行序列化，并且序列化后的结果较小，
能够有效地节省传输占用的数据大小。另外众多周知，gRPC 是基于 HTTP/2 协议进行设计的，有非常显著的优势。

另外常常会有人问，为什么是 Protobuf，为什么 gRPC 不用 JSON、XML 这类 IDL 呢，我想主要有如下原因：

    在定义上更简单，更明了。
    数据描述文件只需原来的 1/10 至 1/3。
    解析速度是原来的 20 倍至 100 倍。
    减少了二义性。
    生成了更易使用的数据访问类。
    序列化和反序列化速度快。
    开发者本身在传输过程中并不需要过多的关注其内容。

3.1.4.2.2 代码生成

在代码生成上，我们只需要一个 proto 文件就能够定义 gRPC 服务和消息体的约定，
并且 gRPC 及其生态圈提供了大量的工具从 proto 文件中生成服务基类、消息体、客户端等等代码，
也就是客户端和服务端共用一个 proto 文件就可以了，保证了 IDL 的一致性且减少了重复工作。

3.1.4.2.3 流传输

gRPC 通过 HTTP/2 对流传输提供了大量的支持：

    Unary RPC：一元 RPC。
    Server-side streaming RPC：服务端流式 RPC。
    Client-side streaming RPC：客户端流式 RPC。
    Bidirectional streaming RPC：双向流式 RPC。

3.1.4.2.4 超时和取消

gRPC 允许客户端设置截止时间，若超出截止时间那么本次 RPC 请求将会被取消，与此同时服务端也会接收到取消动作的事件，
因此客户端和服务端都可以在达到截止时间后进行取消事件的相关联动处理。

并且根据 Go 语言的上下文（context）的特性，截止时间的传递是可以一层层传递下去的，
也就是我们可以通过一层层 gRPC 调用来进行上下文的传播截止日期和取消事件，有助于我们处理一些上下游的连锁问题等等场景。
但是同时也会带来隐患，如果没有适当处理，第一层的上下文取消，可以把最后的调用也给取消掉，
这在某些场景下可能是有问题的（需要根据实际业务场景判别）。

3.1.4.3 gRPC 缺点

3.1.4.3.1 可读性

默认情况下 gRPC 使用 Protobuf 作为其 IDL，Protobuf 序列化后本质上是二进制格式的数据，并不可读，因此其可读性差，
没法像 HTTP/1.1 那样直接目视调试，除非进行其它的特殊操作调整格式支持。

3.1.4.3.2 浏览器支持

目前来讲，我们无法直接通过浏览器来调用我们的 gRPC 服务，这意味着单从调试上来讲就没那么便捷了，更别提在其它的应用场景上了。

那官方有没有其余的工具协助呢，有的，gRPC-Web 提供了一个 JavaScript 库，使浏览器客户端可以访问 gRPC 服务，
但它也是有限的 gRPC 支持（对流传输的支持比较弱）。gRPC-Web 由两部分组成：一个支持浏览器的 JavaScript 客户端，
以及服务器上的一个 gRPC-Web 代理。调用流程为：gRPC-Web 客户端调用代理，代理将根据 gRPC 请求转发到 gRPC 服务。

但总归是需要额外的组件进行支持的，因此对浏览器的支持是有限的。

3.1.4.3.3 外部组件支持

gRPC 是基于 HTTP/2 设计的，HTTP/2 标准在 2015 年 5 月以 RFC 7540 正式发表，虽然已经过去了好几年，HTTP/3 也已经有了踪影，
但目前为止各大外部组件对 gRPC 这类基于 HTTP/2 设计的组件支持仍然不够完美，甚至有少数暂时就完全不支持。
与此同时，即使外部组件支持了，但其在社区上的相关资料也比较少，需要开发人员花费部分精力进行识别和研究，这是一个需要顾及的点。

3.1.5 小结

在本章节中，我们初步的介绍了 gRPC 和 Protobuf 是什么东西，并且简单的对 gRPC 的优缺点和传统的 RESTful API 进行了对比，
希望借此能够让你形成一个初步的印象，接下来的章节中，我们将进一步对 gRPC 和 Protobuf 进行进一步的说明和使用。


### 3.2 Protobuf 的使用和了解

3.2.1 安装

3.2.1.1 protoc 安装

在 gRPC 开发中，我们常常需要与 Protobuf 进行打交道，而在编写了.proto 文件后，我们会需要到一个编译器，
那就是 protoc，protoc 是 Protobuf 的编译器，是用 C++ 所编写的，其主要功能是用于编译.proto 文件。

接下来我们进行 protoc 的安装，在命令行下执行安装命令（需要依赖一些库，可根据错误提示搜索并进行依赖库的安装）：
```
$ wget https://github.com/google/protobuf/releases/download/v3.11.2/protobuf-all-3.11.2.zip
$ unzip protobuf-all-3.11.2.zip && cd protobuf-3.11.2/
$ ./configure
$ make
$ make install
```

检查是否安装成功，如下：
```
$ protoc --version
```

如果出现如下类似报错：
```
protoc: error while loading shared libraries: libprotobuf.so.15: cannot open shared object file: No such file or directory
```

则执行在命令行执行 `ldconfig` 命令后，再次运行即可成功。但这是为什么呢，为什么要执行这条命令才能够正常运行 protoc 命令呢，
我们可以通过安装时的控制台输出的信息得知，Protocol Buffers Libraries 的默认安装路径在 `/usr/local/lib` 下，如下：
```
Libraries have been installed in:
   /usr/local/lib
...
```

实际上在安装了 protoc 后，我们同时安装了一个新的动态链接库，而 ldconfig 命令一般默认在系统启动时运行，
所以在特定情况下会找不到这个新安装的 lib，因此我们要手动执行 ldconfig，让动态链接库为系统所共享，
它是一个动态链接库管理命令，这就是 ldconfig 命令的作用。

3.2.1.2 protoc 插件安装

我们在上一步安装了 protoc 编译器，但是还是不够的，针对不同的语言，还需要不同的运行时的 protoc 插件，
那么对应 Go 语言就是 protoc-gen-go 插件，接下来可以在命令行执行如下安装命令：
```
$ go get -u github.com/golang/protobuf/protoc-gen-go@v1.3.2
```

同时 protoc-gen-go 因为一直处于更新迭代的过程中，如果不锁定版本，随着时间的推移，
很有可能会出现不兼容的情况（因为需要与 proto 软件包版本相匹配），这是非常麻烦的，因此我们也可以通过如下命令进行安装：
```
$ GIT_TAG="v1.3.2"
$ go get -d -u github.com/golang/protobuf/protoc-gen-go
$ git -C "$(go env GOPATH)"/src/github.com/golang/protobuf checkout $GIT_TAG
$ go install github.com/golang/protobuf/protoc-gen-go
```

将所编译安装的 Protoc Plugin 的可执行文件中移动到相应的 bin 目录下，例如：
```
$ mv $GOPATH/bin/protoc-gen-go /usr/local/go/bin/
```

这里的命令操作并非是绝对必须的，主要目的是将二进制文件 protoc-gen-go 移动到 bin 目录下，
让其可以直接运行 protoc-gen-go 执行，只要达到这个效果就可以了。

3.2.2 初始化 Demo 项目

接下来我们初始化一个 gRPC 专用的 Demo 项目，用于演示后续的 gRPC 和 Protobuf 应用，执行下述命令：
```
$ mkdir -p $HOME/go-programming-tour-book/grpc-demo
$ cd $HOME/go-programming-tour-book/grpc-demo
$ go mod init github.com/go-programming-tour-book/grpc-demo
```

在初始化目录结构后，新建 server、client、proto 目录，便于后续的使用，最终目录结构如下：
```
grpc-demo
├── go.mod
├── client
├── proto
└── server
```

3.2.3 编译和生成 proto 文件

3.2.3.1 创建 proto 文件

我们在项目的 proto 目录下新建 helloworld.proto 文件，写入如下声明：
```
syntax = "proto3";

package helloworld;

service Greeter {
    rpc SayHello (HelloRequest) returns (HelloReply) {}
}

message HelloRequest {
    string name = 1;
}

message HelloReply {
    string message = 1;
}
```

3.2.3.2 生成 proto 文件

接下来我们在项目的根目录下，执行 protoc 的相关命令来生成对应的 pb.go 文件，如下：
```
$ protoc --go_out=plugins=grpc:. ./proto/*.proto 
```

* –go_out：设置所生成 Go 代码输出的目录，该指令会加载 protoc-gen-go 插件达到生成 Go 代码的目的，
生成的文件以 .pb.go 为文件后缀，在这里 “:”（冒号）号充当分隔符的作用，后跟命令所需要的参数集，
在这里代表着要将所生成的 Go 代码输出到所指向 protoc 编译的当前目录。
* plugins=plugin1+plugin2：指定要加载的子插件列表，我们定义的 proto 文件是涉及了 RPC 服务的，
而默认是不会生成 RPC 代码的，因此需要在 go_out 中给出 plugins 参数传递给 protoc-gen-go，告诉编译器，
请支持 RPC（这里指定了内置的 grpc 插件）。

在执行这条命令后，就会生成此 proto 文件的对应.pb.go 文件，如下：
```
helloworld.pb.go helloworld.proto
```

3.2.3.3 生成的.pb.go 文件

我们查看刚刚所生成的 helloworld.pb.go 文件，pb.go 文件是针对 proto 文件所生成的对应的 Go 语言代码，
是我们实际在应用中将会引用到的文件，我们一起看看生成出来的文件提供了什么功能，代码如下：
```
type HelloRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	...
}

func (m *HelloRequest) Reset()         { *m = HelloRequest{} }
func (m *HelloRequest) String() string { return proto.CompactTextString(m) }
func (*HelloRequest) ProtoMessage()    {}
func (*HelloRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d53fe9c48eadaad, []int{0}
}
func (m *HelloRequest) GetName() string {...}
```

在上述代码中，主要涉及针对 HelloRequest 类型，其包含了一组 Getters 方法，能够提供便捷的取值方式，
并且处理了一些空指针取值的情况，还能够通过 Reset 方法来重置该参数。而该方法通过实现 ProtoMessage 方法，
以此表示这是一个实现了 proto.Message 的接口。另外 HelloReply 类型也是类似的生成结果，因此不重复概述。

接下来我们看到.pb.go 文件的初始化方法，其中比较特殊的就是 fileDescriptor 的相关语句，如下：
```
func init() {
	proto.RegisterType((*HelloRequest)(nil), "helloworld.HelloRequest")
	proto.RegisterType((*HelloReply)(nil), "helloworld.HelloReply")
}

func init() { proto.RegisterFile("proto/helloworld.proto", fileDescriptor_4d53fe9c48eadaad) }

var fileDescriptor_4d53fe9c48eadaad = []byte{
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x2b, 0x28, 0xca, 0x2f,
	...
}
```

实际上我们所看到的 fileDescriptor_4d53fe9c48eadaad 表示的是一个经过编译后的 proto 文件，是对 proto 文件的整体描述，
其包含了 proto 文件名、引用（import）内容、包（package）名、选项设置、所有定义的消息体（message）、
所有定义的枚举（enum）、所有定义的服务（ service）、所有定义的方法（rpc method）等等内容，
可以认为就是整个 proto 文件的信息你都能够取到。

同时在我们的每一个 Message Type 中都包含了 Descriptor 方法，Descriptor 代指对一个消息体（message）定义的描述，
而这一个方法则会在 fileDescriptor 中寻找属于自己 Message Field 所在的位置再进行返回，如下：
```
func (*HelloRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d53fe9c48eadaad, []int{0}
}

func (*HelloReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d53fe9c48eadaad, []int{1}
}
```

接下来我们再往下看可以看到 GreeterClient 接口，因为 Protobuf 是客户端和服务端可共用一份.proto 文件的，
因此除了存在数据描述的信息以外，还会存在客户端和服务端的相关内部调用的接口约束和调用方式的实现，
在后续我们在多服务内部调用的时候会经常用到，如下：
```
type GreeterClient interface {
	SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error)
}

type greeterClient struct {
	cc *grpc.ClientConn
}

func NewGreeterClient(cc *grpc.ClientConn) GreeterClient {
	return &greeterClient{cc}
}

func (c *greeterClient) SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error) {
	out := new(HelloReply)
	err := c.cc.Invoke(ctx, "/helloworld.Greeter/SayHello", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}
```

3.2.4 更多的类型支持

在前面的例子中，我们已经大致了解到 Protobuf 的基本使用和内部情况，而其本身也支持了很多的数据类型，
在本节我们将挑选一些常用的类型进行讲解。

3.2.4.1 通用类型

在 Protobuf 中一共支持 double、float、int32、int64、uint32、uint64、sint32、sint64、fixed32、fixed64、
sfixed32、sfixed64、bool、string、bytes 类型，例如一开始使用的是字符串类型，当然你也可以根据实际情况，修改成上述类型，例如：
```
message HelloRequest {
    bytes name = 1;
}
```

另外我们常常会遇到需要传递动态数组的情况，在 protobuf 中，我们可以使用 repeated 关键字，如果一个字段被声明为 repeated，
那么该字段可以重复任意次（包括零次），重复值的顺序将保留在 protobuf 中，将重复字段视为动态大小的数组，如下：
```
message HelloRequest {
    repeated string name = 1;
}
```

3.2.4.2 嵌套类型

嵌套类型，也就是字面意思，在 message 消息体中，又嵌套了其它的 message 消息体，一共有两种模式，如下：
```
message HelloRequest {
    message World {
        string name = 1;
    }
    
    repeated World worlds = 1;
}
```

第一种是将 World 消息体定义在 HelloRequest 消息体中，也就是其归属在消息体 HelloRequest 下，
若要调用则需要使用 HelloRequest.World 的方式，外部才能引用成功。

第二种是将 World 消息体定义在外部，一般比较推荐使用这种方式，清晰、方便，如下：
```
message World {
    string name = 1;
}

message HelloRequest {
    repeated World worlds = 1;
}
```

3.2.4.3 Oneof

如果你希望你的消息体可以包含多个字段，但前提条件是最多同时只允许设置一个字段，那么就可以使用 oneof 关键字来实现这个功能，如下：
```
message HelloRequest {
    oneof name {
        string nick_name = 1;
        string true_name = 2;
    }
}
```

3.2.4.4 Enum

枚举类型，限定你所传入的字段值必须是预定义的值列表之一，如下：
```
enum NameType {
    NickName = 0;
    TrueName = 1;
}

message HelloRequest {
    string name = 1;
    NameType nameType = 2;
}
```

3.2.4.5 Map

map 类型，需要设置键和值的类型，格式为 map<key_type, value_type> map_field = N;，示例如下：
```
message HelloRequest {
    map<string, string> names = 2;
}
```

3.2.5 小结

在本章节中，我们对 Protobuf 进行了更详细的使用和说明，我们可得知.proto 文件需要通过 Protobuf 的编译器 protoc 来编译后才能够使用，
而在各个语言的具体插件实现中，protoc-gen-go 是 protoc 中针对 Go 语言的 protoc plugin，它们是相对隔离且解耦的，
因此在未来我们也可以自己实现一个 protoc plugin，针对企业内部的定制化需求非常的方便。

另外在 Protobuf 的类型使用上，其支持大量的类型，我在上文中只列举了在应用开发中常见的，大家可以根据实际需求再进一步的了解。


### 3.3 gRPC 的使用和了解


### 3.4 运行一个 gRPC 服务


### 3.5 进行服务间内调


### 3.6 同时提供 HTTP 接口


### 3.7 生成接口文档


### 3.8 拦截器介绍和实际使用


### 3.9 Metadata 和 RPC 自定义认证


### 3.10 进行链路追踪


### 3.11 服务注册和发现


### 3.12 实现自定义的 protoc 插件


### 3.13 对接口进行版本管理


### 3.14 思考



## 附注




<br/><br/><br/><br/><br/>
## 参考资料


