---
layout: post
categories: Golang
title: Go 语言编程之旅
meta: Go 语言编程之旅
---
* content
{:toc}

## 正文

这个系列作为入门，是种选择。




本书概览：

![]({{site.baseurl}}/images/20211030/20211030134720.png)

可以先看下 [附录 A：Go Modules 终极入门](https://golang2.eddycjy.com/posts/appendix/01-go-modules-use/) 熟悉一下编程环境，
工欲善其事必先利其器，这样就不会为 GOPATH、Go Modules 所乱花渐欲迷人眼了。



### 第一章 命令行应用

#### 1.1 打开工具之旅

1.1 打开工具之旅

我想，绝大部分工程师，都会想拥有一个属于自己的工具集，那一定是一件很酷又非常有趣的事情。
因为它在给你带来极大的生活和工作效率提高的同时也能给你带来不少的成就感，更重要的是在你持续不断的维护迭代你的项目的时候，
你的技术也会得到磨炼，而你遇到的问题，别人可能也有，当你更进一步地开源出去了，也有可能会给别人带来非常大的帮助，
事实上，GitHub 里许许多多的优秀个人开源项目也是这么来的，这必然是一件一举多得的事情。

因此在本章节中，我们将做一个简单的通用工具集，这是最直接的方式，我们用它解决在平时工作中经常会遇到的一些小麻烦，
让我们不再去借助其它的快捷网站，让我们自己的产品为自己服务，不断的迭代它。

1.1 用什么

本次工具类别的项目我们会在一开始使用标准库 flag 来作为引子，标准库 flag 是在 Go 语言中的一个大利器，
它主要的功能是实现了命令行参数的解析，能够让我们在开发的过程中非常方便的解析和处理命令行参数，
是一个需要必知必会的基础标准库，因此在本章我们会先对标准库 flag 进行基本的讲解。

在后续项目的具体开发和进一步拓展中，我们将使用开源项目 Cobra 来协助我们快速构建我们的 CLI 应用程序，
Cobra 的主要功能是创建功能强大的现代 CLI 应用程序，同时也是一个生成应用程序和命令文件的程序。它非常的便捷和强大，
目前市面上许多的著名的 Go 语言开源项目都是使用 Cobra 来构建的，例如：Kubernetes、Hugo、etcd、Docker 等等，是非常可靠的一个开源项目。

1.2 初始化项目

开始之前，我们通过如下命令初始化 tour 项目（若为 Windows 系统，可根据实际情况自行调整项目的路径），执行如下命令：

$ mkdir -p $HOME/go-programming-tour-book/tour 
$ cd $HOME/go-programming-tour-book/tour
$ go mod init github.com/go-programming-tour-book/tour

在执行命令完毕后，我们就已经完成了初始化项目的第一步，各命令的含义如下：

    确定本书的项目工作路径，并循环递归创建 tour 项目目录。
    切换当前工作区到 tour 项目目录下。
    初始化项目的 Go modules，设置项目的模块路径。

需要注意的一点是，我们在依赖管理上使用的是 Go modules 的模式（详细介绍可见附录），
也就是系统环境变量 GO111MODULE 为 auto 或 on（开启状态），若你在初始化 Go modules 时出现了相关错误提示，应当将 Go modules 开启，如下命令：

$ go env -w GO111MODULE=on

执行这条命令后，Go 工具链将会将系统环境变量 GO111MODULE 设置为 on，但是需要注意的是语句 go env -w 并不支持覆写，你手动进行 export GO111MODULE=on 设置亦可。

另外若是初次使用 Go modules，建议设置国内镜像代理，否则会出现外网模块拉不下来的问题，设置命令如下：

$ go env -w GOPROXY=https://goproxy.cn,direct

1.3 示例
1.3.1 flag 基本使用和长短选项

我们编写一个简单的示例，用于了解标准库 flag 的基本使用，代码如下：

func main() {
	var name string
	flag.StringVar(&name, "name", "Go 语言编程之旅", "帮助信息")
	flag.StringVar(&name, "n", "Go 语言编程之旅", "帮助信息")
	flag.Parse()

	log.Printf("name: %s", name)
}

通过上述代码，我们调用标准库 flag 的 StringVar 方法实现了对命令行参数 name 的解析和绑定，其各个形参的含义分别为命令行标识位的名称、默认值、帮助信息。针对命令行参数，其支持如下三种命令行标志语法，分别如下：

    -flag：仅支持布尔类型。
    -flag x ：仅支持非布尔类型。
    -flag=x：均支持

同时 flag 标准库还提供了多种类型参数绑定的方式，根据各自的应用程序使用情况选用即可，接下来我们运行该程序，检查输出结果与预想的是否一致，如下：

$ go run main.go -name=eddycjy -n= 煎鱼
name: 煎鱼

我们可以发现输出的结果是最后一个赋值的变量，也就是 -n。

你可能会有一些疑惑，为什么长短选项要分开两次调用，一个命令行参数的标志位有长短选项，是常规需求，这样子岂不是重复逻辑，有没有优化的办法呢。

实际上标准库 flag 并不直接支持该功能，但是我们可以通过其它第三方库来实现这个功能，这块我们在后续也会使用到。
1.3.3 子命令的实现

在我们日常使用的 CLI 应用中，另外一个最常见的功能就是子命令的使用，一个工具它可能包含了大量相关联的功能命令以此形成工具集，可以说是刚需，那么这个功能在标准库 flag 中可以如何实现呢，如下述示例：

var name string

func main() {
	flag.Parse()

	args := flag.Args()
	if len(args) <= 0 {
		return
	}
	
	switch args[0] {
	case "go":
		goCmd := flag.NewFlagSet("go", flag.ExitOnError)
		goCmd.StringVar(&name, "name", "Go 语言", "帮助信息")
		_ = goCmd.Parse(args[1:])
	case "php":
		phpCmd := flag.NewFlagSet("php", flag.ExitOnError)
		phpCmd.StringVar(&name, "n", "PHP 语言", "帮助信息")
		_ = phpCmd.Parse(args[1:])
	}

	log.Printf("name: %s", name)
}

在上述代码中，我们首先调用了 flag.Parse 方法，将命令行解析为定义的标志，便于我们后续的参数使用。

另外由于我们需要处理子命令的情况，因此我们调用了 flag.NewFlagSet 方法，该方法会返回带有指定名称和错误处理属性的空命令集给我们去使用，相当于就是创建一个新的命令集了去支持子命令了。

这里需要特别注意的是 flag.NewFlagSet 方法的第二个参数是 ErrorHandling，用于指定处理异常错误的情况处理，其内置提供以下三种模式：

const (
	// 返回错误描述
	ContinueOnError ErrorHandling = iota 
	// 调用 os.Exit(2) 退出程序
	ExitOnError       
	// 调用 panic 语句抛出错误异常
	PanicOnError                       
)

接下来我们运行针对子命令的示例程序，对正确和异常场景进行检查，如下：

$ go run main.go go -name=eddycjy
name: eddycjy

$ go run main.go php -n= 煎鱼   
name: 煎鱼

$ go run main.go go -n=eddycjy
flag provided but not defined: -n
Usage of go:
  -name string
    	帮助信息 (default "Go 语言")
exit status 2

通过输出结果可以知道这段示例程序已经准确的识别了不同的子命令，并且因为我们 ErrorHandling 传递的是 ExitOnError 级别，
因此在识别到传递的命令行参数标志是未定义时，会进行直接退出程序并提示错误信息。
1.4 分析

从使用上来讲，标准库 flag 非常方便，一个简单的 CLI 应用很快就搭建起来了，但是它又是怎么实现的呢，
我们一起来深入看看，要做到知其然知其所以然，肯定非常有意思，整体分析流程如下：

image
1.4.1 flag.Parse

首先我们看到 flag.Parse 方法，它总是在所有命令行参数注册的最后进行调用，函数功能是解析并绑定命令行参数，我们一起看看其内部实现：

var CommandLine = NewFlagSet(os.Args[0], ExitOnError)

func Parse() {
	CommandLine.Parse(os.Args[1:])
}

该方法是调用 NewFlagSet 方法实例化一个新的空命令集，然后通过调用 os.Args 作为外部参数传入。

但这里需要注意一个点，Parse 方法使用的是 CommandLine 变量，它所默认传入的 ErrorHandling 是 ExitOnError，
也就是如果在解析时遇到异常或错误，就会直接退出程序，因此如果你的应用程序不希望解析命令行参数失败，就导致应用启动中断的话，需要进行额外的处理。
1.4.2 FlagSet.Parse

接下来是 FlagSet.Parse，其主要承担了 parse 方法的异常分流处理，如下：

func (f *FlagSet) Parse(arguments []string) error {
	f.parsed = true
	f.args = arguments
	for {
		seen, err := f.parseOne()
		if seen {
			continue
		}
		if err == nil {
			break
		}
		switch f.errorHandling {
		case ContinueOnError:
			return err
		case ExitOnError:
			os.Exit(2)
		case PanicOnError:
			panic(err)
		}
	}
	return nil
}

该方法是对解析方法的进一步封装，实质的解析逻辑放在 parseOne 中，而解析过程中遇到的一些特殊情况，
例如：重复解析、异常处理等，均直接由该方法处理，这实际上是一个分层明显，结构清晰的方法设计，很值得大家去参考。
1.4.3 FlagSet.parseOne

最后会流转到命令行解析的核心方法 FlagSet.parseOne 下进行处理，如下：

func (f *FlagSet) parseOne() (bool, error) {
	if len(f.args) == 0 {
		return false, nil
	}
	s := f.args[0]
	if len(s) < 2 || s[0] != '-' {
		return false, nil
	}
	numMinuses := 1
	if s[1] == '-' {
		numMinuses++
		if len(s) == 2 { // "--" terminates the flags
			f.args = f.args[1:]
			return false, nil
		}
	}
	name := s[numMinuses:]
	if len(name) == 0 || name[0] == '-' || name[0] == '=' {
		return false, f.failf("bad flag syntax: %s", s)
	}
	...
}

在上述代码中，我们可以看到主要是针对一些不符合命令行参数绑定规则的校验处理，大致分为以下四种情况：

    如果命令行参数长度为 0。
    如果遇到长度小于 2 或不满足 flag 标识符”-“。
    如果 flag 标志位为”–“的情况下，则中断处理，并跳过该字符，也就是后续会以”-“进行处理。
    如果在处理 flag 标志位后，取到的参数名不符合规则，也将中断处理，例如：go run main.go go ---name=eddycjy，就会导致返回 bad flag syntax 的错误提示。

在定位命令行参数节点上，采用的依据是根据”-“的索引定位解析出上下的参数名（name）和参数的值（value），部分核心代码如下：

func (f *FlagSet) parseOne() (bool, error) {
	f.args = f.args[1:]
	hasValue := false
	value := ""
	for i := 1; i < len(name); i++ { // equals cannot be first
		if name[i] == '=' {
			value = name[i+1:]
			hasValue = true
			name = name[0:i]
			break
		}
	}
	...
}

最后在设置参数值上，会对值类型进行判断，若是布尔类型，则调用定制的 boolFlag 类型进行判断和处理，
最后通过该 flag 所提供的 Value.Set 方法将参数值设置到对应的 flag 中去，核心代码如下：

func (f *FlagSet) parseOne() (bool, error) {
	if fv, ok := flag.Value.(boolFlag); ok && fv.IsBoolFlag() {
		if hasValue {
			if err := fv.Set(value); err != nil {
				return false, f.failf("invalid boolean value %q for -%s: %v", value, name, err)
			}
		} else {
			if err := fv.Set("true"); err != nil {
				return false, f.failf("invalid boolean flag %s: %v", name, err)
			}
		}
	} else {
		...
		if err := flag.Value.Set(value); err != nil {
			return false, f.failf("invalid value %q for flag -%s: %v", value, name, err)
		}
	}
}

1.5 自定义参数类型

刚刚看到上述的分析后，不知道你是否注意到，flag 的命令行参数类型是可以自定义的，也就是我们的 Value.Set 方法，我们只需要实现其对应的 Value 相关的两个接口就可以了，如下：

type Value interface {
	String() string
	Set(string) error
}

我们将原先的字符串变量 name 修改为类别别名，并为其定义符合 Value 的两个结构体方法，示例代码如下：

type Name string

func (i *Name) String() string {
	return fmt.Sprint(*i)
}

func (i *Name) Set(value string) error {
	if len(*i) > 0 {
		return errors.New("name flag already set")
	}

	*i = Name("eddycjy:" + value)
	return nil
}

func main() {
	var name Name
	flag.Var(&name, "name", "帮助信息")
	flag.Parse()

	log.Printf("name: %s", name)
}

该示例最终的输出结果为 name: eddycjy:Go 语言编程之旅 ，也就是只要我们实现了 Value 的 String 和 Set 方法，
就可以进行定制化，然后无缝地接入我们的命令行参数的解析中，这就是 Go 语言的接口设计魅力之处。

1.6 小结

我们初步介绍了本章的一个基本思路，并对我们最常用的标准库 flag 进行了介绍和使用说明，
标准库 flag 的使用将始终穿插在所有的章节中，因为我们常常会需求读取外部命令行的参数，例如像是启动端口号、日志路径设置等等，非常常用。


#### 1.2 单词格式转换
#### 1.3 便捷的时间工具
#### 1.4 SQL 语句到结构体的转换

###  第二章 HTTP 应用

#### 2.1 开启博客之路
#### 2.2 进行项目设计
#### 2.3 编写公共组件
#### 2.4 生成接口文档
#### 2.5 为接口做参数校验
#### 2.6 模块开发：标签管理
#### 2.7 上传图片和文件服务
#### 2.8 对接口进行访问控制
#### 2.9 应用中间件
#### 2.10 进行链路追踪
#### 2.11 应用配置
#### 2.12 应用编译
#### 2.13 优雅重启和停止
#### 2.14 思考

###  第三章 RPC 应用

#### 3.1 遨游 gRPC 和 Protobuf
#### 3.2 Protobuf 的使用和了解
#### 3.3 gRPC 的使用和了解
#### 3.4 运行一个 gRPC 服务
#### 3.5 进行服务间内调
#### 3.6 同时提供 HTTP 接口
#### 3.7 生成接口文档
#### 3.8 拦截器介绍和实际使用
#### 3.9 Metadata 和 RPC 自定义认证
#### 3.10 进行链路追踪
#### 3.11 服务注册和发现
#### 3.12 实现自定义的 protoc 插件
#### 3.13 对接口进行版本管理
#### 3.14 思考

### 第四章 Websocket 应用

#### 4.1 基于 TCP 的聊天室
#### 4.2 WebSocket 介绍、握手协议和细节
#### 4.3 聊天室需求分析和设计
#### 4.4 实现聊天室：项目组织和基础代码框架
#### 4.5 实现聊天室：核心流程
#### 4.6 实现聊天室：广播器
#### 4.7 非核心功能
#### 4.8 关键性能分析和优化
#### 4.9 Nginx 部署
#### 4.10 总结

### 第五章 进程内缓存

#### 5.1 缓存简介
#### 5.2 缓存淘汰算法
#### 5.3 实现一个进程内缓存
#### 5.4 缓存的性能和优化思路
#### 5.5 高性能缓存库：BigCache
#### 5.6 进程内缓存的优化版

### 第六章 Go 语言中的大杀器

#### 6.1 Go 大杀器之性能剖析 PProf（上）
#### 6.2 Go 大杀器之性能剖析 PProf（下）
#### 6.3 Go 大杀器之跟踪剖析 trace
#### 6.4 用 GODEBUG 看调度跟踪
#### 6.5 用 GODEBUG 看 GC
#### 6.6 Go 进程诊断工具 gops
#### 6.7 公开和发布度量指标
#### 6.8 逃逸分析：变量在哪儿

### 附录

#### 附录 A：Go Modules 终极入门

#### 附录 B：Goroutine 与 panic、recover 的小问题

#### 附录 C：Go 在容器运行时要注意这个细节

#### 附录 D：让 Go panic 的十种方法



<br/><br/><br/><br/><br/>
## 参考资料

Go语言编程之旅：一起用Go做项目 <https://golang2.eddycjy.com/>

煎鱼github <https://github.com/eddycjy>

Go 语言编程之旅：一起用 Go 做项目 github <https://github.com/go-programming-tour-book>

Gin实践 <https://github.com/EDDYCJY/go-gin-example/blob/master/README_ZH.md>

Go Gin Example <https://github.com/EDDYCJY/go-gin-example/blob/master/README_ZH.md>

Go Gin Example github project <https://github.com/eddycjy/go-gin-example>

Gin实践 的连载 <https://eddycjy.com/tags/gin/>
