---
layout: post
categories: Golang
title: Go fmt库
meta: Go fmt库
---
* content
{:toc}

## 正文

fmt库的包：


### 输出

fmt.Print有几个变种：
* Print:   输出到控制台,不接受任何格式化操作
* Println: 输出到控制台并换行
* Printf : 只可以打印出格式化的字符串。只可以直接输出字符串类型的变量（不可以输出别的类型）
* Sprintf：格式化并返回一个字符串而不带任何输出
* Fprintf：来格式化并输出到 io.Writers 而不是 os.Stdout

#### 通用的占位符

* `%v`     值的默认格式。
* `%+v`   类似%v，但输出结构体时会添加字段名
* `%#v`　 相应值的Go语法表示 
* `%T`    相应值的类型的Go语法表示 
* `%%`    百分号,字面上的`%`,非占位符含义

如：
```
package main

import (
	"fmt"
)

type User struct {
	Name string
	Age  int
}

func main() {
	user := User{"xiaoming", 13}
	fmt.Println(user)
	//Go默认形式
	fmt.Printf("%v",user)
	fmt.Println()
	//输出字段名和字段值形式
	fmt.Printf("%+v",user)
	fmt.Println()
	//类型+值对象
	fmt.Printf("%#v",user)
	fmt.Println()
	//值类型的Go语法表示形式
	fmt.Printf("%T",user)
	fmt.Println()
	fmt.Printf("%%")
}
```

输出：
```
{xiaoming 13}
{xiaoming 13}
{Name:xiaoming Age:13}
main.User{Name:"xiaoming", Age:13}
main.User
%
```

#### 常用类型

```
The verbs:
	General:
		%v	the value in a default format
			when printing structs, the plus flag (%+v) adds field names
		%#v	a Go-syntax representation of the value
		%T	a Go-syntax representation of the type of the value
		%%	a literal percent sign; consumes no value

	Boolean:
		%t	the word true or false
	Integer:
		%b	base 2
		%c	the character represented by the corresponding Unicode code point
		%d	base 10
		%o	base 8
		%O	base 8 with 0o prefix
		%q	a single-quoted character literal safely escaped with Go syntax.
		%x	base 16, with lower-case letters for a-f
		%X	base 16, with upper-case letters for A-F
		%U	Unicode format: U+1234; same as "U+%04X"
	Floating-point and complex constituents:
		%b	decimalless scientific notation with exponent a power of two,
			in the manner of strconv.FormatFloat with the 'b' format,
			e.g. -123456p-78
		%e	scientific notation, e.g. -1.234456e+78
		%E	scientific notation, e.g. -1.234456E+78
		%f	decimal point but no exponent, e.g. 123.456
		%F	synonym for %f
		%g	%e for large exponents, %f otherwise. Precision is discussed below.
		%G	%E for large exponents, %F otherwise
		%x	hexadecimal notation (with decimal power of two exponent), e.g. -0x1.23abcp+20
		%X	upper-case hexadecimal notation, e.g. -0X1.23ABCP+20
	String and slice of bytes (treated equivalently with these verbs):
		%s	the uninterpreted bytes of the string or slice
		%q	a double-quoted string safely escaped with Go syntax
		%x	base 16, lower-case, two characters per byte
		%X	base 16, upper-case, two characters per byte
	Slice:
		%p	address of 0th element in base 16 notation, with leading 0x
	Pointer:
		%p	base 16 notation, with leading 0x
		The %b, %d, %o, %x and %X verbs also work with pointers,
		formatting the value exactly as if it were an integer.

	The default format for %v is:
		bool:                    %t
		int, int8 etc.:          %d
		uint, uint8 etc.:        %d, %#x if printed with %#v
		float32, complex64, etc: %g
		string:                  %s
		chan:                    %p
		pointer:                 %p
	For compound objects, the elements are printed using these rules, recursively,
	laid out like this:
		struct:             {field0 field1 ...}
		array, slice:       [elem0 elem1 ...]
		maps:               map[key1:value1 key2:value2 ...]
		pointer to above:   &{}, &[], &map[]

	Width is specified by an optional decimal number immediately preceding the verb.
	If absent, the width is whatever is necessary to represent the value.
	Precision is specified after the (optional) width by a period followed by a
	decimal number. If no period is present, a default precision is used.
	A period with no following number specifies a precision of zero.
	Examples:
		%f     default width, default precision
		%9f    width 9, default precision
		%.2f   default width, precision 2
		%9.2f  width 9, precision 2
		%9.f   width 9, precision 0
		
Other flags:
    +	always print a sign for numeric values;
        guarantee ASCII-only output for %q (%+q)
    -	pad with spaces on the right rather than the left (left-justify the field)
    #	alternate format: add leading 0b for binary (%#b), 0 for octal (%#o),
        0x or 0X for hex (%#x or %#X); suppress 0x for %p (%#p);
        for %q, print a raw (backquoted) string if strconv.CanBackquote
        returns true;
        always print a decimal point for %e, %E, %f, %F, %g and %G;
        do not remove trailing zeros for %g and %G;
        write e.g. U+0078 'x' if the character is printable for %U (%#U).
    ' '	(space) leave a space for elided sign in numbers (% d);
        put spaces between bytes printing strings or slices in hex (% x, % X)
    0	pad with leading zeros rather than spaces;
        for numbers, this moves the padding after the sign
```

## 解说

### 解说一

Print() 函数将参数列表 a 中的各个参数转换为字符串并写入到标准输出中。

非字符串参数之间会添加空格，返回写入的字节数。
```
func Print(a ...interface{}) (n int, err error)
```

Println() 函数功能类似 Print，只不过最后会添加一个换行符。

所有参数之间会添加空格，返回写入的字节数。
```
func Println(a ...interface{}) (n int, err error)
```

Printf() 函数将参数列表 a 填写到格式字符串 format 的占位符中。

填写后的结果写入到标准输出中，返回写入的字节数。
```
func Printf(format string, a ...interface{}) (n int, err error)
```

以下三个函数功能同上面三个函数（Print()、Println()、Printf()），只不过将转换结果写入到 w 中。
```
func Fprint(w io.Writer, a ...interface{}) (n int, err error)
func Fprintln(w io.Writer, a ...interface{}) (n int, err error)
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)
```

以下三个函数功能同上面三个函数（Print()、Println()、Printf()），只不过将转换结果以字符串形式返回。
```
func Sprint(a ...interface{}) string
func Sprintln(a ...interface{}) string
func Sprintf(format string, a ...interface{}) string
```

以下函数功能同 Sprintf() 函数，只不过结果字符串被包装成了 error 类型。
```
func Errorf(format string, a ...interface{}) error
```

实例：
```
func main() {
    fmt.Print("a", "b", 1, 2, 3, "c", "d", "\n")
    fmt.Println("a", "b", 1, 2, 3, "c", "d")
    fmt.Printf("ab %d %d %d cd\n", 1, 2, 3)
    // ab1 2 3cd
    // a b 1 2 3 c d
    // ab 1 2 3 cd

    if err := percent(30, 70, 90, 160); err != nil {
        fmt.Println(err)
    }
    // 30%
    // 70%
    // 90%
    // 数值 160 超出范围（100）
}

func percent(i ...int) error {
    for _, n := range i {
        if n > 100 {
            return fmt.Errorf("数值 %d 超出范围（100）", n)
        }
        fmt.Print(n, "%\n")
    }
    return nil
}
```

Formatter 由自定义类型实现，用于实现该类型的自定义格式化过程。

当格式化器需要格式化该类型的变量时，会调用其 Format 方法。
```
type Formatter interface {
    // f 用于获取占位符的旗标、宽度、精度等信息，也用于输出格式化的结果
    // c 是占位符中的动词
    Format(f State, c rune)
}
```

由格式化器（Print 之类的函数）实现，用于给自定义格式化过程提供信息:
```
type State interface {
    // Formatter 通过 Write 方法将格式化结果写入格式化器中，以便输出。
    Write(b []byte) (ret int, err error)
    // Formatter 通过 Width 方法获取占位符中的宽度信息及其是否被设置。
    Width() (wid int, ok bool)
    // Formatter 通过 Precision 方法获取占位符中的精度信息及其是否被设置。
    Precision() (prec int, ok bool)
    // Formatter 通过 Flag 方法获取占位符中的旗标[+- 0#]是否被设置。
    Flag(c int) bool
}
```

Stringer 由自定义类型实现，用于实现该类型的自定义格式化过程。

当格式化器需要输出该类型的字符串格式时就会调用其 String 方法。
```
type Stringer interface {
    String() string
}
```

Stringer 由自定义类型实现，用于实现该类型的自定义格式化过程。

当格式化器需要输出该类型的 Go 语法字符串（%#v）时就会调用其 String 方法。
```
type GoStringer interface {
    GoString() string
}
```

实例：
```
type Ustr string

func (us Ustr) String() string {
    return strings.ToUpper(string(us))
}

func (us Ustr) GoString() string {
    return `"` + strings.ToUpper(string(us)) + `"`
}

func (u Ustr) Format(f fmt.State, c rune) {
    write := func(s string) {
        f.Write([]byte(s))
    }
    switch c {
    case 'm', 'M':
        write("旗标：[")
        for s := "+- 0#"; len(s) > 0; s = s[1:] {
            if f.Flag(int(s[0])) {
                write(s[:1])
            }
        }
        write("]")
        if v, ok := f.Width(); ok {
            write(" | 宽度：" + strconv.FormatInt(int64(v), 10))
        }
        if v, ok := f.Precision(); ok {
            write(" | 精度：" + strconv.FormatInt(int64(v), 10))
        }
    case 's', 'v': // 如果使用 Format 函数，则必须自己处理所有格式，包括 %#v
        if c == 'v' && f.Flag('#') {
            write(u.GoString())
        } else {
            write(u.String())
        }
    default: // 如果使用 Format 函数，则必须自己处理默认输出
        write("无效格式：" + string(c))
    }
}

func main() {
    u := Ustr("Hello World!")
    // "-" 标记和 "0" 标记不能同时存在
    fmt.Printf("%-+ 0#8.5m\n", u) // 旗标：[+- #] | 宽度：8 | 精度：5
    fmt.Printf("%+ 0#8.5M\n", u)  // 旗标：[+ 0#] | 宽度：8 | 精度：5
    fmt.Println(u)                // HELLO WORLD!
    fmt.Printf("%s\n", u)         // HELLO WORLD!
    fmt.Printf("%#v\n", u)        // "HELLO WORLD!"
    fmt.Printf("%d\n", u)         // 无效格式：d
}
```

Scan 从标准输入中读取数据，并将数据用空白分割并解析后存入 a 提供的变量中（换行符会被当作空白处理），变量必须以指针传入。

当读到 EOF 或所有变量都填写完毕则停止扫描。

返回成功解析的参数数量。
```
func Scan(a ...interface{}) (n int, err error)
```

Scanln 和 Scan 类似，只不过遇到换行符就停止扫描。
```
func Scanln(a ...interface{}) (n int, err error)
```

Scanf 从标准输入中读取数据，并根据格式字符串 format 对数据进行解析，将解析结果存入参数 a 所提供的变量中，变量必须以指针传入。

输入端的换行符必须和 format 中的换行符相对应（如果格式字符串中有换行符，则输入端必须输入相应的换行符）。

占位符 %c 总是匹配下一个字符，包括空白，比如空格符、制表符、换行符。

返回成功解析的参数数量。
```
func Scanf(format string, a ...interface{}) (n int, err error)
```

以下三个函数功能同上面三个函数，只不过从 r 中读取数据。
```
func Fscan(r io.Reader, a ...interface{}) (n int, err error)
func Fscanln(r io.Reader, a ...interface{}) (n int, err error)
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)
```

以下三个函数功能同上面三个函数，只不过从 str 中读取数据。
```
func Sscan(str string, a ...interface{}) (n int, err error)
func Sscanln(str string, a ...interface{}) (n int, err error)
func Sscanf(str string, format string, a ...interface{}) (n int, err error)
```

实例:
```
// 对于 Scan 而言，回车视为空白
func main() {
    a, b, c := "", 0, false
    fmt.Scan(&a, &b, &c)
    fmt.Println(a, b, c)
    // 在终端执行后，输入 abc 1 回车 true 回车
    // 结果 abc 1 true
}

// 对于 Scanln 而言，回车结束扫描
func main() {
    a, b, c := "", 0, false
    fmt.Scanln(&a, &b, &c)
    fmt.Println(a, b, c)
    // 在终端执行后，输入 abc 1 true 回车
    // 结果 abc 1 true
}

// 格式字符串可以指定宽度
func main() {
    a, b, c := "", 0, false
    fmt.Scanf("%4s%d%t", &a, &b, &c)
    fmt.Println(a, b, c)
    // 在终端执行后，输入 1234567true 回车
    // 结果 1234 567 true
}
```

Scanner 由自定义类型实现，用于实现该类型的自定义扫描过程。

当扫描器需要解析该类型的数据时，会调用其 Scan 方法。
```
type Scanner interface {
    // state 用于获取占位符中的宽度信息，也用于从扫描器中读取数据进行解析。
    // verb 是占位符中的动词
    Scan(state ScanState, verb rune) error
}
```

由扫描器（Scan 之类的函数）实现，用于给自定义扫描过程提供数据和信息。
```
type ScanState interface {
    // ReadRune 从扫描器中读取一个字符，如果用在 Scanln 类的扫描器中，
    // 则该方法会在读到第一个换行符之后或读到指定宽度之后返回 EOF。
    // 返回“读取的字符”和“字符编码所占用的字节数”
    ReadRune() (r rune, size int, err error)
    // UnreadRune 撤消最后一次的 ReadRune 操作，
    // 使下次的 ReadRune 操作得到与前一次 ReadRune 相同的结果。
    UnreadRune() error
    // SkipSpace 为 Scan 方法提供跳过开头空白的能力。
    // 根据扫描器的不同（Scan 或 Scanln）决定是否跳过换行符。
    SkipSpace()
    // Token 用于从扫描器中读取符合要求的字符串，
    // Token 从扫描器中读取连续的符合 f(c) 的字符 c，准备解析。
    // 如果 f 为 nil，则使用 !unicode.IsSpace(c) 代替 f(c)。
    // skipSpace：是否跳过开头的连续空白。返回读取到的数据。
    // 注意：token 指向共享的数据，下次的 Token 操作可能会覆盖本次的结果。
    Token(skipSpace bool, f func(rune) bool) (token []byte, err error)
    // Width 返回占位符中的宽度值以及宽度值是否被设置
    Width() (wid int, ok bool)
    // 因为上面实现了 ReadRune 方法，所以 Read 方法永远不应该被调用。
    // 一个好的 ScanState 应该让 Read 直接返回相应的错误信息。
    Read(buf []byte) (n int, err error)
}
```

实例：
```
type Ustr string

func (u *Ustr) Scan(state fmt.ScanState, verb rune) (err error) {
    var s []byte
    switch verb {
    case 'S':
        s, err = state.Token(true, func(c rune) bool { return 'A' <= c && c <= 'Z' })
        if err != nil {
            return
        }
    case 's', 'v':
        s, err = state.Token(true, func(c rune) bool { return 'a' <= c && c <= 'z' })
        if err != nil {
            return
        }
    default:
        return fmt.Errorf("无效格式：%c", verb)
    }
    *u = Ustr(s)
    return nil
}

func main() {
    var a, b, c, d, e Ustr
    n, err := fmt.Scanf("%3S%S%3s%2v%x", &a, &b, &c, &d, &e)
    fmt.Println(a, b, c, d, e)
    fmt.Println(n, err)
    // 在终端执行后，输入 ABCDEFGabcdefg 回车
    // 结果：
    // ABC DEFG abc de
    // 4 无效格式：x
}
```

<br/><br/><br/><br/><br/>
## 参考资料

Go中的fmt几种输出的区别和格式化方式 <https://www.cnblogs.com/rickiyang/p/11074171.html>
