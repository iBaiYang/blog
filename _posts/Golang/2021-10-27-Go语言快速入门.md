---
layout: post
categories: Golang
title: Go语言快速入门
meta: Go语言快速入门
---
* content
{:toc}

## 正文

### 一、golang介绍

#### 1. 语言介绍

Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。

Go是从2007年末由Robert Griesemer, Rob Pike, Ken Thompson主持开发，后来还加入了Ian Lance Taylor, Russ Cox等人，
**并最终于2009年11月开源，在2012年早些时候发布了Go 1稳定版本**。现在Go的开发已经是完全开放的，并且拥有一个活跃的社区。

Go 语言是谷歌为充分利用现代硬件性能又兼顾开发效率而设计的一种全新语言。

**Go 是一种跨平台（Mac OS、Windows、Linux 等）静态编译型语言**。拥有媲美 C 语言的强大性能，支持静态类型安全，
在普通计算机上能几秒内快速编译一个大项目，开发效率跟动态语言相差无几。

Go 语言在国内拥有非常活跃的社区、不仅大公司的 Go 项目越来越多，中小公司也都在考虑 Go 的应用。
当前 Go 语言主要应用于后端服务的开发，未来随着 Go 项目的完善，在系统、游戏、UI界面、AI、物联网等领域，都将被广泛使用。

当然 Go 语言有优点也有一些缺点，完美的东西毕竟太少，如果看好 Go 的未来发展，那么不如抛开成见先来体验一番。

#### 2. 特性说明

**跨平台即最终可以执行到Windows，Linux，Unix等操作系统；**

**静态语言**：1）编译工具代码感知更友好；2）商业系统大型开发更有保障；3）静态语言相对封闭，第三方开发包侵害性小；

**动态语言**：1）代码编写更灵活；2）相对代码更简洁；

**编译型和非编译型语言**

<img src="01.golang安装部署.assets/image-20200307113322420.png" alt="image-20200307113322420" style="zoom: 50%;" />

Java 和 C# 比较特殊，源代码需要先转换成一种中间文件（字节码文件），然后再将中间文件拿到虚拟机中执行；

#### 3. 核心开发团队

**Ken Thompson（肯·汤普森）**

<img src="01.golang安装部署.assets/image-20200307104441336.png" alt="image-20200307104441336" style="zoom: 50%;" />

大名鼎鼎、如雷贯耳，Unix操作系统的发明人之一（排在第一号），C语言前身B语言的设计者，UTF-8编码设计者之一，图灵奖得主。
老爷子今年快76岁了（1943年生）。早年一直在贝尔实验室做研究，60多岁的时候被谷歌尊养起来。
2007年，老爷子和Rob Pike、Robert Griesemer一起设计了做出的Go语言。老爷子目前基本不参与Go的设计和开发。

在2011年的一次采访中，老爷子幽默地谈到设计Go语言的初衷是他们很不喜欢C++，因为C++中充满了大量的垃圾特性。

**Rob Pike（罗布·派克）**

<img src="01.golang安装部署.assets/image-20200307104459564.png" alt="image-20200307104459564" style="zoom:50%;" />

早年在贝尔实验室和Ken Thompson结对编程的小弟，早已成长为业内的领军人物。UTF-8两个发明人之一。Go设计团队第一任老大。
如今也退休并被谷歌尊养起来了。Rob Pike仍旧活跃在各个Go论坛组中，适当地发表自己的意见。

顺便说一句，Go语言的地鼠吉祥物是由Rob Pike的媳妇Renee French设计的。

顺便另说一句，Rob Pike曾获得1980年奥运会射箭银牌。

**Robert Griesemer（罗伯特·格瑞史莫）**

<img src="01.golang安装部署.assets/image-20200307104510470.png" alt="image-20200307104510470" style="zoom: 67%;" />

Go语言三名最初的设计者之一，比较年轻。曾参与V8 JavaScript引擎和Java HotSpot虚拟机的研发。目前主要维护Go白皮书和代码解析器等。

#### 4. 开发的优秀项目

语言的目标是用于项目开发，并能打造出很多优秀的产品。那么，Golang有哪些好像优秀的项目呢？不搜不知道，一搜吓一跳！
列举一下我收集到的golang开发的优秀项目，如下：

- docker，golang头号优秀项目，通过虚拟化技术实现的操作系统与应用的隔离，也称为容器；

- kubernetes，是来自 Google 云平台的开源容器集群管理系统。简称k8s，k8s和docker是当前容器化技术的重要基础设施；

- etcd，一种可靠的分布式KV存储系统，有点类似于zookeeper，可用于快速的云配置；

- codis，由国人开发提供的一套优秀的redis分布式解决方案；

- tidb，国内PingCAP 团队开发的一个分布式SQL 数据库，国内很多互联网公司在使用；

- influxdb，时序型DB，着力于高性能查询与存储时序型数据，常用于系统监控与金融领域；

#### 5. 大厂都在用

1. 腾讯蓝鲸
2. 百度APP
3. 知乎python用go重构
4. 字节跳动：抖音
5. 七牛云

#### 6 学习方法

- 多写多写再多写.........
- 实践：自己设计项目，工作中使用

### 二、安装部署

go官网： https://golang.google.cn/dl/ ，请选择自己对应的系统

中文社区：https://studygolang.com/dl

#### 1. win环境

1. 下载go.{version}.windows-amd64.msi或者go.{version}.windows-amd64.zip包，此次使用go.{version}.windows-amd64.zip包
2. 解压压缩文件（这里使用的是D:\Project，后面都基于这个目录）
3. 配置环境变量GOPATH和GOROOT

```bash
# 打开cmd设置
set GOPATH=D:\Project\GOPATH
set GOROOT=D:\Project\GO
set PATH=%PATH%;%GOROOT%\bin
```

当然应该将这些环境变量配置到系统环境变量中

4. 此时打开cmd窗口，运行`go version`即可展示安装golang版本

```bash
> go version
go version go1.13.5 windows/amd64
```

#### 2. linux环境

1. 下载linux版本对应安装包，这里使用 go{version}.linux-amd64.tar.gz
2. 进入linux对应目录，解压文件

```bash
tar -zxvf go{version}.linux-amd64.tar.gz
```

3. 设置环境变量GOPATH和GOROOT

```
# 临时修改
export GOPATH=D:\Project\GOPATH
export GOROOT=D:\Project\GO
export PATH=%PATH%:%GOROOT%\bin
```

修改全局环境变量

```bash
# 编辑全局环境变量文件
vi /etc/profile
# 追加环境变量都最后
export GOPATH=D:\Project\GOPATH
export GOROOT=D:\Project\GO
export PATH=%PATH%:%GOROOT%\bin
# 然后保存文件，并使文件生效
source /etc/profile
```

4. 运行`go version`查看版本信息

```bash
# go version
go version go1.13.5 windows/amd64
```

### 三、运行第一个程序

#### 1. 运行和编译

当然还是hello word示例。创建文件hello.go，使用文本编辑器编辑，一定要注意文件编码为UTF-8

```go
package main

import "fmt"

func main() {
	fmt.Println("Hello World !")
}
```

保存文件后，运行

```bash
>go run hello.go
Hello World !
```

go编译运行

```bash
>go build hello.go

>hello.exe
hello world!
```

#### 2. 交叉编译

交叉编译linux文件

```bash
set CGO_ENABLED=0
set GOOS=linux
set GOARCH=amd64
go build hello.go
```

交叉编译参数

```bash
$GOOS        $GOARCH
android     arm
darwin      386
darwin      amd64
darwin      arm
darwin      arm64
dragonfly   amd64
freebsd     386
freebsd     amd64
freebsd     arm
linux       386
linux       amd64
linux       arm
linux       arm64
linux       ppc64
linux       ppc64le
linux       mips
linux       mipsle
linux       mips64
linux       mips64le
netbsd      386
netbsd      amd64
netbsd      arm
openbsd     386
openbsd     amd64
openbsd     arm
plan9       386
plan9       amd64
solaris     amd64
windows     386
windows     amd64
```

### 开发工具安装



### goModules介绍

go.mod
```
module hello

go 1.14

require (
	github.com/gogf/gf v1.15.3
)
```

hello.go
```
package main

import (
	"fmt"
	"github.com/gogf/gf"
	"github.com/gogf/gf/crypto/gmd5"
)

func main() {
	fmt.Println("hello world!")
	fmt.Println(gf.VERSION)
	fmt.Println(gmd5.EncryptString("123456"))
}
```

### 基础语法

basic.go
```
package main

import (
	"fmt"
	"math"
	"time"
)

func main() {
	// hello world
	/**
	hello world
	*/
	fmt.Println("hello world")

	fmt.Println("##################### values")
	values()

	fmt.Println("##################### variables")
	variables()

	fmt.Println("##################### constants")
	constants()

	fmt.Println("##################### forFunc")
	forFunc()

	fmt.Println("##################### ifElse")
	ifElse()

	fmt.Println("##################### switchFunc")
	switchFunc()
}

// 值
func values() {
	// 字符串拼接用 +
	fmt.Println("hello " + "world " + "!")
	// 整数和浮点数
	fmt.Println("1+2 =", 1+2)
	fmt.Println("11-1 =", 11-1)
	fmt.Println("99*99 =", 99*99)
	fmt.Println("8.0/3.0 =", 8.0/3.0)
	// 布尔型
	fmt.Println(true && false)
	fmt.Println(true || false)
	fmt.Println(!true)
}

// 变量
func variables() {
	// var 声明 1 个或者多个变量。
	var a string = "hello"
	fmt.Println(a)
	var b, c int = 3, 5
	fmt.Println(b, c)

	// 会自动推断已经初始化的变量类型。
	var d = true
	fmt.Println(d)

	// 声明变量且 初始化为0
	var e int
	fmt.Println(e)

	// := 简写会自动推断类型，只能用在初始化
	f := "short"
	fmt.Println(f)
}

// 常量
// 全局常量
const con = "const"

func constants() {
	fmt.Println(con)

	// const 语句可以出现在任何 var 语句可以出现的地方
	const num = 500 * 500 * 500
	// 常数表达式可以执行任意精度的运算
	const num2 = 4e21 / num
	fmt.Println(num2)
	// 数值型常量是没有确定的类型的，直到它们被给定了一个类型，比如说一次显示的类型转化。
	fmt.Println(int64(num2))

	// 当上下文需要时，一个数可以被给定一个类型，比如变量赋值或者函数调用。
	// 举个例子，这里的 math.Sin函数需要一个 float64 的参数。
	fmt.Println(math.Sin(num))
}

// For循环
func forFunc() {
	// 最常用的方式，带单个循环条件。
	i := 1
	for i <= 4 {
		fmt.Println(i)
		i = i + 1
	}

	// 经典的初始化/条件/后续形式 for 循环。
	for j := 6; j <= 8; j++ {
		fmt.Println(j)
	}

	// 不带条件的 for 循环将一直执行，直到在循环体内使用了 break 或者 return 来跳出循环。
	for {
		fmt.Println("for...")
		break
	}

	for n := 0; n <= 7; n++ {
		if n%2 == 0 {
			continue
		}
		fmt.Println(n)
	}
}

// if/else
func ifElse() {
	if 9%2 == 0 {
		fmt.Println("9 is even")
	} else {
		fmt.Println("9 is odd")
	}

	// 你可以不要 else 只用 if 语句。
	if 12%4 == 0 {
		fmt.Println("12 is divisible by 4")
	}

	// 在条件语句之前可以有一个语句；
	// 任何在这里声明的变量都可以在所有的条件分支中使用。
	if num := 7; num < 0 {
		fmt.Println(num, "正数")
	} else if num < 10 {
		fmt.Println(num, "小于10")
	} else {
		fmt.Println(num, "其他")
	}

	// 注意，在 Go 中，你可以不适用圆括号，但是花括号是需要的。
	// Go 里没有三目运算符，
	// 所以即使你只需要基本的条件判断，你仍需要使用完整的 if 语句。
}

// 分支结构
func switchFunc() {
	i := 2
	switch i {
	case 1:
		fmt.Println("1")
	case 2:
		fmt.Println("2")
	case 3:
		fmt.Println("3")
	}

	// 在一个 case 语句中，你可以使用逗号来分隔多个表达式。
	// 在这个例子中，我们很好的使用了可选的default 分支。
	switch time.Now().Weekday() {
	case time.Saturday, time.Sunday:
		fmt.Println("星期天")
	default:
		fmt.Println("工作日")
	}

	// 不带表达式的 switch 是实现 if/else 逻辑的另一种方式。
	//  这里展示了 case 表达式是如何使用非常量的。
	t := time.Now()
	switch {
	case t.Hour() < 12:
		fmt.Println("12点前")
	default:
		fmt.Println("12点后，包含12点")
	}

	// 这里是一个函数变量
	whatAmI := func(i interface{}) {
		switch t := i.(type) {
		case bool:
			fmt.Println("bool")
		case int:
			fmt.Println("int")
		default:
			fmt.Printf("什么类型 %T\n", t)
		}
	}
	whatAmI(true)
	whatAmI(1)
	whatAmI("嘿")
}
```

### 常用数据结构

```
package main

import "fmt"

func main() {
	// hello world
	fmt.Println("hello world")

	fmt.Println("##################### arrays")
	arrays()

	fmt.Println("##################### slice")
	slice()

	fmt.Println("##################### mapFunc")
	mapFunc()

	fmt.Println("##################### rangeFunc")
	rangeFunc()
}

// 数组
func arrays() {
	// 这里我们创建了一个数组 test1 来存放刚好 5 个 int。
	// 元素的类型和长度都是数组类型的一部分。
	// 数组默认是零值的，对于 int 数组来说也就是 0。
	var test1 [6]int
	fmt.Println("内容:", test1)
	// 我们可以使用 array[index] = value 语法来设置数组指定位置的值，或者用 array[index] 得到值。
	test1[4] = 100
	fmt.Println("设置:", test1)
	fmt.Println("获取:", test1[4])
	// 使用内置函数 len 返回数组的长度
	fmt.Println("长度:", len(test1))

	// 使用这个语法在一行内初始化一个数组
	test2 := [6]int{1, 2, 3, 4, 5, 6}
	fmt.Println("数据:", test2)

	// 数组的存储类型是单一的，但是你可以组合这些数据来构造多维的数据结构。
	var twoTest [3][4]int
	for i := 0; i < 3; i++ {
		for j := 0; j < 4; j++ {
			twoTest[i][j] = i + j
		}
	}
	// 注意，在使用 fmt.Println 来打印数组的时候，会使用[v1 v2 v3 ...] 的格式显示
	fmt.Println("二维: ", twoTest)
}

// 切片
func slice() {
	// Slice 是 Go 中一个关键的数据类型，是一个比数组更加强大的序列接口

	// 不像数组，slice 的类型仅由它所包含的元素决定（不像数组中还需要元素的个数）。
	// 要创建一个长度非零的空slice，需要使用内建的方法 make。
	// 这里我们创建了一个长度为3的 string 类型 slice（初始化为零值）。
	test1 := make([]string, 3)
	fmt.Println("数据:", test1)
	// 我们可以和数组一样设置和得到值
	test1[0] = "A"
	test1[1] = "C"
	test1[2] = "B"
	fmt.Println("数据:", test1)
	fmt.Println("获取:", test1[2])
	// 如你所料，len 返回 slice 的长度
	fmt.Println("长度:", len(test1))

	// 作为基本操作的补充，slice 支持比数组更多的操作。
	// 其中一个是内建的 append，它返回一个包含了一个或者多个新值的 slice。
	// 注意我们接受返回由 append返回的新的 slice 值。
	test1 = append(test1, "D")
	test1 = append(test1, "E", "F")
	fmt.Println("追加:", test1)

	// Slice 也可以被 copy。这里我们创建一个空的和 test1 有相同长度的 slice test2，并且将 test1 复制给 test2。
	test2 := make([]string, len(test1))
	copy(test2, test1)
	fmt.Println("拷贝:", test2)
	// Slice 支持通过 slice[low:high] 语法进行“切片”操作。例如，这里得到一个包含元素 test1[2], test1[3],test1[4] 的 slice。
	l := test1[2:5]
	fmt.Println("切片1:", l)
	// 这个 slice 从 test1[0] 到（但是不包含）test1[5]。
	l = test1[:5]
	fmt.Println("切片2:", l)
	// 这个 slice 从（包含）test1[2] 到 slice 的后一个值。
	l = test1[2:]
	fmt.Println("切片3:", l)
	// 我们可以在一行代码中声明并初始化一个 slice 变量。
	t := []string{"g", "h", "i"}
	fmt.Println("数据:", t)

	// Slice 可以组成多维数据结构。内部的 slice 长度可以不同，这和多位数组不同。
	twoTest := make([][]int, 3)
	for i := 0; i < 3; i++ {
		innerLen := i + 1
		twoTest[i] = make([]int, innerLen)
		for j := 0; j < innerLen; j++ {
			twoTest[i][j] = i + j
		}
	}
	// 注意，slice 和数组不同，虽然它们通过 fmt.Println 输出差不多。
	fmt.Println("二维: ", twoTest)
}

// 键值对 key/value
func mapFunc() {
	// 要创建一个空 map，需要使用内建的 make:make(map[key-type]val-type).
	map1 := make(map[string]int)
	// 使用典型的 make[key] = val 语法来设置键值对。
	map1["k1"] = 7
	map1["k2"] = 13
	// 使用例如 Println 来打印一个 map 将会输出所有的键值对。
	fmt.Println("数据:", map1)
	// 使用 name[key] 来获取一个键的值
	v1 := map1["k1"]
	fmt.Println("值: ", v1)
	// 当对一个 map 调用内建的 len 时，返回的是键值对数目
	fmt.Println("长度:", len(map1))
	// 内建的 delete 可以从一个 map 中移除键值对
	delete(map1, "k2")
	fmt.Println("数据:", map1)
	// 当从一个 map 中取值时，可选的第二返回值指示这个键是在这个 map 中。
	// 这可以用来消除键不存在和键有零值，像 0 或者 "" 而产生的歧义。
	_, prs := map1["k2"]
	fmt.Println("是否存在:", prs)
	// 你也可以通过这个语法在同一行申明和初始化一个新的map。
	map2 := map[string]int{"F": 1, "B": 2}
	// 注意一个 map 在使用 fmt.Println 打印的时候，是以 map[k:v k:v]的格式输出的。
	fmt.Println("数据:", map2)
}

// Range 遍历
func rangeFunc() {
	// 这里我们使用 range 来统计一个 slice 的元素个数。数组也可以采用这种方法。
	array1 := []int{2, 3, 4}
	sum := 0
	for _, num := range array1 {
		sum += num
	}
	fmt.Println("求和:", sum)

	// range 在数组和 slice 中都同样提供每个项的索引和值。
	// 上面我们不需要索引，所以我们使用 空值定义符_ 来忽略它。
	// 有时候我们实际上是需要这个索引的。
	for i, num := range array1 {
		if num == 3 {
			fmt.Println("索引:", i)
		}
	}

	// range 在 map 中迭代键值对。
	map1 := map[string]string{"A": "苹果", "B": "香蕉"}
	for k, v := range map1 {
		fmt.Printf("%s -> %s\n", k, v)
	}
	for k := range map1 {
		fmt.Println("键:", k)
	}

	// range 在字符串中迭代 unicode 编码。
	// 第一个返回值是rune 的起始字节位置，然后第二个是 rune 自己。
	for i, c := range "abA" {
		fmt.Println(i, c)
	}
}
```

### 函数介绍

```
package main

import "fmt"

func main() {
	// hello world
	fmt.Println("hello world")

	// 1. 加法
	res := plus(1, 2)
	fmt.Println("1+2 =", res)
	res = plusPlus(1, 2, 3)
	fmt.Println("1+2+3 =", res)

	// 2. 多值返回
	// 这里我们通过多赋值 操作来使用这两个不同的返回值。
	a, b := vals()
	fmt.Println(a)
	fmt.Println(b)
	// 如果你仅仅想返回值的一部分的话，你可以使用空白定义符 _。
	_, c := vals()
	fmt.Println(c)

	// 3. 可变参数
	// 变参函数使用常规的调用方式，除了参数比较特殊。
	sum(1, 2)
	sum(1, 2, 3)
	// 如果你的 slice 已经有了多个值，想把它们作为变参使用，你要这样调用 func(slice...)。
	nums := []int{1, 2, 3, 4}
	sum(nums...)

	// 4. 闭包
	// 我们调用 intSeq 函数，将返回值（也是一个函数）赋给nextInt。
	// 这个函数的值包含了自己的值 i，这样在每次调用 nextInt 时都会更新 i 的值。
	nextInt := intSeq()
	// 通过多次调用 nextInt 来看看闭包的效果。
	fmt.Println(nextInt())
	fmt.Println(nextInt())
	fmt.Println(nextInt())
	// 为了确认这个状态对于这个特定的函数是唯一的，我们重新创建并测试一下。
	newInts := intSeq()
	fmt.Println(newInts())

	// 5. 递归
	fmt.Println(fact(7))
}

// 函数
// 这里是一个函数，接受两个 int 并且以 int 返回它们的和
func plus(a int, b int) int {
	// Go 需要明确的返回值，例如，它不会自动返回最后一个表达式的值
	return a + b
}

// (int, int) 在这个函数中标志着这个函数返回 2 个 int。
func plusPlus(a, b, c int) int {
	return a + b + c
}

// 多返回值函数
func vals() (int, int) {
	return 3, 7
}

// 变参函数
func sum(nums ...int) {
	fmt.Print(nums, " ")
	total := 0
	for _, num := range nums {
		total += num
	}
	fmt.Println(total)
}

// 闭包
// 这个 intSeq 函数返回另一个在 intSeq 函数体内定义的匿名函数。
// 这个返回的函数使用闭包的方式 隐藏 变量 i。
func intSeq() func() int {
	i := 0
	return func() int {
		i += 1
		return i
	}
}

// 递归
// face 函数在到达 face(0) 前一直调用自身。
func fact(n int) int {
	if n == 0 {
		return 1
	}
	return n * fact(n-1)
}
```

### 指针结构体接口



### 错误处理


### 协程


### 常用函数




### 并发 


<br/><br/><br/><br/><br/>
## 参考资料

golang基础教程-go语言快速入门 blibli <www.bilibili.com/video/av94410029>

github：[https://github.com/goflyfox/gostudy](https://github.com/goflyfox/gostudy)

gitee：[https://gitee.com/goflyfox/gostudy](https://gitee.com/goflyfox/gostudy)

腾讯课堂教程地址：[golang基础教程-快速入门go语言](https://ke.qq.com/course/2585401?taid=9426843331949369&tuin=13b4f9bd)

bilibili教程地址：[golang基础教程-快速入门go语言](https://www.bilibili.com/video/av94410029)

西瓜视频教程地址：[golang基础教程-快速入门go语言](https://www.ixigua.com/pseries/6809291194665796100/)

