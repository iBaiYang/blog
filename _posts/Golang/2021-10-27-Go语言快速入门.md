---
layout: post
categories: Golang
title: Go语言快速入门
meta: Go语言快速入门
---
* content
{:toc}

## 正文

### 一、golang介绍

#### 1. 语言介绍

Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。

Go是从2007年末由Robert Griesemer, Rob Pike, Ken Thompson主持开发，后来还加入了Ian Lance Taylor, Russ Cox等人，
**并最终于2009年11月开源，在2012年早些时候发布了Go 1稳定版本**。现在Go的开发已经是完全开放的，并且拥有一个活跃的社区。

Go 语言是谷歌为充分利用现代硬件性能又兼顾开发效率而设计的一种全新语言。

**Go 是一种跨平台（Mac OS、Windows、Linux 等）静态编译型语言**。拥有媲美 C 语言的强大性能，支持静态类型安全，
在普通计算机上能几秒内快速编译一个大项目，开发效率跟动态语言相差无几。

Go 语言在国内拥有非常活跃的社区、不仅大公司的 Go 项目越来越多，中小公司也都在考虑 Go 的应用。
当前 Go 语言主要应用于后端服务的开发，未来随着 Go 项目的完善，在系统、游戏、UI界面、AI、物联网等领域，都将被广泛使用。

当然 Go 语言有优点也有一些缺点，完美的东西毕竟太少，如果看好 Go 的未来发展，那么不如抛开成见先来体验一番。

#### 2. 特性说明

**跨平台即最终可以执行到Windows，Linux，Unix等操作系统；**

**静态语言**：1）编译工具代码感知更友好；2）商业系统大型开发更有保障；3）静态语言相对封闭，第三方开发包侵害性小；

**动态语言**：1）代码编写更灵活；2）相对代码更简洁；

**编译型和非编译型语言**

![]({{site.baseurl}}/images/goflyfox/01.golang安装部署/image-20200307113322420.png)

Java 和 C# 比较特殊，源代码需要先转换成一种中间文件（字节码文件），然后再将中间文件拿到虚拟机中执行；

#### 3. 核心开发团队

**Ken Thompson（肯·汤普森）**

![]({{site.baseurl}}/images/goflyfox/01.golang安装部署/image-20200307104441336.png)

大名鼎鼎、如雷贯耳，Unix操作系统的发明人之一（排在第一号），C语言前身B语言的设计者，UTF-8编码设计者之一，图灵奖得主。
老爷子今年快76岁了（1943年生）。早年一直在贝尔实验室做研究，60多岁的时候被谷歌尊养起来。
2007年，老爷子和Rob Pike、Robert Griesemer一起设计了做出的Go语言。老爷子目前基本不参与Go的设计和开发。

在2011年的一次采访中，老爷子幽默地谈到设计Go语言的初衷是他们很不喜欢C++，因为C++中充满了大量的垃圾特性。

**Rob Pike（罗布·派克）**

![]({{site.baseurl}}/images/goflyfox/01.golang安装部署/image-20200307104459564.png)

早年在贝尔实验室和Ken Thompson结对编程的小弟，早已成长为业内的领军人物。UTF-8两个发明人之一。Go设计团队第一任老大。
如今也退休并被谷歌尊养起来了。Rob Pike仍旧活跃在各个Go论坛组中，适当地发表自己的意见。

顺便说一句，Go语言的地鼠吉祥物是由Rob Pike的媳妇Renee French设计的。

顺便另说一句，Rob Pike曾获得1980年奥运会射箭银牌。

**Robert Griesemer（罗伯特·格瑞史莫）**

![]({{site.baseurl}}/images/goflyfox/01.golang安装部署/image-20200307104510470.png)

Go语言三名最初的设计者之一，比较年轻。曾参与V8 JavaScript引擎和Java HotSpot虚拟机的研发。目前主要维护Go白皮书和代码解析器等。

#### 4. 开发的优秀项目

语言的目标是用于项目开发，并能打造出很多优秀的产品。那么，Golang有哪些好像优秀的项目呢？不搜不知道，一搜吓一跳！
列举一下我收集到的golang开发的优秀项目，如下：

- docker，golang头号优秀项目，通过虚拟化技术实现的操作系统与应用的隔离，也称为容器；

- kubernetes，是来自 Google 云平台的开源容器集群管理系统。简称k8s，k8s和docker是当前容器化技术的重要基础设施；

- etcd，一种可靠的分布式KV存储系统，有点类似于zookeeper，可用于快速的云配置；

- codis，由国人开发提供的一套优秀的redis分布式解决方案；

- tidb，国内PingCAP 团队开发的一个分布式SQL 数据库，国内很多互联网公司在使用；

- influxdb，时序型DB，着力于高性能查询与存储时序型数据，常用于系统监控与金融领域；

#### 5. 大厂都在用

1. 腾讯蓝鲸
2. 百度APP
3. 知乎python用go重构
4. 字节跳动：抖音
5. 七牛云

#### 6 学习方法

- 多写多写再多写.........
- 实践：自己设计项目，工作中使用

### 二、安装部署

go官网： <https://golang.google.cn/dl/> ，请选择自己对应的系统

中文社区：<https://studygolang.com/dl>

#### 1. win环境

* 下载go.{version}.windows-amd64.msi或者go.{version}.windows-amd64.zip包，此次使用go.{version}.windows-amd64.zip包
* 解压压缩文件（这里使用的是D:\Project，后面都基于这个目录）
* 配置环境变量GOPATH和GOROOT

```bash
# 打开cmd设置
set GOPATH=D:\Project\GOPATH
set GOROOT=D:\Project\GO
set PATH=%PATH%;%GOROOT%\bin
```

当然应该将这些环境变量配置到系统环境变量中

* 此时打开cmd窗口，运行`go version`即可展示安装golang版本

```bash
> go version
go version go1.13.5 windows/amd64
```

#### 2. linux环境

* 下载linux版本对应安装包，这里使用 go{version}.linux-amd64.tar.gz
* 进入linux对应目录，解压文件

```bash
tar -zxvf go{version}.linux-amd64.tar.gz
```

* 设置环境变量GOPATH和GOROOT

```
# 临时修改
export GOPATH=D:\Project\GOPATH
export GOROOT=D:\Project\GO
export PATH=%PATH%:%GOROOT%\bin
```

修改全局环境变量

```bash
# 编辑全局环境变量文件
vi /etc/profile
# 追加环境变量都最后
export GOPATH=D:\Project\GOPATH
export GOROOT=D:\Project\GO
export PATH=%PATH%:%GOROOT%\bin
# 然后保存文件，并使文件生效
source /etc/profile
```

* 运行`go version`查看版本信息

```bash
# go version
go version go1.13.5 windows/amd64
```

### 三、运行第一个程序

#### 1. 运行和编译

当然还是hello word示例。创建文件hello.go，使用文本编辑器编辑，一定要注意文件编码为UTF-8

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello World !")
}
```

保存文件后，运行

```bash
>go run hello.go
Hello World !
```

go编译运行

```bash
>go build hello.go

>hello.exe
hello world!
```

#### 2. 交叉编译

交叉编译linux文件

```bash
set CGO_ENABLED=0
set GOOS=linux
set GOARCH=amd64
go build hello.go
```

交叉编译参数

```bash
$GOOS        $GOARCH
android     arm
darwin      386
darwin      amd64
darwin      arm
darwin      arm64
dragonfly   amd64
freebsd     386
freebsd     amd64
freebsd     arm
linux       386
linux       amd64
linux       arm
linux       arm64
linux       ppc64
linux       ppc64le
linux       mips
linux       mipsle
linux       mips64
linux       mips64le
netbsd      386
netbsd      amd64
netbsd      arm
openbsd     386
openbsd     amd64
openbsd     arm
plan9       386
plan9       amd64
solaris     amd64
windows     386
windows     amd64
```

### 四、开发环境IDE安装

**工欲善其事，必先利其器**

这里推荐两款golang开发工具，一个是`goland`，一个是`VSCode`；goland是收费的，收费还是有收费的道理，确实比较好用，个人比较推荐；VSCode需要安装插件，免费版本，这个是前端开发的利器，go语言开发感觉还是差一点；

#### 1. Goland

`JetBrains`旗下的产品众多，最出名的就是IDEA，java开发工具；当然PHP，Python，Scala等开发语言，数据库版本都是有的；

`JetBrains`的官方网站为：https://www.jetbrains.com/go/

![]({{site.baseurl}}/images/goflyfox/04.golang开发工具安装/image-20200308213639999.png)

1. 首先打开File->Setting或者Ctrl+Alt+S,设置goroot和gopath，默认会获取环境变量配置

![]({{site.baseurl}}/images/goflyfox/04.golang开发工具安装/image-20200308214137180.png)

![]({{site.baseurl}}/images/goflyfox/04.golang开发工具安装/image-20200308214206249.png)

2. 如果我们需要使用go modules功能，需要进行开启设置；

![]({{site.baseurl}}/images/goflyfox/04.golang开发工具安装/image-20200308214256503.png)

3. 最好我们编写helloworld运行

新建项目study1，选择目录

![]({{site.baseurl}}/images/goflyfox/04.golang开发工具安装/image-20200308214352004.png)

新建go文件

![]({{site.baseurl}}/images/goflyfox/04.golang开发工具安装/image-20200308214422995.png)

编写hello world

```go
package main

import "fmt"

func main(){
    fmt.Println("hello world!")
}
```

![]({{site.baseurl}}/images/goflyfox/04.golang开发工具安装/image-20200308214456521.png)

最后点击左侧启动运行，或者按Ctrl+Shift+F10运行程序

![]({{site.baseurl}}/images/goflyfox/04.golang开发工具安装/image-20200308214525960.png)

最终我们看到hello world运行成功！

#### 2. Goland 常用快捷键

下面列举了一些 Goland 中经常使用到的快捷键。

**文件操作**

| 快捷键           | 作用                                 |
| ---------------- | ------------------------------------ |
| Ctrl + E         | 打开最近浏览过的文件                 |
| Ctrl + N         | 快速打开某个 struct 结构体所在的文件 |
| Ctrl + Shift + N | 快速打开文件                         |
| Shift + F6       | 重命名文件夹、文件、方法、变量名等   |

**代码格式化**

| 快捷键           | 作用                                                         |
| ---------------- | ------------------------------------------------------------ |
| Ctrl + Alt + L   | 格式化代码                                                   |
| Ctrl + 空格      | 代码提示                                                     |
| Ctrl + /         | 单行注释                                                     |
| Ctrl + Shift + / | 多行注释                                                     |
| Ctrl + B 或 F4   | 快速跳转到结构体或方法的定义位置（需将光标移动到结构体或方法的名称上） |
| Ctrl +“+ 或 -”   | 可以将当前（光标所在位置）的方法进行展开或折叠               |

**查找和定位**

| 快捷键                 | 作用                     |
| ---------------------- | ------------------------ |
| Ctrl + R               | 替换文本                 |
| Ctrl + F               | 查找文本                 |
| Ctrl + Shift + F       | 全局查找                 |
| Ctrl + G               | 显示当前光标所在行的行号 |
| Ctrl + Shift + Alt + N | 查找类中的方法或变量     |

**编辑代码**

| 快捷键                      | 作用                                                         |
| --------------------------- | ------------------------------------------------------------ |
| Ctrl + J                    | 快速生成一个代码片段                                         |
| Shift+Enter                 | 向光标的下方插入一行，并将光标移动到该行的开始位置           |
| Ctrl + X                    | 删除当前光标所在行                                           |
| Ctrl + D                    | 复制当前光标所在行                                           |
| Ctrl + Shift + 方向键上或下 | 将光标所在的行进行上下移动（也可以使用 Alt+Shift+方向键上或下） |
| Alt + 回车                  | 自动导入需要导入的包                                         |
| Ctrl + Shift + U            | 将选中的内容进行大小写转化                                   |
| Alt + Insert                | 生成测试代码                                                 |
| Alt + Up/Down               | 快速移动到上一个或下一个方法                                 |
| Ctrl + Alt + Space          | 类名或接口名提示（代码提示）                                 |
| Ctrl + P                    | 提示方法的参数类型（需在方法调用的位置使用，并将光标移动至`( )`的内部或两侧） |

**编辑器相关的快捷键**

| 快捷键                  | 作用                                 |
| ----------------------- | ------------------------------------ |
| Ctrl + Alt + left/right | 返回至上次浏览的位置                 |
| Alt + left/right        | 切换代码视图                         |
| Ctrl + W                | 快速选中代码                         |
| Alt + F3                | 逐个向下查找选中的代码，并高亮显示   |
| Tab                     | 代码标签输入完成后，按 Tab，生成代码 |
| F2 或 Shift + F2        | 快速定位错误或警告                   |
| Alt + Shift + C         | 查看最近的操作                       |
| Alt + 1                 | 快速打开或隐藏工程面板               |

#### 3. VSCode

VSCode 全称 Visual Studio Code，是微软出的一款轻量级代码编辑器，免费、开源而且功能强大。
它支持几乎所有主流的程序语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，
支持插件扩展，并针对网页开发和云端应用开发做了优化。

VSCode的官网：https://code.visualstudio.com/

![]({{site.baseurl}}/images/goflyfox/04.golang开发工具安装/image-20200308213720888.png)

在VSCode中安装Go插件

进入Extensions后直接搜索go，即可安装

![]({{site.baseurl}}/images/goflyfox/04.golang开发工具安装/image-20200308213639991.png)

在编辑代码时会提示安装一些插件，选择安装即可；

如果没有提示也可以自行安装，大致如下

```bash
go get -u -v github.com/bytbox/golint
go get -u -v github.com/golang/tools
go get -u -v github.com/lukehoban/go-outline
go get -u -v github.com/newhook/go-symbols
go get -u -v github.com/josharian/impl
go get -u -v github.com/sqs/goreturns
go get -u -v github.com/cweill/gotests
```



#### 4. VSCode 常用快捷键

| 快捷键               | 功能                |
| -------------------- | ------------------- |
| F2                   | 重命名符号          |
| Ctrl + L             | 选中当前行          |
| Ctrl + /             | 添加/关闭行注释     |
| Ctrl + ←/→           | 按单词移动光标      |
| Ctrl + Shift + ←/→   | 按单词进行选中      |
| Shift + Alt +A       | 添加/关闭块区域注释 |
| Ctrl + Space         | 输入建议            |
| Ctrl + Shift + Space | 参数提示            |
| F12                  | 跳转到定义处        |
| Alt + F12            | 代码片段显示定义    |
| Shift + F12          | 显示所有引用        |
| Shift + Alt + F      | 格式化代码          |

------

**通用快捷键**

| 快捷键          | 作用                   |
| :-------------- | :--------------------- |
| Ctrl+Shift+P,F1 | 展示全局命令面板       |
| Ctrl+P          | 快速打开最近打开的文件 |
| Ctrl+Shift+N    | 打开新的编辑器窗口     |
| Ctrl+Shift+W    | 关闭编辑器             |
| Ctrl+,          | 首选项                 |
| Ctrl+K Ctrl+S   | 快捷键设置             |

------

**基础编辑**

| 快捷键               | 作用                     |
| :------------------- | :----------------------- |
| Ctrl + X             | 剪切                     |
| Ctrl + C             | 复制                     |
| Alt + ↑/↓            | 移动行上下               |
| Shift + Alt + ↑/↓    | 在当前行上下复制当前行   |
| Ctrl + Shift + K     | 删除行                   |
| Ctrl + Enter         | 在当前行下插入新的一行   |
| Ctrl + Shift + Enter | 在当前行上插入新的一行   |
| Ctrl + Shift + \     | 匹配花括号的闭合处，跳转 |
| Ctrl + ] / [         | 行缩进                   |
| Home / End           | 光标跳转到行头/行尾      |
| Ctrl + Home          | 跳转到页头               |
| Ctrl + End           | 跳转到页尾               |
| Ctrl + ↑/↓           | 行视图上下偏移           |
| Alt + PgUp/PgDown    | 屏视图上下偏移           |
| Ctrl + Shift + [     | 折叠区域代码             |
| Ctrl + Shift + ]     | 展开区域代码             |
| Ctrl + K Ctrl + [    | 折叠所有子区域代码       |
| Ctrl + k Ctrl + ]    | 展开所有折叠的子区域代码 |
| Ctrl + K Ctrl + 0    | 折叠所有区域代码         |
| Ctrl + K Ctrl + J    | 展开所有折叠区域代码     |
| Ctrl + K Ctrl + C    | 添加行注释               |
| Ctrl + K Ctrl + U    | 删除行注释               |
| Ctrl + /             | 添加/关闭行注释          |
| Shift + Alt +A       | 添加/关闭块区域注释      |
| Alt + Z              | 添加/关闭词汇包含        |

------

**导航**

| 快捷键             | 作用                     |
| :----------------- | :----------------------- |
| Ctrl + T           | 列出所有符号             |
| Ctrl + G           | 跳转行                   |
| Ctrl + P           | 跳转文件                 |
| Ctrl + Shift + O   | 跳转到符号处             |
| Ctrl + Shift + M   | 打开问题展示面板         |
| F8                 | 跳转到下一个错误或者警告 |
| Shift + F8         | 跳转到上一个错误或者警告 |
| Ctrl + Shift + Tab | 切换到最近打开的文件     |
| Alt + ←/→          | 向后、向前               |
| Ctrl + M           | 进入用Tab来移动焦点      |

------

**查询与替换**

| 快捷键             | 作用                             |
| :----------------- | :------------------------------- |
| Ctrl + F           | 查询                             |
| Ctrl + H           | 替换                             |
| F3 / Shift + F3    | 查询下一个/上一个                |
| Alt + Enter        | 选中所有出现在查询中的           |
| Ctrl + D           | 匹配当前选中的词汇或者行         |
| Ctrl + K  Ctrl + D | 移动当前选择到下个匹配选择的位置 |
| Alt + C / R / W    | 不分大小写/使用正则/全字匹配     |

------

**多行光标操作与选择**

| 快捷键                           | 作用                                     |
| :------------------------------- | :--------------------------------------- |
| Alt + Click                      | 插入光标-支持多个                        |
| Ctrl + Alt + ↑/↓                 | 上下插入光标-支持多个                    |
| Ctrl + U                         | 撤销最后一次光标操作                     |
| Shift + Alt + I                  | 插入光标到选中范围内所有行结束符         |
| Ctrl + L                         | 选中当前行                               |
| Ctrl + Shift + L                 | 选择所有出现在当前选中的行-操作          |
| Ctrl + F2                        | 选择所有出现在当前选中的词汇-操作        |
| Shift + Alt + →                  | 从光标处扩展选中全行                     |
| Shift + Alt + ←                  | 收缩选择区域                             |
| Shift + Alt + (drag mouse)       | 鼠标拖动区域，同时在多个行结束符插入光标 |
| Ctrl + Shift + Alt + (Arrow Key) | 也是插入多行光标的[方向键控制]           |
| Ctrl + Shift + Alt + PgUp/PgDown | 也是插入多行光标的[整屏生效]             |

------

**丰富的语言操作**

| 快捷键               | 作用                           |
| :------------------- | :----------------------------- |
| Ctrl + Space         | 输入建议[智能提示]             |
| Ctrl + Shift + Space | 参数提示                       |
| Tab                  | Emmet指令触发/缩进             |
| Shift + Alt + F      | 格式化代码                     |
| Ctrl + K Ctrl + F    | 格式化选中部分的代码           |
| F12                  | 跳转到定义处                   |
| Alt + F12            | 代码片段显示定义               |
| Ctrl + K F12         | 在其他窗口打开定义处           |
| Ctrl + .             | 快速修复部分可以修复的语法错误 |
| Shift + F12          | 显示所有引用                   |
| F2                   | 重命名符号                     |
| Ctrl + Shift + . / , | 替换下个值                     |
| Ctrl + K Ctrl + X    | 移除空白字符                   |
| Ctrl + K M           | 更改页面文档格式               |

------

**编辑器管理**

| 快捷键                     | 作用                     |
| :------------------------- | :----------------------- |
| Ctrl + F4, Ctrl + W        | 关闭编辑器               |
| Ctrl + k F                 | 关闭当前打开的文件夹     |
| Ctrl + \                   | 切割编辑窗口             |
| Ctrl + 1/2/3               | 切换焦点在不同的切割窗口 |
| Ctrl + K Ctrl ←/→          | 切换焦点在不同的切割窗口 |
| Ctrl + Shift + PgUp/PgDown | 切换标签页的位置         |
| Ctrl + K ←/→               | 切割窗口位置调换         |

------

**文件管理**

| 快捷键             | 作用                                   |
| :----------------- | :------------------------------------- |
| Ctrl + N           | 新建文件                               |
| Ctrl + O           | 打开文件                               |
| Ctrl + S           | 保存文件                               |
| Ctrl + Shift + S   | 另存为                                 |
| Ctrl + K S         | 保存所有当前已经打开的文件             |
| Ctrl + F4          | 关闭当前编辑窗口                       |
| Ctrl + K Ctrl + W  | 关闭所有编辑窗口                       |
| Ctrl + Shift + T   | 撤销最近关闭的一个文件编辑窗口         |
| Ctrl + K Enter     | 保持开启                               |
| Ctrl + Shift + Tab | 调出最近打开的文件列表，重复按会切换   |
| Ctrl + Tab         | 与上面一致，顺序不一致                 |
| Ctrl + K P         | 复制当前打开文件的存放路径             |
| Ctrl + K R         | 打开当前编辑文件存放位置【文件管理器】 |
| Ctrl + K O         | 在新的编辑器中打开当前编辑的文件       |

------

**显示**

| 快捷键           | 作用                         |
| :--------------- | :--------------------------- |
| F11              | 切换全屏模式                 |
| Shift + Alt + 1  | 切换编辑布局【目前无效】     |
| Ctrl + =/-       | 放大 / 缩小                  |
| Ctrl + B         | 侧边栏显示隐藏               |
| Ctrl + Shift + E | 资源视图和编辑视图的焦点切换 |
| Ctrl + Shift + F | 打开全局搜索                 |
| Ctrl + Shift + G | 打开Git可视管理              |
| Ctrl + Shift + D | 打开DeBug面板                |
| Ctrl + Shift + X | 打开插件市场面板             |
| Ctrl + Shift + H | 在当前文件替换查询替换       |
| Ctrl + Shift + J | 开启详细查询                 |
| Ctrl + Shift + U | 打开输出窗口                 |
| Ctrl + Shift + V | 预览Markdown文件             |
| Ctrl + K V       | 在边栏打开Markdown预览       |
| Ctrl + K Z       | Zen模式                      |

------

**调试**

| 快捷键            | 作用                |
| :---------------- | :------------------ |
| F9                | 添加/解除断点       |
| F5                | 启动调试 / 继续     |
| F11 / Shift + F11 | 单步进入 / 单步跳出 |
| F10               | 单步跳过            |
| Ctrl + K Ctrl + I | 显示悬浮            |

------

**集成终端**

| 快捷键                | 作用                 |
| :-------------------- | :------------------- |
| Ctrl + `              | 打开集成终端         |
| Ctrl + Shift + `      | 创建一个新的终端     |
| Ctrl + C              | 复制所选             |
| Ctrl + V              | 复制到当前激活的终端 |
| Shift + PgUp / PgDown | 页面上下翻屏         |
| Ctrl + Home / End     | 滚动到页面头部或尾部 |

### goModules介绍

go.mod
```
module hello

go 1.14

require (
    github.com/gogf/gf v1.15.3
)
```

hello.go
```
package main

import (
    "fmt"
    "github.com/gogf/gf"
    "github.com/gogf/gf/crypto/gmd5"
)

func main() {
    fmt.Println("hello world!")
    fmt.Println(gf.VERSION)
    fmt.Println(gmd5.EncryptString("123456"))
}
```

### 基础语法

basic.go
```
package main

import (
    "fmt"
    "math"
    "time"
)

func main() {
    // hello world
    /**
    hello world
    */
    fmt.Println("hello world")

    fmt.Println("##################### values")
    values()

    fmt.Println("##################### variables")
    variables()

    fmt.Println("##################### constants")
    constants()

    fmt.Println("##################### forFunc")
    forFunc()

    fmt.Println("##################### ifElse")
    ifElse()

    fmt.Println("##################### switchFunc")
    switchFunc()
}

// 值
func values() {
    // 字符串拼接用 +
    fmt.Println("hello " + "world " + "!")
    // 整数和浮点数
    fmt.Println("1+2 =", 1+2)
    fmt.Println("11-1 =", 11-1)
    fmt.Println("99*99 =", 99*99)
    fmt.Println("8.0/3.0 =", 8.0/3.0)
    // 布尔型
    fmt.Println(true && false)
    fmt.Println(true || false)
    fmt.Println(!true)
}

// 变量
func variables() {
    // var 声明 1 个或者多个变量。
    var a string = "hello"
    fmt.Println(a)
    var b, c int = 3, 5
    fmt.Println(b, c)

    // 会自动推断已经初始化的变量类型。
    var d = true
    fmt.Println(d)

    // 声明变量且 初始化为0
    var e int
    fmt.Println(e)

    // := 简写会自动推断类型，只能用在初始化
    f := "short"
    fmt.Println(f)
}

// 常量
// 全局常量
const con = "const"

func constants() {
    fmt.Println(con)

    // const 语句可以出现在任何 var 语句可以出现的地方
    const num = 500 * 500 * 500
    // 常数表达式可以执行任意精度的运算
    const num2 = 4e21 / num
    fmt.Println(num2)
    // 数值型常量是没有确定的类型的，直到它们被给定了一个类型，比如说一次显示的类型转化。
    fmt.Println(int64(num2))

    // 当上下文需要时，一个数可以被给定一个类型，比如变量赋值或者函数调用。
    // 举个例子，这里的 math.Sin函数需要一个 float64 的参数。
    fmt.Println(math.Sin(num))
}

// For循环
func forFunc() {
    // 最常用的方式，带单个循环条件。
    i := 1
    for i <= 4 {
        fmt.Println(i)
        i = i + 1
    }

    // 经典的初始化/条件/后续形式 for 循环。
    for j := 6; j <= 8; j++ {
        fmt.Println(j)
    }

    // 不带条件的 for 循环将一直执行，直到在循环体内使用了 break 或者 return 来跳出循环。
    for {
        fmt.Println("for...")
        break
    }

    for n := 0; n <= 7; n++ {
        if n%2 == 0 {
            continue
        }
        fmt.Println(n)
    }
}

// if/else
func ifElse() {
    if 9%2 == 0 {
        fmt.Println("9 is even")
    } else {
        fmt.Println("9 is odd")
    }

    // 你可以不要 else 只用 if 语句。
    if 12%4 == 0 {
        fmt.Println("12 is divisible by 4")
    }

    // 在条件语句之前可以有一个语句；
    // 任何在这里声明的变量都可以在所有的条件分支中使用。
    if num := 7; num < 0 {
        fmt.Println(num, "正数")
    } else if num < 10 {
        fmt.Println(num, "小于10")
    } else {
        fmt.Println(num, "其他")
    }

    // 注意，在 Go 中，你可以不适用圆括号，但是花括号是需要的。
    // Go 里没有三目运算符，
    // 所以即使你只需要基本的条件判断，你仍需要使用完整的 if 语句。
}

// 分支结构
func switchFunc() {
    i := 2
    switch i {
    case 1:
        fmt.Println("1")
    case 2:
        fmt.Println("2")
    case 3:
        fmt.Println("3")
    }

    // 在一个 case 语句中，你可以使用逗号来分隔多个表达式。
    // 在这个例子中，我们很好的使用了可选的default 分支。
    switch time.Now().Weekday() {
    case time.Saturday, time.Sunday:
        fmt.Println("星期天")
    default:
        fmt.Println("工作日")
    }

    // 不带表达式的 switch 是实现 if/else 逻辑的另一种方式。
    //  这里展示了 case 表达式是如何使用非常量的。
    t := time.Now()
    switch {
    case t.Hour() < 12:
        fmt.Println("12点前")
    default:
        fmt.Println("12点后，包含12点")
    }

    // 这里是一个函数变量
    whatAmI := func(i interface{}) {
        switch t := i.(type) {
        case bool:
            fmt.Println("bool")
        case int:
            fmt.Println("int")
        default:
            fmt.Printf("什么类型 %T\n", t)
        }
    }
    whatAmI(true)
    whatAmI(1)
    whatAmI("嘿")
}
```

### 常用数据结构

```
package main

import "fmt"

func main() {
    // hello world
    fmt.Println("hello world")

    fmt.Println("##################### arrays")
    arrays()

    fmt.Println("##################### slice")
    slice()

    fmt.Println("##################### mapFunc")
    mapFunc()

    fmt.Println("##################### rangeFunc")
    rangeFunc()
}

// 数组
func arrays() {
    // 这里我们创建了一个数组 test1 来存放刚好 5 个 int。
    // 元素的类型和长度都是数组类型的一部分。
    // 数组默认是零值的，对于 int 数组来说也就是 0。
    var test1 [6]int
    fmt.Println("内容:", test1)
    // 我们可以使用 array[index] = value 语法来设置数组指定位置的值，或者用 array[index] 得到值。
    test1[4] = 100
    fmt.Println("设置:", test1)
    fmt.Println("获取:", test1[4])
    // 使用内置函数 len 返回数组的长度
    fmt.Println("长度:", len(test1))

    // 使用这个语法在一行内初始化一个数组
    test2 := [6]int{1, 2, 3, 4, 5, 6}
    fmt.Println("数据:", test2)

    // 数组的存储类型是单一的，但是你可以组合这些数据来构造多维的数据结构。
    var twoTest [3][4]int
    for i := 0; i < 3; i++ {
        for j := 0; j < 4; j++ {
            twoTest[i][j] = i + j
        }
    }
    // 注意，在使用 fmt.Println 来打印数组的时候，会使用[v1 v2 v3 ...] 的格式显示
    fmt.Println("二维: ", twoTest)
}

// 切片
func slice() {
    // Slice 是 Go 中一个关键的数据类型，是一个比数组更加强大的序列接口

    // 不像数组，slice 的类型仅由它所包含的元素决定（不像数组中还需要元素的个数）。
    // 要创建一个长度非零的空slice，需要使用内建的方法 make。
    // 这里我们创建了一个长度为3的 string 类型 slice（初始化为零值）。
    test1 := make([]string, 3)
    fmt.Println("数据:", test1)
    // 我们可以和数组一样设置和得到值
    test1[0] = "A"
    test1[1] = "C"
    test1[2] = "B"
    fmt.Println("数据:", test1)
    fmt.Println("获取:", test1[2])
    // 如你所料，len 返回 slice 的长度
    fmt.Println("长度:", len(test1))

    // 作为基本操作的补充，slice 支持比数组更多的操作。
    // 其中一个是内建的 append，它返回一个包含了一个或者多个新值的 slice。
    // 注意我们接受返回由 append返回的新的 slice 值。
    test1 = append(test1, "D")
    test1 = append(test1, "E", "F")
    fmt.Println("追加:", test1)

    // Slice 也可以被 copy。这里我们创建一个空的和 test1 有相同长度的 slice test2，并且将 test1 复制给 test2。
    test2 := make([]string, len(test1))
    copy(test2, test1)
    fmt.Println("拷贝:", test2)
    // Slice 支持通过 slice[low:high] 语法进行“切片”操作。例如，这里得到一个包含元素 test1[2], test1[3],test1[4] 的 slice。
    l := test1[2:5]
    fmt.Println("切片1:", l)
    // 这个 slice 从 test1[0] 到（但是不包含）test1[5]。
    l = test1[:5]
    fmt.Println("切片2:", l)
    // 这个 slice 从（包含）test1[2] 到 slice 的后一个值。
    l = test1[2:]
    fmt.Println("切片3:", l)
    // 我们可以在一行代码中声明并初始化一个 slice 变量。
    t := []string{"g", "h", "i"}
    fmt.Println("数据:", t)

    // Slice 可以组成多维数据结构。内部的 slice 长度可以不同，这和多位数组不同。
    twoTest := make([][]int, 3)
    for i := 0; i < 3; i++ {
        innerLen := i + 1
        twoTest[i] = make([]int, innerLen)
        for j := 0; j < innerLen; j++ {
            twoTest[i][j] = i + j
        }
    }
    // 注意，slice 和数组不同，虽然它们通过 fmt.Println 输出差不多。
    fmt.Println("二维: ", twoTest)
}

// 键值对 key/value
func mapFunc() {
    // 要创建一个空 map，需要使用内建的 make:make(map[key-type]val-type).
    map1 := make(map[string]int)
    // 使用典型的 make[key] = val 语法来设置键值对。
    map1["k1"] = 7
    map1["k2"] = 13
    // 使用例如 Println 来打印一个 map 将会输出所有的键值对。
    fmt.Println("数据:", map1)
    // 使用 name[key] 来获取一个键的值
    v1 := map1["k1"]
    fmt.Println("值: ", v1)
    // 当对一个 map 调用内建的 len 时，返回的是键值对数目
    fmt.Println("长度:", len(map1))
    // 内建的 delete 可以从一个 map 中移除键值对
    delete(map1, "k2")
    fmt.Println("数据:", map1)
    // 当从一个 map 中取值时，可选的第二返回值指示这个键是在这个 map 中。
    // 这可以用来消除键不存在和键有零值，像 0 或者 "" 而产生的歧义。
    _, prs := map1["k2"]
    fmt.Println("是否存在:", prs)
    // 你也可以通过这个语法在同一行申明和初始化一个新的map。
    map2 := map[string]int{"F": 1, "B": 2}
    // 注意一个 map 在使用 fmt.Println 打印的时候，是以 map[k:v k:v]的格式输出的。
    fmt.Println("数据:", map2)
}

// Range 遍历
func rangeFunc() {
    // 这里我们使用 range 来统计一个 slice 的元素个数。数组也可以采用这种方法。
    array1 := []int{2, 3, 4}
    sum := 0
    for _, num := range array1 {
        sum += num
    }
    fmt.Println("求和:", sum)

    // range 在数组和 slice 中都同样提供每个项的索引和值。
    // 上面我们不需要索引，所以我们使用 空值定义符_ 来忽略它。
    // 有时候我们实际上是需要这个索引的。
    for i, num := range array1 {
        if num == 3 {
            fmt.Println("索引:", i)
        }
    }

    // range 在 map 中迭代键值对。
    map1 := map[string]string{"A": "苹果", "B": "香蕉"}
    for k, v := range map1 {
        fmt.Printf("%s -> %s\n", k, v)
    }
    for k := range map1 {
        fmt.Println("键:", k)
    }

    // range 在字符串中迭代 unicode 编码。
    // 第一个返回值是rune 的起始字节位置，然后第二个是 rune 自己。
    for i, c := range "abA" {
        fmt.Println(i, c)
    }
}
```

### 函数介绍

```
package main

import "fmt"

func main() {
    // hello world
    fmt.Println("hello world")

    // 1. 加法
    res := plus(1, 2)
    fmt.Println("1+2 =", res)
    res = plusPlus(1, 2, 3)
    fmt.Println("1+2+3 =", res)

    // 2. 多值返回
    // 这里我们通过多赋值 操作来使用这两个不同的返回值。
    a, b := vals()
    fmt.Println(a)
    fmt.Println(b)
    // 如果你仅仅想返回值的一部分的话，你可以使用空白定义符 _。
    _, c := vals()
    fmt.Println(c)

    // 3. 可变参数
    // 变参函数使用常规的调用方式，除了参数比较特殊。
    sum(1, 2)
    sum(1, 2, 3)
    // 如果你的 slice 已经有了多个值，想把它们作为变参使用，你要这样调用 func(slice...)。
    nums := []int{1, 2, 3, 4}
    sum(nums...)

    // 4. 闭包
    // 我们调用 intSeq 函数，将返回值（也是一个函数）赋给nextInt。
    // 这个函数的值包含了自己的值 i，这样在每次调用 nextInt 时都会更新 i 的值。
    nextInt := intSeq()
    // 通过多次调用 nextInt 来看看闭包的效果。
    fmt.Println(nextInt())
    fmt.Println(nextInt())
    fmt.Println(nextInt())
    // 为了确认这个状态对于这个特定的函数是唯一的，我们重新创建并测试一下。
    newInts := intSeq()
    fmt.Println(newInts())

    // 5. 递归
    fmt.Println(fact(7))
}

// 函数
// 这里是一个函数，接受两个 int 并且以 int 返回它们的和
func plus(a int, b int) int {
    // Go 需要明确的返回值，例如，它不会自动返回最后一个表达式的值
    return a + b
}

// (int, int) 在这个函数中标志着这个函数返回 2 个 int。
func plusPlus(a, b, c int) int {
    return a + b + c
}

// 多返回值函数
func vals() (int, int) {
    return 3, 7
}

// 变参函数
func sum(nums ...int) {
    fmt.Print(nums, " ")
    total := 0
    for _, num := range nums {
        total += num
    }
    fmt.Println(total)
}

// 闭包
// 这个 intSeq 函数返回另一个在 intSeq 函数体内定义的匿名函数。
// 这个返回的函数使用闭包的方式 隐藏 变量 i。
func intSeq() func() int {
    i := 0
    return func() int {
        i += 1
        return i
    }
}

// 递归
// face 函数在到达 face(0) 前一直调用自身。
func fact(n int) int {
    if n == 0 {
        return 1
    }
    return n * fact(n-1)
}
```

### 指针结构体接口



### 错误处理


### 协程


### 常用函数




### 并发 


<br/><br/><br/><br/><br/>
## 参考资料

golang基础教程-go语言快速入门 blibli <www.bilibili.com/video/av94410029>

github：[https://github.com/goflyfox/gostudy](https://github.com/goflyfox/gostudy)

gitee：[https://gitee.com/goflyfox/gostudy](https://gitee.com/goflyfox/gostudy)

腾讯课堂教程地址：[golang基础教程-快速入门go语言](https://ke.qq.com/course/2585401?taid=9426843331949369&tuin=13b4f9bd)

bilibili教程地址：[golang基础教程-快速入门go语言](https://www.bilibili.com/video/av94410029)

西瓜视频教程地址：[golang基础教程-快速入门go语言](https://www.ixigua.com/pseries/6809291194665796100/)

