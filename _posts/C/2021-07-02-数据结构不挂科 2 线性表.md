---
layout: post
categories: C
title: 数据结构不挂科 2 线性表
meta: 数据结构不挂科 2 线性表
---
* content
{:toc}

## 正文

### 模块1 线性表的定义

#### ⼩节1 基本概念

**线性表的定义**

`(a1, a2, a3, ... , an−1, an, an+1)`

`0->1->2->3->4->5->6`

ai−1 是 ai的直接前驱元素， ai+1是 ai 的直接后驱元素

是⼀个有限序列，表中各个元素是相继排列的，且每两个相邻元素之间都有直接前驱和直接后继的逻辑关系。

* 例题2-1 线性表是具有n个（ ）队有限序列

A.数据表  B.字符  C. 数据元素  D.数据项

**线性表的四大特点**

1.存在唯⼀的第⼀个元素和最后⼀个元素。

2.除第⼀个元素外，其他元素有且仅有⼀个直接前驱。

3.除最后⼀个元素外，其他元素有且仅有⼀个直接后继。

4.线性表中的每⼀个元素都具有相同的数据类型，且不能按⼦表那样再分割。

```
color={‘red’,’orange’,’yellow’,’green’,’blue’,’black’} 
score={‘667’,’664’,’659’,’662’,’610’,’632’,’’651}
```

* 例题2-2  以下（ ）是⼀个线性表。

A.由n个实数组成的集合   B.由100个字符组成的序列   C.所有整数组成的序列   D.邻接表

* 例题2-3  在线性表中，除开始元素外，每个元素（ ）。

A.只有唯⼀的前驱元素。   B.只有唯⼀的后继元素。   C.有多个前驱元素。   D.有多个后继元素。

#### ⼩节2 线性表基本操作

1.`InitList(&L)`

```
int initList(SqList *L)
{
    L->length = 0;
    return 1;
}
```
   
操作结果：构造⼀个空的线性表L

2.`printList(L)`

```
int printList(SqList L)
{
    if (L.length == 0) {
        printf("链表为空\n");
        return 0;
    }
    
    int i;
    for(i = 0; i < L.length; i++)
    {
        printf("data[%d] = %d\n", i, L.data[i]);
    }
    
    printf("\n");
    
    return 1;
}
```

操纵结果：打印⼀个顺序表，⽅便测试操作是否正确

```
data[0] = 0
data[1] = 1
data[2] = 2
data[3] = 3
data[4] = 4
data[5] = 5
data[6] = 6
data[7] = 7
data[8] = 8
data[9] = 9
```

3.`getlength(L)`

```
int getlength(SqList L)
{
    return L.length;
}
```

操作结果：获取顺序表的⻓度

4.`createList(&L，int length)`

```
int createList(SqList *L, int length)
{
    srand(time(0));
    int i;
    for(i = 0; i < length; i++) 
    {
        L->data[i] = rand() % 100;
        L->length++;
    }
    
    return 1;
}
```

操作结果：创建⼀个顺序表，每个元素的值随机赋值

5.`insertList(&L, int pos, ElemType elem)`

```
int insertList(SqList *L, int pos, ElemType elem)
{
    int i;
    if (pos < 1 || pos > L->length) {
        printf("插入的位置有误，无法插入数据\n");
        return 0;
    }
    
    for(i = L->length - 1; i >= pos - 1; i--) 
    {
        L->data[i+1] = L->date[i];
    }
    L->date[pos-1] = elem;
    L->length++;
    
    return 1;
}
```

操作结果：在指定位置处插⼊⼀个新的元素

6.`locateElem(L，ElemType e)`

```
int locateElem(SqList L, ElemType e)
{
    int i;
    for(i = 0; i < L.length; i++) 
    {
        if (L.data[i] == e) {
            printf("在pos[%d]位置处，查找到了元素elem:%d\n", i+1, e);
            return 1;
        }
    }
    
    return 0;
}
```

操作结果：查找在线性表中是否含有指定元素

* 例题2-4  假设利⽤两个线性表LA和LB分别表示两个集合A和B，现要求⼀个新的集合`A = A U B`。这就要求对线性表作如下操作： 
  扩⼤线性表LA，将存在于线性表LB中⽽不存在于线性表LA中的数据元素插⼊到LA中去。
  只要从线性表LB中依次取得每个数据元素，并依值在线性表LA中进⾏查访，若不存在，则插⼊之。

### 模块2 顺序表

#### ⼩节1 顺序表的定义和特点

**顺序表的定义**

![]({{site.baseurl}}/images/20210705/20210705204908.png)

**顺序表结构体的定义**

```
# define MaxSize 100  // 最大空间

typedef struct
{
    ElemType *elem;
    int length;
} Sqlist;
```

`ElemType` 元素类型，需要什么类型就写什么类型

`*elem` 基地址，前⾯加*号表示取地址的内容

`length` 表示顺序表的⻓度

结构体定义后，若想要定义⼀顺序表L，可以这样写： `SqList L`

#### ⼩节2 顺序表主要操作的实现

**顺序表的插入**

```
// 新元素x插⼊到表中第i个位置
int insertList(SqList &L, int i, DataType &x)
{
    // 表满的情况
    if (L.n == L.maxSize) {
        return 0;
    }
    
    // 参数i不合理的情况
    if (i < 0 || i > L.n+1) {
        return 0;
    }
    
    // i+1之后的位置都依次后移
    for(int j = L.n; j >= i; j--) 
    {
        L.data[j] = L.date[j-1];
    }
    // 插⼊该值
    L.data[i-1] = x;
    // 表⻓加1
    L.n++;
    
    // return：成功则返1 不成功返0
    return 1;
}
```

![]({{site.baseurl}}/images/20210705/20210705210318.png)

**顺序表的删除**

```
int remove(SqList &L, int i, DataType &x)
{
    // 表空的情况
    if (!L.n) {
        return 0;
    }
    
    // 参数i不合理的情况
    if (i < 1 || i > L.n) {
        return 0;
    }
    
    // 把要被删除的值存起来
    x = L.data[i-1];
    
    // 依次前移
    for(int j = i; j < L.n; j++) 
    {
        L.data[j-1] = L.date[j];
    }
    // 表⻓减1
    L.n--;
    
    return 1;
}
```

![]({{site.baseurl}}/images/20210705/20210705210428.png)

#### ⼩节3 顺序表的应⽤举例

* 例题2-5  两个顺序表LA和LB，把它们当作集合来使⽤，完成集合”并“运算的实现,结果存于LA，重复元素只留⼀个。

* 例题2-6  做集合的“交”运算，求LA，LB中的共有元素，结果存于LA。

* 例题2-7  将顺序表 (a1，a2，... ，an) 重新排列为以 a1 为界的两部分：a1 前⾯的值均⽐ a1 ⼩，
  a1 后⾯的值都⽐ a1 ⼤(这⾥假设数据元素的类型具有可⽐性, 不妨设为整型)。 这⼀操作称为划分。a1 也称为基准。
  
### 模块3 单链表

#### ⼩节1 单链表的定义和特点

**单链表**

当⼀个序列中只含有指向它的后继节点的链接时，就称该链表为单链表。

`data | next`

`head-` > `1 |-` > `2 |-` > ... `n |^`

**带头结点的单链表**

头指针head指向头结点，头结点的值域不含任何信息，从头结点的后继结点开始存储数据信息。 
头指针head始终不等于NULL，head->next等于NULL时，链表为空。

**不带头结点的单链表**

头指针head直接指向开始结点。 当head等于NULL时，链表为空。

**如何从线性表中得到单链表？**

链表是⼀个动态的结构，它不需要予分配空间，因此⽣成链表的过程是⼀个结点“逐个插⼊” 的过程。

**单链表的结构定义**

```
typedef int DataType;
typedef struct node    // 链表结点
{
    DataType data;    // 数据域
    struct node *link;    // 链接指针域
} LinkNode, *LinkList;
```

* 例题2-8  单链表中，增加⼀个头结点的⽬的是为了（ ）

A.使单链表⾄少有⼀个结点  B.标识表结点中⾸结点的位置  C.⽅便运算的实现  D.说明单链表是线性表的链式存储

#### ⼩节2 单链表主要操作

#### ⼩节3 单链表的应⽤举例


### 模块4 循环链表和双向链表

#### ⼩节1 循环链表

#### ⼩节2 双向链表


### 例题解析

* 解析2-1 C

线性表是由具有相同数据类型的有限个数据元素组成的，数据元素是由数据项组成的。

* 解析2-2  B

A.指定的是集合，⽽集合中的各元素没有前后驱关系。
C.线性表的定义要求为有限序列，⽽C中序列的元素个数是⽆穷多个的。
D.邻接表属于存储结构，线性表是⼀种逻辑结构，不可将⼆者混为⼀谈。

* 解析2-3  A

线性表中，除最后⼀个元素外，每个元素只有唯⼀的后继元素。

* 解析2-4

```
void union (List &La, List Lb)
{
    La_len = ListLength(La);
    Lb_len = ListLength(Lb);
    for (i=1; i<=Lb_len; i++) 
    {
        GetElem(Lb, i, e);
        if (!LocateElem(La, e, equal)) {
            ListInsert(La, ++La_len, e);
        }
    }
}
```

* 解析2-5

```
void Merge(SqList &LA, SqList &LB)
{
    int n = Length(LA), m = Length(LB), i, k, x;
    for (i = 1; i <= m; i++) 
    {
        x = LB.data[i-1];  // 在LB中取一个元素
        k = Search(LA, x);  // 在LA中查找它
        // 若在LA中未找到则将它插入LA中
        if (k = 0) {
            Insert(LA, n+1, x);  // 插入到第n个元素之后
            n++;
        }        
    }
}
```

* 解析2-6

```
void Intersection(SqList &LA, SqList &LB)
{
    int n = Length(LA), m = Length(LB), i = 1, k, x;
    while (i <= n) 
    {
        x = LA.data[i-1];  // 在LA中取一个元素
        k = Search(LB, x);  // 在LB中查找它
        / 若在LB中未找到则将它从LA中删除掉
        if (k == 0) {
            Remove(LA, i, x);
            n--;
        } else {
            i++;
        }
    }
}
```

* 解析2-7

基本思路： 从第⼆个元素开始到最后⼀个元素，逐⼀向后扫描：
（1）当前数据元素 ai ⽐ a1 ⼤时，表明它已经在 a1 的后⾯，不必改变它与 a1 之间的位置，继续⽐较下⼀个。
（2）当前结点若⽐ a1 ⼩，说明它应该在 a1 的前⾯，此时将它上⾯的元素都依次向下移动⼀个位置，然后将它 置⼊最上⽅。

```
void part(SqList &l)
{
    int i, j;
    Elemtype x, y;
    x = L.elem[0];
    for (i = 1; i < L.length; i++) 
    {
        if (L.elem[i] < x) {
            y = L.elem[i];
            for (j = i -1; j >= 0; j--) 
            {
                L.elem[j+1] = L.elem[j];
                L.elem[0] = y;
            }
        }
    }
}
```

* 解析2-8 C

⽅便运算体现在两个⽅⾯，第⼀，有头结点后，插⼊和删除数据元素的算法统⼀了不再需要判断是否在第⼀个元素之前插⼊或删除第⼀个元素；
第⼆，不论 链表是否为空，其头指针是指向头结点的⾮空指针，链表的头指针不变，因此空表和⾮空表的处理统⼀了。

<br/><br/><br/><br/><br/>
## 参考资料


