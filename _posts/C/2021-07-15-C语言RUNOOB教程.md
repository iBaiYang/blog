---
layout: post
categories: C
title: C语言RUNOOB教程
meta: C语言RUNOOB教程
---
* content
{:toc}

## 正文

### C  语言教程

C 语言是一种通用的、面向过程式的计算机程序设计语言。1972 年，为了移植与开发 UNIX 操作系统，丹尼斯·里奇在贝尔电话实验室设计开发了 C 语言。

当前最新的 C 语言标准为 C18 ，在它之前的 C 语言标准有 C17、C11...C99 等。

```
#include<stdio.h>  

/*
这一句话是必须要的格式
stdio 表示系统文件库, 也可以声明其它的
.h  表示头文件,因为这些文件都是放在程序各文件的开头
#include 告诉预处理器将指定头文件的内容插入到预处理器命令的相应位  导入头文件的预编译指令
<> 表示系统自带的库
也可以写成" " 表示用户自定义的库
如果写成" "并且自定义的库里面没有这个文件系统会自动查找自带的库,如果还是没有报错
*/

int main() // 程序的入口
{ //程序从这里开始运行
    /*
    int 表示数字格式,返回一个数字
    main()主函数 表示程序的入口  一个程序有且只能有一个main函数的存在
    */
    printf("hello C"); //打印一个hello C
    
    return 0; //返回一个整数0,因为它是int类型,所以只能返回整数
}  //程序从这里结束
```


所有的 C 语言程序都需要包含 main() 函数。 代码从 main() 函数开始执行。

`/* ... */` 用于注释说明。

printf() 用于格式化输出到屏幕。printf() 函数在 "stdio.h" 头文件中声明。

stdio.h 是一个头文件 (标准输入输出头文件) , #include 是一个预处理命令，用来引入头文件。 
当编译器遇到 printf() 函数时，如果没有找到 stdio.h 头文件，会发生编译错误。

`return 0;` 语句用于表示退出程序。


### C 简介

C 语言是一种通用的高级语言，最初是由丹尼斯·里奇在贝尔实验室为开发 UNIX 操作系统而设计的。
C 语言最开始是于 1972 年在 DEC PDP-11 计算机上被首次实现。

在 1978 年，布莱恩·柯林汉（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）制作了 C 的第一个公开可用的描述，现在被称为 K&R 标准。

UNIX 操作系统，C编译器，和几乎所有的 UNIX 应用程序都是用 C 语言编写的。由于各种原因，C 语言现在已经成为一种广泛使用的专业语言。

### C 环境设置

文本编辑器

C 编译器

gcc 进行 c 语言编译分为四个步骤：

1.预处理，生成预编译文件（.i 文件）：

`gcc –E hello.c –o hello.i`

2.编译，生成汇编代码（.s 文件）：

`gcc –S hello.i –o hello.s`

3.汇编，生成目标文件（.o 文件）：

`gcc –c hello.s –o hello.o`

4.链接，生成可执行文件：

`gcc hello.o –o hello`

有时候，进行调试，可能会用到某个步骤哦

### C 程序结构

C 程序主要包括以下部分：

    预处理器指令
    函数
    变量
    语句 & 表达式
    注释

```
#include <stdio.h>
 
int main()
{
   /* 我的第一个 C 程序 */
   printf("Hello, World! \n");
   
   return 0;
}
```

程序的第一行 `#include <stdio.h>` 是预处理器指令，告诉 C 编译器在实际编译之前要包含 stdio.h 文件。

下一行 `int main()` 是主函数，程序从这里开始执行。

下一行 `/*...*/` 将会被编译器忽略，这里放置程序的注释内容。它们被称为程序的注释。

下一行 `printf(...)` 是 C 中另一个可用的函数，会在屏幕上显示消息 "Hello, World!"。

下一行 `return 0;` 终止 main() 函数，并返回值 0。

#### 编译 & 执行 C 程序

gcc 命令如果不指定目标文件名时默认生成的可执行文件名为 a.out(linux) 或 a.exe(windows)。

可用 `gcc [源文件名] -o [目标文件名]` 来指定目标文件路径及文件名。

例如，windows 系统上，`gcc hello.c -o target/hello` 会在 target 目录下生成 hello.exe 文件(Linux 系统生成 hello 可执行文件)，
target 目录必须已存在，`[源文件名]` 和 `-o [目标文件名]` 的顺序可互换， `gcc -o target/hello hello.c` 依然有效。

### C 基本语法

#### C 的令牌（Token）

C 程序由各种令牌组成，令牌可以是关键字、标识符、常量、字符串值，或者是一个符号。例如，下面的 C 语句包括五个令牌：
```
printf("Hello, World! \n");
```

这五个令牌分别是：
```
printf
(
"Hello, World! \n"
)
;
```

#### 注释

```
// 单行注释
```

```
/* 单行注释 */

/* 
 多行注释
 多行注释
 多行注释
 */
```

您不能在注释内嵌套注释，注释也不能出现在字符串或字符值中。

#### 标识符

**标识符**：在编程语言中，标识符是用户编程时使用的名字，变量、常量、函数、语句块都有名字。
是用来标识某个实体的一个符号，是对变量名、函数名、标号和其他各种用户定义的对象命名。

C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，
后跟零个或多个字母、下划线和数字（0-9）。

C 标识符内不允许出现标点字符，比如 @、$ 和 %。C 是区分大小写的编程语言。

C语言中标识符的命名规范：
1. 标识符由字母、数字、下划线组成，并且首字母不能是数字。
2. 不能把C的关键字作为用户的标识符，例如：if、for、while等。（注：标识符不能和C语言的关键字相同，也不能和用户自定义的函数或C语言库函数同名）
3. 标识符长度是由机器上的编译系统决定的，一般的限制为8字符，(注：8字符长度限制是C89标准，C99标准已经扩充长度，其实大部分工业标准都更长)。
4. 标识符对大小写敏感，即严格区分大小写。一般对变量名用小写，符号常量命名用大写。（注：C语言中字母是区分大小写的，因此score、Score、SCORE分别代表三个不同的标识符）
5. 标识符命名应做到"见名知意"，例如，长度（外语：length），求和、总计（外语：sum），圆周率（外语：pi）

#### 关键字

下表列出了 C 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。

| 关键字  |    说明 |
| :---- | :---- |
| auto     | 声明自动变量 | 
| break | 跳出当前循环 | 
| case    | 开关语句分支 | 
| char    | 声明字符型变量或函数返回值类型 | 
| const     | 定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变 | 
| continue    | 结束当前循环，开始下一轮循环 | 
| default    | 开关语句中的"其它"分支 | 
| do     | 循环语句的循环体 | 
| double     | 声明双精度浮点型变量或函数返回值类型 | 
| else    | 条件语句否定分支（与 if 连用） | 
| enum    | 声明枚举类型 | 
| extern    | 声明变量或函数是在其它文件或本文件的其他位置定义 | 
| float    | 声明浮点型变量或函数返回值类型 | 
| for    | 一种循环语句 | 
| goto    | 无条件跳转语句 | 
| if    | 条件语句 | 
| int    | 声明整型变量或函数 | 
| long     | 声明长整型变量或函数返回值类型 | 
| register    | 声明寄存器变量 | 
| return     | 子程序返回语句（可以带参数，也可不带参数） | 
| short    | 声明短整型变量或函数 | 
| signed    | 声明有符号类型变量或函数 | 
| sizeof    | 计算数据类型或变量长度（即所占字节数） | 
| static     | 声明静态变量 | 
| struct    | 声明结构体类型 | 
| switch     | 用于开关语句 | 
| typedef    | 用以给数据类型取别名 | 
| unsigned    | 声明无符号类型变量或函数 | 
| union    | 声明共用体类型 | 
| void    | 声明函数无返回值或无参数，声明无类型指针 | 
| volatile    | 说明变量在程序执行中可被隐含地改变 | 
| while     | 循环语句的循环条件 | 

C99 新增关键字

`_Bool`     `_Complex`     `_Imaginary`     `inline`     `restrict`

C11 新增关键字

`Alignas`     `_Alignof`     `_Atomic`     `_Generic`     `_Noreturn`  `_Static_assert`     `_Thread_local`

#### C 中的空格

在 C 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，
让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。

```
int age;
```

在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。

```
fruit = apples + oranges;
```

fruit 和 =，或者 = 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。

### C 数据类型

![]({{site.baseurl}}/images/20210705/20210705132217.png)

以下列出了32位系统与64位系统的存储大小的差别:

![]({{site.baseurl}}/images/20210715/20210715134031.jpg)

为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 sizeof 运算符。
表达式 sizeof(type) 得到对象或类型的存储字节大小。
```
#include <stdio.h>
#include <limits.h>
 
int main()
{
   printf("int 存储大小 : %lu \n", sizeof(int));
   
   return 0;
}
```

%lu 为 32 位无符号整数。

#### 浮点类型

float  单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。  1.2E-38 到 3.4E+38 ， 6 位小数

double  双精度浮点值。双精度是1位符号，11位指数，52位小数。  2.3E-308 到 1.7E+308 ， 15 位小数

#### void 类型

void 类型指定没有可用的值。它通常用于以下三种情况下：

1. 函数返回为空， C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 `void exit (int status);`
2. 函数参数为空， C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 `int rand(void);`
3. 指针指向 void， 类型为 `void *` 的指针代表对象的地址，而不是类型。例如，内存分配函数 `void *malloc( size_t size );` 返回指向 void 的指针，可以转换为任何数据类型。

#### 数据类型转换

1、数据类型转换：C 语言中如果一个表达式中含有不同类型的常量和变量，在计算时，会将它们自动转换为同一种类型；
在 C 语言中也可以对数据类型进行强制转换；

2、自动转换规则：

    a）浮点数赋给整型，该浮点数小数被舍去；
    b）整数赋给浮点型，数值不变，但是被存储到相应的浮点型变量中； 

3、强制类型转换形式: (类型说明符)(表达式)

实例程序：
```
#include<stdio.h>

int main()
{
    float f,x=3.6,y=5.2;
    int i=4,a,b;
    a=x+y;
    b=(int)(x+y);
    f=10/i;
    printf("a=%d,b=%d,f=%f,x=%f\n",a,b,f,x);
}
```

例中先计算 x+y 值为 8.8，然后赋值给 a，因为a为整型，所以自取整数部分8，a=8;

接下来 b 把 x+y 强制转换为整型;

最后 10/i 是两个整数相除，结果仍为整数 2，把 2 赋给浮点数 f;

x 为浮点型直接输出。

### C 变量

变量其实只不过是程序可操作的存储区的名称。
C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。

变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C 是大小写敏感的。

#### C 中的变量定义

变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。

格式，type 必须是一个有效的 C 数据类型，variable_list 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔：
```
type variable_list;
type variable_name = value;
```

如：
```
int    i, j, k;
char   c, ch;
float  f, salary;
double d;

extern int d = 3, f = 5;    // d 和 f 的声明与初始化
int d = 3, f = 5;           // 定义并初始化 d 和 f
byte z = 22;                // 定义并初始化 z
char x = 'x';               // 变量 x 的值为 'x'
```

行 `int i, j, k;` 声明并定义了变量 i、j 和 k，这指示编译器创建类型为 int 的名为 i、j、k 的变量。

变量可以在声明的时候被初始化，如 行 `int d = 3, f = 5;`。

不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0）。

**解说1**

```
extern int a;     // 声明一个全局变量 a
int a;            // 定义一个全局变量 a
extern int a =0;  // 定义一个全局变量 a 并给初值。一旦给予赋值，一定是定义，定义才会分配存储空间
int a =0;         //定义一个全局变量 a，并给初值
```

声明之后你不能直接使用这个变量，需要定义之后才能使用。

第四个等于第三个，都是定义一个可以被外部使用的全局变量，并给初值。

糊涂了吧，他们看上去可真像。但是定义只能出现在一处。也就是说，不管是 `int a` 还是 `int a=0` 都只能出现一次，而那个 `extern int a` 可以出现很多次。

当你要引用一个全局变量的时候，你就要声明 `extern int a` 这时候 extern 不能省略，因为省略了，就变成 `int a` 这是一个定义，不是声明。

**解说2**

一个变量一定要先初始化才可以使用，因为 c 语言中默认一个没有初始化的变量值是一个不可知的很大值。
如下面所示，a 没有初始化，打印出 a 的值是 1606422582。

```
#include <stdio.h>  
int main()   
{  
    int a;  
    printf("a的值是%d\n",a);  
    return 0;  
}  
```

**解说3**

变量定义：用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义。

变量声明：用于向程序表明变量的类型和名字。

定义也是声明，extern 声明不是定义。

定义也是声明：当定义变量时我们声明了它的类型和名字。

extern 声明不是定义：通过使用 extern 关键字声明变量名而不定义它。

注意：

变量在使用前就要被定义或者声明。

在一个程序中，变量只能定义一次，却可以声明多次。

定义分配存储空间，而声明不会。

**全局变量和局部变量在内存中的区别**

全局变量保存在内存的全局存储区中，占用静态的存储单元；局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。

C语言经过编译之后将内存分为以下几个区域：

（1）栈（stack）：由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址。操作方式类似数据结构中的栈。

（2）堆（heap）：用于程序动态申请分配和释放空间。C语言中的malloc和free，C++中的new和delete均是在堆中进行的。
正常情况下，程序员申请的空间在使用结束后应该释放，若程序员没有释放空间，则程序结束时系统自动回收。注意：这里的“堆”并不是数据结构中的“堆”。

（3）全局（静态）存储区：分为DATA段和BSS段。DATA段（全局初始化区）存放初始化的全局变量和静态变量；
BSS段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。
其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。

（4）文字常量区：存放常量字符串。程序结束后由系统释放。

（5）程序代码区：存放程序的二进制代码。 

显然，C语言中的全局变量和局部变量在内存中是有区别的。C语言中的全局变量包括外部变量和静态变量，均是保存在全局存储区中，占用永久性的存储单元；
局部变量，即自动变量，保存在栈中，只有在所在函数被调用时才由系统动态在栈中分配临时性的存储单元。

```
#include <stdio.h>
#include <stdlib.h>

int k1 = 1;
int k2;
static int k3 = 2;
static int k4;

int main( )
{  
    static int m1=2, m2;
    int i=1;
    char *p;
    char str[10] = "hello";
    char *q = "hello";
    p = (char *)malloc( 100 );
    free(p);
    printf("栈区-变量地址  i：%p\n", &i);
    printf("                p：%p\n", &p);
    printf("              str：%p\n", str);
    printf("                q：%p\n", &q);
    printf("堆区地址-动态申请：%p\n", p);
    printf("全局外部有初值 k1：%p\n", &k1);
    printf("    外部无初值 k2：%p\n", &k2);
    printf("静态外部有初值 k3：%p\n", &k3);
    printf("    外静无初值 k4：%p\n", &k4);
    printf("  内静态有初值 m1：%p\n", &m1);
    printf("  内静态无初值 m2：%p\n", &m2);
    printf("文字常量地址    ：%p, %s\n",q, q);
    printf("程序区地址      ：%p\n",&main);
    
    return 0;
}
```

#### C 中的变量声明

变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。
变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。

变量的声明有两种情况：
1. 一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。
2. 另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。

除非有extern关键字，否则都是变量的定义。

#### C 中的左值（Lvalues）和右值（Rvalues）

C 中有两种类型的表达式：
1. 左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
2. 右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。

总结：
1. 当需要保存数据的时候，需要lvalues。
2. 当需要读取数据的时候，需要rvalues。 

lvalues 和 rvalues 角色的相互转换。

1、 根据表达式的上下文情况，lvalues 在需要 rvalues 的地方会自动转换为 rvalues。例如:
```
int n;
int m;
m = n+2; // 这个表达式里 n 是 rvalues
```

2、 rvalues 永远不能转换为 lvalues

### C 常量

常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。

常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。

常量就像是常规的变量，只不过常量的值在定义后不能进行修改。

#### 整数常量

整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。

整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。

#### 浮点常量

浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。

#### 字符常量

字符常量是括在单引号中，例如，`'x'` 可以存储在 char 类型的简单变量中。

字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）。

#### 字符串常量

字符串字面值或常量是括在双引号 `""` 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。

在 C 语言中，单引号与双引号是有很大区别的。

在 C 语言中没有专门的字符串类型，因此双引号内的字符串会被存储到一个数组中，这个字符串代表指向这个数组起始字符的指针；

而单引号中的内容是一个 char 类型，是一个字符，这个字符对应的是 ASCII 表中的序列值。

#### 定义常量

在 C 中，有两种简单的定义常量的方式：
1. 使用 #define 预处理器。
2. 使用 const 关键字。

```
#define identifier value

const type variable = value;
```

const 声明常量要在一个语句内完成。

**解说1**

`#define` 是宏定义，它不能定义常量，但宏定义可以实现在字面意义上和其它定义常量相同的功能，
本质的区别就在于 `#define` 不为宏名分配内存，而 const 也不为常量分配内存，怎么回事呢，
其实 const 并不是去定义一个常量，而是去改变一个变量的存储类，把该变量所占的内存变为只读！

**解说2**

const 定义的是变量不是常量，只是这个变量的值不允许改变是常变量！带有类型。编译运行的时候起作用存在类型检查。

define 定义的是不带类型的常数，只进行简单的字符替换。在预编译的时候起作用，不存在类型检查。
1、两者的区别

(1) 编译器处理方式不同

    #define 宏是在预处理阶段展开。
    const 常量是编译运行阶段使用。

(2) 类型和安全检查不同

    #define 宏没有类型，不做任何类型检查，仅仅是展开。
    const 常量有具体的类型，在编译阶段会执行类型检查。

(3) 存储方式不同

    #define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。）
    const常量会在内存中分配(可以是堆中也可以是栈中)。

(4) const 可以节省空间，避免不必要的内存分配。 例如：

```
#define NUM 3.14159 //常量宏
const doulbe Num = 3.14159; //此时并未将Pi放入ROM中 ......
double i = Num; //此时为Pi分配内存，以后不再分配！
double I= NUM; //编译期间进行宏替换，分配内存
double j = Num; //没有内存分配
double J = NUM; //再进行宏替换，又一次分配内存！
```

const 定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象 #define 一样给出的是立即数，
所以，const 定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 #define 定义的常量在内存中有若干个拷贝。

(5) 提高了效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，
没有了存储与读内存的操作，使得它的效率也很高。

(6) 宏替换只作替换，不做计算，不做表达式求解;

宏预编译时就替换了，程序运行时，并不分配内存。

**解说3**

define 注意“边缘效应”，例：#define N 2+3, N 的值是 5。

```
double a;
a = (float)N/(float)2;
```

在编译时我们预想 a=2.5，实际打印结果是 3.5 原因是在预处理阶段，编译器将 a=N/2 处理成 a=2+3/2，
这就是 define 宏的边缘效应，所以我们应该写成 `#define N (2+3)`。

### C 存储类

存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：

    auto
    register
    static
    extern

auto 是局部变量的默认存储类, 限定变量只能在函数内部使用；

register 代表了寄存器变量，不在内存中使用；

static 是全局变量的默认存储类,表示变量在程序生命周期内可见；

extern 表示全局变量，即对程序内所有文件可见；

#### auto 存储类

auto 存储类是所有局部变量默认的存储类。

```
{
   int mount;
   auto int month;
}
```

上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量。

#### register 存储类

register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），
且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。

寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，
它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。

#### static 存储类

static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。
因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。

全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。

#### extern 存储类

extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。
当您使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。
可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。

**C 语言中全局变量、局部变量、静态全局变量、静态局部变量的区别**

从作用域看：

1、全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。
当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。

2、静态局部变量具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，
它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。

3、局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，
函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。

4、静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，
即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。

从分配内存空间看：

1、全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间

2、全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。
这两者的区别虽在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。
而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。
由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。

    1)静态变量会被放在程序的静态数据存储区(全局可见)中，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与堆栈变量和堆变量的区别。
    2)变量用static告知编译器，自己仅仅在变量的作用范围内可见。这一点是它与全局变量的区别。

从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。
把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。应予以注意。

Tips:

    A.若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度；
    B.若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度；
    C.设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见；
    D.如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量(这样的函数被称为：带"内部存储器"功能的的函数)
    E.函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。

### C 运算符


### C 判断


### C 循环


### C 函数


### C 作用域规则


### C 数组


### C enum(枚举)


### C 指针


### C 函数指针与回调函数



### C 字符串


### C 结构体


### C 共用体


### C 位域


### C typedef


### C 输入 & 输出


### C 文件读写


### C 预处理器


### C 头文件


### C 强制类型转换


### C 错误处理


### C 递归


### C 可变参数


### C 内存管理


### C 命令行参数


### C 排序算法


### C 语言实例


### C 经典100例



<br/><br/><br/><br/><br/>
## 参考资料

<https://www.runoob.com/cprogramming/c-tutorial.html>
