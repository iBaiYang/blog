---
layout: post
categories: C
title: Linux C编程一站式学习 记录
meta: Linux C编程一站式学习 
---
* content
{:toc}

### 正文

《Linux C编程一站式学习》 是宋劲杉写的一本关系C语言学习的好书，充分考虑到了学以致用的环境Linux。
看了好多C语言的书，包括谭浩强的那本，但还是无法下手编程，不能解决实际操作问题，另外感觉只是翻书，
始终不了解C代码是怎么操作计算机底层的，查来查去说道要想知道C语言是怎样与计算机底层交互的，
就需要去把这几本书翻一遍：编译原理、操作系统、计算机组成原理、数据结构、数据库、网络、软件工程 等。
这里面哪一本不是砖头厚？听名字都要后退3步。所以一直想能找到一本领进门的书，这本书可以使人更透彻的学习。
偶然逛知乎碰到了《Linux C编程一站式学习》，翻了几天，被这本书打动了，这就是我一直在找的那本书，
入门浅显、知识点覆盖全面、知其然还能知其所以然，而且还是开源的。这里就是一些知识点记录一下，以备查阅翻看。

gdb <http://akaedu.github.io/book/ch10.html>

#### c运算符优先级

1. 标识符、 常量、 字符串 和 用()括号套起来的表达式 是组成表达式的最基本单元，在运算中做操作数，优先级最高。

2. 后缀运算符，包括数组取下标`[]` 、 函数调用`()` 、 结构体取成员`.` 、 指向结构体的指针取成员`->` 、 `后缀自增++`、 `后缀自减--`。
如果一个操作数后面有多个后缀，按照离操作数从近到远的顺序(也就是从左到右)依次计算，
比如 a.name++ ，先算 a.name ，再++，这里的 .name 应该看成 a 的一个后缀，而不是把 . 看成双目运算符。

3. 单目运算符，包括`++前缀自增`、`--前缀自减`、 `sizeof` 、 类型转换`()`、 取地址运算`&` 、 指针间接寻址`*`、`正号+`、`负号-`、 `按位取反~`、 `逻辑非!`。
如果一个操作数前面有多个前缀，按照离操作数从近到远的顺序(也就是从右到左)依次计算，比如 !~a ，先算 ~a ，再求!。

4. 乘*、除/、模%运算符。 这三个运算符是左结合的。

5. 加+、减-运算符。左结合。

6. 移位运算符<<和>>。左结合。

7. 关系运算符< > <= >=。左结合。

8. 相等性运算符==和!=。左结合。

9. 按位与`&`。左结合。

10. 按位异或`^`。左结合。

11. 按位或`|`。左结合。

12. 逻辑与`&&`。左结合。

13. 逻辑或`||`。左结合。

14. 条件运算符`:?`。在第 2 节 “if/else语句”讲过Dangling-else问题，条件运算符也有类似的问题。
例如 a ? b : c ? d : e 是看成 (a ? b : c) ? d : e 还是 a ? b : (c ? d : e) 呢?C语言规定是后者。

15. 赋值 `=` 和 各种复合赋值`*= /= %= += -= <<= >>= &= ^= |=`。 在双目运算符中只有赋值和复合赋值是右结合的。

16. 逗号运算符`，` 。 左结合。

#### 指向指针的指针

指针可以指向复合类型。

指针也可以指向指针自己，看一个例子：
```
#include <stdio.h>

int main(void)
{
    int i;
    int *pi = &i;
	int **ppi = &pi;
    printf("   &i=%p\n   pi=%p\n  &pi=%p\n  ppi=%p\n *ppi=%p\n", &i, pi, &pi, ppi, *ppi);
   
    return 0;
}
```

输出：
```
   &i=0x7ffdcce13ed4
   pi=0x7ffdcce13ed4
  &pi=0x7ffdcce13ec8
  ppi=0x7ffdcce13ec8
 *ppi=0x7ffdcce13ed4
```

可以看出，`*` 只是一个标示，说明这个变量保存的是另一个标量的地址，如ppi保存的是pi的地址，`*ppi`意思是读取ppi保存的值也就是pi地址上的保存的值，即i的地址。

可以看出`*(&i) = i` , 分析下`**ppi`： `**ppi = *(*ppi) = *(*(&pi)) = *pi = *(&i) = i`，从里面也看到了`*ppi = *(&pi) = pi = &i`。

#### 指向数组的指针

先看一下 typedef 的使用。

C标准规定 size_t 是一种无符号整型,编译器可以用 typedef 做一个类型声明:
```
typedef unsigned long size_t;
```

那么 size_t 就代表 unsigned long 型。不同平台的编译器可能会根据自己平台的具体情况定义 size_t 所代表的类型,
比如有的平台定义为 unsigned long 型,有的平台定义为 unsigned long long 型,C标准规定 size_t 这个名字就是为了隐藏这些细节,
使代码具有可移植性。

所以注意不要把 size_t 类型和它所代表的真实类型混用,例如:
```
unsigned long x;
size_t y;
x = y;
```

如果在一种ILP32平台上定义 size_t 代表 unsigned long long 型,这段代码把 y 赋给 x 时就把高位截掉了,结果可能是错的。

typedef 这个关键字用于给某种类型起个新名字，比如上面的 typedef 声明可以这么看:去掉 typedef 就成了一个变量声明 `unsigned long size_t;` ， 
size_t 是一个变量名，类型是 unsigned long ，那么加上 typedef 之后， size_t 就是一个类型名，就代表 unsigned long 类型。
再举个例子:
```
typedef char array_t[10];
array_t a;
```

这相当于声明 `char a[10];` 。 类型名也遵循标识符的命名规则,并且通常加个 _t 后缀表示Type。

定义一个指向数组的指针，该数组有10个int元素：
````
int (*a)[10];
````

和指针数组的定义`int *a[10];` 相比，仅仅多了一个()括号。如何记住和区分这两种定义呢？
我们可以认为`[]`比`*`有更高的优先级，如果a先和`*`结合则表示a是一个指针，如果a先和`[]`结合则表示a是一个数组。

`int *a[10];` 这个定义可以拆成两句：
```
typedef int *t;
t a[10];
```
t代表`int *`类型，a则是由这种类型的元素组成的数组。

`int (*a)[10];` 这个定义也可以拆成两句：
```
typedef int t[10];
t *a;
```
t代表由10个int组成的数组类型，a则是指向这种类型的指针。

现在看指向数组的指针如何使用：
```
int a[10];
int (*pa)[10] = &a;
```

a是一个数组，在`&a`这个表达式中，数组名做左值，取整个数组的首地址赋给指针pa。注意，`&a[0]`表示数组a的首元素的首地址，而`&a`表示数组a的首地址，
显然这两个地址的数值相同，但这两个表达式的类型是两种不同的指针类型，前者`&a[0]`的类型是`int *`，而后者`&a`的类型是`int (*)[10]`。
`*pa`就表示pa所指向的数组a，所以取数组的`a[0]`元素可以用表达式`(*pa)[0]`。 注意到`*pa`可以写成`pa[0]`，
所以`(*pa)[0]`这个表达式也可以改写成`pa[0][0]`，pa就像一个二维数组的名字，它表示什么含义呢？下面把pa和二维数组放在一起做个分析。

`int a[5][10];` 和`int (*pa)[10];` 之间的关系同样类似于`int a[10];` 和`int *pa;` 之间的关系：a是由一种元素组成的数组，pa则是指向这种元素的指针。
所以，如果pa指向a的首元素：
```
int a[5][10];
int (*pa)[10] = &a[0];
```

则`pa[0]` 和`a[0]` 取的是同一个元素，唯一比原来复杂的地方在于这个元素是由10个int组成的数组，而不是基本类型。
这样，我们可以把pa当成二维数组名来使用，`pa[1][2]` 和`a[1][2]` 取的也是同一个元素，而且pa比a用起来更灵活，数组名不支持赋值、自增等运算，
而指针可以支持，pa++使pa跳过二维数组的一行（40个字节），指向`a[1]`的首地址。

或者换个角度想一下，数组的本质就是指针，一维数组 `int a【10】; int *pa = &a[0];`， 数组名做右值时自动转换成指向首元素的指针,
`int *pa = &a[0]; => int *pa = a;`，可以看出pa就是a，`*pa = *a = *(&a[0]) = a[0]`，
取`a[2]`的值有 `a[2] = *(pa + 2) = *(&a[0] + 2) = *(a + 2)`。 
`a[2]` 和 `pa[2]` 本质上是一样的，都是通过指针间接寻址访问元素。

一维数组用指针可以运算，如果二维数组每一行的第1个位置都有指针指向，那二维数组运算起来会方便很多，而这个正是上面说的指向数组的指针，
指针加1就是移到下一行的第1个位置。三维数组也类似。

#### 链表

linkedlist.h
```
/* linkedlist.h */
#ifndef LINKEDLIST_H
#define LINKEDLIST_H

typedef struct node *link;
struct node {
    unsigned char item;
    link next;
};

link make_node(unsigned char item);
void free_node(link p);
link search(unsigned char key);
void insert(link p);
void delete(link p);
void traverse(void (*visit)(link));
void destroy(void);
void push(link p);
link pop(void);

#endif
```

linkedlist.c
```
/* linkedlist.c */
#include <stdlib.h>
#include "linkedlist.h"

static link head = NULL;

link make_node(unsigned char item)
{
	link p = malloc(sizeof *p);
	p->item = item;
	p->next = NULL;
	return p;
}

void free_node(link p)
{
	free(p);
}

link search(unsigned char key)
{
	link p;
	for (p = head; p; p = p->next)
		if (p->item == key)
			return p;
	return NULL;
}

void insert(link p)
{
	p->next = head;
	head = p;
}

void delete(link p)
{
	link pre;
	if (p == head) {
		head = p->next;
		return;
	}
	for (pre = head; pre; pre = pre->next)
		if (pre->next == p) {
			pre->next = p->next;
			return;
		}
}

/* delete方法改进 */
void delete(link p)
{
	link *pnext;
	for (pnext = &head; *pnext; pnext = &(*pnext)->next)
		if (*pnext == p) {
			*pnext = p->next;
			return;
		}
}

void traverse(void (*visit)(link))
{
	link p;
	for (p = head; p; p = p->next)
		visit(p);
}

void destroy(void)
{
	link q, p = head;
	head = NULL;
	while (p) {
		q = p;
		p = p->next;
		free_node(q);
	}
}

void push(link p)
{
	insert(p);
}

link pop(void)
{
	if (head == NULL)
		return NULL;
	else {
		link p = head;
		head = head->next;
		return p;
	}
}
```

main.c
```
/* main.c */
#include <stdio.h>
#include "linkedlist.h"

void print_item(link p)
{
	printf("%d\n", p->item); 
}

int main(void)
{
	link p = make_node(10);
	insert(p);
	p = make_node(5);
	insert(p);
	p = make_node(90);
	insert(p);
	p = search(5);
	delete(p);
	free_node(p);
	traverse(print_item);
	destroy();

	p = make_node(100);
	push(p);
	p = make_node(200);
	push(p);
	p = make_node(250);
	push(p);
	while (p = pop()) {
		print_item(p);
		free_node(p);
	}

	return 0;
}
```

##### 双向链表

doublylinkedlist.h
```
/* doublylinkedlist.h */
#ifndef DOUBLYLINKEDLIST_H
#define DOUBLYLINKEDLIST_H

typedef struct node *link;
struct node {
	unsigned char item;
	link prev, next;
};

link make_node(unsigned char item);
void free_node(link p);
link search(unsigned char key);
void insert(link p);
void delete(link p);
void traverse(void (*visit)(link));
void destroy(void);
void enqueue(link p);
link dequeue(void);

#endif
```

doublylinkedlist.c
```
/* doublylinkedlist.c */
#include <stdlib.h>
#include "doublylinkedlist.h"

struct node tailsentinel;
struct node headsentinel = {0, NULL, &tailsentinel};
struct node tailsentinel = {0, &headsentinel, NULL};

static link head = &headsentinel;
static link tail = &tailsentinel;

link make_node(unsigned char item)
{
	link p = malloc(sizeof *p);
	p->item = item;
	p->prev = p->next = NULL;
	return p;
}

void free_node(link p)
{
	free(p);
}

link search(unsigned char key)
{
	link p;
	for (p = head->next; p != tail; p = p->next)
		if (p->item == key)
			return p;
	return NULL;
}

void insert(link p)
{
	p->next = head->next;
	head->next->prev = p;
	head->next = p;
	p->prev = head;
}

void delete(link p)
{
	p->prev->next = p->next;
	p->next->prev = p->prev;
}

void traverse(void (*visit)(link))
{
	link p;
	for (p = head->next; p != tail; p = p->next)
		visit(p);
}

void destroy(void)
{
	link q, p = head->next;
	head->next = tail;
	tail->prev = head;
	while (p != tail) {
		q = p;
		p = p->next;
		free_node(q);
	}
}

void enqueue(link p)
{
	insert(p);
}

link dequeue(void)
{
	if (tail->prev == head)
		return NULL;
	else {
		link p = tail->prev;
		delete(p);
		return p;
	}
}
```

main.c
```
/* main.c */
#include <stdio.h>
#include "doublylinkedlist.h"

void print_item(link p)
{
	printf("%d\n", p->item); 
}

int main(void)
{
	link p = make_node(10);
	insert(p);
	p = make_node(5);
	insert(p);
	p = make_node(90);
	insert(p);
	p = search(5);
	delete(p);
	free_node(p);
	traverse(print_item);
	destroy();

	p = make_node(100);
	enqueue(p);
	p = make_node(200);
	enqueue(p);
	p = make_node(250);
	enqueue(p);
	while (p = dequeue()) {
		print_item(p);
		free_node(p);
	}

	return 0;
}
```

#### 二叉树

binarytree.h
```
/* binarytree.h */
#ifndef BINARYTREE_H
#define BINARYTREE_H

typedef struct node *link;
struct node {
     unsigned char item;
     link l, r;
};

link init(unsigned char VLR[], unsigned char LVR[], int n);
void pre_order(link t, void (*visit)(link));
void in_order(link t, void (*visit)(link));
void post_order(link t, void (*visit)(link));
int count(link t);
int depth(link t);
void destroy(link t);

#endif
```

binarytree.c
```
/* binarytree.c */
#include <stdlib.h>
#include "binarytree.h"

static link make_node(unsigned char item)
{
	link p = malloc(sizeof *p);
	p->item = item;
	p->l = p->r = NULL;
	return p;
}

static void free_node(link p)
{
	free(p);
}

link init(unsigned char VLR[], unsigned char LVR[], int n)
{
	link t;
	int k;
	if (n <= 0)
		return NULL;
	for (k = 0; VLR[0] != LVR[k]; k++);
	t = make_node(VLR[0]);
	t->l = init(VLR+1, LVR, k);
	t->r = init(VLR+1+k, LVR+1+k, n-k-1);
	return t;
}

void pre_order(link t, void (*visit)(link))
{
	if (!t)
		return;
	visit(t);
	pre_order(t->l, visit);
	pre_order(t->r, visit);
}

void in_order(link t, void (*visit)(link))
{
	if (!t)
		return;
	in_order(t->l, visit);
	visit(t);
	in_order(t->r, visit);
}

void post_order(link t, void (*visit)(link))
{
	if (!t)
		return;
	post_order(t->l, visit);
	post_order(t->r, visit);
	visit(t);
}

int count(link t)
{
	if (!t)
		return 0;
	return 1 + count(t->l) + count(t->r);
}

int depth(link t)
{
	int dl, dr;
	if (!t)
		return 0;
	dl = depth(t->l);
	dr = depth(t->r);
	return 1 + (dl > dr ? dl : dr);
}

void destroy(link t)
{
	post_order(t, free_node);
}
```

main.c
```
/* main.c */
#include <stdio.h>
#include "binarytree.h"

void print_item(link p)
{
	printf("%d", p->item);
}

int main()
{
	unsigned char pre_seq[] = { 4, 2, 1, 3, 6, 5, 7 };
	unsigned char in_seq[] = { 1, 2, 3, 4, 5, 6, 7 };
	link root = init(pre_seq, in_seq, 7);
	pre_order(root, print_item);
	putchar('\n');
	in_order(root, print_item);
	putchar('\n');
	post_order(root, print_item);
	putchar('\n');
	printf("count=%d depth=%d\n", count(root), depth(root));
	destroy(root);
	return 0;
}
```

##### 排序二叉树

排序二叉树（BST，Binary Search Tree）具有这样的性质：对于二叉树中的任意节点，如果它有左子树或右子树，
则该节点的数据成员大于左子树所有节点的数据成员，且小于右子树所有节点的数据成员。

bst.h
```
/* bst.h */
#ifndef BST_H
#define BST_H

typedef struct node *link;
struct node {
     unsigned char item;
     link l, r;
};

link search(link t, unsigned char key);
link insert(link t, unsigned char key);
link delete(link t, unsigned char key);
void print_tree(link t);

#endif
```

bst.c
```
/* bst.c */
#include <stdlib.h>
#include <stdio.h>
#include "bst.h"

static link make_node(unsigned char item)
{
	link p = malloc(sizeof *p);
	p->item = item;
	p->l = p->r = NULL;
	return p;
}

static void free_node(link p)
{
	free(p);
}

link search(link t, unsigned char key)
{
	if (!t)
		return NULL;
	if (t->item > key)
		return search(t->l, key);
	if (t->item < key)
		return search(t->r, key);
	/* if (t->item == key) */
	return t;
}

link insert(link t, unsigned char key)
{
	if (!t)
		return make_node(key);
	if (t->item > key) /* insert to left subtree */
		t->l = insert(t->l, key);
	else /* if (t->item <= key), insert to right subtree */
		t->r = insert(t->r, key);
	return t;
}

link delete(link t, unsigned char key)
{
	link p;
	if (!t)
		return NULL;
	if (t->item > key) /* delete from left subtree */
		t->l = delete(t->l, key);
	else if (t->item < key) /* delete from right subtree */
		t->r = delete(t->r, key);
	else { /* if (t->item == key) */
		if (t->l == NULL && t->r == NULL) { /* if t is leaf node */
			free_node(t);
			t = NULL;
		} else if (t->l) { /* if t has left subtree */
			/* replace t with the rightmost node in left subtree */
			for (p = t->l; p->r; p = p->r);
			t->item = p->item;
			t->l = delete(t->l, t->item);
		} else { /* if t has right subtree */
			/* replace t with the leftmost node in right subtree */
			for (p = t->r; p->l; p = p->l);
			t->item = p->item;
			t->r = delete(t->r, t->item);
		}
	}
	return t;
}

void print_tree(link t)
{
	if (t) {
		printf("(");
		printf("%d", t->item);
		print_tree(t->l);
		print_tree(t->r);
		printf(")");
	} else
		printf("()");
}
```

main.c
```
/* main.c */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "bst.h"

#define RANGE 100
#define N 6

void print_item(link p)
{
	printf("%d", p->item);
}

int main()
{
	int i, key;
	link root = NULL;
	srand(time(NULL));
	for (i = 0; i < N; i++)
		root = insert(root, rand() % RANGE);
	printf("\t\\tree");
	print_tree(root);
	printf("\n\n");
	while (root) {
		key = rand() % RANGE;
		if (search(root, key)) {
			printf("delete %d in tree\n", key);
			root = delete(root, key);
			printf("\t\\tree");
			print_tree(root);
			printf("\n\n");
		}
	}
}
```

<br/><br/><br/><br/><br/>
### 参考资料

Linux C编程一站式学习 <http://akaedu.github.io/book/>

Linux基本操作学习 <http://happypeter.github.io/LGCB/book/index.html>

亚嵌教育 <http://akaedu.github.io/>

你是如何学习 Linux 编程的？ <https://www.zhihu.com/question/20730157?sort=created>

十个最值得阅读学习的C开源项目代码 <https://blog.csdn.net/deeplee021/article/details/40583877>

源码阅读——十个C开源项目 <https://my.oschina.net/zhoukuo/blog/335788>

源码开放学ARM <http://www.lumit.org/>
