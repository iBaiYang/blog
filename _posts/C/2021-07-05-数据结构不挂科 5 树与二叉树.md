---
layout: post
categories: C
title: 数据结构不挂科 5 树与二叉树
meta: 数据结构不挂科 5 树与二叉树
---
* content
{:toc}

## 正文

### 树的基本概念

#### 定义及特点

**树的定义**

树是N(N>=0)个结点的有限集合。

N = 0 时，称为空树

任意一棵非空树中应满足：

(1) 有且仅有一个特定的称为根的结点。

(2) 当 N > 1 时，其余结点可分为m(m>0)个互不相交的有限集合T1，T2，...，Tm，其中每个集合本身又是一棵树，称为根结点的子树

**树的特点**

树是一种递归的数据结构：

(1) 除根结点外的所有结点有且仅有一个前驱结点。

(2) 树中的所有结点可以有零个或多个后继结点。

#### 基本术语

![]({{site.baseurl}}/images/20210720/20210720203544.png)

**祖先结点**与**子孙结点**：根A到结点K的唯一路径上的任意结点，称为结点K的祖先结点。结点B是结点K的祖先结点，结点K是结点B的子孙结点。

**双亲结点**与**孩子结点**：路径上最接近结点K的结点E称为K的双亲结点，K为结点E的孩子结点。

**根**：A是树中唯一没有双亲的结点。

**兄弟结点**：有相同双亲的结点称为兄弟结点，如结点K和结点L。

**结点的度**：树中的一个结点的自结点个数称为该结点的度。

**树的度**：树中结点的最大度称为树的度。

**分支结点**：度大于0的结点称为分支结点。

**叶子结点**：度为0的结点称为叶子结点。

**结点的层次**：从根开始定义，根结点为第一层，它的子结点为第二层，依此类推。

**结点的深度**：从根结点开始自顶向下逐层累加。

**结点的高度**：从叶结点开始自底向上逐层累加。

**树的高度**：树中结点的最大层数。

**有序树**：树中结点的子树从左到右是有次序的，不能交换。

**无序树**：树中结点的子树从左到右没有次序，可以交换。

**路径**：树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的。

**路径长度**：路径上所经过的边的个数。

* 例题5-1  树最适合用来表示（ ）的数据。

A．有序   B．无序   C．任意元素之间具有多种联系。   D．元素之间具有分支层次关系


#### 性质

1. 树中的结点数等于所有结点的度数加1。
2. 度为m的树中第i层上至多有 m^(i-1) 个结点(i >= 1)。
3. 高度为h的m叉树至多有 (m^h - 1)/(m-1) 个结点。
4. 具有n个结点的m叉树的最小高度为 logm(n(m-1)+1) 向上取整。

* 例题5-2   一棵有n个结点的树的所有结点的度数之和为（ ）。

A．n-1   B．n   C．n+1   D．2n

* 例题5-3   树的路径长度是从树根到每个结点的路径长度的（ ）。

A．总和   B．最小值   C．最大值   D．平均值

### 二叉树

#### 基本概念

**二叉树的定义**

两个限制条件：
1. 每个结点至多有两棵树。
2. 子树有左右顺序之分，不能颠倒。

**特殊的二叉树**

满二叉树：棵高度为h，并且含有2^h - 1个结点的二叉树。

![]({{site.baseurl}}/images/20210720/20210720204857.png)

完全二叉树：设一棵高度为h，有n个结点的二叉树，
当且仅当其每一个结点都与高度为h的满二叉树中编号为其1～n的结点一一对应时，称为完全二叉树。

![]({{site.baseurl}}/images/20210720/20210720204945.png)

二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。
定义：一棵空树，或具有如下性质的二叉树：
* 左子树上所有结点的值均小于根结点的值；
* 右子树的所有结点的值均大于根结点的值；

平衡二叉树（Balanced Binary Tree）：树上任一结点的左子树和右子树的深度之差不超过1。

**二叉树的性质**

1. 非空二叉树上叶子结点数等于度为2的结点数加1，即 N0 = N2 + 1。
2. 非空二叉树上第K层上至多有 2^(k-1) 个结点(k >= 1)。
3. 高度为H的二叉树至多有2^H - 1个结点(H >= 1)。
4. 对完全二叉树按从上到下、从左到右的顺序依次编号1，2，...，N，则：
* 当 i > 1 时，结点i的双亲编号为 i/2 下取整
* 当 2i <= N 时，结点i左孩子编号为 2i，否则无左孩子
* 当 2i+1 <= N 时，结点i右孩子编号为 2i+1，否则无右孩子
* 结点i所在层次（深度）为 log2i 下取整+1
5. 具有N个(N>0)结点的完全二叉树高度为 log2(N+1) 上取整或 log2N 下取整+1

* 例题5-4  下列关于二叉树的说法中，正确的是（ ）。

A．度为2的有序树就是二叉树。

B．含有n个结点的二叉树的高度为`[log2n]+1`。

C．在完全二叉树中，若一个结点没有左孩子，则它必是叶结点。

D．在任意一棵非空二叉树排序树中，删除某结点后又将其插入，则所得二叉排序树与删除前原二叉排序树相同。

* 例题5-5  设高度为h的二叉树上只有度为0和度为2的结点，则此类二叉树中所包含的结点数至少为（ ）。

A．h   B．2h-1   C．2h+1   D．h+1

**二叉树的存储结构「顺序存储」**

即用一个数组来存储一棵二叉树。

最适合于完全二叉树和满二叉树，用于存储一般二叉树会浪费大量的存储空间。

**二叉树的存储结构「链式存储」**

即用一个链表来存储一棵二叉树，二叉树中每一个结点用链表的一个链结点来存储。
包含数据域data，左指针域Ichild，右指针域rchild。

链式存储的结构体定义
```
typedef struct BiTnode
{
    ELemType data;
    struct BiTnode *lchild, *rchild;
} BiTnode, *BiTree
```

* 例题5-6   一棵有n个结点的二叉树采用二叉链存储结点，其中空指针数为（ ）。

A．n   B．n+1   C．n-1   D．2n


#### 实体操作

**二叉树的遍历「先序遍历」**

如果二叉树为空，什么也不做，否则：
1. 访问根结点
2. 先序遍历左子树
3. 先序遍历右子树

```
void PreOrder(BiTtree T) {
    if (T != NULL) {
        visit(T);  // 访问根结点
        PreOrder(T->lchild);  // 递归遍历左子树
        PreOrder(T->rchild);  // 递归遍历右子树
    }
}
```

**二叉树的遍历「中序遍历」**

如果二叉树为空，什么也不做，否则：
1. 中序遍历左子树
2. 访问根结点
3. 中序遍历右子树

```
void InOrder(BiTtree T) {
    if (T != NULL) {
        InOrder(T->lchild);  // 递归遍历左子树
        visit(T);  // 访问根结点
        InOrder(T->rchild);  // 递归遍历右子树
    }
}
```

**二叉树的遍历「后序遍历」**

如果二叉树为空，什么也不做，否则：
1. 后序遍历左子树
2. 后序遍历右子树
3. 访问根结点

```
void PostOrder(BiTtree T) {
    if (T != NULL) {
        PostOrder(T->rchild);  // 递归遍历右子树
        PostOrder(T->lchild);  // 递归遍历左子树
        visit(T);  // 访问根结点
    }
}
```

**二叉树的遍历「递归算法和非递归算法的转换」**

可以借助栈，将二叉树的递归遍历算法转换为非递归算法。
1. 扫描（并非访问）根结点的所有左结点，并将它们一一进栈
2. 出栈一个结点*p，则访问它
3. 扫描该结点的右孩子结点，将其进栈
4. 再扫描该右孩子结点的所有左结点并一一进栈
5. 如此继续，直至栈空

```
void InOrder(BiTtree T)
{
    // 二叉树中序遍历的非递归算法，算法需要借助一个栈
    InitStack(S);  // 初始化栈
    BiTtree p = T;  // p是遍历指针
    while (p || !IsEmpty(S))
    {
        if (p) {
            Push(S, p);
            p = p->lchild;
        } else {
            POp(S, p);
            visit(p);
            p = p->rchild;
        }
    }
}
```

**二叉树的遍历「层次遍历」**

按照箭头所指⽅向，按照1、2、3、4的层次顺序，对二叉树中各个结点进⾏访问。

```
void LevelOrder(BiTree T)
{
    InitQueue(Q);
    BiTtree p;
    Enqueue(Q, T);
    while (!IsEmpty(Q)) {
        DeQueue(Q, p);
        visit(p);
        if (p->lchild != NULL) {
            Enqueue(Q, p->lchild);
        }
        if (p->rchild != NULL) {
            Enqueue(Q, p->rchild);
        }
    }
}
```

* 例题5-7

对二叉树的结点从1开始进⾏连续编号，要求每个结点的编号大于其左、右孩子的编号，同一结点的左、右孩子中，
其左孩子的编号小于右孩子的编号，可采用（ ）次序的遍历实现编号。

A．先序遍历   B．中序遍历    C．后序遍历   D．层次遍历

**线索二叉树**

线索二叉树的基本概念

若无左子树，令Ichild指向其前驱结点；
若无右子树，令rchild指向其后继结点。

| ltag | lchild | data | rchild | rtag |

ltag：
```
0 Ichild域指示结点的左孩子
1 Ichild域指示结点的前驱
```

rtag：
```
0 rchild域指示结点的右孩子
1 rchild域指示结点的后继
```

线索二叉树的存储结构

```

```

线索二叉树的构造

对二叉树的线索化，实质上就是遍历一次二叉树。

在遍历过程中，检查当前结点左、右指针域是否为空，若为空，将它们改为指向前驱结点或后继结点的线索。

线索二叉树的遍历

求中序线索二叉树中中序序列下的第一个结点
```

```

求中序线索二叉树中结点p在中序序列下的后继结点
```

```

* 例题5-8  下列序列中，不能唯一地确定一棵二叉树的是（ ）。

A．层次序列和中序序列   B．先序序列和中序序列
C．后序序列和中序序列   D．先序序列和后序序列


#### 具体应用




### 树、森林


### 例题解析

* 解析5-1  D

树是一种分层结构，它特别适合组织那些具有分支层次关系的数据。

* 解析5-2  A

除根结点外，其他每个结点都是某个结点的孩子结点，因此树中所有结点的度数加1等于结点数，所以所有结点的度数之和就等于总结点数减1。

* 解析5-3  A

树的路径长度是所有路径长度的总和，树根到每个结点的路径的最大值应是树的高度-1。

* 解析5-4  C

A.二叉树是有序树，在二叉树中，若某个结点只有一个孩子结点，则这个孩子结点的左右次序是确定的；
⽽在度为2的有序树中，若某个结点只有一个孩子结点，则这个孩子结点就无须区分其左右次序。

B.其仅当为完全二叉树时才有意义，对于任意一棵二叉树，高度可能为`[log2n]+1~n`。

C.根据完全二叉树的定义，在完全二叉树中，若有度为1度结点，则只可能有一个，且该结点只有左孩子无右孩子。

D.在二叉排序树中插入结点时，一定插入在叶结点的位置，故若先删除分支结点再插入，则会导致二叉排序树的重构，其结果就不再相同。

* 解析5-5  B

结点最少的情况如图，除根结点层只有1个结点外，其他h-1层均有两个结点，结点总数=2(h-1)+1=2h-1。

![]({{site.baseurl}}/images/20210720/20210720205725.png)

* 解析5-6  B

非空指针数=总分支数=n-1，空指针数=2×结点总数-非空指针数=2n-(n-1)=n+1。

* 解析5-7  C

对每个顶点从1开始按序编号，要求结点编号大于其左、右孩子编号，并且左孩子编号小于右孩子编号。
编号越大说明遍历顺序越靠后，因此，三者遍历顺序为先左子树再右子树后根结点，4个选项中仅后序遍历满足要求。







<br/><br/><br/><br/><br/>
## 参考资料


