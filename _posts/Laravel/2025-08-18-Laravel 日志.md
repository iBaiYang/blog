---
layout: post
categories: Laravel
title: Laravel 日志
meta: Laravel 日志
---
* content
{:toc}

## 日志服务提供者注册

在 app 项目实例化时就会调用 `registerBaseServiceProviders()` 方法注册日志服务提供者 `$this->register(new \Illuminate\Log\LogServiceProvider($this));`

看下日志服务提供者 Illuminate\Log\LogServiceProvider 的源码：

```php
<?php

namespace Illuminate\Log;

use Illuminate\Support\ServiceProvider;

class LogServiceProvider extends ServiceProvider
{
    /**
     * Register the service provider.
     *
     * @return void
     */
    public function register()
    {
        $this->app->singleton('log', function () {
            return new LogManager($this->app);
        });
    }
}
```

具体服务是 Illuminate\Log\LogManager，为单例。

## 日志服务分析

`app('log')->info('log', [])` 、`Log::info('log', [])`、`logger()->info('log', [])` 三种方式记录日志时会初始化。

配置在 app 目录下的 config/logging.php 中：
```php
<?php

use Monolog\Handler\NullHandler;
use Monolog\Handler\StreamHandler;
use Monolog\Handler\SyslogUdpHandler;

return [

    /*
    |--------------------------------------------------------------------------
    | Default Log Channel
    |--------------------------------------------------------------------------
    |
    | This option defines the default log channel that gets used when writing
    | messages to the logs. The name specified in this option should match
    | one of the channels defined in the "channels" configuration array.
    |
    */

    'default' => env('LOG_CHANNEL', 'stack'),

    /*
    |--------------------------------------------------------------------------
    | Log Channels
    |--------------------------------------------------------------------------
    |
    | Here you may configure the log channels for your application. Out of
    | the box, Laravel uses the Monolog PHP logging library. This gives
    | you a variety of powerful log handlers / formatters to utilize.
    |
    | Available Drivers: "single", "daily", "slack", "syslog",
    |                    "errorlog", "monolog",
    |                    "custom", "stack"
    |
    */

    'channels' => [
        'stack' => [
            'driver' => 'stack',
            'channels' => ['single'],
            'ignore_exceptions' => false,
        ],

        'single' => [
            'driver' => 'single',
            'path' => storage_path('logs/laravel.log'),
            'level' => 'debug',
        ],

        'daily' => [
            'driver' => 'daily',
            'path' => storage_path('logs/laravel.log'),
            'level' => 'debug',
            'days' => 14,
        ],

        'slack' => [
            'driver' => 'slack',
            'url' => env('LOG_SLACK_WEBHOOK_URL'),
            'username' => 'Laravel Log',
            'emoji' => ':boom:',
            'level' => 'critical',
        ],

        'papertrail' => [
            'driver' => 'monolog',
            'level' => 'debug',
            'handler' => SyslogUdpHandler::class,
            'handler_with' => [
                'host' => env('PAPERTRAIL_URL'),
                'port' => env('PAPERTRAIL_PORT'),
            ],
        ],

        'stderr' => [
            'driver' => 'monolog',
            'handler' => StreamHandler::class,
            'formatter' => env('LOG_STDERR_FORMATTER'),
            'with' => [
                'stream' => 'php://stderr',
            ],
        ],

        'syslog' => [
            'driver' => 'syslog',
            'level' => 'debug',
        ],

        'errorlog' => [
            'driver' => 'errorlog',
            'level' => 'debug',
        ],

        'null' => [
            'driver' => 'monolog',
            'handler' => NullHandler::class,
        ],

        'emergency' => [
            'path' => storage_path('logs/laravel.log'),
        ],
    ],

];
```

结合提供的 `LogManager`、`Logger` 类和配置文件，看一下记录日志过程：

**1. 日志调用入口**

当使用 `Log::info('Message')` 或 `logger()->info('Message')` 时：

- `Log` Facade 代理到 `LogManager` 实例。
- `LogManager` 实现了 `Psr\Log\LoggerInterface`，调用其方法（如 `info()`）会触发 `__call` 魔术方法：

```php
public function __call($method, $parameters) {
    return $this->driver()->$method(...$parameters);
}

public function info($message, array $context = [])
{
    $this->driver()->info($message, $context);
}
```

**2. 获取日志驱动（Driver）**

- `driver()` 方法获取默认驱动（由 `config/logging.php` 的 `default` 定义，如 `'stack'`）：

```php
public function driver($driver = null)
{
    return $this->get($driver ?? $this->getDefaultDriver());
}
```

- `get()` 方法解析通道：
  - 优先从缓存 `$channels` 中获取。
  - 不存在时通过 `resolve($name)` 创建并缓存。

```php
protected function get($name)
{
    try {
        return $this->channels[$name] ?? with($this->resolve($name), function ($logger) use ($name) {
            return $this->channels[$name] = $this->tap($name, new Logger($logger, $this->app['events']));
        });
    } catch (Throwable $e) {
        return tap($this->createEmergencyLogger(), function ($logger) use ($e) {
            $logger->emergency('Unable to create configured logger. Using emergency logger.', [
                'exception' => $e,
            ]);
        });
    }
}
```

**3. 解析日志通道（Resolve Channel）**

`resolve($name)` 根据配置创建 Monolog 实例：

1. 读取配置：`$config = $this->configurationFor($name);`（从 `config/logging.channels.$name` 获取）。
2. 选择驱动创建方式：
   - 自定义驱动：通过 `extend()` 注册的闭包（`$customCreators`）。
   - 内置驱动：调用形如 `create{Driver}Driver` 的方法（如 `createStackDriver`）。
   - Monolog 驱动：使用 `createMonologDriver` 实例化第三方处理器。

```php
protected function configurationFor($name)
{
    return $this->app['config']["logging.channels.{$name}"];
}

public function extend($driver, Closure $callback)
{
    $this->customCreators[$driver] = $callback->bindTo($this, $this);

    return $this;
}

protected function resolve($name)
{
    $config = $this->configurationFor($name);

    if (is_null($config)) {
        throw new InvalidArgumentException("Log [{$name}] is not defined.");
    }

    if (isset($this->customCreators[$config['driver']])) {
        return $this->callCustomCreator($config);
    }

    $driverMethod = 'create'.ucfirst($config['driver']).'Driver';

    if (method_exists($this, $driverMethod)) {
        return $this->{$driverMethod}($config);
    }

    throw new InvalidArgumentException("Driver [{$config['driver']}] is not supported.");
}
```

**4. 创建驱动实例（关键步骤）**

示例：`stack` 驱动

```php
protected function createStackDriver(array $config) {
    // 收集子通道的处理器
    $handlers = collect($config['channels'])->flatMap(function ($channel) {
        return $this->channel($channel)->getHandlers();
    })->all();

    // 忽略异常时用 WhatFailureGroupHandler 包装
    if ($config['ignore_exceptions'] ?? false) {
        $handlers = [new WhatFailureGroupHandler($handlers)];
    }

    return new Monolog($this->parseChannel($config), $handlers);
}

public function channel($channel = null)
{
    return $this->driver($channel);
}

protected function createSingleDriver(array $config)
{
    return new Monolog($this->parseChannel($config), [
        $this->prepareHandler(
            new StreamHandler(
                $config['path'], $this->level($config),
                $config['bubble'] ?? true, $config['permission'] ?? null, $config['locking'] ?? false
            ), $config
        ),
    ]);
}

protected function createMonologDriver(array $config)
{
    if (! is_a($config['handler'], HandlerInterface::class, true)) {
        throw new InvalidArgumentException(
            $config['handler'].' must be an instance of '.HandlerInterface::class
        );
    }

    $with = array_merge(
        ['level' => $this->level($config)],
        $config['with'] ?? [],
        $config['handler_with'] ?? []
    );

    return new Monolog($this->parseChannel($config), [$this->prepareHandler(
        $this->app->make($config['handler'], $with), $config
    )]);
}
```

- 递归解析子通道（如 `single`）：
  - `single` 驱动调用 `createSingleDriver`，创建 `StreamHandler` 写入文件。
  - 最终返回包含处理器的 `Monolog` 实例。

其他驱动创建
- `single`：单文件日志（`StreamHandler`）。
- `daily`：按日期轮转（`RotatingFileHandler`）。
- `slack`：发送到 Slack（`SlackWebhookHandler`）。
- `monolog`：自定义 Monolog 处理器（如 `SyslogUdpHandler`）。

**5. 包装为 Laravel Logger**

- 将 Monolog 实例包装到 `Illuminate\Log\Logger`：

```php
protected function get($name) {
    return $this->channels[$name] = $this->tap($name, new Logger($logger, $this->app['events']));
}

protected function tap($name, Logger $logger)
{
    foreach ($this->configurationFor($name)['tap'] ?? [] as $tap) {
        [$class, $arguments] = $this->parseTap($tap);

        $this->app->make($class)->__invoke($logger, ...explode(',', $arguments));
    }

    return $logger;
}
```

- `tap()` 方法应用配置中的 `tap` 管道（可添加自定义处理逻辑）。

**6. 记录日志流程**

当调用 `$logger->info('Message', $context)`：

1、格式化消息：

```php
protected function formatMessage($message) {
    if (is_array($message)) return var_export($message, true);
    if ($message instanceof Jsonable) return $message->toJson();
    if ($message instanceof Arrayable) return var_export($message->toArray(), true);
    return $message;
}
```

2、触发事件：

```php
protected function writeLog($level, $message, $context) {
    $this->fireLogEvent($level, $message, $context); // 分发 MessageLogged 事件
    $this->logger->{$level}($message, $context); // 调用 Monolog 的方法
}
```

3、Monolog 处理：

- 调用处理器链（如 `StreamHandler->handle()`）。
- 处理器使用 `LineFormatter` 格式化日志（默认包含堆栈跟踪）。
- 写入目标（文件/Slack/系统日志等）。

**7. 异常处理**

- 创建应急日志：当解析配置失败时，调用 `createEmergencyLogger()`：

```php
protected function get($name) {
    try { /* ... */ } catch (Throwable $e) {
        return tap($this->createEmergencyLogger(), function ($logger) use ($e) {
            $logger->emergency('Unable to create configured logger.', ['exception' => $e]);
        });
    }
}
```

- 使用默认文件路径（`storage/logs/laravel.log`）确保日志不丢失。

**关键设计亮点**

1. 灵活驱动：内置多种驱动（文件/Slack/Syslog），支持自定义扩展。
2. 通道堆叠：通过 `stack` 驱动组合多个日志渠道。
3. 事件挂钩：记录时触发 `MessageLogged` 事件，便于监听。
4. 异常回退：自动降级到应急日志，避免系统崩溃。
5. PSR-3 兼容：实现标准接口，确保与其他组件兼容。

整个过程体现了 Laravel 日志系统的模块化设计，通过解耦日志管理、通道解析、处理器封装，提供了高扩展性和可靠性。

## 源码

### LogServiceProvider 类

Illuminate\Log\LogServiceProvider 源码：

```php
<?php

namespace Illuminate\Log;

use Illuminate\Support\ServiceProvider;

class LogServiceProvider extends ServiceProvider
{
    /**
     * Register the service provider.
     *
     * @return void
     */
    public function register()
    {
        $this->app->singleton('log', function () {
            return new LogManager($this->app);
        });
    }
}
```

### LogManager 类

Illuminate\Log\LogManager 源码：

```php
<?php

namespace Illuminate\Log;

use Closure;
use Illuminate\Support\Str;
use InvalidArgumentException;
use Monolog\Formatter\LineFormatter;
use Monolog\Handler\ErrorLogHandler;
use Monolog\Handler\FormattableHandlerInterface;
use Monolog\Handler\HandlerInterface;
use Monolog\Handler\RotatingFileHandler;
use Monolog\Handler\SlackWebhookHandler;
use Monolog\Handler\StreamHandler;
use Monolog\Handler\SyslogHandler;
use Monolog\Handler\WhatFailureGroupHandler;
use Monolog\Logger as Monolog;
use Psr\Log\LoggerInterface;
use Throwable;

class LogManager implements LoggerInterface
{
    use ParsesLogConfiguration;

    /**
     * The application instance.
     *
     * @var \Illuminate\Contracts\Foundation\Application
     */
    protected $app;

    /**
     * The array of resolved channels.
     *
     * @var array
     */
    protected $channels = [];

    /**
     * The registered custom driver creators.
     *
     * @var array
     */
    protected $customCreators = [];

    /**
     * The standard date format to use when writing logs.
     *
     * @var string
     */
    protected $dateFormat = 'Y-m-d H:i:s';

    /**
     * Create a new Log manager instance.
     *
     * @param  \Illuminate\Contracts\Foundation\Application  $app
     * @return void
     */
    public function __construct($app)
    {
        $this->app = $app;
    }

    /**
     * Create a new, on-demand aggregate logger instance.
     *
     * @param  array  $channels
     * @param  string|null  $channel
     * @return \Psr\Log\LoggerInterface
     */
    public function stack(array $channels, $channel = null)
    {
        return new Logger(
            $this->createStackDriver(compact('channels', 'channel')),
            $this->app['events']
        );
    }

    /**
     * Get a log channel instance.
     *
     * @param  string|null  $channel
     * @return \Psr\Log\LoggerInterface
     */
    public function channel($channel = null)
    {
        return $this->driver($channel);
    }

    /**
     * Get a log driver instance.
     *
     * @param  string|null  $driver
     * @return \Psr\Log\LoggerInterface
     */
    public function driver($driver = null)
    {
        return $this->get($driver ?? $this->getDefaultDriver());
    }

    /**
     * @return array
     */
    public function getChannels()
    {
        return $this->channels;
    }

    /**
     * Attempt to get the log from the local cache.
     *
     * @param  string  $name
     * @return \Psr\Log\LoggerInterface
     */
    protected function get($name)
    {
        try {
            return $this->channels[$name] ?? with($this->resolve($name), function ($logger) use ($name) {
                return $this->channels[$name] = $this->tap($name, new Logger($logger, $this->app['events']));
            });
        } catch (Throwable $e) {
            return tap($this->createEmergencyLogger(), function ($logger) use ($e) {
                $logger->emergency('Unable to create configured logger. Using emergency logger.', [
                    'exception' => $e,
                ]);
            });
        }
    }

    /**
     * Apply the configured taps for the logger.
     *
     * @param  string  $name
     * @param  \Illuminate\Log\Logger  $logger
     * @return \Illuminate\Log\Logger
     */
    protected function tap($name, Logger $logger)
    {
        foreach ($this->configurationFor($name)['tap'] ?? [] as $tap) {
            [$class, $arguments] = $this->parseTap($tap);

            $this->app->make($class)->__invoke($logger, ...explode(',', $arguments));
        }

        return $logger;
    }

    /**
     * Parse the given tap class string into a class name and arguments string.
     *
     * @param  string  $tap
     * @return array
     */
    protected function parseTap($tap)
    {
        return Str::contains($tap, ':') ? explode(':', $tap, 2) : [$tap, ''];
    }

    /**
     * Create an emergency log handler to avoid white screens of death.
     *
     * @return \Psr\Log\LoggerInterface
     */
    protected function createEmergencyLogger()
    {
        $config = $this->configurationFor('emergency');

        $handler = new StreamHandler(
            $config['path'] ?? $this->app->storagePath().'/logs/laravel.log',
            $this->level(['level' => 'debug'])
        );

        return new Logger(
            new Monolog('laravel', $this->prepareHandlers([$handler])),
            $this->app['events']
        );
    }

    /**
     * Resolve the given log instance by name.
     *
     * @param  string  $name
     * @return \Psr\Log\LoggerInterface
     *
     * @throws \InvalidArgumentException
     */
    protected function resolve($name)
    {
        $config = $this->configurationFor($name);

        if (is_null($config)) {
            throw new InvalidArgumentException("Log [{$name}] is not defined.");
        }

        if (isset($this->customCreators[$config['driver']])) {
            return $this->callCustomCreator($config);
        }

        $driverMethod = 'create'.ucfirst($config['driver']).'Driver';

        if (method_exists($this, $driverMethod)) {
            return $this->{$driverMethod}($config);
        }

        throw new InvalidArgumentException("Driver [{$config['driver']}] is not supported.");
    }

    /**
     * Call a custom driver creator.
     *
     * @param  array  $config
     * @return mixed
     */
    protected function callCustomCreator(array $config)
    {
        return $this->customCreators[$config['driver']]($this->app, $config);
    }

    /**
     * Create a custom log driver instance.
     *
     * @param  array  $config
     * @return \Psr\Log\LoggerInterface
     */
    protected function createCustomDriver(array $config)
    {
        $factory = is_callable($via = $config['via']) ? $via : $this->app->make($via);

        return $factory($config);
    }

    /**
     * Create an aggregate log driver instance.
     *
     * @param  array  $config
     * @return \Psr\Log\LoggerInterface
     */
    protected function createStackDriver(array $config)
    {
        $handlers = collect($config['channels'])->flatMap(function ($channel) {
            return $this->channel($channel)->getHandlers();
        })->all();

        if ($config['ignore_exceptions'] ?? false) {
            $handlers = [new WhatFailureGroupHandler($handlers)];
        }

        return new Monolog($this->parseChannel($config), $handlers);
    }

    /**
     * Create an instance of the single file log driver.
     *
     * @param  array  $config
     * @return \Psr\Log\LoggerInterface
     */
    protected function createSingleDriver(array $config)
    {
        return new Monolog($this->parseChannel($config), [
            $this->prepareHandler(
                new StreamHandler(
                    $config['path'], $this->level($config),
                    $config['bubble'] ?? true, $config['permission'] ?? null, $config['locking'] ?? false
                ), $config
            ),
        ]);
    }

    /**
     * Create an instance of the daily file log driver.
     *
     * @param  array  $config
     * @return \Psr\Log\LoggerInterface
     */
    protected function createDailyDriver(array $config)
    {
        return new Monolog($this->parseChannel($config), [
            $this->prepareHandler(new RotatingFileHandler(
                $config['path'], $config['days'] ?? 7, $this->level($config),
                $config['bubble'] ?? true, $config['permission'] ?? null, $config['locking'] ?? false
            ), $config),
        ]);
    }

    /**
     * Create an instance of the Slack log driver.
     *
     * @param  array  $config
     * @return \Psr\Log\LoggerInterface
     */
    protected function createSlackDriver(array $config)
    {
        return new Monolog($this->parseChannel($config), [
            $this->prepareHandler(new SlackWebhookHandler(
                $config['url'],
                $config['channel'] ?? null,
                $config['username'] ?? 'Laravel',
                $config['attachment'] ?? true,
                $config['emoji'] ?? ':boom:',
                $config['short'] ?? false,
                $config['context'] ?? true,
                $this->level($config),
                $config['bubble'] ?? true,
                $config['exclude_fields'] ?? []
            ), $config),
        ]);
    }

    /**
     * Create an instance of the syslog log driver.
     *
     * @param  array  $config
     * @return \Psr\Log\LoggerInterface
     */
    protected function createSyslogDriver(array $config)
    {
        return new Monolog($this->parseChannel($config), [
            $this->prepareHandler(new SyslogHandler(
                Str::snake($this->app['config']['app.name'], '-'),
                $config['facility'] ?? LOG_USER, $this->level($config)
            ), $config),
        ]);
    }

    /**
     * Create an instance of the "error log" log driver.
     *
     * @param  array  $config
     * @return \Psr\Log\LoggerInterface
     */
    protected function createErrorlogDriver(array $config)
    {
        return new Monolog($this->parseChannel($config), [
            $this->prepareHandler(new ErrorLogHandler(
                $config['type'] ?? ErrorLogHandler::OPERATING_SYSTEM, $this->level($config)
            )),
        ]);
    }

    /**
     * Create an instance of any handler available in Monolog.
     *
     * @param  array  $config
     * @return \Psr\Log\LoggerInterface
     *
     * @throws \InvalidArgumentException
     * @throws \Illuminate\Contracts\Container\BindingResolutionException
     */
    protected function createMonologDriver(array $config)
    {
        if (! is_a($config['handler'], HandlerInterface::class, true)) {
            throw new InvalidArgumentException(
                $config['handler'].' must be an instance of '.HandlerInterface::class
            );
        }

        $with = array_merge(
            ['level' => $this->level($config)],
            $config['with'] ?? [],
            $config['handler_with'] ?? []
        );

        return new Monolog($this->parseChannel($config), [$this->prepareHandler(
            $this->app->make($config['handler'], $with), $config
        )]);
    }

    /**
     * Prepare the handlers for usage by Monolog.
     *
     * @param  array  $handlers
     * @return array
     */
    protected function prepareHandlers(array $handlers)
    {
        foreach ($handlers as $key => $handler) {
            $handlers[$key] = $this->prepareHandler($handler);
        }

        return $handlers;
    }

    /**
     * Prepare the handler for usage by Monolog.
     *
     * @param  \Monolog\Handler\HandlerInterface  $handler
     * @param  array  $config
     * @return \Monolog\Handler\HandlerInterface
     */
    protected function prepareHandler(HandlerInterface $handler, array $config = [])
    {
        $isHandlerFormattable = false;

        if (Monolog::API === 1) {
            $isHandlerFormattable = true;
        } elseif (Monolog::API === 2 && $handler instanceof FormattableHandlerInterface) {
            $isHandlerFormattable = true;
        }

        if ($isHandlerFormattable && ! isset($config['formatter'])) {
            $handler->setFormatter($this->formatter());
        } elseif ($isHandlerFormattable && $config['formatter'] !== 'default') {
            $handler->setFormatter($this->app->make($config['formatter'], $config['formatter_with'] ?? []));
        }

        return $handler;
    }

    /**
     * Get a Monolog formatter instance.
     *
     * @return \Monolog\Formatter\FormatterInterface
     */
    protected function formatter()
    {
        return tap(new LineFormatter(null, $this->dateFormat, true, true), function ($formatter) {
            $formatter->includeStacktraces();
        });
    }

    /**
     * Get fallback log channel name.
     *
     * @return string
     */
    protected function getFallbackChannelName()
    {
        return $this->app->bound('env') ? $this->app->environment() : 'production';
    }

    /**
     * Get the log connection configuration.
     *
     * @param  string  $name
     * @return array
     */
    protected function configurationFor($name)
    {
        return $this->app['config']["logging.channels.{$name}"];
    }

    /**
     * Get the default log driver name.
     *
     * @return string
     */
    public function getDefaultDriver()
    {
        return $this->app['config']['logging.default'];
    }

    /**
     * Set the default log driver name.
     *
     * @param  string  $name
     * @return void
     */
    public function setDefaultDriver($name)
    {
        $this->app['config']['logging.default'] = $name;
    }

    /**
     * Register a custom driver creator Closure.
     *
     * @param  string  $driver
     * @param  \Closure  $callback
     * @return $this
     */
    public function extend($driver, Closure $callback)
    {
        $this->customCreators[$driver] = $callback->bindTo($this, $this);

        return $this;
    }

    /**
     * Unset the given channel instance.
     *
     * @param  string|null  $driver
     * @return $this
     */
    public function forgetChannel($driver = null)
    {
        $driver = $driver ?? $this->getDefaultDriver();

        if (isset($this->channels[$driver])) {
            unset($this->channels[$driver]);
        }
    }

    /**
     * System is unusable.
     *
     * @param  string  $message
     * @param  array  $context
     * @return void
     */
    public function emergency($message, array $context = [])
    {
        $this->driver()->emergency($message, $context);
    }

    /**
     * Action must be taken immediately.
     *
     * Example: Entire website down, database unavailable, etc. This should
     * trigger the SMS alerts and wake you up.
     *
     * @param  string  $message
     * @param  array  $context
     * @return void
     */
    public function alert($message, array $context = [])
    {
        $this->driver()->alert($message, $context);
    }

    /**
     * Critical conditions.
     *
     * Example: Application component unavailable, unexpected exception.
     *
     * @param  string  $message
     * @param  array  $context
     * @return void
     */
    public function critical($message, array $context = [])
    {
        $this->driver()->critical($message, $context);
    }

    /**
     * Runtime errors that do not require immediate action but should typically
     * be logged and monitored.
     *
     * @param  string  $message
     * @param  array  $context
     * @return void
     */
    public function error($message, array $context = [])
    {
        $this->driver()->error($message, $context);
    }

    /**
     * Exceptional occurrences that are not errors.
     *
     * Example: Use of deprecated APIs, poor use of an API, undesirable things
     * that are not necessarily wrong.
     *
     * @param  string  $message
     * @param  array  $context
     * @return void
     */
    public function warning($message, array $context = [])
    {
        $this->driver()->warning($message, $context);
    }

    /**
     * Normal but significant events.
     *
     * @param  string  $message
     * @param  array  $context
     * @return void
     */
    public function notice($message, array $context = [])
    {
        $this->driver()->notice($message, $context);
    }

    /**
     * Interesting events.
     *
     * Example: User logs in, SQL logs.
     *
     * @param  string  $message
     * @param  array  $context
     * @return void
     */
    public function info($message, array $context = [])
    {
        $this->driver()->info($message, $context);
    }

    /**
     * Detailed debug information.
     *
     * @param  string  $message
     * @param  array  $context
     * @return void
     */
    public function debug($message, array $context = [])
    {
        $this->driver()->debug($message, $context);
    }

    /**
     * Logs with an arbitrary level.
     *
     * @param  mixed  $level
     * @param  string  $message
     * @param  array  $context
     * @return void
     */
    public function log($level, $message, array $context = [])
    {
        $this->driver()->log($level, $message, $context);
    }

    /**
     * Dynamically call the default driver instance.
     *
     * @param  string  $method
     * @param  array  $parameters
     * @return mixed
     */
    public function __call($method, $parameters)
    {
        return $this->driver()->$method(...$parameters);
    }
}
```

### ParsesLogConfiguration 类

Illuminate\Log\ParsesLogConfiguration 源码：

```php
<?php

namespace Illuminate\Log;

use InvalidArgumentException;
use Monolog\Logger as Monolog;

trait ParsesLogConfiguration
{
    /**
     * The Log levels.
     *
     * @var array
     */
    protected $levels = [
        'debug' => Monolog::DEBUG,
        'info' => Monolog::INFO,
        'notice' => Monolog::NOTICE,
        'warning' => Monolog::WARNING,
        'error' => Monolog::ERROR,
        'critical' => Monolog::CRITICAL,
        'alert' => Monolog::ALERT,
        'emergency' => Monolog::EMERGENCY,
    ];

    /**
     * Get fallback log channel name.
     *
     * @return string
     */
    abstract protected function getFallbackChannelName();

    /**
     * Parse the string level into a Monolog constant.
     *
     * @param  array  $config
     * @return int
     *
     * @throws \InvalidArgumentException
     */
    protected function level(array $config)
    {
        $level = $config['level'] ?? 'debug';

        if (isset($this->levels[$level])) {
            return $this->levels[$level];
        }

        throw new InvalidArgumentException('Invalid log level.');
    }

    /**
     * Extract the log channel from the given configuration.
     *
     * @param  array  $config
     * @return string
     */
    protected function parseChannel(array $config)
    {
        return $config['name'] ?? $this->getFallbackChannelName();
    }
}
```

### Logger 类

Illuminate\Log\Logger 源码：

```php
<?php

namespace Illuminate\Log;

use Closure;
use Illuminate\Contracts\Events\Dispatcher;
use Illuminate\Contracts\Support\Arrayable;
use Illuminate\Contracts\Support\Jsonable;
use Illuminate\Log\Events\MessageLogged;
use Psr\Log\LoggerInterface;
use RuntimeException;

class Logger implements LoggerInterface
{
    /**
     * The underlying logger implementation.
     *
     * @var \Psr\Log\LoggerInterface
     */
    protected $logger;

    /**
     * The event dispatcher instance.
     *
     * @var \Illuminate\Contracts\Events\Dispatcher|null
     */
    protected $dispatcher;

    /**
     * Create a new log writer instance.
     *
     * @param  \Psr\Log\LoggerInterface  $logger
     * @param  \Illuminate\Contracts\Events\Dispatcher|null  $dispatcher
     * @return void
     */
    public function __construct(LoggerInterface $logger, Dispatcher $dispatcher = null)
    {
        $this->logger = $logger;
        $this->dispatcher = $dispatcher;
    }

    /**
     * Log an emergency message to the logs.
     *
     * @param  string  $message
     * @param  array  $context
     * @return void
     */
    public function emergency($message, array $context = [])
    {
        $this->writeLog(__FUNCTION__, $message, $context);
    }

    /**
     * Log an alert message to the logs.
     *
     * @param  string  $message
     * @param  array  $context
     * @return void
     */
    public function alert($message, array $context = [])
    {
        $this->writeLog(__FUNCTION__, $message, $context);
    }

    /**
     * Log a critical message to the logs.
     *
     * @param  string  $message
     * @param  array  $context
     * @return void
     */
    public function critical($message, array $context = [])
    {
        $this->writeLog(__FUNCTION__, $message, $context);
    }

    /**
     * Log an error message to the logs.
     *
     * @param  string  $message
     * @param  array  $context
     * @return void
     */
    public function error($message, array $context = [])
    {
        $this->writeLog(__FUNCTION__, $message, $context);
    }

    /**
     * Log a warning message to the logs.
     *
     * @param  string  $message
     * @param  array  $context
     * @return void
     */
    public function warning($message, array $context = [])
    {
        $this->writeLog(__FUNCTION__, $message, $context);
    }

    /**
     * Log a notice to the logs.
     *
     * @param  string  $message
     * @param  array  $context
     * @return void
     */
    public function notice($message, array $context = [])
    {
        $this->writeLog(__FUNCTION__, $message, $context);
    }

    /**
     * Log an informational message to the logs.
     *
     * @param  string  $message
     * @param  array  $context
     * @return void
     */
    public function info($message, array $context = [])
    {
        $this->writeLog(__FUNCTION__, $message, $context);
    }

    /**
     * Log a debug message to the logs.
     *
     * @param  string  $message
     * @param  array  $context
     * @return void
     */
    public function debug($message, array $context = [])
    {
        $this->writeLog(__FUNCTION__, $message, $context);
    }

    /**
     * Log a message to the logs.
     *
     * @param  string  $level
     * @param  string  $message
     * @param  array  $context
     * @return void
     */
    public function log($level, $message, array $context = [])
    {
        $this->writeLog($level, $message, $context);
    }

    /**
     * Dynamically pass log calls into the writer.
     *
     * @param  string  $level
     * @param  string  $message
     * @param  array  $context
     * @return void
     */
    public function write($level, $message, array $context = [])
    {
        $this->writeLog($level, $message, $context);
    }

    /**
     * Write a message to the log.
     *
     * @param  string  $level
     * @param  string  $message
     * @param  array  $context
     * @return void
     */
    protected function writeLog($level, $message, $context)
    {
        $this->fireLogEvent($level, $message = $this->formatMessage($message), $context);

        $this->logger->{$level}($message, $context);
    }

    /**
     * Register a new callback handler for when a log event is triggered.
     *
     * @param  \Closure  $callback
     * @return void
     *
     * @throws \RuntimeException
     */
    public function listen(Closure $callback)
    {
        if (! isset($this->dispatcher)) {
            throw new RuntimeException('Events dispatcher has not been set.');
        }

        $this->dispatcher->listen(MessageLogged::class, $callback);
    }

    /**
     * Fires a log event.
     *
     * @param  string  $level
     * @param  string  $message
     * @param  array  $context
     * @return void
     */
    protected function fireLogEvent($level, $message, array $context = [])
    {
        // If the event dispatcher is set, we will pass along the parameters to the
        // log listeners. These are useful for building profilers or other tools
        // that aggregate all of the log messages for a given "request" cycle.
        if (isset($this->dispatcher)) {
            $this->dispatcher->dispatch(new MessageLogged($level, $message, $context));
        }
    }

    /**
     * Format the parameters for the logger.
     *
     * @param  mixed  $message
     * @return mixed
     */
    protected function formatMessage($message)
    {
        if (is_array($message)) {
            return var_export($message, true);
        } elseif ($message instanceof Jsonable) {
            return $message->toJson();
        } elseif ($message instanceof Arrayable) {
            return var_export($message->toArray(), true);
        }

        return $message;
    }

    /**
     * Get the underlying logger implementation.
     *
     * @return \Psr\Log\LoggerInterface
     */
    public function getLogger()
    {
        return $this->logger;
    }

    /**
     * Get the event dispatcher instance.
     *
     * @return \Illuminate\Contracts\Events\Dispatcher
     */
    public function getEventDispatcher()
    {
        return $this->dispatcher;
    }

    /**
     * Set the event dispatcher instance.
     *
     * @param  \Illuminate\Contracts\Events\Dispatcher  $dispatcher
     * @return void
     */
    public function setEventDispatcher(Dispatcher $dispatcher)
    {
        $this->dispatcher = $dispatcher;
    }

    /**
     * Dynamically proxy method calls to the underlying logger.
     *
     * @param  string  $method
     * @param  array  $parameters
     * @return mixed
     */
    public function __call($method, $parameters)
    {
        return $this->logger->{$method}(...$parameters);
    }
}
```

### MessageLogged 类

Illuminate\Log\Events\MessageLogged 源码：

```php
<?php

namespace Illuminate\Log\Events;

class MessageLogged
{
    /**
     * The log "level".
     *
     * @var string
     */
    public $level;

    /**
     * The log message.
     *
     * @var string
     */
    public $message;

    /**
     * The log context.
     *
     * @var array
     */
    public $context;

    /**
     * Create a new event instance.
     *
     * @param  string  $level
     * @param  string  $message
     * @param  array  $context
     * @return void
     */
    public function __construct($level, $message, array $context = [])
    {
        $this->level = $level;
        $this->message = $message;
        $this->context = $context;
    }
}
```

## 自定义日志一

laravel中默认的一个日志驱动是single，所有日志信息都保存在`logs/laravel.log`一个文件中，我们需要把error错误日志写到另一个独立的文件中，这样才能对错误信息一目了然。

下面写一下。一个把错误日志写入文件`logs/laravel-error_one.log`的第一种示例，其中包括日志ID、日志步骤、用户ID、请求URL、请求方法、请求参数、响应状态码、响应数据、异常信息、异常位置、请求时间等。


日志处理器文件：

```php
<?php

namespace App\Logging\Handlers;

use Monolog\Handler\AbstractProcessingHandler;
use Monolog\Logger;
use Monolog\Formatter\LineFormatter;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\File;

class ErrorLogOneHandler extends AbstractProcessingHandler
{
    /**
     * 日志文件路径
     *
     * @var string
     */
    protected $logPath;

    /**
     * 文件权限
     *
     * @var int|null
     */
    protected $filePermission;

    /**
     * 是否使用文件锁
     *
     * @var bool
     */
    protected $useLocking;

    /**
     * 文件句柄
     *
     * @var resource|null
     */
    protected $fileHandle;

    /**
     * 构造函数
     *
     * @param string $logPath 日志文件路径
     * @param int $level 日志级别
     * @param bool $bubble 是否向上传播
     * @param int|null $filePermission 文件权限
     * @param bool $useLocking 是否使用文件锁
     */
    public function __construct(
        $logPath,
        $level = Logger::ERROR,
        $bubble = true,
        $filePermission = null,
        $useLocking = false
    ) {
        parent::__construct($level, $bubble);

        $this->logPath = $logPath;
        $this->filePermission = $filePermission;
        $this->useLocking = $useLocking;

        // 确保日志目录存在
        $logDir = dirname($logPath);
        if (!File::exists($logDir)) {
            File::makeDirectory($logDir, 0755, true);
        }

        // 设置格式化器
        // $this->setFormatter(new LineFormatter(
        //     "[%datetime%] %channel%.%level_name%: %message% %context% %extra%\n",
        //     null,
        //     true,
        //     true
        // ));

        // 格式化器配置
        $this->setFormatter(new LineFormatter(
            "[%datetime%] %channel%.%level_name% %context% %extra%\n", // 移除冒号和%message%
            "Y-m-d H:i:s", // 设置日期格式
            true,
            true
        ));
    }

    /**
     * 写入日志记录
     *
     * @param array $record
     */
    protected function write(array $record): void
    {
        global $log_id;
        global $log_step;

        // 添加用户 ID 到日志上下文
        $content = [
            'log_id' => $log_id,
            'log_step' => $log_step++,
            'user_id' => $this->getUserId(),
            'log_msg' => $record['message'],
            'request_url' => $this->getRequestUrl(),
            'request_method' => $this->getRequestMethod(),
            'request_params' => $this->getRequestParams(),
            'response_status' => $record['context']['code'] ?? 'N/A',
            'response_data' => $this->formatResponseData($record['context']['responent'] ?? []),
            'exception_message' => $this->getExceptionMessage($record),
            'exception_location' => $this->getExceptionLocation($record),
            'request_time' => date('Y-m-d H:i:s'),
        ];
        $record['context'] = array_merge($content, $record['context']);


        // 格式化日志记录
        $formatted = $this->getFormatter()->format($record);

        // 写入文件
        $this->writeToFile($formatted);
    }

    /**
     * 获取当前用户 ID
     *
     * @return string|int
     */
    protected function getUserId()
    {
        try {
            // 尝试获取认证用户 ID
            // if (Auth::check()) {
            //     return Auth::id();
            // }
            if (!empty(session()->get('admin_id'))) {
                return session()->get('admin_id');
            }

            // 如果是命令行环境，尝试获取当前系统用户
            if (app()->runningInConsole()) {
                return get_current_user() ?: 'console';
            }

            // 如果无法获取用户 ID，返回未知
            return 'unknown';
        } catch (\Exception $e) {
            // 防止因获取用户信息失败导致日志记录失败
            return 'error_getting_user';
        }
    }

    /**
     * 获取请求URL
     */
    protected function getRequestUrl()
    {
        if (app()->runningInConsole()) {
            return 'console';
        }
        return request() ? request()->fullUrl() : 'N/A';
    }

    /**
     * 获取请求方法
     */
    protected function getRequestMethod()
    {
        if (app()->runningInConsole()) {
            return 'console';
        }
        return request() ? request()->method() : 'N/A';
    }

    /**
     * 获取请求参数（过滤敏感信息）
     */
    protected function getRequestParams()
    {
        if (app()->runningInConsole() || !request()) {
            return [];
        }

        $params = request()->all();
        // 过滤敏感字段
        $sensitive = ['password', 'token', 'secret', '_token'];
        foreach ($sensitive as $key) {
            if (isset($params[$key])) {
                $params[$key] = '***';
            }
        }
        return json_encode($params, JSON_UNESCAPED_UNICODE);
    }

    /**
     * 格式化响应数据
     */
    protected function formatResponseData($data)
    {
        if (empty($data)) {
            return 'N/A';
        }
        // 限制响应数据长度
        $json = json_encode($data, JSON_UNESCAPED_UNICODE);
        return strlen($json) > 500 ? substr($json, 0, 500) . '...' : $json;
    }

    /**
     * 获取异常消息
     */
    protected function getExceptionMessage($record)
    {
        if (isset($record['context']['exception']) && $record['context']['exception'] instanceof \Exception) {
            return $record['context']['exception']->getMessage();
        }
        return 'N/A';
    }

    /**
     * 获取异常位置
     */
    protected function getExceptionLocation($record)
    {
        if (isset($record['context']['exception']) && $record['context']['exception'] instanceof \Exception) {
            $trace = $record['context']['exception']->getTrace()[0] ?? [];
            return isset($trace['file'], $trace['line']) ? 
                $trace['file'] . ':' . $trace['line'] : 'N/A';
        }
        return 'N/A';
    }

    /**
     * 将内容写入文件
     *
     * @param string $data
     */
    protected function writeToFile($data)
    {
        // 打开文件（如果尚未打开）
        if (null === $this->fileHandle) {
            $this->openFile();
        }

        // 使用文件锁（如果需要）
        if ($this->useLocking) {
            flock($this->fileHandle, LOCK_EX);
        }

        // 写入文件
        fwrite($this->fileHandle, $data);

        // 释放文件锁（如果需要）
        if ($this->useLocking) {
            flock($this->fileHandle, LOCK_UN);
        }
    }

    /**
     * 打开日志文件
     */
    protected function openFile()
    {
        // 文件打开模式：追加模式，如果文件不存在则创建
        $fileMode = File::exists($this->logPath) ? 'a' : 'w';

        $this->fileHandle = fopen($this->logPath, $fileMode);
        if (false === $this->fileHandle) {
            throw new \RuntimeException(sprintf('无法打开日志文件 "%s"', $this->logPath));
        }

        // 设置文件权限
        if (null !== $this->filePermission) {
            @chmod($this->logPath, $this->filePermission);
        }
    }

    /**
     * 关闭文件句柄
     */
    protected function closeFile()
    {
        if (null !== $this->fileHandle) {
            fclose($this->fileHandle);
            $this->fileHandle = null;
        }
    }


    // protected function getDefaultFormatter()
    // {
    //     // 使用与 Laravel 相同的格式
    //     return new \Monolog\Formatter\LineFormatter(
    //         "[%datetime%] %channel%.%level_name%: %message% %context% %extra%\n",
    //         null,
    //         true,
    //         true
    //     );
    // }

    /**
     * 关闭处理器
     */
    public function close(): void
    {
        $this->closeFile();
        parent::close();
    }

    /**
     * 析构函数
     */
    public function __destruct()
    {
        try {
            $this->close();
        } catch (\Exception $e) {
            // 避免在析构时抛出异常
        }
    }
}
```

注册自定义日志处理器。

在 AppServiceProvider 中注册这个自定义处理器：

```php
<?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
        //
    }

    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        //

        // 错误日志处理通道一
        $this->app->make('log')->extend('error_log_one', function ($app, $config) {
            // 创建处理器实例
            $handler = new \App\Logging\Handlers\ErrorLogOneHandler(
                $config['path'] ?? storage_path('logs/error-log_one.log'),
                $this->level($config),
                $config['bubble'] ?? true,
                $config['permission'] ?? null,
                $config['locking'] ?? false
            );

            // 创建日志记录器
            return new \Monolog\Logger($this->parseChannel($config), [$handler]);
        });
    }

    /**
     * 日志等级
     *
     * @param array $config
     * @return void
     */
    protected function level(array $config)
    {
        $level = $config['level'] ?? 'error';

        // 日志级别映射
        $levels = [
            'debug' => \Monolog\Logger::DEBUG,
            'info' => \Monolog\Logger::INFO,
            'notice' => \Monolog\Logger::NOTICE,
            'warning' => \Monolog\Logger::WARNING,
            'error' => \Monolog\Logger::ERROR,
            'critical' => \Monolog\Logger::CRITICAL,
            'alert' => \Monolog\Logger::ALERT,
            'emergency' => \Monolog\Logger::EMERGENCY,
        ];

        return $levels[strtolower($level)] ?? \Monolog\Logger::ERROR;
    }

    /**
     * 解析通道名称
     *
     * @param  array  $config
     * @return string
     */
    protected function parseChannel(array $config)
    {
        return $config['name'] ?? $this->app->environment();
    }
}
```

在项目入口文件中写入加入以下代码，用于记录具体步骤：

```php
$log_id = uniqid() . mt_rand(100000, 999999);
$log_step = 1;
```

配置日志通道。

在 config/logging.php 中配置新的错误日志通道：

```php
'channels' => [
    // 创建一个堆栈通道，同时包含常规日志和错误日志
    'stack' => [
        'driver' => 'stack',
        'channels' => ['single', 'error_log_one'],
        'ignore_exceptions' => false,
    ],

    // 原有的 single 通道保持不变
    'single' => [
        'driver' => 'single',
        'path' => storage_path('logs/laravel.log'),
        'level' => 'debug',
    ],

    // 新增错误日志通道
    'error_log_one' => [
        'driver' => 'error_log_one',
        'path' => storage_path('logs/laravel-error_one.log'),
        'level' => 'error', // 只记录 error 及以上级别的日志
        'bubble' => false, // 防止日志向上传播到其他处理器
        'permission' => 0664, // 文件权限
        'locking' => false, // 不使用文件锁
    ],
],
```

生成日志如下：
```
[2025-08-23 11:58:31] local.ERROR {"log_id":"68a93c6798f7b494589","log_step":3,"user_id":3,"log_msg":"SQLSTATE[42S22]: Column not found: 1054 Unknown column 'created_admin_id1' in 'where clause' (SQL: select count(*) as aggregate from `fb_user_targeting_template` where `status` >= 0 and `created_admin_id1` = 3)","request_url":"http://t2v.local2/admin/fbbatch_user_targeting_template_api?_token=zFMSsEEyos1MxnXC34kqk7CEdxRX4QQb75668y7SY&limit=10&page=1&s=%2F%2Fadmin%2Ffbbatch_user_targeting_template_api&searchParams=%7B%22name%22%3A%22%22%7D","request_method":"GET","request_params":"{\"s\":\"\\/\\/admin\\/fbbatch_user_targeting_template_api\",\"_token\":\"***\",\"page\":\"1\",\"limit\":\"10\",\"searchParams\":\"{\\\"name\\\":\\\"\\\"}\"}","response_status":"N/A","response_data":"N/A","exception_message":"SQLSTATE[42S22]: Column not found: 1054 Unknown column 'created_admin_id1' in 'where clause' (SQL: select count(*) as aggregate from `fb_user_targeting_template` where `status` >= 0 and `created_admin_id1` = 3)","exception_location":"C:\\develop\\www\\t2v\\vendor\\laravel\\framework\\src\\Illuminate\\Database\\Connection.php:629","request_time":"2025-08-23 11:58:31","exception":"[object] (Illuminate\\Database\\QueryException(code: 42S22): SQLSTATE[42S22]: Column not found: 1054 Unknown column 'created_admin_id1' in 'where clause' (SQL: select count(*) as aggregate from `fb_user_targeting_template` where `status` >= 0 and `created_admin_id1` = 3) at C:\\develop\\www\\t2v\\vendor\\laravel\\framework\\src\\Illuminate\\Database\\Connection.php:669)
[previous exception] [object] (PDOException(code: 42S22): SQLSTATE[42S22]: Column not found: 1054 Unknown column 'created_admin_id1' in 'where clause' at C:\\develop\\www\\t2v\\vendor\\laravel\\framework\\src\\Illuminate\\Database\\Connection.php:331)"} 
```





## 参考资料

Laravel 6 中文文档 <https://learnku.com/docs/laravel/6.x/facades/5146>

Laravel 实用小技巧——日志告警功能应该怎么做 <https://learnku.com/articles/82018>


