---
layout: post
categories: Laravel
title: Laravel 服务提供者
meta: Laravel 服务提供者
---
* content
{:toc}

## 基本概念

服务提供者是所有 Laravel 应用程序的引导中心。你的应用程序，以及 通过服务器引导的 Laravel 核心服务都是通过服务提供器引导。

但是，「引导」是什么意思呢？ 通常，我们可以理解为注册，比如注册服务容器绑定，事件监听器，中间件，甚至是路由。服务提供者是配置应用程序的中心。或者说「服务提供者」是配置应用的中心，它的主要工作是使用「服务容器」实现服务容器绑定、事件监听器、中间件，甚至是路由的注册。

什么是服务提供者？如果说服务容器是提供绑定和依赖注入的的工具，那么 服务提供者 则是实现绑定的工具。

当打开 Laravel 的 config/app.php 文件时，会看到 providers 数组。数组中的内容是应用程序要加载的所有服务提供者的类。当然，其中有很多 「延迟」 提供者，他们并不会在每次请求的时候都加载，只有他们的服务实际被需要时才会加载。

除核心服务外，几乎所有的服务提供者都定义在配置文件 config/app.php 文件中的 providers 节点中。

服务提供者的典型处理流程是，当 Laravel 应用接收到 HTTP 请求时会去执行「服务提供者的 register（注册）」方法，将各个服务「绑定」到容器内；之后，到了实际处理请求阶段，依据使用情况按需加载所需服务。这样的优势很明显能够提升应用的性能。

还有一些核心服务提供者并没有定义在 providers 配置节点中，而是直接在应用实例化，就是在 Illuminate\Foundation\Application 服务容器实例化阶段时就完成了注册服务：
```php
<?php
...

class Application extends Container implements ApplicationContract, HttpKernelInterface
{
    /**省略若干**/

    public function __construct($basePath = null)
    {
        ...
        $this->registerBaseServiceProviders();
        ...
    }

    /**
     * Register all of the base service providers. 
     * 注册应用基础服务提供者
     *
     * @return void
     */
    protected function registerBaseServiceProviders()
    {
        $this->register(new EventServiceProvider($this));  // 事件服务提供者

        $this->register(new LogServiceProvider($this));  // 日志服务提供者
        
        $this->register(new RoutingServiceProvider($this));  // 路由服务提供者
    }

    /**省略若干**/
}
```

## 使用方法

**创建自定义服务提供者**

所有的服务提供者都会继承 Illuminate\Support\ServiceProvider 类。 大多服务提供者都包含一个 register 和一个 boot 方法。在 register 方法中， 只需要将服务绑定到服务容器。

Laavel提供了生成服务提供者的命令：
```bash
php artisan make:provider ServiceNameProvider
```

运行后会在 app/Providers 目录下创建 ServiceNameProvider.php 文件。打开该文件看下它的源码：

```php
<?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class ServiceNameProvider extends ServiceProvider
{
    /**
     * Register services.
     *
     * @return void
     */
    public function register()
    {
        //
    }

    /**
     * Bootstrap services.
     *
     * @return void
     */
    public function boot()
    {
        //
    }
}
```

文档中提到：在 register 方法中，你只需要将服务绑定到服务容器中。而不要尝试在 register 方法中注册任何监听器，路由，或者其他任何功能。否则，你可能会意外地使用到尚未加载的服务提供者提供的服务。

这里需要说明的是如果在register 方法中进行除服务绑定以外的其他操作，可能会用到还未注册的服务，此时会报错。这些操作都应该放到 boot 方法中。

在register()方法中写入注册该服务代码，如注册elasticsearch服务：

```php
$this->app->singleton('elasticsearch', function ($app) {
    return new Elasticsearch();
});
```

**配置服务提供者**

上面服务提供者创建完成后，需要把该服务提供者提供的elasticsearch服务注册到服务容器中。打开 config/app.php 文件写入的 providers 数组中，看下代码：

```php
<?php

return [
    'name' => env('APP_NAME', 'Laravel'),
    'env' => env('APP_ENV', 'production'),
    'debug' => (bool) env('APP_DEBUG', false),
    'url' => env('APP_URL', 'http://localhost'),
    'asset_url' => env('ASSET_URL', null),
    'timezone' => 'Asia/Shanghai',
    'locale' => 'en',
    'fallback_locale' => 'en',
    'faker_locale' => 'en_US',
    'key' => env('APP_KEY'),

    'providers' => [
        Illuminate\Auth\AuthServiceProvider::class,
        Illuminate\Broadcasting\BroadcastServiceProvider::class,
        Illuminate\Bus\BusServiceProvider::class,
        Illuminate\Cache\CacheServiceProvider::class,
        Illuminate\Foundation\Providers\ConsoleSupportServiceProvider::class,
        Illuminate\Cookie\CookieServiceProvider::class,
        Illuminate\Database\DatabaseServiceProvider::class,
        Illuminate\Encryption\EncryptionServiceProvider::class,
        Illuminate\Filesystem\FilesystemServiceProvider::class,
        Illuminate\Foundation\Providers\FoundationServiceProvider::class,
        Illuminate\Hashing\HashServiceProvider::class,
        Illuminate\Mail\MailServiceProvider::class,
        Illuminate\Notifications\NotificationServiceProvider::class,
        Illuminate\Pagination\PaginationServiceProvider::class,
        Illuminate\Pipeline\PipelineServiceProvider::class,
        Illuminate\Queue\QueueServiceProvider::class,
        Illuminate\Redis\RedisServiceProvider::class,
        Illuminate\Auth\Passwords\PasswordResetServiceProvider::class,
        Illuminate\Session\SessionServiceProvider::class,
        Illuminate\Translation\TranslationServiceProvider::class,
        Illuminate\Validation\ValidationServiceProvider::class,
        Illuminate\View\ViewServiceProvider::class,

        /*
         * Package Service Providers...
         */

        /*
         * Application Service Providers...
         */
        App\Providers\AppServiceProvider::class,  // 服务提供器，进行简单绑定

        App\Providers\AuthServiceProvider::class,
        // App\Providers\BroadcastServiceProvider::class,
        App\Providers\EventServiceProvider::class,
        App\Providers\RouteServiceProvider::class,

        App\Providers\ServiceNameProvider::class,  // <-- 自定义服务提供者
    ],

    'aliases' => [
        'App' => Illuminate\Support\Facades\App::class,
        'Arr' => Illuminate\Support\Arr::class,
        'Artisan' => Illuminate\Support\Facades\Artisan::class,
        'Auth' => Illuminate\Support\Facades\Auth::class,
        'Blade' => Illuminate\Support\Facades\Blade::class,
        'Broadcast' => Illuminate\Support\Facades\Broadcast::class,
        'Bus' => Illuminate\Support\Facades\Bus::class,
        'Cache' => Illuminate\Support\Facades\Cache::class,
        'Config' => Illuminate\Support\Facades\Config::class,
        'Cookie' => Illuminate\Support\Facades\Cookie::class,
        'Crypt' => Illuminate\Support\Facades\Crypt::class,
        'DB' => Illuminate\Support\Facades\DB::class,
        'Eloquent' => Illuminate\Database\Eloquent\Model::class,
        'Event' => Illuminate\Support\Facades\Event::class,
        'File' => Illuminate\Support\Facades\File::class,
        'Gate' => Illuminate\Support\Facades\Gate::class,
        'Hash' => Illuminate\Support\Facades\Hash::class,
        'Lang' => Illuminate\Support\Facades\Lang::class,
        'Log' => Illuminate\Support\Facades\Log::class,
        'Mail' => Illuminate\Support\Facades\Mail::class,
        'Notification' => Illuminate\Support\Facades\Notification::class,
        'Password' => Illuminate\Support\Facades\Password::class,
        'Queue' => Illuminate\Support\Facades\Queue::class,
        'Redirect' => Illuminate\Support\Facades\Redirect::class,
        'Redis' => Illuminate\Support\Facades\Redis::class,
        'Request' => Illuminate\Support\Facades\Request::class,
        'Response' => Illuminate\Support\Facades\Response::class,
        'Route' => Illuminate\Support\Facades\Route::class,
        'Schema' => Illuminate\Support\Facades\Schema::class,
        'Session' => Illuminate\Support\Facades\Session::class,
        'Storage' => Illuminate\Support\Facades\Storage::class,
        'Str' => Illuminate\Support\Str::class,
        'URL' => Illuminate\Support\Facades\URL::class,
        'Validator' => Illuminate\Support\Facades\Validator::class,
        'View' => Illuminate\Support\Facades\View::class,
    ],
];
```

这样就完成了 服务提供者 从 创建 到 注册 的整个流程。

**AppServiceProvider服务提供器**

通过上面操作，我们可能会想到为什么要多此一举写服务提供者呢，直接把服务注册到服务容器不就可以了吗？

确实可以，对于一些简单的服务，直接注册到应用实例，即服务容器中即可，如通过 bind、singleton 、instance 方法等，直接在 index.php 入口文件中 `$app->singleton('elasticsearch', (new Elasticsearch()))`等 注册服务。

但是对于一些复杂的服务，如数据库连接、缓存、队列等，这些服务的初始化逻辑比较复杂，不适合放在 `register()` 方法中。此时就需要使用服务提供者的 `boot()` 方法。

那么我们现在怎么把这些简单的服务注册到服务容器中呢？通过研究服务容器，我们会发现我们无法修改服务容器，服务容器是底层。我们能修改的只是服务提供者。但服务提供者却提供了一个给服务容器提供数据的入口，这是我们可以利用的地方。

对于一些服务的简单绑定，可以使用服务提供器`App\Providers\AppServiceProvider`的 bindings 和 singletons 属性替代服务提供者进行绑定。当服务提供器被框架加载时，将自动检查这些属性并注册相应的绑定：

```php
<?php

namespace App\Providers;

use App\Contracts\ServerProvider;
use App\Contracts\DowntimeNotifier;
use App\Services\PingdomDowntimeNotifier;
use App\Services\DigitalOceanServerProvider;
use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
        //
    }

    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        //
    }

    /**
     * 设定所有的容器绑定的对应关系
     *
     * @var array
     */
    public $bindings = [
        ServerProvider::class => DigitalOceanServerProvider::class,
    ];

    /**
     * 设定所有的单例模式容器绑定的对应关系
     *
     * @var array
     */
    public $singletons = [
        DowntimeNotifier::class => PingdomDowntimeNotifier::class,
        ServerToolsProvider::class => ServerToolsProvider::class,
   ];
}
```

### boot() 方法

在 Laravel 中，服务提供者（Service Provider）的 `boot()` 方法是一个关键部分，用于在 所有服务提供者注册完成后 执行初始化逻辑。以下是详细说明：

**作用**

1、延迟初始化：`boot()` 在所有服务提供者的 `register()` 方法执行完毕后调用，确保所有依赖的服务已注册到容器中，可以安全使用其他服务。

2、配置框架功能：用于注册路由、中间件、事件监听器、视图合成器等需要依赖其他服务的组件。

**使用场景**

注册路由。在 `boot()` 中定义路由，避免因其他服务未注册导致的错误：
```php
public function boot()
{
    Route::get('/example', function () {
        return view('example');
    });
}
```

绑定事件监听器：
```php
use Illuminate\Support\Facades\Event;

public function boot()
{
    Event::listen('user.login', function ($user) {
        // 处理用户登录事件
    });
}
```

配置视图合成器：
```php
use Illuminate\Support\Facades\View;

public function boot()
{
    View::composer('profile', function ($view) {
        $view->with('user', auth()->user());
    });
}
```

加载资源文件。自动加载路由、配置、翻译等文件：
```php
public function boot()
{
    $this->loadRoutesFrom(__DIR__.'/routes.php');
    $this->loadViewsFrom(__DIR__.'/views', 'my-package');
    $this->loadTranslationsFrom(__DIR__.'/lang', 'my-package');
}
```

**注意事项**

1、避免服务绑定：`boot()` 中不应进行服务容器的绑定（如 `$app->bind()`），绑定操作应放在 `register()` 方法中。

2、依赖注入：可以通过参数注入所需依赖：

```php
use Illuminate\Contracts\Events\Dispatcher;

public function boot(Dispatcher $events)
{
    $events->listen('event.name', 'EventHandler');
}
```

**示例：自定义服务提供者**

1、生成服务提供者

```bash
php artisan make:provider MyServiceProvider
```

2、编写 `boot()` 逻辑

```php
namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use Illuminate\Support\Facades\View;

class MyServiceProvider extends ServiceProvider
{
    public function boot()
    {
        // 注册视图合成器
        View::composer('dashboard', function ($view) {
            $view->with('stats', $this->getDashboardStats());
        });

        // 加载自定义路由
        $this->loadRoutesFrom(__DIR__.'/../routes/custom.php');
    }

    protected function getDashboardStats()
    {
        return [/* 数据逻辑 */];
    }

    public function register()
    {
        // 绑定服务到容器（如需要）
        $this->app->singleton('my-service', function () {
            return new MyService();
        });
    }
}
```

3、注册服务提供者，在 `config/app.php` 的 `providers` 数组中添加：

```php
'providers' => [
    // 其他服务提供者...
    App\Providers\MyServiceProvider::class,
],
```

**总结**

* `boot()`：用于在所有服务注册完成后执行初始化操作（如路由、事件、视图配置）。
* `register()`：仅用于向服务容器绑定服务，避免在此方法外进行其他操作。

通过合理使用 `boot()` 方法，可以确保 Laravel 应用的各个组件在正确的时间点初始化，保持代码的清晰和可维护性。

## 为什么使用服务提供者

app/Providers/EnvatoCustomServiceProvider.php 文件，加入如下代码：
```php
<?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use App\Library\Services\DemoOne;

class EnvatoCustomServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->app->bind('App\Library\Services\DemoOne', function ($app) {
            return new DemoOne();
        });
    }

    public function boot()
    {
    }
} 
```

app/Library/Services/DemoOne.php 文件：
```php
 <?php
namespace App\Library\Services;

class DemoOne
{
    public function doSomethingUseful()
    {
      return 'Output from DemoOne';
    }
}
```

然后，在控制器的构造函数中注入依赖：
```php
<?php
namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Library\Services\DemoOne;

class TestController extends Controller
{
    public function index(DemoOne $customServiceInstance)
    {
        echo $customServiceInstance->doSomethingUseful();
    }
}
```

以上便是一个使用绑定的简单方法。事实上，对于这个示例其实并不需要创建一个服务提供者，并实现 register 方法，因为 Laravel 还可以通过 PHP 的方式功能自动解析。

如果我们需要绑定的服务依赖于其它接口，创建服务提供者则很有必要。看个例子。

首先，创建一个简单的接口 app/Library/Services/Contracts/CustomServiceInterface.php。

```php
<?php
// app/Library/Services/Contracts/CustomServiceInterface.php
namespace App\Library\Services\Contracts;

Interface CustomServiceInterface
{
    public function doSomethingUseful();
}
```

然后，创建两个基于此接口的具体实现。或者说，创建两个继承此接口的实现类。

一个是定义在 app/Library/Services/DemoOne.php 文件中的 DemoOne 类。

```php
<?php
// app/Library/Services/DemoOne.php
namespace App\Library\Services;

use App\Library\Services\Contracts\CustomServiceInterface;

class DemoOne implements CustomServiceInterface
{
    public function doSomethingUseful()
    {
      return 'Output from DemoOne';
    }
}
```

类似的，还有 app/Library/Services/DemoTwo.php。

```php
<?php
// app/Library/Services/DemoTwo.php
namespace App\Library\Services;

use App\Library\Services\Contracts\CustomServiceInterface;

class DemoTwo implements CustomServiceInterface
{
    public function doSomethingUseful()
    {
      return 'Output from DemoTwo';
    }
}
```

现在，将绑定具体类名修改为绑定接口。打开 EnvatoCustomServiceProvider.php 文件并改成如下代码：

```php
<?php
namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use App\Library\Services\DemoOne;

class EnvatoCustomServiceProvider extends ServiceProvider
{
    public function boot()
    {
    }

    public function register()
    {
        $this->app->bind('App\Library\Services\Contracts\CustomServiceInterface', function ($app) {
          return new DemoOne();
        });
    }
}
```

这里，我们将 DemoOne 实现类绑定到 App\Library\Services\Contracts\CustomServiceInterface 接口。后续，所有依赖 App\Library\Services\Contracts\CustomServiceInterface 接口的功能都被解析成 App\Library\Services\DemoOne 对象。

我们还需要调整下控制器中的代码。

```php
<?php
namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Library\Services\Contracts\CustomServiceInterface;

class TestController extends Controller
{
    public function index(CustomServiceInterface $customServiceInstance)
    {
        echo $customServiceInstance->doSomethingUseful();
    }
}
```

这里 $customServiceInstance 对象就是 App\Library\Services\DemoOne 类的实例！也就是说依赖于CustomServiceInterface时，会根据服务提供者绑定的服务进行解析。这种方案的优势在于可以很容易的替换掉 DemoOne 这个实现。

如果我们想使用 DemoTwo 替换掉 DemoOne 服务。此时，仅需简单的调整下服务提供者中的代码 EnvatoCustomServiceProvider.php。

```php
<?php
namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use App\Library\Services\DemoTwo;

class EnvatoCustomServiceProvider extends ServiceProvider
{
    public function boot()
    {
    }

    public function register()
    {
        $this->app->bind('App\Library\Services\Contracts\CustomServiceInterface', function ($app) {
          return new DemoTwo();
        });
    }
}
```

使用同样的手法甚至可以将自定义的实现替换掉任何核心服务中的依赖。不仅如此，除了 bind 方法；Laravel 服务容器还提供多种绑定方法，如 singleton、instance 等。

## 实现原理

所有的服务提供者都会继承 Illuminate\Support\ServiceProvider 类。我们看下这个类：

```php
<?php

namespace Illuminate\Support;

use Illuminate\Console\Application as Artisan;
use Illuminate\Contracts\Support\DeferrableProvider;
use Illuminate\Database\Eloquent\Factory as ModelFactory;

abstract class ServiceProvider
{
    /**
     * The application instance.
     *
     * @var \Illuminate\Contracts\Foundation\Application
     */
    protected $app;

    /**
     * Create a new service provider instance.
     *
     * @param  \Illuminate\Contracts\Foundation\Application  $app
     * @return void
     */
    public function __construct($app)
    {
        $this->app = $app;
    }

    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
        //
    }

    /**省略若干**/
}
```

这里的 `$this->app` 就是应用实例，也就是服务容器。



## 源码

Illuminate\Support\ServiceProvider源码：

```php
<?php

namespace Illuminate\Support;

use Illuminate\Console\Application as Artisan;
use Illuminate\Contracts\Support\DeferrableProvider;
use Illuminate\Database\Eloquent\Factory as ModelFactory;

abstract class ServiceProvider
{
    /**
     * The application instance.
     *
     * @var \Illuminate\Contracts\Foundation\Application
     */
    protected $app;

    /**
     * The paths that should be published.
     *
     * @var array
     */
    public static $publishes = [];

    /**
     * The paths that should be published by group.
     *
     * @var array
     */
    public static $publishGroups = [];

    /**
     * Create a new service provider instance.
     *
     * @param  \Illuminate\Contracts\Foundation\Application  $app
     * @return void
     */
    public function __construct($app)
    {
        $this->app = $app;
    }

    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
        //
    }

    /**
     * Merge the given configuration with the existing configuration.
     *
     * @param  string  $path
     * @param  string  $key
     * @return void
     */
    protected function mergeConfigFrom($path, $key)
    {
        if (! $this->app->configurationIsCached()) {
            $this->app['config']->set($key, array_merge(
                require $path, $this->app['config']->get($key, [])
            ));
        }
    }

    /**
     * Load the given routes file if routes are not already cached.
     *
     * @param  string  $path
     * @return void
     */
    protected function loadRoutesFrom($path)
    {
        if (! $this->app->routesAreCached()) {
            require $path;
        }
    }

    /**
     * Register a view file namespace.
     *
     * @param  string|array  $path
     * @param  string  $namespace
     * @return void
     */
    protected function loadViewsFrom($path, $namespace)
    {
        $this->callAfterResolving('view', function ($view) use ($path, $namespace) {
            if (isset($this->app->config['view']['paths']) &&
                is_array($this->app->config['view']['paths'])) {
                foreach ($this->app->config['view']['paths'] as $viewPath) {
                    if (is_dir($appPath = $viewPath.'/vendor/'.$namespace)) {
                        $view->addNamespace($namespace, $appPath);
                    }
                }
            }

            $view->addNamespace($namespace, $path);
        });
    }

    /**
     * Register a translation file namespace.
     *
     * @param  string  $path
     * @param  string  $namespace
     * @return void
     */
    protected function loadTranslationsFrom($path, $namespace)
    {
        $this->callAfterResolving('translator', function ($translator) use ($path, $namespace) {
            $translator->addNamespace($namespace, $path);
        });
    }

    /**
     * Register a JSON translation file path.
     *
     * @param  string  $path
     * @return void
     */
    protected function loadJsonTranslationsFrom($path)
    {
        $this->callAfterResolving('translator', function ($translator) use ($path) {
            $translator->addJsonPath($path);
        });
    }

    /**
     * Register database migration paths.
     *
     * @param  array|string  $paths
     * @return void
     */
    protected function loadMigrationsFrom($paths)
    {
        $this->callAfterResolving('migrator', function ($migrator) use ($paths) {
            foreach ((array) $paths as $path) {
                $migrator->path($path);
            }
        });
    }

    /**
     * Register Eloquent model factory paths.
     *
     * @param  array|string  $paths
     * @return void
     */
    protected function loadFactoriesFrom($paths)
    {
        $this->callAfterResolving(ModelFactory::class, function ($factory) use ($paths) {
            foreach ((array) $paths as $path) {
                $factory->load($path);
            }
        });
    }

    /**
     * Setup an after resolving listener, or fire immediately if already resolved.
     *
     * @param  string  $name
     * @param  callable  $callback
     * @return void
     */
    protected function callAfterResolving($name, $callback)
    {
        $this->app->afterResolving($name, $callback);

        if ($this->app->resolved($name)) {
            $callback($this->app->make($name), $this->app);
        }
    }

    /**
     * Register paths to be published by the publish command.
     *
     * @param  array  $paths
     * @param  mixed  $groups
     * @return void
     */
    protected function publishes(array $paths, $groups = null)
    {
        $this->ensurePublishArrayInitialized($class = static::class);

        static::$publishes[$class] = array_merge(static::$publishes[$class], $paths);

        foreach ((array) $groups as $group) {
            $this->addPublishGroup($group, $paths);
        }
    }

    /**
     * Ensure the publish array for the service provider is initialized.
     *
     * @param  string  $class
     * @return void
     */
    protected function ensurePublishArrayInitialized($class)
    {
        if (! array_key_exists($class, static::$publishes)) {
            static::$publishes[$class] = [];
        }
    }

    /**
     * Add a publish group / tag to the service provider.
     *
     * @param  string  $group
     * @param  array  $paths
     * @return void
     */
    protected function addPublishGroup($group, $paths)
    {
        if (! array_key_exists($group, static::$publishGroups)) {
            static::$publishGroups[$group] = [];
        }

        static::$publishGroups[$group] = array_merge(
            static::$publishGroups[$group], $paths
        );
    }

    /**
     * Get the paths to publish.
     *
     * @param  string|null  $provider
     * @param  string|null  $group
     * @return array
     */
    public static function pathsToPublish($provider = null, $group = null)
    {
        if (! is_null($paths = static::pathsForProviderOrGroup($provider, $group))) {
            return $paths;
        }

        return collect(static::$publishes)->reduce(function ($paths, $p) {
            return array_merge($paths, $p);
        }, []);
    }

    /**
     * Get the paths for the provider or group (or both).
     *
     * @param  string|null  $provider
     * @param  string|null  $group
     * @return array
     */
    protected static function pathsForProviderOrGroup($provider, $group)
    {
        if ($provider && $group) {
            return static::pathsForProviderAndGroup($provider, $group);
        } elseif ($group && array_key_exists($group, static::$publishGroups)) {
            return static::$publishGroups[$group];
        } elseif ($provider && array_key_exists($provider, static::$publishes)) {
            return static::$publishes[$provider];
        } elseif ($group || $provider) {
            return [];
        }
    }

    /**
     * Get the paths for the provider and group.
     *
     * @param  string  $provider
     * @param  string  $group
     * @return array
     */
    protected static function pathsForProviderAndGroup($provider, $group)
    {
        if (! empty(static::$publishes[$provider]) && ! empty(static::$publishGroups[$group])) {
            return array_intersect_key(static::$publishes[$provider], static::$publishGroups[$group]);
        }

        return [];
    }

    /**
     * Get the service providers available for publishing.
     *
     * @return array
     */
    public static function publishableProviders()
    {
        return array_keys(static::$publishes);
    }

    /**
     * Get the groups available for publishing.
     *
     * @return array
     */
    public static function publishableGroups()
    {
        return array_keys(static::$publishGroups);
    }

    /**
     * Register the package's custom Artisan commands.
     *
     * @param  array|mixed  $commands
     * @return void
     */
    public function commands($commands)
    {
        $commands = is_array($commands) ? $commands : func_get_args();

        Artisan::starting(function ($artisan) use ($commands) {
            $artisan->resolveCommands($commands);
        });
    }

    /**
     * Get the services provided by the provider.
     *
     * @return array
     */
    public function provides()
    {
        return [];
    }

    /**
     * Get the events that trigger this service provider to register.
     *
     * @return array
     */
    public function when()
    {
        return [];
    }

    /**
     * Determine if the provider is deferred.
     *
     * @return bool
     */
    public function isDeferred()
    {
        return $this instanceof DeferrableProvider;
    }
}
```









## 参考资料

Laravel 6 中文文档  <https://learnku.com/docs/laravel/6.x/providers/5132>

深入剖析 Laravel 服务提供者实现原理 <https://learnku.com/articles/12986/in-depth-analysis-of-the-principle-of-laravel-service-provider-implementation>

Laravel 服务提供者指南 <https://learnku.com/articles/12852/laravel-service-provider-guide>

How to Register and Use Laravel Service Providers <https://code.tutsplus.com/how-to-register-use-laravel-service-providers--cms-28966t>

