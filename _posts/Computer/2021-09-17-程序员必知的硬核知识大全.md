---
layout: post
categories: Computer
title: 程序员必知的硬核知识大全
meta: 程序员必知的硬核知识大全
---
* content
{:toc}

![]({{site.baseurl}}/images/20210917/20210917103136.png)

## CPU

大家都是程序员，大家都是和计算机打交道的程序员，大家都是和计算机中软件硬件打交道的程序员，
大家都是和CPU打交道的程序员，所以，不管你是玩儿硬件的还是做软件的，你的世界都少不了计算机最核心的 - CPU

### CPU是什么

CPU 的全称是 Central Processing Unit，它是你的电脑中最硬核的组件，这种说法一点不为过。
CPU 是能够让你的计算机叫计算机的核心组件，但是它却不能代表你的电脑，CPU 与计算机的关系就相当于大脑和人的关系。
它是一种小型的计算机芯片，它嵌入在台式机、笔记本电脑或者平板电脑的主板上。
通过在单个计算机芯片上放置数十亿个微型晶体管来构建 CPU。 
这些晶体管使它能够执行运行存储在系统内存中的程序所需的计算，也就是说 CPU 决定了你电脑的计算能力。

### CPU实际做什么

CPU 的核心是从程序或应用程序获取指令并执行计算。此过程可以分为三个关键阶段：**提取**，**解码**和**执行**。
CPU从系统的 RAM 中提取指令，然后解码该指令的实际内容，然后再由 CPU 的相关部分执行该指令。

RAM : 随机存取存储器（英语：Random Access Memory，缩写：RAM），也叫主存，是与 CPU 直接交换数据的内部存储器。
它可以随时读写（刷新时除外），而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储介质

### CPU的内部结构

说了这么多 CPU 的重要性，那么 CPU 的内部结构是什么呢？又是由什么组成的呢？
下图展示了一般程序的运行流程（以 C 语言为例），可以说了解程序的运行流程是掌握程序运行机制的基础和前提。

![]({{site.baseurl}}/images/20210917/20210917123136.png)

在这个流程中，CPU 负责的就是解释和运行最终转换成机器语言的内容。

CPU 主要由两部分构成：控制单元 和 算术逻辑单元（ALU）

* 控制单元：从内存中提取指令并解码执行
* 算数逻辑单元（ALU）：处理算数和逻辑运算

CPU 是计算机的心脏和大脑，它和内存都是由许多晶体管组成的电子部件。它接收数据输入，执行指令并处理信息。
它与输入/输出（I / O）设备进行通信，这些设备向 CPU 发送数据和从 CPU 接收数据。

从功能来看，CPU 的内部由**寄存器**、**控制器**、**运算器**和**时钟**四部分组成，各部分之间通过电信号连通。

![]({{site.baseurl}}/images/20210917/20210917123138.png)

* 寄存器是中央处理器内的组成部分。它们可以用来暂存指令、数据和地址。可以将其看作是内存的一种。
根据种类的不同，一个 CPU 内部会有 20 - 100个寄存器。
* 控制器负责把内存上的指令、数据读入寄存器，并根据指令的结果控制计算机
* 运算器负责运算从内存中读入寄存器的数据
* 时钟 负责发出 CPU 开始计时的时钟信号

接下来简单解释一下内存，为什么说 CPU 需要讲一下内存呢，因为内存是与 CPU 进行沟通的桥梁。
计算机所有程序的运行都是在内存中运行的，内存又被称为主存，其作用是存放 CPU 中的运算数据，
以及与硬盘等外部存储设备交换的数据。只要计算机在运行中，CPU 就会把需要运算的数据调到主存中进行运算，
当运算完成后CPU再将结果传送出来，主存的运行也决定了计算机的稳定运行。

主存通过控制芯片与 CPU 进行相连，由可读写的元素构成，每个字节（1 byte = 8 bits）都带有一个地址编号，
注意是一个字节，而不是一个位。CPU 通过地址从主存中读取数据和指令，也可以根据地址写入数据。
注意一点：当计算机关机时，内存中的指令和数据也会被清除。

#### CPU是寄存器的集合体

在 CPU 的四个结构中，我们程序员只需要了解寄存器就可以了，其余三个不用过多关注，为什么这么说？
因为程序是把寄存器作为对象来描述的。

说到寄存器，就不得不说到汇编语言，我大学是学信息管理与信息系统的，
我就没有学过汇编这门课（就算有这门课也不会好好学hhhh），出来混总是要还的，要想作为一个硬核程序员，
不能不了解这些概念。说到汇编语言，就不得不说到高级语言，说到高级语言就不得不牵扯出语言这个概念。

##### 计算机语言

我们生而为人最明显的一个特征是我们能通过讲话来实现彼此的交流，但是计算机听不懂你说的话，
你要想和他交流必须按照计算机指令来交换，这就涉及到语言的问题，计算机是由二进制构成的，
它只能听的懂二进制也就是机器语言，但是普通人是无法看懂机器语言的，这个时候就需要一种电脑既能识别，
人又能理解的语言，最先出现的就是汇编语言。但是汇编语言晦涩难懂，所以又出现了像是 C，C++，Java 的这种高级语言。

所以计算机语言一般分为两种：低级语言（机器语言，汇编语言）和高级语言。使用高级语言编写的程序，
经过编译转换成机器语言后才能运行，而汇编语言经过汇编器才能转换为机器语言。

##### 汇编语言

首先来看一段用汇编语言表示的代码清单

```
mov eax, dword ptr [ebp-8]   /* 把数值从内存复制到 eax */
add eax, dword ptr [ebp-0Ch] /* 把 eax 的数值和内存的数值相加 */
mov dword ptr [ebp-4], eax /* 把 eax 的数值（上一步的结果）存储在内存中*/
```

这是采用汇编语言（assembly）编写程序的一部分。汇编语言采用 助记符(memonic) 来编写程序，
每一个原本是电信号的机器语言指令会有一个与其对应的助记符，例如 mov,add 分别是数据的存储（move）和相加（addition）的简写。
汇编语言和机器语言是一一对应的。这一点和高级语言有很大的不同，通常我们将汇编语言编写的程序转换为机器语言的过程称为 汇编；
反之，机器语言转化为汇编语言的过程称为 反汇编。

汇编语言能够帮助你理解计算机做了什么工作，机器语言级别的程序是通过寄存器来处理的，
上面代码中的 eax,ebp 都是表示的寄存器，是 CPU 内部寄存器的名称，所以可以说 CPU 是一系列寄存器的集合体。
在内存中的存储通过地址编号来表示，而寄存器的种类则通过名字来区分。

不同类型的 CPU ，其内部寄存器的种类，数量以及寄存器存储的数值范围都是不同的。
不过，根据功能的不同，可以将寄存器划分为下面这几类

    种类           功能
    累加寄存器     存储运行的数据和运算后的数据。
    标志寄存器     用于反应处理器的状态和运算结果的某些特征以及控制指令的执行。
    程序计数器     程序计数器是用于存放下一条指令所在单元的地址的地方。
    基址寄存器     存储数据内存的起始位置
    变址寄存器     存储基址寄存器的相对地址
    通用寄存器     存储任意数据
    指令寄存器     储存正在被运行的指令，CPU内部使用，程序员无法对该寄存器进行读写
    栈寄存器       存储栈区域的起始位置

其中**程序计数器**、**累加寄存器**、**标志寄存器**、**指令寄存器**和**栈寄存器**都只有一个，其他寄存器一般有多个。

![]({{site.baseurl}}/images/20210917/20210917123140.png)

#### 程序计数器

程序计数器(Program Counter)是用来存储下一条指令所在单元的地址。

程序执行时，PC的初值为程序第一条指令的地址，在顺序执行程序时，
控制器首先按程序计数器所指出的指令地址从内存中取出一条指令，然后分析和执行该指令，同时将PC的值加1指向下一条要执行的指令。

我们还是以一个事例为准来详细的看一下程序计数器的执行过程

![]({{site.baseurl}}/images/20210917/20210917123142.png)

这是一段进行相加的操作，程序启动，在经过编译解析后会由操作系统把硬盘中的程序复制到内存中，
示例中的程序是将 123 和 456 执行相加操作，并将结果输出到显示器上。由于使用机器语言难以描述，
所以这是经过翻译后的结果，实际上每个指令和数据都可能分布在不同的地址上，但为了方便说明，
把组成一条指令的内存和数据放在了一个内存地址上。

地址 0100 是程序运行的起始位置。Windows 等操作系统把程序从硬盘复制到内存后，
会将程序计数器作为设定为起始位置 0100，然后执行程序，每执行一条指令后，
程序计数器的数值会增加1（或者直接指向下一条指令的地址），然后，CPU 就会根据程序计数器的数值，
从内存中读取命令并执行，也就是说，**程序计数器控制着程序的流程**。

#### 条件分支和循环机制

我们都学过高级语言，高级语言中的条件控制流程主要分为三种：顺序执行、条件分支、循环判断三种，
顺序执行是按照地址的内容顺序的执行指令。条件分支是根据条件执行任意地址的指令。循环是重复执行同一地址的指令。

* 顺序执行的情况比较简单，每执行一条指令程序计数器的值就是 + 1。
* 条件和循环分支会使程序计数器的值指向任意的地址，这样一来，程序便可以返回到上一个地址来重复执行同一个指令，或者跳转到任意指令。

下面以条件分支为例来说明程序的执行过程（循环也很相似）

![]({{site.baseurl}}/images/20210917/20210917123144.png)

程序的开始过程和顺序流程是一样的，CPU 从0100处开始执行命令，在0100和0101都是顺序执行，PC 的值顺序+1，
执行到0102地址的指令时，判断0106寄存器的数值大于0，跳转（jump）到0104地址的指令，将数值输出到显示器中，
然后结束程序，0103 的指令被跳过了，这就和我们程序中的 if() 判断是一样的，在不满足条件的情况下，
指令会直接跳过。所以 PC 的执行过程也就没有直接+1，而是下一条指令的地址。

#### 标志寄存器

条件和循环分支会使用到 jump（跳转指令），会根据当前的指令来判断是否跳转，上面我们提到了标志寄存器，
无论当前累加寄存器的运算结果是正数、负数还是零，标志寄存器都会将其保存（也负责溢出和奇偶校验）

* 溢出（overflow）：是指运算的结果超过了寄存器的长度范围
* 奇偶校验（parity check）：是指检查运算结果的值是偶数还是奇数

CPU 在进行运算时，标志寄存器的数值会根据当前运算的结果自动设定，运算结果的正、负和零三种状态由标志寄存器的三个位表示。
标志寄存器的第一个字节位、第二个字节位、第三个字节位各自的结果都为1时，分别代表着正数、零和负数。

![]({{site.baseurl}}/images/20210917/20210917123146.png)

CPU 的执行机制比较有意思，假设累加寄存器中存储的 XXX 和通用寄存器中存储的 YYY 做比较，执行比较的背后，
CPU 的运算机制就会做减法运算。而无论减法运算的结果是正数、零还是负数，都会保存到标志寄存器中。
结果为正表示 XXX 比 YYY 大，结果为零表示 XXX 和 YYY 相等，结果为负表示 XXX 比 YYY 小。
程序比较的指令，实际上是在 CPU 内部做减法运算。

#### 函数调用机制

接下来，我们继续介绍函数调用机制，哪怕是高级语言编写的程序，
函数调用处理也是通过把程序计数器的值设定成函数的存储地址来实现的。
函数执行跳转指令后，必须进行返回处理，单纯的指令跳转没有意义，下面是一个实现函数跳转的例子

![]({{site.baseurl}}/images/20210917/20210917123148.png)

图中将变量 a 和 b 分别赋值为 123 和 456 ，调用 MyFun(a,b) 方法，进行指令跳转。
图中的地址是将 C 语言编译成机器语言后运行时的地址，由于1行 C 程序在编译后通常会变为多行机器语言，
所以图中的地址是分散的。在执行完 MyFun(a,b)指令后，程序会返回到 MyFun(a,b) 的下一条指令，CPU 继续执行下面的指令。

函数的调用和返回很重要的两个指令是 call 和 return 指令，再将函数的入口地址设定到程序计数器之前，
call 指令会把调用函数后要执行的指令地址存储在名为栈的主存内。函数处理完毕后，再通过函数的出口来执行 return 指令。
return 指令的功能是把保存在栈中的地址设定到程序计数器。
MyFun 函数在被调用之前，0154 地址保存在栈中，MyFun 函数处理完成后，会把0154的地址保存在程序计数器中。这个调用过程如下

![]({{site.baseurl}}/images/20210917/20210917123150.png)

在一些高级语言的条件或者循环语句中，函数调用的处理会转换成 call 指令，函数结束后的处理则会转换成 return 指令。

#### 通过地址和索引实现数组

接下来我们看一下基址寄存器和变址寄存器，通过这两个寄存器，我们可以对主存上的特定区域进行划分，来实现类似数组的操作，
首先，我们用十六进制数将计算机内存上的 00000000 - FFFFFFFF 的地址划分出来。
那么，凡是该范围的内存地址，只要有一个 32 位的寄存器，便可查看全部地址。
但如果想要想数组那样分割特定的内存区域以达到连续查看的目的的话，使用两个寄存器会更加方便。

例如，我们用两个寄存器（基址寄存器和变址寄存器）来表示内存的值

![]({{site.baseurl}}/images/20210917/20210917123152.png)

这种表示方式很类似数组的构造，数组是指同样长度的数据在内存中进行连续排列的数据构造。
用数组名表示数组全部的值，通过索引来区分数组的各个数据元素，例如: `a[0]` - `a[4]`，`[]`内的 0 - 4 就是数组的下标。

### CPU指令执行过程

那么 CPU 是如何执行一条条的指令的呢？

几乎所有的冯·诺伊曼型计算机的CPU，其工作都可以分为5个阶段：
**取指令**、**指令译码**、**执行指令**、**访存取数**、**结果写回**。

* 取指令阶段是将内存中的指令读取到 CPU 中寄存器的过程，程序寄存器用于存储下一条指令所在的地址
* 指令译码阶段，在取指令完成后，立马进入指令译码阶段，在指令译码阶段，指令译码器按照预定的指令格式，
对取回的指令进行拆分和解释，识别区分出不同的指令类别以及各种获取操作数的方法。
* 执行指令阶段，译码完成后，就需要执行这一条指令了，此阶段的任务是完成指令所规定的各种操作，具体实现指令的功能。
* 访问取数阶段，根据指令的需要，有可能需要从内存中提取数据，此阶段的任务是：根据指令地址码，
得到操作数在主存中的地址，并从主存中读取该操作数用于运算。
* 结果写回阶段，作为最后一个阶段，结果写回（Write Back，WB）阶段把执行指令阶段的运行结果数据“写回”到某种存储形式：
结果数据经常被写到CPU的内部寄存器中，以便被后续的指令快速地存取；
    
## 内存

CPU 和 内存就像是一堆不可分割的恋人一样，是无法拆散的一对儿，没有内存，CPU 无法执行程序指令，那么计算机也就失去了意义；
只有内存，无法执行指令，那么计算机照样无法运行。

那么什么是内存呢？内存和 CPU 如何进行交互？下面就来介绍一下

### 什么是内存

内存（Memory）是计算机中最重要的部件之一，它是程序与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，
因此内存对计算机的影响非常大，内存又被称为主存，其作用是存放 CPU 中的运算数据，以及与硬盘等外部存储设备交换的数据。
只要计算机在运行中，CPU 就会把需要运算的数据调到主存中进行运算，当运算完成后CPU再将结果传送出来，
主存的运行也决定了计算机的稳定运行。

### 内存的物理结构

在了解一个事物之前，你首先得先需要见过它，你才会有印象，才会有想要了解的兴趣，
所以我们首先需要先看一下什么是内存以及它的物理结构是怎样的。

内存的内部是由各种 IC 电路组成的，它的种类很庞大，但是其主要分为三种存储器

* 随机存储器（RAM）： 内存中最重要的一种，表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会丢失。
* 只读存储器（ROM）：ROM 一般只能用于数据的读取，不能写入数据，但是当机器停电时，这些数据不会丢失。
* 高速缓存（Cache）：Cache 也是我们经常见到的，它分为一级缓存（L1 Cache）、二级缓存（L2 Cache）、
三级缓存（L3 Cache）这些数据，它位于内存和 CPU 之间，是一个读写速度比内存更快的存储器。
当 CPU 向内存写入数据时，这些数据也会被写入高速缓存中。当 CPU 需要读取数据时，会直接从高速缓存中直接读取，
当然，如需要的数据在Cache中没有，CPU会再去读取内存中的数据。

内存 IC 是一个完整的结构，它内部也有电源、地址信号、数据信号、控制信号和用于寻址的 IC 引脚来进行数据的读写。
下面是一个虚拟的 IC 引脚示意图

![]({{site.baseurl}}/images/20210917/20210917123154.png)

图中 VCC 和 GND 表示电源，A0 - A9 是地址信号的引脚，D0 - D7 表示的是控制信号、RD 和 WR 都是好控制信号，
我用不同的颜色进行了区分，将电源连接到 VCC 和 GND 后，就可以对其他引脚传递 0 和 1 的信号，
大多数情况下，+5V 表示1，0V 表示 0。

我们都知道内存是用来存储数据，那么这个内存 IC 中能存储多少数据呢？D0 - D7 表示的是数据信号，
也就是说，一次可以输入输出 8 bit = 1 byte 的数据。A0 - A9 是地址信号共十个，
表示可以指定 00000 00000 - 11111 11111 共 2 的 10次方 = 1024个地址。每个地址都会存放 1 byte 的数据，
因此我们可以得出内存 IC 的容量就是 1 KB。

如果我们使用的是 512 MB 的内存，这就相当于是 512000（512 * 1000） 个内存 IC。
当然，一台计算机不太可能有这么多个内存 IC ，然而，通常情况下，一个内存 IC 会有更多的引脚，也就能存储更多数据。

#### 内存的读写过程

让我们把关注点放在内存 IC 对数据的读写过程上来吧！我们来看一个对内存IC 进行数据写入和读取的模型

![]({{site.baseurl}}/images/20210917/20210917123156.png)

来详细描述一下这个过程，假设我们要向内存 IC 中写入 1byte 的数据的话，它的过程是这样的：

* 首先给 VCC 接通 +5V 的电源，给 GND 接通 0V 的电源，使用 A0 - A9 来指定数据的存储场所，
然后再把数据的值输入给 D0 - D7 的数据信号，并把 WR（write）的值置为 1，执行完这些操作后，即可以向内存 IC 写入数据
* 读出数据时，只需要通过 A0 - A9 的地址信号指定数据的存储场所，然后再将 RD 的值置为 1 即可。
* 图中的 RD 和 WR 又被称为控制信号。其中当WR 和 RD 都为 0 时，无法进行写入和读取操作。

#### 内存的现实模型

为了便于记忆，我们把内存模型映射成为我们现实世界的模型，在现实世界中，内存的模型很想我们生活的楼房。
在这个楼房中，1层可以存储一个字节的数据，楼层号就是地址，下面是内存和楼层整合的模型图

![]({{site.baseurl}}/images/20210917/20210917123158.png)

我们知道，程序中的数据不仅只有数值，还有数据类型的概念，从内存上来看，就是占用内存大小（占用楼层数）的意思。
即使物理上强制以 1 个字节为单位来逐一读写数据的内存，在程序中，通过指定其数据类型，也能实现以特定字节数为单位来进行读写。

下面是一个以特定字节数为例来读写指令字节的程序的示例

```
// 定义变量
char a;
short b;
long c;

// 变量赋值
a = 123;
b = 123;
c = 123;
```

我们分别声明了三个变量 a,b,c ，并给每个变量赋上了相同的 123，这三个变量表示内存的特定区域。
通过变量，即使不指定物理地址，也可以直接完成读写操作，操作系统会自动为变量分配内存地址。

这三个变量分别表示 1 个字节长度的 char，2 个字节长度的 short，表示4 个字节的 long。
因此，虽然数据都表示的是 123，但是其存储时所占的内存大小是不一样的。如下所示

![]({{site.baseurl}}/images/20210917/20210917123160.png)

这里的 123 都没有超过每个类型的最大长度，所以 short 和 long 类型为所占用的其他内存空间分配的数值是0，
这里我们采用的是低字节序列的方式存储

* 低字节序列：将数据低位存储在内存低位地址。
* 高字节序列：将数据的高位存储在内存地位的方式称为高字节序列。

### 内存的使用

#### 指针

指针是 C 语言非常重要的特征，指针也是一种变量，只不过它所表示的不是数据的值，而是内存的地址。
通过使用指针，可以对任意内存地址的数据进行读写。

在了解指针读写的过程前，我们先需要了解如何定义一个指针，和普通的变量不同，在定义指针时，
我们通常会在变量名前加一个 * 号。例如我们可以用指针定义如下的变量

```
char *d; // char类型的指针 d 定义
short *e; // short类型的指针 e 定义
long *f; // long类型的指针 f 定义
```

我们以32位计算机为例，32位计算机的内存地址是 4 字节，在这种情况下，指针的长度也是 32 位。
然而，变量 d e f 却代表了不同的字节长度，这是为什么呢？

实际上，这些数据表示的是从内存中一次读取的字节数，比如 d e f 的值都为 100，
那么使用 char 类型时就能够从内存中读写 1 byte 的数据，使用 short 类型就能够从内存读写 2 字节的数据， 
使用 long 就能够读写 4 字节的数据，下面是一个完整的类型字节表

    类型    32位    64位
    char    1    1
    short int    2    2
    int    4    4
    unsigned int    4    4
    float    4    4
    double    8    8
    long    4    8
    long long    8    8
    unsigned long    4    8

我们可以用图来描述一下这个读写过程

![]({{site.baseurl}}/images/20210917/20210917123162.png)

#### 数组的内存实现

数组是指多个相同的数据类型在内存中连续排列的一种形式。作为数组元素的各个数据会通过下标编号来区分，
这个编号也叫做索引，如此一来，就可以对指定索引的元素进行读写操作。

首先先来认识一下数组，我们还是用 char、short、long 三种元素来定义数组，
数组的元素用`[value]` 扩起来，里面的值代表的是数组的长度，就像下面的定义

```
char g[100];
short h[100];
long i[100];
```

数组定义的数据类型，也表示一次能够读写的内存大小，char 、short 、long 分别以 1 、2 、4 个字节为例进行内存的读写。

数组是内存的实现，数组和内存的物理结构完全一致，尤其是在读写1个字节的时候，
当字节数超过 1 时，只能通过逐个字节来读取，下面是内存的读写过程

![]({{site.baseurl}}/images/20210917/20210917123164.png)

#### 栈和队列

我们上面提到数组是内存的一种实现，使用数组能够使编程更加高效，下面我们就来认识一下其他数据结构，
通过这些数据结构也可以操作内存的读写。

##### 栈

栈（stack）是一种很重要的数据结构，栈采用 LIFO（Last In First Out）即后入先出的方式对内存进行操作。
它就像一个大的收纳箱，你可以往里面放相同类型的东西，比如书，最先放进收纳箱的书在最下面，
最后放进收纳箱的书在最上面，如果你想拿书的话， 必须从最上面开始取，否则是无法取出最下面的书籍的。

栈的数据结构就是这样，你把书籍压入收纳箱的操作叫做压入（push），你把书籍从收纳箱取出的操作叫做弹出（pop），
它的模型图大概是这样

![]({{site.baseurl}}/images/20210917/20210917123166.png)

入栈相当于是增加操作，出栈相当于是删除操作，只不过叫法不一样。栈和内存不同，它不需要指定元素的地址。它的大概使用如下

```
// 压入数据
Push(123);
Push(456);
Push(789);

// 弹出数据
j = Pop();
k = Pop();
l = Pop();
```

在栈中，LIFO 方式表示栈的数组中所保存的最后面的数据（Last In）会被最先读取出来（First On）。

![]({{site.baseurl}}/images/20210917/20210917123168.png)

##### 队列

队列和栈很相似但又不同，相同之处在于队列也不需要指定元素的地址，
不同之处在于队列是一种 先入先出(First In First Out) 的数据结构。
队列在我们生活中的使用很像是我们去景区排队买票一样，第一个排队的人最先买到票，以此类推，
俗话说: 先到先得。它的使用如下

```
// 往队列中写入数据
EnQueue(123);
EnQueue(456);
EnQueue(789);

// 从队列中读出数据
m = DeQueue();
n = DeQueue();
o = DeQueue();
```

向队列中写入数据称为 EnQueue()入列，从队列中读出数据称为DeQueue()。

![]({{site.baseurl}}/images/20210917/20210917123170.png)

与栈相对，FIFO 的方式表示队列中最先所保存的数据会优先被读取出来。

![]({{site.baseurl}}/images/20210917/20210917123172.png)

队列的实现一般有两种：顺序队列 和 循环队列，我们上面的事例使用的是顺序队列，那么下面我们看一下循环队列的实现方式

**环形缓冲区**

循环队列一般是以环状缓冲区(ring buffer)的方式实现的，它是一种用于表示一个固定尺寸、头尾相连的缓冲区的数据结构，
适合缓存数据流。假如我们要用 6 个元素的数组来实现一个环形缓冲区，这时可以从起始位置开始有序的存储数据，
然后再按照存储时的顺序把数据读出。在数组的末尾写入数据后，后一个数据就会从缓冲区的头开始写。
这样，数组的末尾和开头就连接了起来。

![]({{site.baseurl}}/images/20210917/20210917123174.png)

#### 链表

下面我们来介绍一下链表和 二叉树，它们都是可以不用考虑索引的顺序就可以对元素进行读写的方式。
通过使用链表，可以高效的对数据元素进行添加 和 删除操作。而通过使用二叉树，则可以更高效的对数据进行检索。

在实现数组的基础上，除了数据的值之外，通过为其附带上下一个元素的索引，即可实现链表。
数据的值和下一个元素的地址（索引）就构成了一个链表元素，如下所示

![]({{site.baseurl}}/images/20210917/20210917123176.png)

对链表的添加和删除都是非常高效的，我们来叙述一下这个添加和删除的过程，
假如我们要删除地址为 `p[2]` 的元素，链表该如何变化呢？

![]({{site.baseurl}}/images/20210917/20210917123178.png)

我们可以看到，删除地址为 `p[2]` 的元素后，直接将链表剔除，
并把 `p[2]` 前一个位置的元素 `p[1]` 的**指针域**指向 `p[2]` 下一个链表元素的数据区即可。

![]({{site.baseurl}}/images/20210917/20210917123180.png)

那么对于新添加进来的链表，需要确定插入位置，比如要在 `p[2]` 和 `p[3]` 之间插入地址为 `p[6]` 的元素，
需要将 `p[6]` 的前一个位置 `p[2]` 的指针域改为 `p[6]` 的地址，然后将 `p[6]` 的指针域改为 `p[3]` 的地址即可。

链表的添加不涉及到 数据的移动，所以链表的添加和删除很快，而数组的添加设计到数据的移动，
所以比较慢，通常情况下，使用数组来检索数据，使用链表来进行添加和删除操作。

#### 二叉树



## 二进制

我们都知道，计算机的底层都是使用二进制数据进行数据流传输的，那么为什么会使用二进制表示计算机呢？
或者说，什么是二进制数呢？在拓展一步，如何使用二进制进行加减乘除？下面就来看一下

### 为什么用二进制表示

### 什么是二进制数

那么什么是二进制数呢？为了说明这个问题，我们先把 00100111 这个数转换为十进制数看一下，
二进制数转换为十进制数，直接将各位置上的值 * 位权即可，那么我们将上面的数值进行转换

### 移位运算和乘除的关系

### 便于计算机处理的补数

### 算数右移和逻辑右移的区别

### 逻辑运算的窍门

## 压缩算法

### 认识压缩算法

#### 文件存储

#### 压缩算法的定义

### 几种常用压缩算法的理解

#### RLE算法的机制

##### RLE算法的缺点

#### 哈夫曼算法和莫尔斯编码

#### 用二叉树实现哈夫曼算法

##### 哈夫曼树能够提升压缩比率

#### 可逆压缩和非可逆压缩

## 磁盘

### 认识磁盘

#### 程序不读入内存就无法运行

### 磁盘构件

#### 磁盘缓存

#### 虚拟内存

##### 虚拟内存与内部的交换方式

### 节约内存

#### 通过DLL文件实现函数共有

#### 通过调用_stdcall来减少程序文件的大小

#### 磁盘的物理结构

## 操作系统环境

### Windows操作系统克服了CPU以外的硬件差异

### 不同操作系统的API差异性

### FreeBSD Port帮你轻松使用源代码

### 可以使用虚拟机获取其他环境

#### 提供相同运行环境的Java虚拟机

### BIOS和引导

## 操作系统功能的历史

### 要把操作系统放在第一位

### 系统调用和编程语言的移植性

### 操作系统和高级编程语言使硬件抽象化

### Windows操作系统的特征

#### 32位操作系统

#### 通过API函数集来提供系统调用

#### 提供采用了 GUI的用户界面

#### 通过WYSIWYG实现打印输出

#### 提供多任务功能

#### 提供网络功能和数据库功能

#### 通过即插即用实现设备驱动的自动设定

## 汇编语言与本地环境

### 通过编译器输出汇编语言的源代码

### 不会转换成本地代码的伪指令

### 汇编语言的语法是操作码+操作数

#### 指令解析

#### 函数的调用机制

#### 函数的内部处理

#### 全局变量和局部变量

#### 临时确保局部变量使用的内存空间

#### 循环控制语句的处理

#### 条件分支的处理方法

#### 了解程序运行逻辑的必要性

## 应用和硬件的关系

### 支持硬件输入输出的IN指令和OUT指令

### 测试输入和输出程序

### 外围设备的中断请求

### 用中断来实现实时处理

### 利用DMA实现短时间内大量数据传输

### 文字和图片的显示机制




<br/><br/><br/><br/><br/>
## 参考资料

计算机基础知识总结与操作系统 PDF 下载 <https://mp.weixin.qq.com/s/y6S61R_GMHIs0mkvYiABJw>

计算机基础知识总结与操作系统 PDF 下载 <https://zhuanlan.zhihu.com/p/161622194>

程序员不得不了解的硬核知识大全 <https://www.cnblogs.com/cxuanblog/p/12195745.html>

程序员必知的硬核知识大全.pdf <https://max.book118.com/html/2020/0719/7110032131002151.shtm>

程序员cxuan <https://jishuin.proginn.com/p/763bfbd544c8>

计算机是怎样跑起来的 <https://www.ituring.com.cn/book/1139>

