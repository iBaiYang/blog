---
layout: post
categories: Yii2
title: Yii2 事件
meta: 使用事件，可以在特定的时点，触发执行预先设定的一段代码，事件既是代码解耦的一种方式，也是设计业务流程的一种模式。
---
* content
{:toc}

### 正文

#### 引导

使用事件，可以在特定的时点，触发执行预先设定的一段代码，事件既是代码解耦的一种方式，也是设计业务流程的一种模式。现代软件中，
事件无处不在，比如，你发了个微博，触发了一个事件，导致关注你的人，看到了你新发出来的内容。
对于事件而言，有这么几个要素：
1. 这是一个什么事件？一个软件系统里，有诸多事件，发布新微博是事件，删除微博也是一种事件。
2. 谁触发了事件？你发的微博，就是你触发的事件。
3. 谁负责监听这个事件？或者谁能知道这个事件发生了？服务器上处理用户注册的模块，肯定不会收到你发出新微博的事件。
4. 事件怎么处理？对于发布新微博的事件，就是通知关注了你的其他用户。
5. 事件相关数据是什么？对于发布新微博事件，包含的数据至少要有新微博的内容，时间等。

#### Yii中与事件相关的类

Yii中，事件是在 yii\base\Component 中引入的，需要使用事件时，从 yii\base\Component 进行继承。
同时，Yii中还有一个与事件紧密相关的 yii\base\Event ，他封装了与事件相关的有关数据，并提供一些功能函数作为辅助：
```
class Event extends Object
{
    public $name;               // 事件名
    public $sender;             // 事件发布者，通常是调用了 trigger() 的对象或类。
    public $handled = false;    // 是否终止事件的后续处理
    public $data;               // 事件相关数据

    private static $_events = [];

    public static function on($class, $name, $handler, $data = null, $append = true)
    {
        // ... ...
        // 用于绑定事件handler
    }

    public static function off($class, $name, $handler = null)
    {
        // ... ...
        // 用于取消事件handler绑定
    }

    public static function hasHandlers($class, $name)
    {
        // ... ...
        // 用于判断是否有相应的handler与事件对应
    }

    public static function trigger($class, $name, $event = null)
    {
        // ... ...
        // 用于触发事件
    }
}
```

看一下 yii\base\Event 的源码：
```
<?php
namespace yii\base;

/**
 * Event is the base class for all event classes.
 *
 * It encapsulates the parameters associated with an event.
 * The [[sender]] property describes who raises the event.
 * And the [[handled]] property indicates if the event is handled.
 * If an event handler sets [[handled]] to be `true`, the rest of the
 * uninvoked handlers will no longer be called to handle the event.
 *
 * Additionally, when attaching an event handler, extra data may be passed
 * and be available via the [[data]] property when the event handler is invoked.
 *
 * For more details and usage information on Event, see the [guide article on events](guide:concept-events).
 *
 * @author Qiang Xue <qiang.xue@gmail.com>
 * @since 2.0
 */
class Event extends Object
{
    /**
     * @var string the event name. This property is set by [[Component::trigger()]] and [[trigger()]].
     * Event handlers may use this property to check what event it is handling.
     */
    public $name;
    /**
     * @var object the sender of this event. If not set, this property will be
     * set as the object whose `trigger()` method is called.
     * This property may also be a `null` when this event is a
     * class-level event which is triggered in a static context.
     */
    public $sender;
    /**
     * @var bool whether the event is handled. Defaults to `false`.
     * When a handler sets this to be `true`, the event processing will stop and
     * ignore the rest of the uninvoked event handlers.
     */
    public $handled = false;
    /**
     * @var mixed the data that is passed to [[Component::on()]] when attaching an event handler.
     * Note that this varies according to which event handler is currently executing.
     */
    public $data;

    /**
     * @var array contains all globally registered event handlers.
     */
    private static $_events = [];


    /**
     * Attaches an event handler to a class-level event.
     *
     * When a class-level event is triggered, event handlers attached
     * to that class and all parent classes will be invoked.
     *
     * For example, the following code attaches an event handler to `ActiveRecord`'s
     * `afterInsert` event:
     *
     * ```php
     * Event::on(ActiveRecord::className(), ActiveRecord::EVENT_AFTER_INSERT, function ($event) {
     *     Yii::trace(get_class($event->sender) . ' is inserted.');
     * });
     * ```
     *
     * The handler will be invoked for EVERY successful ActiveRecord insertion.
     *
     * For more details about how to declare an event handler, please refer to [[Component::on()]].
     *
     * @param string $class the fully qualified class name to which the event handler needs to attach.
     * @param string $name the event name.
     * @param callable $handler the event handler.
     * @param mixed $data the data to be passed to the event handler when the event is triggered.
     * When the event handler is invoked, this data can be accessed via [[Event::data]].
     * @param bool $append whether to append new event handler to the end of the existing
     * handler list. If `false`, the new handler will be inserted at the beginning of the existing
     * handler list.
     * @see off()
     */
    public static function on($class, $name, $handler, $data = null, $append = true)
    {
        $class = ltrim($class, '\\');
        if ($append || empty(self::$_events[$name][$class])) {
            self::$_events[$name][$class][] = [$handler, $data];
        } else {
            array_unshift(self::$_events[$name][$class], [$handler, $data]);
        }
    }

    /**
     * Detaches an event handler from a class-level event.
     *
     * This method is the opposite of [[on()]].
     *
     * @param string $class the fully qualified class name from which the event handler needs to be detached.
     * @param string $name the event name.
     * @param callable $handler the event handler to be removed.
     * If it is `null`, all handlers attached to the named event will be removed.
     * @return bool whether a handler is found and detached.
     * @see on()
     */
    public static function off($class, $name, $handler = null)
    {
        $class = ltrim($class, '\\');
        if (empty(self::$_events[$name][$class])) {
            return false;
        }
        if ($handler === null) {
            unset(self::$_events[$name][$class]);
            return true;
        }

        $removed = false;
        foreach (self::$_events[$name][$class] as $i => $event) {
            if ($event[0] === $handler) {
                unset(self::$_events[$name][$class][$i]);
                $removed = true;
            }
        }
        if ($removed) {
            self::$_events[$name][$class] = array_values(self::$_events[$name][$class]);
        }
        return $removed;
    }

    /**
     * Detaches all registered class-level event handlers.
     * @see on()
     * @see off()
     * @since 2.0.10
     */
    public static function offAll()
    {
        self::$_events = [];
    }

    /**
     * Returns a value indicating whether there is any handler attached to the specified class-level event.
     * Note that this method will also check all parent classes to see if there is any handler attached
     * to the named event.
     * @param string|object $class the object or the fully qualified class name specifying the class-level event.
     * @param string $name the event name.
     * @return bool whether there is any handler attached to the event.
     */
    public static function hasHandlers($class, $name)
    {
        if (empty(self::$_events[$name])) {
            return false;
        }
        if (is_object($class)) {
            $class = get_class($class);
        } else {
            $class = ltrim($class, '\\');
        }

        $classes = array_merge(
            [$class],
            class_parents($class, true),
            class_implements($class, true)
        );

        foreach ($classes as $class) {
            if (!empty(self::$_events[$name][$class])) {
                return true;
            }
        }

        return false;
    }

    /**
     * Triggers a class-level event.
     * This method will cause invocation of event handlers that are attached to the named event
     * for the specified class and all its parent classes.
     * @param string|object $class the object or the fully qualified class name specifying the class-level event.
     * @param string $name the event name.
     * @param Event $event the event parameter. If not set, a default [[Event]] object will be created.
     */
    public static function trigger($class, $name, $event = null)
    {
        if (empty(self::$_events[$name])) {
            return;
        }
        if ($event === null) {
            $event = new static;
        }
        $event->handled = false;
        $event->name = $name;

        if (is_object($class)) {
            if ($event->sender === null) {
                $event->sender = $class;
            }
            $class = get_class($class);
        } else {
            $class = ltrim($class, '\\');
        }

        $classes = array_merge(
            [$class],
            class_parents($class, true),
            class_implements($class, true)
        );

        foreach ($classes as $class) {
            if (!empty(self::$_events[$name][$class])) {
                foreach (self::$_events[$name][$class] as $handler) {
                    $event->data = $handler[1];
                    call_user_func($handler[0], $event);
                    if ($event->handled) {
                        return;
                    }
                }
            }
        }
    }
}
```

#### 事件handler

所谓事件handler就是事件处理程序，负责事件触发后怎么办的问题。从本质上来讲，一个事件handler就是一段PHP代码，即一个PHP函数。
对于一个事件handler，可以是以下的形式提供：

* 一个PHP全局函数的函数名，不带参数和括号，光秃秃的就一个函数名。如 trim ，注意，不是 trim($str) 也不是 trim() 。
* 一个对象的方法，或一个类的静态方法。如 $person->sayHello() 可以用为事件handler，
但要改写成以数组的形式， [$person, 'sayHello'] ，而如果是类的静态方法，那应该是 ['namespace\to\Person', 'sayHello'] 。
* 匿名函数。如 function ($event) { ... }

但无论是何种方式提供，一个事件handler必须具有以下形式:
```
function ($event) {
    // $event 就是前面提到的 yii\base\Event
}
```

还有一点容易犯错的地方，就是对于类自己的成员函数，尽管在调用 on() 进行绑定时，看着这个handler是有效的，
因此，有的小伙伴就写成这样了 $this->on(EVENT_A, 'publicMethod') ，但事实上，这是一个错误的写法。以字符串的形式提供handler，
只能是PHP的全局函数。这是由于handler的调用是通过 call_user_func() 来实现的。
因此，handler的形式，与 call_user_func() 的要求是一致的。

#### 事件的绑定与解除

##### 事件的绑定

有了事件handler，还要告诉Yii，这个handler是负责处理哪种事件的。这个过程，就是事件的绑定。

yii\base\Component::on() 就是用来绑定的，很容易就猜到， yii\base\Component::off() 就是用来解除的。对于绑定，有以下形式:
```
$person = new Person;

// 使用PHP全局函数作为handler来进行绑定
$person->on(Person::EVENT_GREET, 'person_say_hello');

// 使用对象$obj的成员函数say_hello来进行绑定
$person->on(Person::EVENT_GREET, [$obj, 'say_hello']);

// 使用类Greet的静态成员函数say_hello进行绑定
$person->on(Person::EVENT_GREET, ['app\helper\Greet', 'say_hello']);

// 使用匿名函数
$person->on(Person::EVENT_GREET, function ($event) {
    echo 'Hello';
});
```

事件的绑定可以像上面这样在运行时以代码的形式进行绑定，也可以在配置中进行绑定。 
当然，这个配置生效的过程其实也是在运行时的。原理见 配置项（Configuration） 部分的内容。

上面的例子只是简单的绑定了事件与事件handler，如果有额外的数据传递给handler，
可以使用 yii\base\Component::on() 的第三个参数。这个参数将会写进 Event 的相关数据字段，即属性 data 。如:
```
$person->on(Person::EVENT_GREET, 'person_say_hello', 'Hello World!');

// 'Hello World!' 可以通过 $event访问。
function person_say_hello($event)
{
    echo $event->data;                // 将显示 Hello World!
}
```

yii\base\Component 维护了一个handler数组，用来保存绑定的handler:
```
// 这个就是handler数组
private _events = [];

// 绑定过程就是将handler写入_event[]
public function on($name, $handler, $data = null, $append = true)
{
    $this->ensureBehaviors();
    if ($append || empty($this->_events[$name])) {
        $this->_events[$name][] = [$handler, $data];
    } else {
        array_unshift($this->_events[$name], [$handler, $data]);
    }
}
```

<br/><br/><br/><br/><br/>
### 参考资料

深入理解Yii2.0 » Yii 基础 » 事件（Event） <http://www.digpage.com/event.html>

