---
layout: post
categories: Yii2
title: Yii2 事件
meta: 使用事件，可以在特定的时点，触发执行预先设定的一段代码，事件既是代码解耦的一种方式，也是设计业务流程的一种模式。
---
* content
{:toc}

### 正文

#### 引导

使用事件，可以在特定的时点，触发执行预先设定的一段代码，事件既是代码解耦的一种方式，也是设计业务流程的一种模式。现代软件中，
事件无处不在，比如，你发了个微博，触发了一个事件，导致关注你的人，看到了你新发出来的内容。
对于事件而言，有这么几个要素：
1. 这是一个什么事件？一个软件系统里，有诸多事件，发布新微博是事件，删除微博也是一种事件。
2. 谁触发了事件？你发的微博，就是你触发的事件。
3. 谁负责监听这个事件？或者谁能知道这个事件发生了？服务器上处理用户注册的模块，肯定不会收到你发出新微博的事件。
4. 事件怎么处理？对于发布新微博的事件，就是通知关注了你的其他用户。
5. 事件相关数据是什么？对于发布新微博事件，包含的数据至少要有新微博的内容，时间等。

#### Yii中与事件相关的类

Yii中，事件是在 yii\base\Component 中引入的，需要使用事件时，从 yii\base\Component 进行继承。
```
class Component extends Object
{
    private $_events = [];
    
    public function hasEventHandlers($name)
    {
        // ... ...
        // 用于判断是否有相应的handler与事件对应
    }
    
    public function on($name, $handler, $data = null, $append = true)
    {
        // ... ...
        // 用于绑定事件handler
    }
    
    public function off($name, $handler = null)
    {
        // ... ...
        // 用于取消事件handler绑定
    }
    
    public function trigger($name, Event $event = null)
    {
        // ... ...
        // 用于触发事件
    }
}
```

同时，Yii中还有一个与事件紧密相关的 yii\base\Event ，**他封装了与事件相关的有关数据，并提供一些功能函数作为辅助**：
```
class Event extends Object
{
    public $name;               // 事件名
    public $sender;             // 事件发布者，通常是调用了 trigger() 的对象或类。
    public $handled = false;    // 是否终止事件的后续处理
    public $data;               // 事件相关数据

    private static $_events = [];

    public static function on($class, $name, $handler, $data = null, $append = true)
    {
        // ... ...
        // 用于绑定事件handler
    }

    public static function off($class, $name, $handler = null)
    {
        // ... ...
        // 用于取消事件handler绑定
    }

    public static function hasHandlers($class, $name)
    {
        // ... ...
        // 用于判断是否有相应的handler与事件对应
    }

    public static function trigger($class, $name, $event = null)
    {
        // ... ...
        // 用于触发事件
    }
}
```

#### 事件handler

所谓事件handler就是事件处理程序，负责事件触发后怎么办的问题。从本质上来讲，一个事件handler就是一段PHP代码，即一个PHP函数。
对于一个事件handler，可以是以下的形式提供：

* 一个PHP全局函数的函数名，不带参数和括号，光秃秃的就一个函数名。如 trim ，注意，不是 trim($str) 也不是 trim() 。
* 一个对象的方法，或一个类的静态方法。如 $person->sayHello() 可以用为事件handler，
但要改写成以数组的形式， [$person, 'sayHello'] ，而如果是类的静态方法，那应该是 ['namespace\to\Person', 'sayHello'] 。
* 匿名函数。如 function ($event) { ... }

但无论是何种方式提供，一个事件handler必须具有以下形式:
```
function ($event) {
    // $event 就是前面提到的 yii\base\Event
}
```

还有一点容易犯错的地方，就是在调用 on() 进行绑定时，对于类自己的成员函数，
有的小伙伴就写成这样了 $this->on(EVENT_A, 'publicMethod') ，但事实上，这是一个错误的写法。
以字符串的形式提供handler，只能是PHP的全局函数。这是由于handler的调用是通过 call_user_func() 来实现的。
因此，handler的形式，与 call_user_func() 的要求是一致的。
这里字符串的形式 publicMethod 是类成员函数，不是全局函数，所以会报错，不能用。

#### 事件的绑定与解除

##### 事件的绑定

有了事件handler，还要告诉Yii，这个handler是负责处理哪种事件的。这个过程，就是事件的绑定。

yii\base\Component::on() 就是用来绑定的，很容易就猜到， yii\base\Component::off() 就是用来解除的。对于绑定，有以下形式:
```
$person = new Person;  // 继承自yii\base\Component

// 使用PHP全局函数作为handler来进行绑定
$person->on(Person::EVENT_GREET, 'person_say_hello');

// 使用对象$obj的成员函数say_hello来进行绑定
$person->on(Person::EVENT_GREET, [$obj, 'say_hello']);

// 使用类Greet的静态成员函数say_hello进行绑定
$person->on(Person::EVENT_GREET, ['app\helper\Greet', 'say_hello']);

// 使用匿名函数
$person->on(Person::EVENT_GREET, function ($event) {
    echo 'Hello';
});
```

保存在yii\base\Component中的private $_events的数据结构：
```
$_events[Person::EVENT_GREET] = [
    [
        'person_say_hello',
        null
    ],
    [
        [$obj, 'say_hello'],
        null
    ],
    [
        ['app\helper\Greet', 'say_hello'],
        null
    ],
    [
        function ($event) {
            echo 'Hello';
        },
        null
    ],    
];
```

事件的绑定可以像上面这样在运行时以代码的形式进行绑定，也可以在配置中进行绑定。 
当然，这个配置生效的过程其实也是在运行时的。原理见 配置项（Configuration） 部分的内容。

上面的例子只是简单的绑定了事件与事件handler，如果有额外的数据传递给handler，
可以使用 yii\base\Component::on() 的第三个参数。这个参数将会写进 Event 的相关数据字段，即属性 data 。如:
```
$person->on(Person::EVENT_GREET, 'person_say_hello', 'Hello World!');

// 'Hello World!' 可以通过 $event访问。
function person_say_hello($event)
{
    echo $event->data;                // 将显示 Hello World!
}
```

保存在yii\base\Component中的private $_events的数据结构：
```
$_events[Person::EVENT_GREET] = [
    [
        'person_say_hello',
        'Hello World!'
    ]
];
```

yii\base\Component 维护了一个handler数组，用来保存绑定的handler:
```
// 这个就是handler数组
private _events = [];

// 绑定过程就是将handler写入_event[]
public function on($name, $handler, $data = null, $append = true)
{
    $this->ensureBehaviors();
    if ($append || empty($this->_events[$name])) {
        $this->_events[$name][] = [$handler, $data];
    } else {
        array_unshift($this->_events[$name], [$handler, $data]);
    }
}
```

##### 保存handler的数据结构

从上面代码我们可以了解两个方向的内容，一是 $_event[] 的数据结构，二是绑定handler的逻辑。

从handler数组 $_evnet[] 的结构看，首先他是一个数组，保存了该Component的所有事件handler。 
该数组的下标为事件名，数组元素是形为 [$handler, $data] 的一系列数组。

在事件的绑定逻辑上，按照以下顺序：

* 参数 $append 是否为 true 。为 true 表示所要绑定的事件handler要放在 $_event[] 数组的最后面。这也是默认的绑定方式。
* 参数 $append 是否为 false 。表示handler要放在数组的最前面。这个时候，要多进行一次判定。
* 如果所有绑定的事件还没有已经绑定好的handler，也就是说，将要绑定的handler是第一个，那么无论 $append 是否是 true ，
该handler必然是第一个元素，也是最后一个元素。
* 如果 $append 为 false ，且要绑定的事件已经有了handler，那么，就将新绑定的事件插入到数组的最前面。

handler在 $_event[] 数组中的位置很重要，代表的是执行的先后顺序。这个在 多个事件handler的顺序 中会讲到。

##### 事件的解除

在解除时，就是使用 unset() 函数，处理 $_event[] 数组的相应元素。 yii\base\Component::off() 如下所示:
```
public function off($name, $handler = null)
{
    $this->ensureBehaviors();
    if (empty($this->_events[$name])) {
        return false;
    }

    // $handler === null 时解除$name的所有handler
    if ($handler === null) {
        unset($this->_events[$name]);
        return true;
    } else {
        $removed = false;

        // 遍历所有的 $handler
        foreach ($this->_events[$name] as $i => $event) {
            // 清楚指定事件处理函数$handler这一条
            if ($event[0] === $handler) {
                unset($this->_events[$name][$i]);
                $removed = true;
            }
        }
        if ($removed) {
            $this->_events[$name] = array_values($this->_events[$name]);
        }
        return $removed;
    }
}
```

要留意以下几点：

* 当 $handler 为 null 时，表示解除 $name 事件的所有handler。
* 在解除 $handler 时，将会解除所有的这个事件下的 $handler 。虽然一个handler多次绑定在同一事件上的情况不多见，
但这并不是没有，也不是没有意义的事情。在特定的情况下，确实有一个handler多次绑定在同一事件上。因此在解除时，
所有的 $handler 都会被解除。而且没有办法只解除其中的一两个。

#### 事件的触发

事件的处理程序handler有了，事件与事件handler关联好了，那么只要事件触发了，handler就会按照设计的路子走。
事件的触发，需要调用 yii\base\Component::trigger()
```
public function trigger($name, Event $event = null)
{
    $this->ensureBehaviors();
    if (!empty($this->_events[$name])) {
        if ($event === null) {
            $event = new Event;
        }
        if ($event->sender === null) {
            $event->sender = $this;
        }
        $event->handled = false;
        $event->name = $name;

        // 遍历handler数组，并依次调用
        foreach ($this->_events[$name] as $handler) {
            $event->data = $handler[1];

            // 使用PHP的call_user_func调用handler
            call_user_func($handler[0], $event);

            // 如果在某一handler中，将$evnet->handled 设为true，就不再调用后续的handler
            if ($event->handled) {
                return;
            }
        }
    }
    Event::trigger($this, $name, $event);   // 触发类一级的事件
}
```

以 yii\base\Application 为例，他定义了两个事件， EVENT_BEFORE_REQUEST EVENT_AFTER_REQUEST 分别在处理请求的前后触发:
```
abstract class Application extends Module
{
    // 定义了两个事件
    const EVENT_BEFORE_REQUEST = 'beforeRequest';
    const EVENT_AFTER_REQUEST = 'afterRequest';

    public function run()
    {
        try {

            $this->state = self::STATE_BEFORE_REQUEST;

            // 先触发EVENT_BEFORE_REQUEST
            $this->trigger(self::EVENT_BEFORE_REQUEST);

            $this->state = self::STATE_HANDLING_REQUEST;

            // 处理Request
            $response = $this->handleRequest($this->getRequest());

            $this->state = self::STATE_AFTER_REQUEST;

            // 处理完毕后触发EVENT_AFTER_REQUEST
            $this->trigger(self::EVENT_AFTER_REQUEST);

            $this->state = self::STATE_SENDING_RESPONSE;
            $response->send();

            $this->state = self::STATE_END;

            return $response->exitStatus;

        } catch (ExitException $e) {

            $this->end($e->statusCode, isset($response) ? $response : null);
            return $e->statusCode;

        }
    }
}
```

对于事件的定义，提倡使用const 常量的形式，可以避免写错。 
trigger('Hello') 和 trigger('hello') 可是不同的事件哦。原因在于handler数组下标，就是事件名。 
而PHP里数组下标是区分大小写的。所以，用类常量的方式，可以避免这种头疼的问题。

在触发事件时，可以把与事件相关的数据传递给所有的handler。比如，发布新微博事件:
```
// 定义事件的关联数据
class MsgEvent extend yii\base\Event
{
    public $dateTime;   // 微博发出的时间
    public $author;     // 微博的作者
    public $content;    // 微博的内容
}

// 在发布新的微博时，准备好要传递给handler的数据
$event = new MsgEvent;
$event->author = $auhtor;
$event->content = $content;

// 触发事件，$msg对象继承自Component
$msg->trigger(Msg::EVENT_NEW_MESSAGE, $event);
```

注意这里数据的传入，与使用 on() 绑定handler时传入数据方法的不同。
在 on() 中，使用一个简单变量，传入，并在handler中通过 $event->data 进行访问。这个是在绑定时确定的数据。
而有的数据是没办法在绑定时确定的，如发出微博的时间。这个时候，就需要在触发事件时提供其他的数据了。也就是上面这段代码使用的方法了。
这两种方法，一种用于提供绑定时的相关数据，一种用于提供事件触发时的数据，各有所长，互相补充。

#### 多个事件handler的顺序

使用 yii\base\Component::on() 可以为各种事件绑定handler，也可以为同一事件绑定多个handler。
假如，你是微博系统的技术人员，刚开始的时候，你指定新发微博的事件handler就是通知关注者有新的内容发布了。
现在，你不光要保留这个功能，你还要通知微博中@到的所有人。这个时候，一种做法是直接在原来的handler末尾加上新的代码，以处理这个新的需要。
另一个方法，就是再写一个handler，并绑定到这个事件上。从易于维护的角度来讲，第二种方法是比较合理的。
前一种方法由于修改了原来正常使用的代码，可能会影响原来的正常功能。
同时，如果一直有新的需求，那么很快这个handler就会变得很杂，很大。所以，建议使用第二种方法。

Yii中是支持这种一对多的绑定的。那么，在一个事件触发时，哪个handler会被先执行呢？各handler之间总有一个先后问题吧。
这个可能不同的编程语言、不同的框架有不同的实现方式。有的语言是以堆栈的形式来保存handler，可能会以后绑定上去的事件先执行的方式运作。
这种方式的好处是编码的人权限大些，可以对事件进行更改、拦截、中止，移花接木、偷天换日、无中生有，各种欺骗后面的handler。
而Yii是使用数组来保存handler的，并按顺序执行这些handler。这意味着一般框架上预设的handler会先执行。
但是不要以为Yii的事件handler就没办法偷天换日了，要使后加上的事件handler先运行，只需在调用 yii\base\Component::on() 进行绑定时，
将第四个参数设为 $append 设为 false 那么这个handler就会被放在数组的最前面了，它就会被最先执行，它也就有可能欺骗后面的handler了。

为了加强安全生产，国家安监局对某个煤矿进行监管，一旦发生矿难，他们会收到报警，这就是一个事件和一个handler:
```
$coal->on(Coal::EVENT_DISASTER, [$government, 'onDisaster']);

class Government extend yii\base\Component
{
    ... ...

    public function onDisaster($event)
    {
        echo 'DISASTER! from ' . $event->sender;
    }
}
```

由于煤矿自身也要进行管理，所以，政府允许煤矿可以编写自己的handler对矿难进行处理。 
但是，这个小煤窑的老板，你有张良计，我有过墙梯，对于发生矿难这一事件编写了一个handler专门用于瞒报:
```
// 第四个参数设为false，使得该handler在整个handler数组中处于第一个
$coal->on(Coal::EVENT_DISASTER, [$baddy, 'onDisaster'], null, false);

calss Baddy extend yii\base\Component
{
    ... ...

    public function onDisaster($event)
    {
        // 将事件标记为已经处理完毕，阻止后续事件handler介入。
        $event->handled = true;
    }
}
```

我们要阻止他，所以要把绑定好的handler解除。这个解除是绑定的逆向过程，在实质上，
就是把对应的handler从handler数组中删除。使用 yii\base\Component::off() 就能删除:
```
// 删除所有EVENT_DISASTER事件的handler
$coal->off(Coal::EVENT_DISASTER);

// 删除一个PHP全局函数的handler
$coal->off(Coal::EVENT_DISASTER, 'global_onDisaster');

// 删除一个对象的成员函数的handler
$coal->off(Coal::EVENT_DISASTER, [$baddy, 'onDisaster']);

// 删除一个类的静态成员函数的handler
$coal->off(Coal::EVENT_DISASTER, ['path\to\Baddy', 'static_onDisaster']);

// 删除一个匿名函数的handler
$coal->off(Coal::EVENT_DISASTER, $anonymousFunction);
```

其中，第三种方法就可以把小煤窑老板的handler解除下来。

细心的读者朋友可能留意到，在删除匿名函数handler时，需要使用一个变量。请读者朋友留意，
就算你调用 yii\base\Component::on() yii\base\Component::off() 时，写了两个一模一样的匿名函数，
你也没办法把你前面的匿名handler解除。从本质上来讲，两个匿名函数就是两个不同的存在，为了能够正确解除，
需要先把匿名handler保存成一个变量，如上面的 $anonymousFunction ，然后再依次绑定、解除。但是，使用了变量后，
就失去了匿名函数的一大心理上的优势，你本不用去关心他的，我的建议是在这种情况下，就不要使用匿名函数了。因此，
在作为handler时，要慎重使用匿名函数。只有在确定不需要解除时，才可以使用。

#### 事件的级别

前面的事件，都是针对类的实例而言的，也就是事件的触发、处理全部都在实例范围内。这种级别的事件用情专一，不与类的其他实例发生关系，
也不与其他类、其他实例发生关系。除了实例级别的事件外，还有类级别的事件。对于Yii，由于Application是一个单例，
所有的代码都可以访问这个单例。因此，是一个特殊级别的事件，全局事件。但是，本质上，他只是一个实例级别的事件。

这就好比是公司里的不同阶层。底层的码农们只能自己发发牢骚，个人的喜怒哀乐只发生在自己身上，影响不了其他人。
而团队负责人如果心情不好，整个团队的所有成员今天都要战战兢兢，慎言慎行。到了公司老总那里，他今天不爽，
哪个不长眼的敢上去触霉头？事件也是这样的，不同层次的事件，决定了他影响到的范围。

##### 类级别事件

先讲讲类级别的事件。类级别事件用于响应所有类实例的事件。比如，工头需要了解所有工人的下班时间， 
那么，对于数百个工人，即数百个Worker实例，工头难道要一个一个去绑定自己的handler么？ 这也太低级了吧？
其实，他只需要绑定一个handler到Worker类，这样每个工人下班时，他都能知道了。 
与实例级别的事件不同，类级别事件的绑定需要使用 yii\base\Event::on()
```
Event::on(
    Worker::className(),                     // 第一个参数表示事件发生的类
    Worker::EVENT_OFF_DUTY,                  // 第二个参数表示是什么事件
    function ($event) {                      // 对事件的处理
        echo $event->sender . ' 下班了';
    }
);
```

现在Event中的private static $_events储存的数据结构：
```
$_events[Worker::EVENT_OFF_DUTY][Worker::className()][] = [
    [
        function ($event) {                     
            echo $event->sender . ' 下班了';
        },
        null
    ]
];
```

这样，每个工人下班时，会触发自己的事件处理函数，比如去打卡。之后，会触发类级别事件。 
类级别事件的触发仍然是在 yii\base\Component::trigger() 中，还记得该函数的最后一个语句么:
```
Event::trigger($this, $name, $event);                // 触发类一级的事件
```

这里就是这样：
```
Event::trigger(new Worker, Worker::EVENT_OFF_DUTY, new Event); 
```

这个语句就触发了类级别的事件。类级别事件，总是在实例事件后触发。既然触发时机靠后，那么如果有一天你要早退又不想老板知道，
你就可以向小煤窑老板那样，通过 $event->handled = true ，来终止事件处理。

从 yii\base\Event::trigger() 的参数列表来看，比 yii\base\Component::trigger() 多了一个参数 $class 表示这是哪个类的事件。
因此，在保存 $_event[] 数组上， yii\base\Event 也比 yii\base\Component 要多一个维度:
```
// Component中的$_event[] 数组
$_event[$eventName][] = [$handler, $data];

// Event中的$_event[] 数组
$_event[$eventName][$calssName][] = [$handler, $data];
```

那么，反过来的话，低级别的handler可以在高级别事件发生时发生作用么？这当然也是不行的。由于类级别事件不与任意的实例相关联，
所以，类级别事件触发时，类的实例可能都还没有呢，怎么可能进行处理呢？

类级别事件的触发，应使用 yii\base\Event::trigger() 。这个函数不会触发实例级别的事件。
值得注意的是， $event->sender 。在实例级别事件中， $event->sender 指向触发事件的实例，而在类级别事件中， 指向的是类名。
在 yii\base\Event::trigger() 代码中，有:
```
if (is_object($class)) {        // $class 是trigger()的第一个参数，表示类名
    if ($event->sender === null) {
        $event->sender = $class;
    }
    $class = get_class($class); // 传入的是一个实例，则以类名替换之
} else {
    $class = ltrim($class, '\\');
}
```

这段代码会对 $evnet->sender 进行设置，如果传入的时候，已经指定了他的值，那么这个值会保留，否则，就会替换成类名。

对于类级别事件，有一个要格外注意的地方，就是他不光会触发自身这个类的事件，
这个类的所有祖先类的同一事件也会被触发。但是，自身类事件与所有祖先类的事件，视为同一级别:
```
// 最外面的循环遍历所有祖先类
do {
    if (!empty(self::$_events[$name][$class])) {
        foreach (self::$_events[$name][$class] as $handler) {
            $event->data = $handler[1];
            call_user_func($handler[0], $event);

            // 所有的事件都是同一级别，可以随时终止
            if ($event->handled) {
                return;
            }
        }
    }
} while (($class = get_parent_class($class)) !== false);
```

上面的嵌套循环的深度，或者叫时间复杂度，受两个方面影响，一是类继承结构的深度，二是 $_event[$name][$class][] 数组的元素个数，
即已经绑定的handler的数量。从实践经验看，一般软件工程继承深度超过十层的就很少见，而事件绑定上，同一事件的绑定handler超过十几个也比较少见。
因此，上面的嵌套循环运算数量级大约在100～1000之间，这是可以接受的。

但是，从机制上来讲，由于类级别事件会被类自身、类的实例、后代类、后代类实例所触发，所以，对于越底层的类而言，
其类事件的影响范围就越大。因此，在使用类事件上要注意，尽可能往后代类安排，以控制好影响范围，尽可能不在基础类上安排类事件。

##### 全局事件

接下来再讲讲全局级别事件。上面提到过，所谓的全局事件，本质上只是一个实例事件罢了。
他只是利用了Application实例在整个应用的生命周期中全局可访问的特性，来实现这个全局事件的。
当然，你也可以将他绑定在任意全局可访问的的Component上。

全局事件一个最大优势在于：在任意需要的时候，都可以触发全局事件，也可以在任意必要的时候绑定，或解除一个事件:
```
Yii::$app->on('bar', function ($event) {
    echo get_class($event->sender);        // 显示当前触发事件的对象的类名称
});
```

此时Component中的private $_events的数据结构是：
```
$_events['bar'][] = [
    [
        function ($event) {                     
            echo get_class($event->sender);
        },
        null
    ]
];
```

触发全局事件:
```
Yii::$app->trigger('bar', new Event(['sender' => $this]));
```

call_user_func的调用结构：
```
call_user_func(
    function ($event) {                     
        echo get_class($event->sender);
    },
    new Event(['sender' => $this, 'data' => null])
);
```

上面的 Yii::$app->on() 可以在任何地方调用，就可以完成事件的绑定。而 Yii::$app->trigger() 只要在绑定之后的任何时候调用就OK了。

#### 源码

yii\base\Componentn源码：
```
<?php
namespace yii\base;

use Yii;

/**
 * Component is the base class that implements the *property*, *event* and *behavior* features.
 *
 * Component provides the *event* and *behavior* features, in addition to the *property* feature which is implemented in
 * its parent class [[\yii\base\Object|Object]].
 *
 * Event is a way to "inject" custom code into existing code at certain places. For example, a comment object can trigger
 * an "add" event when the user adds a comment. We can write custom code and attach it to this event so that when the event
 * is triggered (i.e. comment will be added), our custom code will be executed.
 *
 * An event is identified by a name that should be unique within the class it is defined at. Event names are *case-sensitive*.
 *
 * One or multiple PHP callbacks, called *event handlers*, can be attached to an event. You can call [[trigger()]] to
 * raise an event. When an event is raised, the event handlers will be invoked automatically in the order they were
 * attached.
 *
 * To attach an event handler to an event, call [[on()]]:
 *
 * 
 * $post->on('update', function ($event) {
 *     // send email notification
 * });
 * 
 *
 * In the above, an anonymous function is attached to the "update" event of the post. You may attach
 * the following types of event handlers:
 *
 * - anonymous function: `function ($event) { ... }`
 * - object method: `[$object, 'handleAdd']`
 * - static class method: `['Page', 'handleAdd']`
 * - global function: `'handleAdd'`
 *
 * The signature of an event handler should be like the following:
 *
 * 
 * function foo($event)
 * 
 *
 * where `$event` is an [[Event]] object which includes parameters associated with the event.
 *
 * You can also attach a handler to an event when configuring a component with a configuration array.
 * The syntax is like the following:
 *
 * 
 * [
 *     'on add' => function ($event) { ... }
 * ]
 * 
 *
 * where `on add` stands for attaching an event to the `add` event.
 *
 * Sometimes, you may want to associate extra data with an event handler when you attach it to an event
 * and then access it when the handler is invoked. You may do so by
 *
 * 
 * $post->on('update', function ($event) {
 *     // the data can be accessed via $event->data
 * }, $data);
 * 
 *
 * A behavior is an instance of [[Behavior]] or its child class. A component can be attached with one or multiple
 * behaviors. When a behavior is attached to a component, its public properties and methods can be accessed via the
 * component directly, as if the component owns those properties and methods.
 *
 * To attach a behavior to a component, declare it in [[behaviors()]], or explicitly call [[attachBehavior]]. Behaviors
 * declared in [[behaviors()]] are automatically attached to the corresponding component.
 *
 * One can also attach a behavior to a component when configuring it with a configuration array. The syntax is like the
 * following:
 *
 * 
 * [
 *     'as tree' => [
 *         'class' => 'Tree',
 *     ],
 * ]
 * 
 *
 * where `as tree` stands for attaching a behavior named `tree`, and the array will be passed to [[\Yii::createObject()]]
 * to create the behavior object.
 *
 * For more details and usage information on Component, see the [guide article on components](guide:concept-components).
 *
 * @property Behavior[] $behaviors List of behaviors attached to this component. This property is read-only.
 *
 */
class Component extends Object
{
    /**
     * @var array the attached event handlers (event name => handlers)
     */
    private $_events = [];
    /**
     * @var Behavior[]|null the attached behaviors (behavior name => behavior). This is `null` when not initialized.
     */
    private $_behaviors;


    /**
     * Returns the value of a component property.
     * This method will check in the following order and act accordingly:
     *
     *  - a property defined by a getter: return the getter result
     *  - a property of a behavior: return the behavior property value
     *
     * Do not call this method directly as it is a PHP magic method that
     * will be implicitly called when executing `$value = $component->property;`.
     * @param string $name the property name
     * @return mixed the property value or the value of a behavior's property
     * @throws UnknownPropertyException if the property is not defined
     * @throws InvalidCallException if the property is write-only.
     * @see __set()
     */
    public function __get($name)
    {
        $getter = 'get' . $name;
        if (method_exists($this, $getter)) {
            // read property, e.g. getName()
            return $this->$getter();
        }

        // behavior property
        $this->ensureBehaviors();
        foreach ($this->_behaviors as $behavior) {
            if ($behavior->canGetProperty($name)) {
                return $behavior->$name;
            }
        }

        if (method_exists($this, 'set' . $name)) {
            throw new InvalidCallException('Getting write-only property: ' . get_class($this) . '::' . $name);
        }

        throw new UnknownPropertyException('Getting unknown property: ' . get_class($this) . '::' . $name);
    }

    /**
     * Sets the value of a component property.
     * This method will check in the following order and act accordingly:
     *
     *  - a property defined by a setter: set the property value
     *  - an event in the format of "on xyz": attach the handler to the event "xyz"
     *  - a behavior in the format of "as xyz": attach the behavior named as "xyz"
     *  - a property of a behavior: set the behavior property value
     *
     * Do not call this method directly as it is a PHP magic method that
     * will be implicitly called when executing `$component->property = $value;`.
     * @param string $name the property name or the event name
     * @param mixed $value the property value
     * @throws UnknownPropertyException if the property is not defined
     * @throws InvalidCallException if the property is read-only.
     * @see __get()
     */
    public function __set($name, $value)
    {
        $setter = 'set' . $name;
        if (method_exists($this, $setter)) {
            // set property
            $this->$setter($value);

            return;
        } elseif (strncmp($name, 'on ', 3) === 0) {
            // on event: attach event handler
            $this->on(trim(substr($name, 3)), $value);

            return;
        } elseif (strncmp($name, 'as ', 3) === 0) {
            // as behavior: attach behavior
            $name = trim(substr($name, 3));
            $this->attachBehavior($name, $value instanceof Behavior ? $value : Yii::createObject($value));

            return;
        }

        // behavior property
        $this->ensureBehaviors();
        foreach ($this->_behaviors as $behavior) {
            if ($behavior->canSetProperty($name)) {
                $behavior->$name = $value;
                return;
            }
        }

        if (method_exists($this, 'get' . $name)) {
            throw new InvalidCallException('Setting read-only property: ' . get_class($this) . '::' . $name);
        }

        throw new UnknownPropertyException('Setting unknown property: ' . get_class($this) . '::' . $name);
    }

    /**
     * Checks if a property is set, i.e. defined and not null.
     * This method will check in the following order and act accordingly:
     *
     *  - a property defined by a setter: return whether the property is set
     *  - a property of a behavior: return whether the property is set
     *  - return `false` for non existing properties
     *
     * Do not call this method directly as it is a PHP magic method that
     * will be implicitly called when executing `isset($component->property)`.
     * @param string $name the property name or the event name
     * @return bool whether the named property is set
     * @see http://php.net/manual/en/function.isset.php
     */
    public function __isset($name)
    {
        $getter = 'get' . $name;
        if (method_exists($this, $getter)) {
            return $this->$getter() !== null;
        }

        // behavior property
        $this->ensureBehaviors();
        foreach ($this->_behaviors as $behavior) {
            if ($behavior->canGetProperty($name)) {
                return $behavior->$name !== null;
            }
        }

        return false;
    }

    /**
     * Sets a component property to be null.
     * This method will check in the following order and act accordingly:
     *
     *  - a property defined by a setter: set the property value to be null
     *  - a property of a behavior: set the property value to be null
     *
     * Do not call this method directly as it is a PHP magic method that
     * will be implicitly called when executing `unset($component->property)`.
     * @param string $name the property name
     * @throws InvalidCallException if the property is read only.
     * @see http://php.net/manual/en/function.unset.php
     */
    public function __unset($name)
    {
        $setter = 'set' . $name;
        if (method_exists($this, $setter)) {
            $this->$setter(null);
            return;
        }

        // behavior property
        $this->ensureBehaviors();
        foreach ($this->_behaviors as $behavior) {
            if ($behavior->canSetProperty($name)) {
                $behavior->$name = null;
                return;
            }
        }

        throw new InvalidCallException('Unsetting an unknown or read-only property: ' . get_class($this) . '::' . $name);
    }

    /**
     * Calls the named method which is not a class method.
     *
     * This method will check if any attached behavior has
     * the named method and will execute it if available.
     *
     * Do not call this method directly as it is a PHP magic method that
     * will be implicitly called when an unknown method is being invoked.
     * @param string $name the method name
     * @param array $params method parameters
     * @return mixed the method return value
     * @throws UnknownMethodException when calling unknown method
     */
    public function __call($name, $params)
    {
        $this->ensureBehaviors();
        foreach ($this->_behaviors as $object) {
            if ($object->hasMethod($name)) {
                return call_user_func_array([$object, $name], $params);
            }
        }
        throw new UnknownMethodException('Calling unknown method: ' . get_class($this) . "::$name()");
    }

    /**
     * This method is called after the object is created by cloning an existing one.
     * It removes all behaviors because they are attached to the old object.
     */
    public function __clone()
    {
        $this->_events = [];
        $this->_behaviors = null;
    }

    /**
     * Returns a value indicating whether a property is defined for this component.
     * A property is defined if:
     *
     * - the class has a getter or setter method associated with the specified name
     *   (in this case, property name is case-insensitive);
     * - the class has a member variable with the specified name (when `$checkVars` is true);
     * - an attached behavior has a property of the given name (when `$checkBehaviors` is true).
     *
     * @param string $name the property name
     * @param bool $checkVars whether to treat member variables as properties
     * @param bool $checkBehaviors whether to treat behaviors' properties as properties of this component
     * @return bool whether the property is defined
     * @see canGetProperty()
     * @see canSetProperty()
     */
    public function hasProperty($name, $checkVars = true, $checkBehaviors = true)
    {
        return $this->canGetProperty($name, $checkVars, $checkBehaviors) || $this->canSetProperty($name, false, $checkBehaviors);
    }

    /**
     * Returns a value indicating whether a property can be read.
     * A property can be read if:
     *
     * - the class has a getter method associated with the specified name
     *   (in this case, property name is case-insensitive);
     * - the class has a member variable with the specified name (when `$checkVars` is true);
     * - an attached behavior has a readable property of the given name (when `$checkBehaviors` is true).
     *
     * @param string $name the property name
     * @param bool $checkVars whether to treat member variables as properties
     * @param bool $checkBehaviors whether to treat behaviors' properties as properties of this component
     * @return bool whether the property can be read
     * @see canSetProperty()
     */
    public function canGetProperty($name, $checkVars = true, $checkBehaviors = true)
    {
        if (method_exists($this, 'get' . $name) || $checkVars && property_exists($this, $name)) {
            return true;
        } elseif ($checkBehaviors) {
            $this->ensureBehaviors();
            foreach ($this->_behaviors as $behavior) {
                if ($behavior->canGetProperty($name, $checkVars)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Returns a value indicating whether a property can be set.
     * A property can be written if:
     *
     * - the class has a setter method associated with the specified name
     *   (in this case, property name is case-insensitive);
     * - the class has a member variable with the specified name (when `$checkVars` is true);
     * - an attached behavior has a writable property of the given name (when `$checkBehaviors` is true).
     *
     * @param string $name the property name
     * @param bool $checkVars whether to treat member variables as properties
     * @param bool $checkBehaviors whether to treat behaviors' properties as properties of this component
     * @return bool whether the property can be written
     * @see canGetProperty()
     */
    public function canSetProperty($name, $checkVars = true, $checkBehaviors = true)
    {
        if (method_exists($this, 'set' . $name) || $checkVars && property_exists($this, $name)) {
            return true;
        } elseif ($checkBehaviors) {
            $this->ensureBehaviors();
            foreach ($this->_behaviors as $behavior) {
                if ($behavior->canSetProperty($name, $checkVars)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Returns a value indicating whether a method is defined.
     * A method is defined if:
     *
     * - the class has a method with the specified name
     * - an attached behavior has a method with the given name (when `$checkBehaviors` is true).
     *
     * @param string $name the property name
     * @param bool $checkBehaviors whether to treat behaviors' methods as methods of this component
     * @return bool whether the method is defined
     */
    public function hasMethod($name, $checkBehaviors = true)
    {
        if (method_exists($this, $name)) {
            return true;
        } elseif ($checkBehaviors) {
            $this->ensureBehaviors();
            foreach ($this->_behaviors as $behavior) {
                if ($behavior->hasMethod($name)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Returns a list of behaviors that this component should behave as.
     *
     * Child classes may override this method to specify the behaviors they want to behave as.
     *
     * The return value of this method should be an array of behavior objects or configurations
     * indexed by behavior names. A behavior configuration can be either a string specifying
     * the behavior class or an array of the following structure:
     *
     * ```php
     * 'behaviorName' => [
     *     'class' => 'BehaviorClass',
     *     'property1' => 'value1',
     *     'property2' => 'value2',
     * ]
     * ```
     *
     * Note that a behavior class must extend from [[Behavior]]. Behaviors can be attached using a name or anonymously.
     * When a name is used as the array key, using this name, the behavior can later be retrieved using [[getBehavior()]]
     * or be detached using [[detachBehavior()]]. Anonymous behaviors can not be retrieved or detached.
     *
     * Behaviors declared in this method will be attached to the component automatically (on demand).
     *
     * @return array the behavior configurations.
     */
    public function behaviors()
    {
        return [];
    }

    /**
     * Returns a value indicating whether there is any handler attached to the named event.
     * @param string $name the event name
     * @return bool whether there is any handler attached to the event.
     */
    public function hasEventHandlers($name)
    {
        $this->ensureBehaviors();
        return !empty($this->_events[$name]) || Event::hasHandlers($this, $name);
    }

    /**
     * Attaches an event handler to an event.
     *
     * The event handler must be a valid PHP callback. The following are
     * some examples:
     *
     * ```
     * function ($event) { ... }         // anonymous function
     * [$object, 'handleClick']          // $object->handleClick()
     * ['Page', 'handleClick']           // Page::handleClick()
     * 'handleClick'                     // global function handleClick()
     * ```
     *
     * The event handler must be defined with the following signature,
     *
     * ```
     * function ($event)
     * ```
     *
     * where `$event` is an [[Event]] object which includes parameters associated with the event.
     *
     * @param string $name the event name
     * @param callable $handler the event handler
     * @param mixed $data the data to be passed to the event handler when the event is triggered.
     * When the event handler is invoked, this data can be accessed via [[Event::data]].
     * @param bool $append whether to append new event handler to the end of the existing
     * handler list. If false, the new handler will be inserted at the beginning of the existing
     * handler list.
     * @see off()
     */
    public function on($name, $handler, $data = null, $append = true)
    {
        $this->ensureBehaviors();
        if ($append || empty($this->_events[$name])) {
            $this->_events[$name][] = [$handler, $data];
        } else {
            array_unshift($this->_events[$name], [$handler, $data]);
        }
    }

    /**
     * Detaches an existing event handler from this component.
     * This method is the opposite of [[on()]].
     * @param string $name event name
     * @param callable $handler the event handler to be removed.
     * If it is null, all handlers attached to the named event will be removed.
     * @return bool if a handler is found and detached
     * @see on()
     */
    public function off($name, $handler = null)
    {
        $this->ensureBehaviors();
        if (empty($this->_events[$name])) {
            return false;
        }
        if ($handler === null) {
            unset($this->_events[$name]);
            return true;
        }

        $removed = false;
        foreach ($this->_events[$name] as $i => $event) {
            if ($event[0] === $handler) {
                unset($this->_events[$name][$i]);
                $removed = true;
            }
        }
        if ($removed) {
            $this->_events[$name] = array_values($this->_events[$name]);
        }
        return $removed;
    }

    /**
     * Triggers an event.
     * This method represents the happening of an event. It invokes
     * all attached handlers for the event including class-level handlers.
     * @param string $name the event name
     * @param Event $event the event parameter. If not set, a default [[Event]] object will be created.
     */
    public function trigger($name, Event $event = null)
    {
        $this->ensureBehaviors();
        if (!empty($this->_events[$name])) {
            if ($event === null) {
                $event = new Event;
            }
            if ($event->sender === null) {
                $event->sender = $this;
            }
            $event->handled = false;
            $event->name = $name;
            foreach ($this->_events[$name] as $handler) {
                $event->data = $handler[1];
                call_user_func($handler[0], $event);
                // stop further handling if the event is handled
                if ($event->handled) {
                    return;
                }
            }
        }
        // invoke class-level attached handlers
        Event::trigger($this, $name, $event);
    }

    /**
     * Returns the named behavior object.
     * @param string $name the behavior name
     * @return null|Behavior the behavior object, or null if the behavior does not exist
     */
    public function getBehavior($name)
    {
        $this->ensureBehaviors();
        return isset($this->_behaviors[$name]) ? $this->_behaviors[$name] : null;
    }

    /**
     * Returns all behaviors attached to this component.
     * @return Behavior[] list of behaviors attached to this component
     */
    public function getBehaviors()
    {
        $this->ensureBehaviors();
        return $this->_behaviors;
    }

    /**
     * Attaches a behavior to this component.
     * This method will create the behavior object based on the given
     * configuration. After that, the behavior object will be attached to
     * this component by calling the [[Behavior::attach()]] method.
     * @param string $name the name of the behavior.
     * @param string|array|Behavior $behavior the behavior configuration. This can be one of the following:
     *
     *  - a [[Behavior]] object
     *  - a string specifying the behavior class
     *  - an object configuration array that will be passed to [[Yii::createObject()]] to create the behavior object.
     *
     * @return Behavior the behavior object
     * @see detachBehavior()
     */
    public function attachBehavior($name, $behavior)
    {
        $this->ensureBehaviors();
        return $this->attachBehaviorInternal($name, $behavior);
    }

    /**
     * Attaches a list of behaviors to the component.
     * Each behavior is indexed by its name and should be a [[Behavior]] object,
     * a string specifying the behavior class, or an configuration array for creating the behavior.
     * @param array $behaviors list of behaviors to be attached to the component
     * @see attachBehavior()
     */
    public function attachBehaviors($behaviors)
    {
        $this->ensureBehaviors();
        foreach ($behaviors as $name => $behavior) {
            $this->attachBehaviorInternal($name, $behavior);
        }
    }

    /**
     * Detaches a behavior from the component.
     * The behavior's [[Behavior::detach()]] method will be invoked.
     * @param string $name the behavior's name.
     * @return null|Behavior the detached behavior. Null if the behavior does not exist.
     */
    public function detachBehavior($name)
    {
        $this->ensureBehaviors();
        if (isset($this->_behaviors[$name])) {
            $behavior = $this->_behaviors[$name];
            unset($this->_behaviors[$name]);
            $behavior->detach();
            return $behavior;
        }

        return null;
    }

    /**
     * Detaches all behaviors from the component.
     */
    public function detachBehaviors()
    {
        $this->ensureBehaviors();
        foreach ($this->_behaviors as $name => $behavior) {
            $this->detachBehavior($name);
        }
    }

    /**
     * Makes sure that the behaviors declared in [[behaviors()]] are attached to this component.
     */
    public function ensureBehaviors()
    {
        if ($this->_behaviors === null) {
            $this->_behaviors = [];
            foreach ($this->behaviors() as $name => $behavior) {
                $this->attachBehaviorInternal($name, $behavior);
            }
        }
    }

    /**
     * Attaches a behavior to this component.
     * @param string|int $name the name of the behavior. If this is an integer, it means the behavior
     * is an anonymous one. Otherwise, the behavior is a named one and any existing behavior with the same name
     * will be detached first.
     * @param string|array|Behavior $behavior the behavior to be attached
     * @return Behavior the attached behavior.
     */
    private function attachBehaviorInternal($name, $behavior)
    {
        if (!($behavior instanceof Behavior)) {
            $behavior = Yii::createObject($behavior);
        }
        if (is_int($name)) {
            $behavior->attach($this);
            $this->_behaviors[] = $behavior;
        } else {
            if (isset($this->_behaviors[$name])) {
                $this->_behaviors[$name]->detach();
            }
            $behavior->attach($this);
            $this->_behaviors[$name] = $behavior;
        }

        return $behavior;
    }
}
```

看一下 yii\base\Event 的源码：
```
<?php
namespace yii\base;

/**
 * Event is the base class for all event classes.
 *
 * It encapsulates the parameters associated with an event.
 * The [[sender]] property describes who raises the event.
 * And the [[handled]] property indicates if the event is handled.
 * If an event handler sets [[handled]] to be `true`, the rest of the
 * uninvoked handlers will no longer be called to handle the event.
 *
 * Additionally, when attaching an event handler, extra data may be passed
 * and be available via the [[data]] property when the event handler is invoked.
 *
 */
class Event extends Object
{
    /**
     * @var string the event name. This property is set by [[Component::trigger()]] and [[trigger()]].
     * Event handlers may use this property to check what event it is handling.
     */
    public $name;
    /**
     * @var object the sender of this event. If not set, this property will be
     * set as the object whose `trigger()` method is called.
     * This property may also be a `null` when this event is a
     * class-level event which is triggered in a static context.
     */
    public $sender;
    /**
     * @var bool whether the event is handled. Defaults to `false`.
     * When a handler sets this to be `true`, the event processing will stop and
     * ignore the rest of the uninvoked event handlers.
     */
    public $handled = false;
    /**
     * @var mixed the data that is passed to [[Component::on()]] when attaching an event handler.
     * Note that this varies according to which event handler is currently executing.
     */
    public $data;

    /**
     * @var array contains all globally registered event handlers.
     */
    private static $_events = [];


    /**
     * Attaches an event handler to a class-level event.
     *
     * When a class-level event is triggered, event handlers attached
     * to that class and all parent classes will be invoked.
     *
     * For example, the following code attaches an event handler to `ActiveRecord`'s
     * `afterInsert` event:
     *
     * ```php
     * Event::on(ActiveRecord::className(), ActiveRecord::EVENT_AFTER_INSERT, function ($event) {
     *     Yii::trace(get_class($event->sender) . ' is inserted.');
     * });
     * ```
     *
     * The handler will be invoked for EVERY successful ActiveRecord insertion.
     *
     * For more details about how to declare an event handler, please refer to [[Component::on()]].
     *
     * @param string $class the fully qualified class name to which the event handler needs to attach.
     * @param string $name the event name.
     * @param callable $handler the event handler.
     * @param mixed $data the data to be passed to the event handler when the event is triggered.
     * When the event handler is invoked, this data can be accessed via [[Event::data]].
     * @param bool $append whether to append new event handler to the end of the existing
     * handler list. If `false`, the new handler will be inserted at the beginning of the existing
     * handler list.
     * @see off()
     */
    public static function on($class, $name, $handler, $data = null, $append = true)
    {
        $class = ltrim($class, '\\');
        if ($append || empty(self::$_events[$name][$class])) {
            self::$_events[$name][$class][] = [$handler, $data];
        } else {
            array_unshift(self::$_events[$name][$class], [$handler, $data]);
        }
    }

    /**
     * Detaches an event handler from a class-level event.
     *
     * This method is the opposite of [[on()]].
     *
     * @param string $class the fully qualified class name from which the event handler needs to be detached.
     * @param string $name the event name.
     * @param callable $handler the event handler to be removed.
     * If it is `null`, all handlers attached to the named event will be removed.
     * @return bool whether a handler is found and detached.
     * @see on()
     */
    public static function off($class, $name, $handler = null)
    {
        $class = ltrim($class, '\\');
        if (empty(self::$_events[$name][$class])) {
            return false;
        }
        if ($handler === null) {
            unset(self::$_events[$name][$class]);
            return true;
        }

        $removed = false;
        foreach (self::$_events[$name][$class] as $i => $event) {
            if ($event[0] === $handler) {
                unset(self::$_events[$name][$class][$i]);
                $removed = true;
            }
        }
        if ($removed) {
            self::$_events[$name][$class] = array_values(self::$_events[$name][$class]);
        }
        return $removed;
    }

    /**
     * Detaches all registered class-level event handlers.
     * @see on()
     * @see off()
     * @since 2.0.10
     */
    public static function offAll()
    {
        self::$_events = [];
    }

    /**
     * Returns a value indicating whether there is any handler attached to the specified class-level event.
     * Note that this method will also check all parent classes to see if there is any handler attached
     * to the named event.
     * @param string|object $class the object or the fully qualified class name specifying the class-level event.
     * @param string $name the event name.
     * @return bool whether there is any handler attached to the event.
     */
    public static function hasHandlers($class, $name)
    {
        if (empty(self::$_events[$name])) {
            return false;
        }
        if (is_object($class)) {
            $class = get_class($class);
        } else {
            $class = ltrim($class, '\\');
        }

        $classes = array_merge(
            [$class],
            class_parents($class, true),
            class_implements($class, true)
        );

        foreach ($classes as $class) {
            if (!empty(self::$_events[$name][$class])) {
                return true;
            }
        }

        return false;
    }

    /**
     * Triggers a class-level event.
     * This method will cause invocation of event handlers that are attached to the named event
     * for the specified class and all its parent classes.
     * @param string|object $class the object or the fully qualified class name specifying the class-level event.
     * @param string $name the event name.
     * @param Event $event the event parameter. If not set, a default [[Event]] object will be created.
     */
    public static function trigger($class, $name, $event = null)
    {
        if (empty(self::$_events[$name])) {
            return;
        }
        if ($event === null) {
            $event = new static;
        }
        $event->handled = false;
        $event->name = $name;

        if (is_object($class)) {
            if ($event->sender === null) {
                $event->sender = $class;
            }
            $class = get_class($class);
        } else {
            $class = ltrim($class, '\\');
        }

        $classes = array_merge(
            [$class],
            class_parents($class, true),
            class_implements($class, true)
        );

        foreach ($classes as $class) {
            if (!empty(self::$_events[$name][$class])) {
                foreach (self::$_events[$name][$class] as $handler) {
                    $event->data = $handler[1];
                    call_user_func($handler[0], $event);
                    if ($event->handled) {
                        return;
                    }
                }
            }
        }
    }
}
```

<br/><br/><br/><br/><br/>
### 参考资料

深入理解Yii2.0 » Yii 基础 » 事件（Event） <http://www.digpage.com/event.html>

call_user_func <https://www.php.net/manual/zh/function.call-user-func.php>

call_user_func_array <https://www.php.net/manual/zh/function.call-user-func-array.php>

Yii 2.0 权威指南 关键概念（Key Concepts）: 事件（Events） <https://www.yiichina.com/doc/guide/2.0/concept-events>

