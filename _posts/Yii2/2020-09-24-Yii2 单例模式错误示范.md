---
layout: post
categories: Yii2
title: Yii2 单例模式错误示范
meta: 单例模式错误示范
---
* content
{:toc}

### 正文

一次在项目中要新增RabbitMQ队列服务器，原来有一个，就想着用同一个类就可以了，只是加一下配置，但调试时发现新队列服务器并没有接收到数据。
仔细查看下，发现使用的RabbitMQ队列服务的component是单例模式，后面的参数配置并没有起作用。现在怎么解决这个问题呢？

一种方案是，可以复制一份RabbitMQ队列服务的component，然后给这个复制组件配置参数实现功能。但这样这两个组件有大量相同的代码，
不符合主流开发思想。

怎么解决这个问题呢？想到了工厂模式，传入不同的参数，实例化类为不同的对象。但使用的时候怎么实例化是个问题：需要把参数传进去，每一次使用都要实例化一次。
这么想来还是要用单例模式：一次实例化，多次使用。但又要是可配置单例，可以说是工厂模式加单例模式的复合体。

想来想去，突然想到了Yii2中数据库的配置，可以配置多个数据库，但使用的类是一个类。我们这里也可以使用这种方式。查询后，
发现Yii2使用了容器和依赖注入、还有服务定位，对component组件类有要求：
要继承自`yii\base\Component`，要实现`init()`方法，再就是配置参数要用`public`申明。

项目加载阶段会把组件及其配置都加载好，使用到这个组件时，如`Yii::$app->queue`，会调用`get()`实例化这个组件对象，
以后不会再重复实例化，会直接使用这个实例化好的对象。

看一下配置：
```
"components" => [
    'queue' => [
        "class" =>  'common\components\LRabbitQueue',
        'credentials'   => [
            'host' => '192.168.0.1',
            'port' => '5672',
            'login' => 'mqadmin',
            'password' => 'mqadmin'
        ]
    ],
    'queueNew' => [
        "class" =>  'common\components\LRabbitQueue',
        'credentials'   => [
            'host' => '192.168.0.2',
            'port' => '5672',
            'login' => 'mqadmin',
            'password' => 'mqadmin'
        ]
    ],
],
```

原来的component类：
```
<?php
namespace common\components;

use Yii;
use yii\base\Component;

class LRabbitQueue extends Component
{
    const LOG_PREFIX = 'common.components.LRedisCache.';
    private $connection;
    public $credentials;

    
    public function init()
    {

    }

    /**
     * 初始化连接
     */
    public function initConnection()
    {
        if (!$this->connection || !is_resource($this->connection)) {
            // 这里的Yii::$app->queue->credentials固定死了配置，是导致新组件不可用的原因
            $this->connection = new \AMQPConnection(Yii::$app->queue->credentials);
        }
        if (!$this->connection->isConnected()) {
            $this->connect();
        }
    }

    public function connect($tryNum=3) {
        try {
            $this->connection->connect();
        }
        catch(\Exception $e) {
            if (--$tryNum) {
                Yii::warning("msg[".$e->getMessage()."]", self::LOG_PREFIX . __FUNCTION__);
                sleep(1);
                $this->connect($tryNum);
            } else {
                Yii::error("msg[".$e->getMessage()."]", self::LOG_PREFIX . __FUNCTION__);
                throw $e;
            }
        }

    }
    
    public function getConnection() {
        $this->initConnection();
        return $this->connection;
    }

    /**
     * 日志进队
     * @param $message
     * @param $exchange
     * @param $routing
     * @return bool
     */
    public function produce($message, $exchange, $routing)
    {
        $message = json_encode($message);

        $channel = new \AMQPChannel($this->getConnection());
        $ex = new \AMQPExchange($channel);
        $ex->setName($exchange);
        $ex->setType(AMQP_EX_TYPE_DIRECT);
        $ex->setFlags(AMQP_DURABLE);

        $ex->declareExchange();

        if (!$ex->publish($message, $routing, 1, ['delivery_mode' => 2])) {
            return false;
        }

        return true;
    }

    public function batchProduce($messageList, $exchange, $routing)
    {
        $channel = new \AMQPChannel($this->getConnection());
        $ex = new \AMQPExchange($channel);
        $ex->setName($exchange);
        $ex->setType(AMQP_EX_TYPE_DIRECT);
        $ex->setFlags(AMQP_DURABLE);

        $ex->declareExchange();

        foreach ($messageList as $message) {
            $messageJson = json_encode($message);

            if (!$ex->publish($messageJson, $routing, 1, ['delivery_mode' => 2])) {
                return false;
            }
        }

        return true;
    }

    /**
     * @param $message
     * @param $exchange
     * @param $routing
     * @param $ttl    消息生存时间(1000 = 1s)
     * @return bool
     * @created by Jhu
     * 通用延迟消费进队方法,消息持久化
     */
    public function produceTtl($message, $exchange, $routing, $ttl)
    {

        $message = json_encode($message);

        $channel = new \AMQPChannel($this->getConnection());
        $ex = new \AMQPExchange($channel);
        $ex->setName($exchange);
        $ex->setType(AMQP_EX_TYPE_DIRECT);
        $ex->setFlags(AMQP_DURABLE);

        $ex->declareExchange();

        $argument = array(
            'delivery_mode' => 2,
            'expiration' => $ttl
        );

        if (!$ex->publish($message, $routing, 1, $argument)) {
            return false;
        }

        return true;
    }
}
```

修改后的新component类：
```
<?php
namespace common\components;

use Yii;
use yii\base\Component;

class LRabbitQueue extends Component
{
    const LOG_PREFIX = 'common.components.LRedisCache.';
    private $connection;
    public $credentials;

    public function init()
    {
        parent::init();
        $this->connection = new \AMQPConnection($this->credentials);
    }

    public function connect($tryNum=3) {
        try {
            $this->connection->connect();
        }
        catch(\Exception $e) {
            if (--$tryNum) {
                Yii::warning("msg[".$e->getMessage()."]", self::LOG_PREFIX . __FUNCTION__);
                sleep(1);
                $this->connect($tryNum);
            } else {
                Yii::error("msg[".$e->getMessage()."]", self::LOG_PREFIX . __FUNCTION__);
                throw $e;
            }
        }
    }
    
    public function getConnection()
    {
        if (!$this->connection->isConnected()) {
            $this->connect();
        }
        return $this->connection;
    }

    /**
     * 日志进队
     * @param $message
     * @param $exchange
     * @param $routing
     * @return bool
     */
    public function produce($message, $exchange, $routing)
    {
        $message = json_encode($message);

        $channel = new \AMQPChannel($this->getConnection());
        $ex = new \AMQPExchange($channel);
        $ex->setName($exchange);
        $ex->setType(AMQP_EX_TYPE_DIRECT);
        $ex->setFlags(AMQP_DURABLE);

        $ex->declareExchange();

        if (!$ex->publish($message, $routing, 1, ['delivery_mode' => 2])) {
            return false;
        }

        return true;
    }

    public function batchProduce($messageList, $exchange, $routing)
    {
        $channel = new \AMQPChannel($this->getConnection());
        $ex = new \AMQPExchange($channel);
        $ex->setName($exchange);
        $ex->setType(AMQP_EX_TYPE_DIRECT);
        $ex->setFlags(AMQP_DURABLE);

        $ex->declareExchange();

        foreach ($messageList as $message) {
            $messageJson = json_encode($message);

            if (!$ex->publish($messageJson, $routing, 1, ['delivery_mode' => 2])) {
                return false;
            }
        }

        return true;
    }

    /**
     * @param $message
     * @param $exchange
     * @param $routing
     * @param $ttl    消息生存时间(1000 = 1s)
     * @return bool
     * @created by Jhu
     * 通用延迟消费进队方法,消息持久化
     */
    public function produceTtl($message, $exchange, $routing, $ttl)
    {

        $message = json_encode($message);

        $channel = new \AMQPChannel($this->getConnection());
        $ex = new \AMQPExchange($channel);
        $ex->setName($exchange);
        $ex->setType(AMQP_EX_TYPE_DIRECT);
        $ex->setFlags(AMQP_DURABLE);

        $ex->declareExchange();

        $argument = array(
            'delivery_mode' => 2,
            'expiration' => $ttl
        );

        if (!$ex->publish($message, $routing, 1, $argument)) {
            return false;
        }

        return true;
    }
}
```

Yii2中要用到单例时都可以考虑使用服务定位的方式实现，方便以后维护。

这里$credentials这个参数并没有看到赋值，为什么可以访问？这是因为这个组件类继承自`yii\base\Component`，
而`yii\base\Component`又继承自`yii\base\Object`，`yii\base\Object`中有：
```
public function __construct($config = [])
{
    if (!empty($config)) {
        Yii::configure($this, $config);
    }
    $this->init();
}
```

`Yii::configure`源码：
```
public static function configure($object, $properties)
{
    foreach ($properties as $name => $value) {
            $object->$name = $value;
    }

    return $object;
}
```

你可能又发现一个疑问，$config这个参数怎么取到的？

这是因为在项目入口文件`index.php`中有：
```
<?php
defined('YII_DEBUG') or define('YII_DEBUG', true);
defined('YII_ENV') or define('YII_ENV', 'dev');

require __DIR__ . '/../../vendor/autoload.php';
require __DIR__ . '/../../vendor/yiisoft/yii2/Yii.php';
require __DIR__ . '/../../common/config/bootstrap.php';
require __DIR__ . '/../config/bootstrap.php';

$config = yii\helpers\ArrayHelper::merge(
    require __DIR__ . '/../../common/config/main.php',
    require __DIR__ . '/../../common/config/main-local.php',
    require __DIR__ . '/../config/main.php',
    require __DIR__ . '/../config/main-local.php'
);

(new yii\web\Application($config))->run();
```

`$config` 这个数组会被 `new yii\web\Application($config)`
》 `yii\base\Application->__construct($config)` 
-> `yii\base\Component::__construct($config)` 
》 `yii\base\Object::__construct($config)` 
-> `Yii::configure($this, $config)` 所调用：
```
public static function configure($object, $properties)
{
    foreach ($properties as $name => $value) {
        $object->$name = $value;
    }

    return $object;
}
```

<br/><br/><br/><br/><br/>
### 参考资料

PHP 常用设计模式-单例模式 <https://ibaiyang.github.io/blog/php/2019/07/30/PHP-%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8Fsingleton>

深入理解Yii2.0 依赖注入和依赖注入容器 <https://ibaiyang.github.io/blog/yii2/2019/06/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Yii2.0-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%B9%E5%99%A8.html>

深入理解Yii2.0 服务定位器 <https://ibaiyang.github.io/blog/yii2/2019/06/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Yii2.0-%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%BD%8D%E5%99%A8.html>






