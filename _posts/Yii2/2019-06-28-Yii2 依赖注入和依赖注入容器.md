---
layout: post
categories: Yii2
title: Yii2 依赖注入和依赖注入容器
meta: 依赖注入和依赖注入容器
---
* content
{:toc}

### 正文

#### 实例引导

看下面代码：
```
namespace app\models;

use yii\base\Object;
use yii\db\Connection;

// 定义接口
interface UserFinderInterface
{
    function findUser();
}

// 定义类，实现接口
class UserFinder extends Object implements UserFinderInterface
{
    public $db;

    // 从构造函数看，这个类依赖于 Connection
    public function __construct(Connection $db, $config = [])
    {
        $this->db = $db;
        parent::__construct($config);
    }

    public function findUser()
    {
    }
}

class UserLister extends Object
{
    public $finder;

    // 从构造函数看，这个类依赖于 UserFinderInterface接口
    public function __construct(UserFinderInterface $finder, $config = [])
    {
        $this->finder = $finder;
        parent::__construct($config);
    }
}
```

从依赖关系看，这里的 UserLister 类依赖于接口 UserFinderInterface ， 而接口有一个实现就是 UserFinder 类，但这类又依赖于 Connection 。

那么，按照一般常规的作法，要实例化一个 UserLister 通常这么做:
```
$db = new \yii\db\Connection(['dsn' => '...']);
$finder = new UserFinder($db);
$lister = new UserLister($finder);
```

就是逆着依赖关系，从最底层的 Connection 开始实例化，接着是 UserFinder 最后是 UserLister 。 
在写代码的时候，这个前后顺序是不能乱的。而且，需要用到的单元，你要自己一个一个提前准备好。
如果是多人开发，如果依赖有10－20个，估计光实例化的代码，就可以写满一屏幕了。你自己都被搞乱了，所以我们需要一个解决依赖加载的方案。

而且，如果是团队开发，有些单元应当是共用的，如邮件投递服务。 不能说你写个模块，要用到邮件服务了，就自己实例化一个邮件服务吧？
那样岂不是有N模块就有N个邮件服务了？ 最好的方式是使邮件服务成为一个单例，这样任何模块在需要邮件服务时，使用的其实是同一个实例。 
用传统的这种实例化对象的方法来实现的话，就没那么直接了。

如果改用DI容器的话，应该是这样的:
```
use yii\di\Container;

// 创建一个DI容器
$container = new Container;

// 为Connection指定一个数组作为依赖，当需要Connection的实例时，
// 使用这个数组进行创建
$container->set('yii\db\Connection', [
    'dsn' => '...',
]);

// 在需要使用接口 UserFinderInterface 时，采用UserFinder类实现
$container->set('app\models\UserFinderInterface', [
    'class' => 'app\models\UserFinder',
]);

// 为UserLister定义一个别名
$container->set('userLister', 'app\models\UserLister');

// 获取这个UserList的实例
$lister = $container->get('userLister');
```

采用DI容器的办法，首先各 set() 语句没有前后关系的要求， set() 只是写入特定的数据结构， 并未涉及具体依赖关系的解析。
所以，前后关系不重要，先定义什么依赖，后定义什么依赖没有关系。

其次，上面根本没有在DI容器中定义 UserFinder 对于 Connection 的依赖。 但是DI容器通过对 UserFinder 构造函数的分析，
能了解到这个类会对 Connection 依赖。这个过程是自动的。

最后，上面只有一个 get() 看起来好像根本没有实例化其他如 Connection 单元一样，但事实上，DI容器已经安排好了一切。 
在获取 userLister 之前， Connection 和 UserFinder 都会被自动实例化。 其中， Connection 是根据依赖定义中的配置数组进行实例化的。




#### 实例分析

刚开始提到那个例子，下面继续分析。

经过前面的几个 set() 语句之后，DI容器的 $_params 数组是空的， $_singletons 数组也是空的。 $_definintions 数组却有了新的内容:
```
$_definitions = [
    'yii\db\Connection' => [
        'class' => 'yii\db\Connection',    // 注意这里
        'dsn' => ...
    ],
    'app\models\UserFinderInterface' => ['class' => 'app\models\UserFinder'],
    'userLister' => ['class' => 'app\models\UserLister']    // 注意这里
];
```

调用 get('userLister') 过程：

![](https://raw.githubusercontent.com/iBaiYang/PictureWareroom/master/20190627/DI.png)

DI容器解析依赖获取实例的过程示意图

在 DI容器解析依赖获取实例的过程示意图 中绿色方框表示DI容器的5个数组，浅蓝色圆边方框表示调用的函数和方法。 
蓝色箭头表示读取内存，红色箭头表示写入内存，虚线箭头表示参照的内存对象，粗线绿色箭头表示回溯过程。 
图中3个圆柱体表示实例化过程中，创建出来的3个实例。

![](https://raw.githubusercontent.com/iBaiYang/PictureWareroom/master/20190627/DataOfDI.png)


<br/><br/><br/><br/><br/>
### 参考资料

深入理解Yii2.0 » Yii 模式 » 依赖注入和依赖注入容器 <http://www.digpage.com/di.html>

