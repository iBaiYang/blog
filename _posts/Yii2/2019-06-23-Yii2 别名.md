---
layout: post
categories: Yii2
title: Yii2 别名
meta: 别名(Alias)，可以将别名视为特殊的常量变量，他的作用在于避免将一些文件路径、URL以硬编码的方式 写入代码中，或者多处出现一长串的文件路径、URL。
---
* content
{:toc}

### 正文

别名(Alias)，可以将别名视为特殊的常量变量，他的作用在于避免将一些文件路径、URL以硬编码的方式 写入代码中，或者多处出现一长串的文件路径、URL。

#### 预定义的别名

Yii中，别名以 @ 开头，以区别于正常的文件路径和URL。Yii中预定义了许多常用的 别名。别名的定义一般放在应用的最开始的阶段进行，
比如引导阶段、初始化阶段等。 这样可以保证后续代码可以使用这些定义好的别名。

##### 配置文件中的别名
配置文件中的别名，bootstrap.php 中有：
```
Yii::setAlias('common', dirname(__DIR__));
Yii::setAlias('frontend', dirname(dirname(__DIR__)) . '/frontend');
Yii::setAlias('backend', dirname(dirname(__DIR__)) . '/backend');
Yii::setAlias('console', dirname(dirname(__DIR__)) . '/console');
```
定义了 @common ， @frontend ， @backend 和 @console 4个别名。 
开发者也可以自己在 bootstrap.php 中加入自己的别名定义，这是最常运用的定义别名的方式。

##### Yii预定义的别名

这类别名直接写到Yii的代码中去了。这些预定义的别名，主要分布在 yii\BaseYii 和 yii\base\Application 等类中。

在 yii\BaseYii 中:
```
// 定义了 @yii 别名
public static $aliases = ['@yii' => __DIR__];
```

yii\BaseYii::$aliases 用于保存整个Yii应用的所有的别名。 这里默认地把 yii\BaseYii.php 所在的目录作为 @yii 别名。

另外，对于 yii\base\Application 在其构造函数 __construct() 中，会调用以下代码:
```
public function preInit(&$config)
{
    ... ...

    // basePath必须在配置文件中给出，否则会抛出弃常
    if (isset($config['basePath'])) {
        // 这里会设置 @app
        $this->setBasePath($config['basePath']);
        unset($config['basePath']);
    } else {
        throw new InvalidConfigException(
        'The "basePath" configuration for the Application is required.');
    }

    // @vendor 如果配置文件中设置了 vendorPath 使用配置的值，否则使用默认的
    if (isset($config['vendorPath'])) {
        $this->setVendorPath($config['vendorPath']);
        unset($config['vendorPath']);
    } else {
        $this->getVendorPath();
    }

    // @runtime 如果配置文件中设置了 runtimePath ，就使用配置的值，否则使用默认的
    if (isset($config['runtimePath'])) {
        $this->setRuntimePath($config['runtimePath']);
        unset($config['runtimePath']);
    } else {
        $this->getRuntimePath();
    }

    ... ...
}
```

上面的代码中，预定义了5个别名： @app ， @vendor @bower @npm ， @runtime 。 上面的代码中， basePath 不是别名，
但必须由开发者自己在配置文件中设定，表示应用的根目录。 对于frontend而言，就是目录 /frontend 。 
在定义 basePath 时，Yii顺便定义了 @app ，代码在 yii\base\Application::setBasePath() 中:
```
public function setBasePath($path)
{
    parent::setBasePath($path);
    Yii::setAlias('@app', $this->getBasePath());
}
```
可以看出， @app 与 basePath 是一致的。

在 yii\base\Application 的初始化过程中，与设置 basePath 类似， 在配置 vendorPath runtimePath 时，
Yii会调用 setVendorPath() setRuntimePath() 。 如果未在配置文件中对这两个配置项作出设置，
Yii会调用 getVendorPath() 和 getRuntimePath() ， 这两个函数最终也会调用相应的set函数对这些别名进行定义。

@vendor ， @bower ， @npm 和 @runtime 这4个别名就由这两个set函数定义:
```
public function getVendorPath()
{
    // 在未设置vendorPath时，使用默认值
    if ($this->_vendorPath === null) {
        $this->setVendorPath($this->getBasePath() . DIRECTORY_SEPARATOR . 'vendor');
    }

    return $this->_vendorPath;
}

// 这里定义了3个别名
public function setVendorPath($path)
{
    $this->_vendorPath = Yii::getAlias($path);
    Yii::setAlias('@vendor', $this->_vendorPath);
    Yii::setAlias('@bower', $this->_vendorPath . DIRECTORY_SEPARATOR . 'bower');
    Yii::setAlias('@npm', $this->_vendorPath . DIRECTORY_SEPARATOR . 'npm');
}

public function getRuntimePath()
{
    // 在未设置runtimePath时，使用默认值
    if ($this->_runtimePath === null) {
        $this->setRuntimePath($this->getBasePath() . DIRECTORY_SEPARATOR . 'runtime');
    }

    return $this->_runtimePath;
}

// 这里定义了 @runtime 别名
public function setRuntimePath($path)
{
    $this->_runtimePath = Yii::getAlias($path);
    Yii::setAlias('@runtime', $this->_runtimePath);
}
```

对于上面的代码，默认情况下，会有：

* @app ，必须由开发者在配置文件中提供，一般为配置文件的 dirname(__DIR__) 。 即 /frontend 之类的目录。
* @vendor ，一般定义为 @app/vendor ，高级模板中则定义为 @app/../vendor
* @bower ，定义为 @vendor/bower
* @npm ，定义为 @vendor/npm
* @runtime ，定义为 @app/runtime

但是，这里有一个比较特殊的，就是 @vendor 。 对于使用Yii基础模版创建的应用而言，会使用上面提到的 @app/vendor 。 
但是，对于使用高级模版创建的应用，你会发现，vendor目录并不在 frontend 或 backend 目录下， 
而是跟他们是兄弟目录。这是因为对于整个工程而言，这个vendor的内容是 frontend 和 backend等共用的。 

因此，实际上高级应用模版的 @vendor 应该是 @app/../vendor ，上面的代码显然不适用。
Yii也已经考虑到了。在使用高级模板创建应用时， /common/config/main.php 配置文件会重新设定 vendorPath：
```
'vendorPath' => dirname(dirname(__DIR__)) . '/vendor'
```
这样就避免了使用代码中默认的值。

对于Web应用， yii\base\Web\Application 中又定义了 @webroot 和 @web 2个别名:
```
protected function bootstrap()
{
    $request = $this->getRequest();
    Yii::setAlias('@webroot', dirname($request->getScriptFile()));
    Yii::setAlias('@web', $request->getBaseUrl());

    parent::bootstrap();
}
```
这里 @webroot 就是入口脚本 index.php 所在的目录。 而 @web 则是URL别名，表示当前应用的根URL地址 。

最后一个藏有别名的地方，在于Yii的扩展（extensions）。 当使用Composer安装扩展后，会向 @vendor/yiisoft/extensions.php 写入信息，
其中就包含相应的别名。 只不过这些别名通常都是二级别名。然后，在 yii\base\Application::bootstrap() 中，将这些扩展的别名进行注册。

首先看看一个典型的 extensions.php
```
<?php

$vendorDir = dirname(__DIR__);

return array (
  'yiisoft/yii2-swiftmailer' =>
  array (
    'name' => 'yiisoft/yii2-swiftmailer',
    'version' => '9999999-dev',
    'alias' =>
    array (
      '@yii/swiftmailer' => $vendorDir . '/yiisoft/yii2-swiftmailer',
    ),
  ),

 ... ...

 'yiisoft/yii2-gii' =>
  array (
    'name' => 'yiisoft/yii2-gii',
    'version' => '9999999-dev',
    'alias' =>
    array (
      '@yii/gii' => $vendorDir . '/yiisoft/yii2-gii',
    ),
  ),
);
```

注意上面这段代码中的 alias ，这个键对应的就是一个别名及其所代表的实际路径。 
至于具体对这个 extensions.php 的内容进行处理并注册成别名的工作， 是由 yii\base\Application::bootstrap() 完成:
```
protected function bootstrap()
{
    // 将 extensions.php 的内容读取进 $this->extensions 备用
    if ($this->extensions === null) {
        $file = Yii::getAlias('@vendor/yiisoft/extensions.php');
        $this->extensions = is_file($file) ? include($file) : [];
    }

    // 遍历 $this->extensions 并注册别名
    foreach ($this->extensions as $extension) {
        if (!empty($extension['alias'])) {
            foreach ($extension['alias'] as $name => $path) {
                Yii::setAlias($name, $path);
            }
        }
        ... ...
    }
}
```

经过上面这些代码，我们的各种插件也有了自己的别名，如上面的 @yii\swiftmailer ， @yii\gii 等，常见的还有 @yii\bootstrap 等。

##### 所有预定义的别名

小结一下，默认预定义别名一共有12个，其中路径别名11个，URL别名只有 @web 1个：


* @yii 表示Yii框架所在的目录，也是 yii\BaseYii 类文件所在的位置；
* @app 表示正在运行的应用的根目录，一般是 /frontend ；
* @vendor 表示Composer第三方库所在目录，一般是 @app/vendor 或 @app/../vendor ；
* @bower 表示Bower第三方库所在目录，一般是 @vendor/bower ；
* @npm 表示NPM第三方库所在目录，一般是 @vendor/npm ；
* @runtime 表示正在运行的应用的运行时用于存放运行时文件的目录，一般是 @app/runtime ；
* @webroot 表示正在运行的应用的入口文件 index.php 所在的目录，一般是 @app/web；
* @web URL别名，表示当前应用的根URL，主要用于前端；
* @common 表示通用文件夹；
* @frontend 表示前台应用所在的文件夹；
* @backend 表示后台应用所在的文件夹；
* @console 表示命令行应用所在的文件夹；
* 其他使用Composer安装的Yii扩展注册的二级别名。

这样，在整个Yii应用中，只要使用上述别名，就可方便、且统一地表示特定的路径或URL。



<br/><br/><br/><br/><br/>
### 参考资料

深入理解Yii2.0 » Yii 约定 » 别名(Alias) <http://www.digpage.com/aliases.html>
