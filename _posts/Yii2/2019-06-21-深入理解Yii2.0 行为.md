---
layout: post
categories: Yii2
title: 深入理解Yii2.0 行为
meta: 使用行为（behavior）可以在不修改现有类的情况下，对类的功能进行扩充。 
---
* content
{:toc}

## 正文

![]({{site.baseurl}}/images/20190823/20190823191034.png)

![]({{site.baseurl}}/images/20190823/20190823191058.png)

### 引导

使用行为（behavior）可以在不修改现有类的情况下，对类的功能进行扩充。 通过将行为绑定到一个类，可以使类具有行为本身所定义的属性和方法，
就好像类本来就有这些属性和方法一样。 而且不需要写一个新的类去继承或包含现有类。

Yii中的行为，其实是 `yii\base\Behavior` 类的实例， 只要将一个Behavior实例绑定到任意的 `yii\base\Component` 实例上， 
这个Component就可以拥有该Behavior所定义的属性和方法了。而如果将行为与事件关联起来，可以玩的花样就更多了。

但有一点需要注意，Behavior只能与Component类绑定。所以，如果你写了一个类，需要使用到行为，那么就果断地继承自 `yii\base\Component` 。

### 使用行为

一个绑定了行为的类，表现起来是这样的:
```
// Step 1: 定义一个将要绑定行为的类
class MyClass extends yii\base\Component
{
    // 空的
}

// Step 2: 定义一个行为类，他将绑定到MyClass上
class MyBehavior extends yii\base\Behavior
{
    // 行为的一个属性
    public $property1 = 'This is property in MyBehavior.';

    // 行为的一个方法
    public function method1()
    {
        return 'Method in MyBehavior is called.';
    }
}

$myClass = new MyClass();
$myBehavior = new MyBehavior();

// Step 3: 将行为绑定到类上
$myClass->attachBehavior('myBehavior', $myBehavior);

// Step 4: 访问行为中的属性和方法，就和访问类自身的属性和方法一样
echo $myClass->property1;
echo $myClass->method1();
```

可以看到行为中的属性和方法可以被所绑定的类像访问自身的属性和方法一样直接访问。代码中， 
$myClass 是没有 property1 、 method() 成员的。这俩是 $myBehavior 的成员。 但是，通过 attachBehavior() 将行为绑定到对象之后， 
$myCalss 就将别人的属性和方法都变成了自己的。

另外，从上面的代码中，你还要掌握使用行为的大致流程：
* 从 `yii\base\Component` 派生自己的类，以便使用行为；
* 从 `yii\base\Behavior` 派生自己的行为类，里面定义行为涉及到的属性、方法；
* 将Component和Behavior绑定起来；
* 像使用Component自身的属性和方法一样，尽情使用行为中定义的属性和方法。

### 行为的要素

我们提到了行为只是 `yii\base\Behavior` 类的实例。 那么这个类究竟有什么秘密呢？其实说破了也没有什么，他只是一个简单的封装而已，非常的简单:
```
class Behavior extends Object
{
    // 指向行为本身所绑定的Component对象
    public $owner;

    // Behavior 基类本身没用，主要是子类使用，重载这个函数返回一个数组表示行为所关联的事件
    public function events()
    {
        return [];
    }

    // 绑定行为到 $owner
    public function attach($owner)
    {
        ... ...
    }

    // 解除绑定
    public function detach()
    {
        ... ...
    }
}
```

这就是Behavior的全部代码了，是不是很简单？Behavior类的要素的确很简单：
* $owner 成员变量，用于指向行为的依附对象；
* events() 用于表示行为所有要响应的事件；
* attach() 用于将行为与Component绑定起来；
* deatch() 用于将行为从Component上解除。

#### Behavior源码

看一下完整源码：
```
<?php
namespace yii\base;

/**
 * Behavior is the base class for all behavior classes.
 *
 * A behavior can be used to enhance the functionality of an existing component without modifying its code.
 * In particular, it can "inject" its own methods and properties into the component
 * and make them directly accessible via the component. It can also respond to the events triggered in the component
 * and thus intercept the normal code execution.
 *
 * For more details and usage information on Behavior, see the [guide article on behaviors](guide:concept-behaviors).
 *
 * @author Qiang Xue <qiang.xue@gmail.com>
 * @since 2.0
 */
class Behavior extends Object
{
    /**
     * @var Component the owner of this behavior
     */
    public $owner;


    /**
     * Declares event handlers for the [[owner]]'s events.
     *
     * Child classes may override this method to declare what PHP callbacks should
     * be attached to the events of the [[owner]] component.
     *
     * The callbacks will be attached to the [[owner]]'s events when the behavior is
     * attached to the owner; and they will be detached from the events when
     * the behavior is detached from the component.
     *
     * The callbacks can be any of the following:
     *
     * - method in this behavior: `'handleClick'`, equivalent to `[$this, 'handleClick']`
     * - object method: `[$object, 'handleClick']`
     * - static method: `['Page', 'handleClick']`
     * - anonymous function: `function ($event) { ... }`
     *
     * The following is an example:
     *
     * ```php
     * [
     *     Model::EVENT_BEFORE_VALIDATE => 'myBeforeValidate',
     *     Model::EVENT_AFTER_VALIDATE => 'myAfterValidate',
     * ]
     * ```
     *
     * @return array events (array keys) and the corresponding event handler methods (array values).
     */
    public function events()
    {
        return [];
    }

    /**
     * Attaches the behavior object to the component.
     * The default implementation will set the [[owner]] property
     * and attach event handlers as declared in [[events]].
     * Make sure you call the parent implementation if you override this method.
     * @param Component $owner the component that this behavior is to be attached to.
     */
    public function attach($owner)
    {
        $this->owner = $owner;
        foreach ($this->events() as $event => $handler) {
            $owner->on($event, is_string($handler) ? [$this, $handler] : $handler);
        }
    }

    /**
     * Detaches the behavior object from the component.
     * The default implementation will unset the [[owner]] property
     * and detach event handlers declared in [[events]].
     * Make sure you call the parent implementation if you override this method.
     */
    public function detach()
    {
        if ($this->owner) {
            foreach ($this->events() as $event => $handler) {
                $this->owner->off($event, is_string($handler) ? [$this, $handler] : $handler);
            }
            $this->owner = null;
        }
    }
}
```

#### 行为的依附对象

`yii\base\Behavior::$owner` 指向的是Behavior实例本身所依附的对象。这是行为中引用所依附对象的唯一手段了。 通过这个 $owner ，
行为才能访问所依附的Component，才能将本身的方法作为事件handler绑定到Component上。

$owner 由 `yii\base\Behavior::attach()` 进行赋值。 也就是在将行为绑定到某个Component时， 
$owner 就已经名花有主了。 一般情况下，不需要你自己手动去指定 $owner 的值， 
在调用 `yii\base\Componet::attachBehavior()` 将行为与对象绑定时， 
Component会自动地将 $this 作为参数，调用 `yii\base\Behavior::attach()` 。

有一点需要格外注意，由于行为从本质来讲是一个PHP类，其方法就是类方法，就是成员函数。 所以，在行为的方法中， 
$this 引用的是行为本身， 试图通过 $this 来访问行为所依附的Component是行不通的。 
正确的方法是通过 `yii\base\Behavior::$owner` 来访问Component。

#### 行为所要响应的事件

行为与事件结合后，可以在不对类作修改的情况下，补充类在事件触发后的各种不同反应。 
为此，只需要重载 `yii\base\Behavior::events()` 方法，表示这个行为将对类的何种事件进行何种反馈即可:
```
namespace app\Components;

use yii\db\ActiveRecord;
use yii\base\Behavior;

class MyBehavior extends Behavior
{
    // 重载events() 使得在事件触发时，调用行为中的一些方法
    public function events()
    {
        // 在EVENT_BEFORE_VALIDATE事件触发时，调用成员函数 beforeValidate
        return [
            ActiveRecord::EVENT_BEFORE_VALIDATE => 'beforeValidate',
        ];
    }

    // 注意beforeValidate 是行为的成员函数，而不是绑定的类的成员函数。
    // 还要注意，这个函数的签名，要满足事件handler的要求。
    public function beforeValidate($event)
    {
        // ...
    }
}
```

上面的代码中， events() 返回一个数组，表示所要做出响应的事件， 上例中的事件是 `ActiveRecord::EVENT_BEFORE_VALIDATE` ，
以数组的键来表示， 而数组的值则表示做好反应的事件handler，上例中是 `beforeValidate()` ，事件handler可以是以下形式：
* 字符串，表示行为类的方法，如上面的例子就是这种情况。 这个是与事件handler不同的，
事件handler中使用字符串时，是表示PHP全局函数，而这里表示行为类内部的方法。
* 一个对象或类的成员函数，以数组的形式，如 `[$object, 'methodName']` 。这个与事件handler是一致的。
* 一个匿名函数。

对于事件响应函数的签名，要求与事件handler一样:
```
function ($event) {   }
```
具体参考 事件（Event） 的内容。

#### 行为的绑定与解除

说到绑定与解除，这意味着这个事情有2方，行为和Component。单独一方是没有绑定或解除的说法的。
对于绑定和解除，Behavior 分别使用 `attach()` 和 `detach()` 来实现。具体内容，下面再展开。

### 定义一个行为

定义一个行为，就是准备好要注入到现有类中去的属性和方法， 这些属性和方法要写到一个 `yii\base\Behavior` 类中。 
所以，定义一个行为，就是写一个 Behavior的子类，子类中包含了所要注入的属性和方法:
```
namespace app\Components;

use yii\base\Behavior;

class MyBehavior extends Behavior
{
    public $prop1;

    private $_prop2;
    private $_prop3;
    private $_prop4;

    public function getProp2()
    {
        return $this->_prop2;
    }

    public function setProp3($value)
    {
        $this->_prop3 = $value;
    }

    public function foo()
    {
        // ...
    }

    protected function bar()
    {
        // ...
    }
}
```

上面的代码通过定义一个 `app\Components\MyBehavior` 类而定义一个行为。 
由于 MyBehavior 继承自 `yii\base\Behavior` 从而间接地继承自 `yii\base\Object` 。 
因此，这个类有一个public的成员变量 `prop1` ， 一个只读属性 `prop2` ，一个只写属性 `prop3` ，一个public的方法 `foo()` 。 
另外，还有一个private 的成员变量 `$_prop4` ，一个protected 的方法 `bar()` 。 

当这MyBehavior与一个Component绑定后， 绑定的Component也就拥有了 `prop1` 、`prop2` 这两个属性和方法 `foo()` ，
因为他们都是 public 的。 而 private 的 `$_prop4` 和 protected 的 bar 就得不到了。 至于原因么，后面讲行为注入的原理时，我们再解释。

#### 行为的绑定

行为的绑定通常是由Component来发起。
有两种方式可以将一个Behavior绑定到一个 `yii\base\Component` 。 一种是静态的方法，另一种是动态的。
静态的方法在实践中用得比较多一些。 因为一般情况下，在你的代码没跑起来之前，一个类应当具有何种行为，是确定的。 
动态绑定的方法主要是提供了更灵活的方式。

##### 静态方法绑定行为

静态绑定行为，只需要重载 `yii\base\Component::behaviors()` 就可以了。 这个方法用于描述类所具有的行为。
如何描述呢？ 使用配置来描述，可以是Behavior类名，也可以是Behavior类的配置数组:
```
namespace app\models;

use yii\db\ActiveRecord;
use app\Components\MyBehavior;

class User extends ActiveRecord
{
    public function behaviors()
    {
        return [
            // 匿名行为，只有行为类名
            MyBehavior::className(),

            // 命名行为，只有行为类名，名为myBehavior2的行为
            'myBehavior2' => MyBehavior::className(),

            // 匿名行为，配置数组，给出了MyBehavior类的配置数组
            [
                'class' => MyBehavior::className(),
                'prop1' => 'value1',
                'prop3' => 'value3',
            ],

            // 命名行为，配置数组，名为myBehavior4的行为，也是给出了MyBehavior类的配置数组
            'myBehavior4' => [
                'class' => MyBehavior::className(),
                'prop1' => 'value1',
                'prop3' => 'value3',
            ]
        ];
    }
}
```

通过指定行为配置数组相应的键可以给行为关联一个名称。这种行为称为命名行为。如果行为没有指定名称就是匿名行为。

还有一个静态的绑定办法，就是通过配置文件来绑定:
```
[
    'as myBehavior2' => MyBehavior::className(),

    'as myBehavior3' => [
        'class' => MyBehavior::className(),
        'prop1' => 'value1',
        'prop3' => 'value3',
    ],
]
```

看个例子：
```
return [
    'id' => 'app-frontend',
    'basePath' => dirname(__DIR__),
    'bootstrap' => ['log'],
    'controllerNamespace' => 'frontend\controllers',
    'components' => [
        'client' => [
            'class' => 'path\to\ClassName',
            'propertyName' => 'propertyValue',
            'on eventName' => $eventHandler,
            'as behaviorName' => $behaviorConfig,
        ],
    ],

    'params' => [...],
];
```

##### 动态方法绑定行为

动态绑定行为，需要调用 `yii\base\Compoent::attachBehaviors()`:
```
use app\components\MyBehavior;

// 附加行为对象
$component->attachBehavior('myBehavior1', new MyBehavior);

// 附加行为类
$component->attachBehavior('myBehavior2', MyBehavior::className());

// 附加配置数组
$component->attachBehavior('myBehavior3', [
    'class' => MyBehavior::className(),
    'prop1' => 'value1',
    'prop2' => 'value2',
]);
```

可以通过 `yii\base\Component::attachBehaviors()` 方法一次附加多个行为：
```
$Component->attachBehaviors([
    'myBehavior1' => new MyBehavior,  // 这是一个命名行为
    MyBehavior::className(),          // 这是一个匿名行为
]);
```

这个方法接受一个数组参数，参数的含义与上面静态绑定行为是一样一样的。

这里以数组的键作为行为的命名，而对于没有提供键名的行为，就是匿名行为。

对于命名的行为，可以调用 `yii\base\Component::getBehavior()` 来取得这个绑定好的行为:
```
$behavior = $Component->getBehavior('myBehavior2');
```

对于匿名的行为，则没有办法直接引用了。但是，可以获取所有的绑定好的行为:
```
$behaviors = $Component->getBehaviors();
```

#### 绑定的内部原理

只是重载一个 `yii\base\Component::behaviors()` 就可以这么神奇地使用行为了？ 这只是冰山的一角，实际上关系到绑定的过程，有关的方面有：

* `yii\base\Component::behaviors()`
* `yii\base\Component::ensureBehaviors()`
* `yii\base\Component::attachBehaviorInternal()`
* `yii\base\Behavior::attach()`

4个方法中，Behavior只占其一，更多的代码，是在Component中完成的。

`yii\base\Component::behaviors()` 上面讲静态方法绑定行为时已经提到了，就是返回一个数组用于描述行为。

`yii\base\Component::ensuerBehaviors()` 会在Component的诸多地方调用 `__get()` 、 `__set()` 、 `__isset()` 、 `__unset()` 、 `__call()` 、 
`canGetProperty()` 、 `hasMethod()` 、 `hasEventHandlers()` 、 `on()` 、 `off()` 等用到，只要涉及到类的属性、方法、事件这个函数都会被调用到。
就像名字所表明的，他的作用在于“ensure” 。其实只是确保 `behaviors()` 中所描述的行为已经进行了绑定而已:
```
public function ensureBehaviors()
{
    // 为null表示尚未绑定，为空数组表示没有绑定任何行为
    if ($this->_behaviors === null) {
        $this->_behaviors = [];

        // 遍历 $this->behaviors() 返回的数组，并绑定
        foreach ($this->behaviors() as $name => $behavior) {
            $this->attachBehaviorInternal($name, $behavior);
        }
    }
}
```
这个方法主要是对子类用的， `yii\base\Compoent` 没有任何预先注入的行为，所以，这个调用没有用。 
但是对于子类，你可能重载了 `yii\base\Compoent::behaviros()` 来预先注入一些行为。 那么，这个函数会将这些行为先注入进来。

`yii\base\Component::attachBehaviorInternal()`：
```
private function attachBehaviorInternal($name, $behavior)
{
    // 不是 Behavior 实例，说明只是类名、配置数组，那么就创建出来吧
    if (!($behavior instanceof Behavior)) {
        $behavior = Yii::createObject($behavior);
    }

    // 匿名行为
    if (is_int($name)) {
        $behavior->attach($this);
        $this->_behaviors[] = $behavior;

    // 命名行为
    } else {

        // 已经有一个同名的行为，要先解除，再将新的行为绑定上去。
        if (isset($this->_behaviors[$name])) {
            $this->_behaviors[$name]->detach();
        }
        $behavior->attach($this);
        $this->_behaviors[$name] = $behavior;
    }
    return $behavior;
}
```
首先要注意到，这是一个private成员。其实在Yii中，所有后缀为 *Internal 的方法，都是私有的。 这个方法干了这么几件事：
* 如果 $behavior 参数并非是一个 Behavior 实例，就以之为参数，用 `Yii::createObject()` 创建出来。
* 如果以匿名行为的形式绑定行为，那么直接将行为附加在这个类上。
* 如果是命名行为，先看看是否有同名的行为已经绑定在这个类上，如果有，用后来的行为取代之前的行为。

`yii\base\Behavior::attach()` , 在 `yii\base\Component::attachBehaviorInternal()` 中，
 以 `$this` 为参数调用了 `yii\base\Behavior::attach()` ：
 ```
public function attach($owner)
{
    $this->owner = $owner;
    foreach ($this->events() as $event => $handler) {
        $owner->on($event, is_string($handler) ? [$this, $handler] : $handler);
    }
}
```

上面的代码干了两件事：
* 设置好行为的 `$owner` ，使得行为可以访问、操作所依附的对象
* 遍历行为中的 `events()` 返回的数组，将准备响应的事件，通过所依附类的 `on()` 绑定到类上

说了这么多，关于绑定，做个小结：
* 绑定的动作从Component发起；
* 静态绑定通过重载 `yii\base\Componet::behaviors()` 实现；
* 动态绑定通过调用 `yii\base\Component::attachBehaviors()` 实现；
* 行为还可以通过为 Component 配置 as 配置项进行绑定；
* 行为有匿名行为和命名行为之分，区别在于绑定时是否给出命名。 命名行为可以通过其命名进行标识，从而有针对性地进行解除等操作；
* 绑定过程中，后绑定的行为会取代已经绑定的同名行为；
* 绑定的意义有两点，一是为行为设置 `$owner` 。二是将行为中拟响应的事件的handler绑定到类中去。

#### 解除行为

解除行为只需调用 `yii\base\Component::detachBehavior()` 就OK了:
```
$Component->detachBehavior('myBehavior2');
```

这样就可以解除已经绑定好的名为 myBehavior2 的行为了。 但是，对于匿名行为，这个方法就无从下手了。
不过我们可以一不做二不休，解除所有绑定好的行为:
```
$Component->detachBehaviors();
```

这上面两种方法，都会调用到 `yii\base\Behavior::detach()` ，其代码如下:
```
public function detach()
{
    // 这得是个名花有主的行为才有解除一说
    if ($this->owner) {

        // 遍历行为定义的事件，一一解除
        foreach ($this->events() as $event => $handler) {
            $this->owner->off($event, is_string($handler) ? [$this, $handler] : $handler);
        }
        $this->owner = null;
    }
}
```

与 `yii\base\Behavior::attach()` 相反，解除的过程就是干两件事： 
一是将 `$owner` 设置为 `null` ，表示这个行为没有依附到任何类上。 
二是通过Component的 `off()` 将绑定到类上的事件hanlder解除下来。一句话，善始善终。

#### 行为响应的事件实例

上面的绑定和解除过程，我们看到Yii费了那么大劲，主要就是为了将行为中的事件handler绑定到类中去。 
在实际编程时，行为用得最多的，也是对于Compoent各种事件的响应。 通过行为注入，可以在不修改现有类的代码的情况下，
更改、扩展类对于事件的响应和支持。 使用这个技巧，可以玩出很炫的花样。 而要将行为与Component的事件关联起来，
就要通过 `yii\base\Behavior::events()` 方法。

上面Behavior基类的代码中，这个方法只是返回了一个空数组，说明不对所依附的Compoent的任何事件产生关联。 
但是在实际使用时，往往通过重载这个方法来告诉Yii，这个行为将对Compoent的何种事件，使用哪个方法进行处理。

比如，Yii自带的 `yii\behaviors\AttributeBehavior` 类，定义了在一个 ActiveRecord 对象的某些事件发生时， 
自动对某些字段进行修改的行为。 他有一个很常用的子类 `yii\behaviors\TimeStampBehavior` 用于将指定的字段设置为一个当前的时间戳。 
常用于表示最后修改日期、上次登陆时间等场景。我们以这个行为为例，来分析行为响应事件的原理。

在 `yii\behaviors\AttributeBehavior::event()` 中，类代码如下:
```
<?php
namespace yii\behaviors;

use Yii;
use Closure;
use yii\base\Behavior;
use yii\base\Event;
use yii\db\ActiveRecord;

class AttributeBehavior extends Behavior
{
    public $attributes = [];
    
    public $value;
    
    public $skipUpdateOnClean = true;
 
    public function events()
    {
        // array_keys() 获取数组键名返回新数组
        // array_fill_keys(array $keys , mixed $value ) 使用 value 参数的值作为值，使用 keys 数组的值作为键来填充一个数组
        // 大意是对指定属性使用evaluateAttributes方法handle
        return array_fill_keys(array_keys($this->attributes), 'evaluateAttributes');
    }
    
    public function evaluateAttributes($event)
    {
        if ($this->skipUpdateOnClean
            && $event->name == ActiveRecord::EVENT_BEFORE_UPDATE
            && empty($this->owner->dirtyAttributes)
        ) {
            return;
        }
    
        if (!empty($this->attributes[$event->name])) {
            $attributes = (array) $this->attributes[$event->name];
            $value = $this->getValue($event);
            foreach ($attributes as $attribute) {
                // ignore attribute names which are not string (e.g. when set by TimestampBehavior::updatedAtAttribute)
                if (is_string($attribute)) {
                    $this->owner->$attribute = $value;
                }
            }
        }
    }
    
    protected function getValue($event)
    {
        if ($this->value instanceof Closure || is_array($this->value) && is_callable($this->value)) {
            return call_user_func($this->value, $event);
        }
    
        return $this->value;
    }
}
```
events()这段代码将返回一个数组，其键值为 `$this->attributes` 数组的键值， 数组元素的值为成员函数 evaluateAttributes 。

而在 `yii\behaviors\TimeStampBehavior::init()` 中，类有以下的代码:
```
namespace yii\behaviors;

use yii\base\InvalidCallException;
use yii\db\BaseActiveRecord;

class TimestampBehavior extends AttributeBehavior
{
    public $createdAtAttribute = 'created_at';
    
    public $updatedAtAttribute = 'updated_at';
    
    public $value;
    
    public function init()
    {
        parent::init();
    
        if (empty($this->attributes)) {
            // 重点看这里
            $this->attributes = [
                BaseActiveRecord::EVENT_BEFORE_INSERT => [$this->createdAtAttribute, $this->updatedAtAttribute],
                BaseActiveRecord::EVENT_BEFORE_UPDATE => $this->updatedAtAttribute,
            ];
        }
    }
    
    protected function getValue($event)
    {
        if ($this->value === null) {
            return time();
        }
        return parent::getValue($event);
    }
        
    public function touch($attribute)
    {
        /* @var $owner BaseActiveRecord */
        $owner = $this->owner;
        if ($owner->getIsNewRecord()) {
            throw new InvalidCallException('Updating the timestamp is not possible on a new record.');
        }
        $owner->updateAttributes(array_fill_keys((array) $attribute, $this->getValue(null)));
    }
}
```

上面的代码重点看的是对于 `$this->attributes` 的初始化部分。 结合上面2个方法的代码，
对于 `yii\base\Behavior::events()` 的返回数组，其格式应该是这样的:
```
return [
    BaseActiveRecord::EVENT_BEFORE_INSERT => 'evaluateAttributes',
    BaseActiveRecord::EVENT_BEFORE_UPDATE => 'evaluateAttributes',
];
```

数组的键值用于指定要响应的事件， 这里是 `BaseActiveRecord::EVENT_BEFORE_INSERT` 和 `BaseActiveRecord::EVENT_BEFORE_UPDATE` 。 
数组的值是一个事件handler，如上面的 evaluateAttributes 。

那么一旦TimeStampBehavior与某个ActiveRecord绑定：
```
<?php
namespace common\models;

use yii;
use yii\db\ActiveRecord;
use yii\behaviors\TimeStampBehavior;

class LeaveType extends ActiveRecord
{
    public function behaviors()
    {
        return [
            TimeStampBehavior::className()
        ];
    }   
        
    public static function getDb()
    {
        return yii::$app->db;
    }

    public static function tableName()
    {
        return 'leave_type';
    }
}
```

就会调用 `yii\behaviors\TimeStampBehavior::attach()` ， 那么就会有:
```
// 这里 $owner 是某个 ActiveRecord
public function attach($owner)
{
    $this->owner = $owner;

    // 遍历上面提到的 events() 所定义的数组
    foreach ($this->events() as $event => $handler) {

        // 调用 ActiveRecord::on 来绑定事件
        // 这里 $handler 为字符串 `evaluateAttributes`
        // 因此，相当于调用 on(BaseActiveRecord::EVENT_BEFORE_INSERT, [$this, 'evaluateAttributes'])
        $owner->on($event, is_string($handler) ? [$this, $handler] : $handler);
    }
}
```

因此，事件 `BaseActiveRecord::EVENT_BEFORE_INSERT` 和 `BaseActiveRecord::EVENT_BEFORE_UPDATE` 就绑定到了ActiveRecord上了。
当新建记录或更新记录时， `TimeStampBehavior::evaluateAttributes` 就会被触发。 从而实现时间戳的功能。

看到这里应该还是对于过程云里雾里，AR是什么时候怎么调用的Behavior的呢？所以下面对上面的流程进行一下追踪。

#### 实例执行流程追踪

我们在 LeaveTypeController 中应该会有这个类似方法：
```
use common\models\LeaveType;
use Yii;
use yii\web\Controller;

class LeaveTypeController extends Controller
{
    ...
    
    public function actionTypePost()
    {
        $req = Yii::$app->request;
        if ( $req->isPost ) {
            $type_id = $req->post('type_id');
            $type_title = $req->post('type_title');
            $type_info = mb_substr($req->post('type_info'), 0, 2000);

            if ( !empty($type_id) ) {
                // 修改
                $data = LeaveType::findOne([
                    'id' => $type_id
                ]);
                $data->title = $type_title;
                $data->info = $type_info;

                if ( $data->save() ) {
                    return 1;
                }
            } else {
                // 新增
                $data = new LeaveType();
                $data->title = $type_title;
                $data->info = $type_info;

                if ( $data->save() ) {
                    return 1;
                }
            }
        }

        return 0;
    }
    
    ...
}
```

当我们通过url调用这个方法时，就切入到了AR执行过程中，比如我们拿新增这一段分析。

extends继承关系：
`common\models\LeaveType` >> `yii\db\ActiveRecord` >> `yii\db\BaseActiveRecord` >> `yii\base\Model` >> `yii\base\Component` >> `yii\base\Object `

当我们调用 LeaveType实例化对象的save()时，调用的是 `yii\db\BaseActiveRecord->save()` ：
```
public function save($runValidation = true, $attributeNames = null)
{
    if ($this->getIsNewRecord()) {
        return $this->insert($runValidation, $attributeNames);
    } else {
        return $this->update($runValidation, $attributeNames) !== false;
    }
}
```

insert()写在`yii\db\ActiveRecord`中（这里是父类使用$this调用子类方法）：
```
public function insert($runValidation = true, $attributes = null)
{
    if ($runValidation && !$this->validate($attributes)) {
        Yii::info('Model not inserted due to validation error.', __METHOD__);
        return false;
    }

    if (!$this->isTransactional(self::OP_INSERT)) {
        return $this->insertInternal($attributes);
    }

    $transaction = static::getDb()->beginTransaction();
    try {
        $result = $this->insertInternal($attributes);
        if ($result === false) {
            $transaction->rollBack();
        } else {
            $transaction->commit();
        }
        return $result;
    } catch (\Exception $e) {
        $transaction->rollBack();
        throw $e;
    } catch (\Throwable $e) {
        $transaction->rollBack();
        throw $e;
    }
}
```

insertInternal()也在`yii\db\ActiveRecord`中：
```
protected function insertInternal($attributes = null)
{
    if (!$this->beforeSave(true)) {
        return false;
    }
    $values = $this->getDirtyAttributes($attributes);
    if (($primaryKeys = static::getDb()->schema->insert(static::tableName(), $values)) === false) {
        return false;
    }
    foreach ($primaryKeys as $name => $value) {
        $id = static::getTableSchema()->columns[$name]->phpTypecast($value);
        $this->setAttribute($name, $id);
        $values[$name] = $id;
    }

    $changedAttributes = array_fill_keys(array_keys($values), null);
    $this->setOldAttributes($values);
    $this->afterSave(true, $changedAttributes);

    return true;
}
```

beforeSave()写在父类`yii\db\BaseActiveRecord`中：
```
public function beforeSave($insert)
{
    $event = new ModelEvent;
    $this->trigger($insert ? self::EVENT_BEFORE_INSERT : self::EVENT_BEFORE_UPDATE, $event);

    return $event->isValid;
}
```

这里可以看到调用了事件处理程序trigger()，trigger()写在`yii\base\Component`中：
```
public function trigger($name, Event $event = null)
{
    $this->ensureBehaviors();
    if (!empty($this->_events[$name])) {
        if ($event === null) {
            $event = new Event;
        }
        if ($event->sender === null) {
            $event->sender = $this;
        }
        $event->handled = false;
        $event->name = $name;
        foreach ($this->_events[$name] as $handler) {
            $event->data = $handler[1];
            call_user_func($handler[0], $event);
            // stop further handling if the event is handled
            if ($event->handled) {
                return;
            }
        }
    }
    // invoke class-level attached handlers
    Event::trigger($this, $name, $event);
}
```

ensureBehaviors()及其调用的attachBehaviorInternal()也都在`yii\base\Component`中：
```
public function ensureBehaviors()
{
    if ($this->_behaviors === null) {
        $this->_behaviors = [];
        foreach ($this->behaviors() as $name => $behavior) {
            $this->attachBehaviorInternal($name, $behavior);
        }
    }
}

private function attachBehaviorInternal($name, $behavior)
{
    if (!($behavior instanceof Behavior)) {
        $behavior = Yii::createObject($behavior);
    }
    if (is_int($name)) {
        $behavior->attach($this);
        $this->_behaviors[] = $behavior;
    } else {
        if (isset($this->_behaviors[$name])) {
            $this->_behaviors[$name]->detach();
        }
        $behavior->attach($this);
        $this->_behaviors[$name] = $behavior;
    }

    return $behavior;
}
```

可以看到，上面这里把写在 LeaveType 中的behaviors()填充到Component->_behaviors[]中，为Behavior行为事件做准备。
instanceof 用于确定一个 PHP 变量是否属于某一类 class 的实例，也就是class实例化后的对象，这里没有实例化，所以需要用createObject实例化一下，
`Yii::createObject('yii\behaviors\TimestampBehavior')`返回结果 $behavior:
```
object(yii\behaviors\TimestampBehavior)#82 (6) {
    ["createdAtAttribute"]=> string(10) "created_at" 
    ["updatedAtAttribute"]=> string(10) "updated_at" 
    ["value"]=> NULL 
    ["attributes"]=> array(2) { 
        ["beforeInsert"]=> array(2) { 
            [0]=> string(10) "created_at" 
            [1]=> string(10) "updated_at" 
        } 
        ["beforeUpdate"]=> string(10) "updated_at" 
    } 
    ["skipUpdateOnClean"]=> bool(true) 
    ["owner"]=> NULL 
} 
```

attach()后 $behavior:
```
object(yii\behaviors\TimestampBehavior)#145 (6) {
  ["createdAtAttribute"]=> string(10) "created_at"
  ["updatedAtAttribute"]=> string(10) "updated_at"
  ["value"]=> NULL
  ["attributes"]=> array(2) {
    ["beforeInsert"]=>
    array(2) {
      [0]=> string(10) "created_at"
      [1]=> string(10) "updated_at"
    }
    ["beforeUpdate"]=> string(10) "updated_at"
  }
  ["skipUpdateOnClean"]=> bool(true)
  ["owner"]=>
  object(common\models\LeaveType)#141 (8) {
    ["_attributes":"yii\db\BaseActiveRecord":private]=> array(0) {}
    ["_oldAttributes":"yii\db\BaseActiveRecord":private]=> NULL
    ["_related":"yii\db\BaseActiveRecord":private]=> array(0) {}
    ["_errors":"yii\base\Model":private]=> NULL
    ["_validators":"yii\base\Model":private]=> NULL
    ["_scenario":"yii\base\Model":private]=> string(7) "default"
    ["_events":"yii\base\Component":private]=>
    array(2) {
      ["beforeInsert"]=>
      array(1) {
        [0]=>
        array(2) {
          [0]=>
          array(2) {
            [0]=> *RECURSION*
            [1]=> string(18) "evaluateAttributes"
          }
          [1]=> NULL
        }
      }
      ["beforeUpdate"]=>
      array(1) {
        [0]=>
        array(2) {
          [0]=>
          array(2) {
            [0]=> *RECURSION*
            [1]=> string(18) "evaluateAttributes"
          }
          [1]=> NULL
        }
      }
    }
    ["_behaviors":"yii\base\Component":private]=>
    array(1) {
      [0]=> *RECURSION*
    }
  }
}
```

yii\base\Component->_behaviors结果：
```
array(1) { 
    [0]=> object(yii\behaviors\TimestampBehavior)#145 (6) {
        ["createdAtAttribute"]=> string(10) "created_at"
        ["updatedAtAttribute"]=> string(10) "updated_at"
        ["value"]=> NULL
        ["attributes"]=>
        array(2) {
          ["beforeInsert"]=>
          array(2) {
            [0]=> string(10) "created_at"
            [1]=> string(10) "updated_at"
          }
          ["beforeUpdate"]=> string(10) "updated_at"
        }
        ["skipUpdateOnClean"]=> bool(true)
        ["owner"]=>
        object(common\models\LeaveType)#141 (8) {
          ["_attributes":"yii\db\BaseActiveRecord":private]=> array(0) {}
          ["_oldAttributes":"yii\db\BaseActiveRecord":private]=> NULL
          ["_related":"yii\db\BaseActiveRecord":private]=> array(0) {}
          ["_errors":"yii\base\Model":private]=> NULL
          ["_validators":"yii\base\Model":private]=> NULL
          ["_scenario":"yii\base\Model":private]=> string(7) "default"
          ["_events":"yii\base\Component":private]=>
          array(2) {
            ["beforeInsert"]=>
            array(1) {
              [0]=>
              array(2) {
                [0]=>
                array(2) {
                  [0]=>
                  *RECURSION*
                  [1]=>
                  string(18) "evaluateAttributes"
                }
                [1]=>
                NULL
              }
            }
            ["beforeUpdate"]=>
            array(1) {
              [0]=>
              array(2) {
                [0]=>
                array(2) {
                  [0]=>
                  *RECURSION*
                  [1]=>
                  string(18) "evaluateAttributes"
                }
                [1]=>
                NULL
              }
            }
          }
          ["_behaviors":"yii\base\Component":private]=>
          array(1) {
            [0]=>
            *RECURSION*
          }
        }
    }
}
```

trigger()中 yii\base\Component->_events 内容：
```
array(1) {
  ["beforeInsert"]=>
  array(1) {
    [0]=>
    array(2) {
      [0]=>
      array(2) {
        [0]=>
        object(yii\behaviors\TimestampBehavior)#145 (6) {
          ["createdAtAttribute"]=> string(10) "created_at"
          ["updatedAtAttribute"]=> string(10) "updated_at"
          ["value"]=> NULL
          ["attributes"]=>
          array(2) {
            ["beforeInsert"]=>
            array(2) {
              [0]=> string(10) "created_at"
              [1]=> string(10) "updated_at"
            }
            ["beforeUpdate"]=> string(10) "updated_at"
          }
          ["skipUpdateOnClean"]=> bool(true)
          ["owner"]=>
          object(common\models\LeaveType)#141 (8) {
            ["_attributes":"yii\db\BaseActiveRecord":private]=>
            array(4) {
              ["title"]=> string(14) "6afterOpen7sdf"
              ["info"]=> string(15) "<p>asd<br/></p>"
              ["create_user_id"]=> int(973)
              ["status"]=> int(10)
            }
            ["_oldAttributes":"yii\db\BaseActiveRecord":private]=> NULL
            ["_related":"yii\db\BaseActiveRecord":private]=> array(0) {}
            ["_errors":"yii\base\Model":private]=> array(0) {}
            ["_validators":"yii\base\Model":private]=>
            object(ArrayObject)#158 (1) {
              ["storage":"ArrayObject":private]=>
              array(0) {
              }
            }
            ["_scenario":"yii\base\Model":private]=>
            string(7) "default"
            ["_events":"yii\base\Component":private]=>
            array(2) {
              ["beforeInsert"]=>
              *RECURSION*
              ["beforeUpdate"]=>
              array(1) {
                [0]=>
                array(2) {
                  [0]=>
                  array(2) {
                    [0]=>
                    *RECURSION*
                    [1]=>
                    string(18) "evaluateAttributes"
                  }
                  [1]=>
                  NULL
                }
              }
            }
            ["_behaviors":"yii\base\Component":private]=>
            array(1) {
              [0]=>
              *RECURSION*
            }
          }
        }
        [1]=>
        string(18) "evaluateAttributes"
      }
      [1]=>
      NULL
    }
  }
}
```

trigger()中 $event 内容：
```
object(yii\base\ModelEvent)#160 (5) {
  ["isValid"]=> bool(true)
  ["name"]=> string(12) "beforeInsert"
  ["sender"]=>
  object(common\models\LeaveType)#141 (8) {
    ["_attributes":"yii\db\BaseActiveRecord":private]=>
    array(4) {
      ["title"]=> string(14) "6afterOpen7sdf"
      ["info"]=> string(15) "<p>asd<br/></p>"
      ["create_user_id"]=> int(973)
      ["status"]=> int(10)
    }
    ["_oldAttributes":"yii\db\BaseActiveRecord":private]=> NULL
    ["_related":"yii\db\BaseActiveRecord":private]=> array(0) {}
    ["_errors":"yii\base\Model":private]=> array(0) {}
    ["_validators":"yii\base\Model":private]=>
    object(ArrayObject)#158 (1) {
      ["storage":"ArrayObject":private]=> array(0) { }
    }
    ["_scenario":"yii\base\Model":private]=>
    string(7) "default"
    ["_events":"yii\base\Component":private]=>
    array(2) {
      ["beforeInsert"]=>
      array(1) {
        [0]=>
        array(2) {
          [0]=>
          array(2) {
            [0]=>
            object(yii\behaviors\TimestampBehavior)#145 (6) {
              ["createdAtAttribute"]=>
              string(10) "created_at"
              ["updatedAtAttribute"]=>
              string(10) "updated_at"
              ["value"]=>
              NULL
              ["attributes"]=>
              array(2) {
                ["beforeInsert"]=>
                array(2) {
                  [0]=>
                  string(10) "created_at"
                  [1]=>
                  string(10) "updated_at"
                }
                ["beforeUpdate"]=>
                string(10) "updated_at"
              }
              ["skipUpdateOnClean"]=>
              bool(true)
              ["owner"]=>
              *RECURSION*
            }
            [1]=>
            string(18) "evaluateAttributes"
          }
          [1]=>
          NULL
        }
      }
      ["beforeUpdate"]=>
      array(1) {
        [0]=>
        array(2) {
          [0]=>
          array(2) {
            [0]=>
            object(yii\behaviors\TimestampBehavior)#145 (6) {
              ["createdAtAttribute"]=>
              string(10) "created_at"
              ["updatedAtAttribute"]=>
              string(10) "updated_at"
              ["value"]=>
              NULL
              ["attributes"]=>
              array(2) {
                ["beforeInsert"]=>
                array(2) {
                  [0]=>
                  string(10) "created_at"
                  [1]=>
                  string(10) "updated_at"
                }
                ["beforeUpdate"]=>
                string(10) "updated_at"
              }
              ["skipUpdateOnClean"]=>
              bool(true)
              ["owner"]=>
              *RECURSION*
            }
            [1]=>
            string(18) "evaluateAttributes"
          }
          [1]=>
          NULL
        }
      }
    }
    ["_behaviors":"yii\base\Component":private]=>
    array(1) {
      [0]=>
      object(yii\behaviors\TimestampBehavior)#145 (6) {
        ["createdAtAttribute"]=>
        string(10) "created_at"
        ["updatedAtAttribute"]=>
        string(10) "updated_at"
        ["value"]=>
        NULL
        ["attributes"]=>
        array(2) {
          ["beforeInsert"]=>
          array(2) {
            [0]=>
            string(10) "created_at"
            [1]=>
            string(10) "updated_at"
          }
          ["beforeUpdate"]=>
          string(10) "updated_at"
        }
        ["skipUpdateOnClean"]=>
        bool(true)
        ["owner"]=>
        *RECURSION*
      }
    }
  }
  ["handled"]=>
  bool(false)
  ["data"]=>
  NULL
}
```

`call_user_func($handler[0], $event)`调用的是：
```
// 两个object参数都可以在上面找到
call_user_func([object(yii\behaviors\TimestampBehavior), "evaluateAttributes"], object(yii\base\ModelEvent));
```

看到这里应该都行为注入及实现原理有进一步理解了吧。

### 行为的属性和方法注入原理

上面我们了解到了行为的用意在于将自身的属性和方法注入给所依附的类。 那么Yii中是如何将一个行为 `yii\base\Behavior` 的属性和方法， 
注入到一个 `yii\base\Component` 中的呢？ 对于属性而言，是通过 `__get()` 和 `__set()` 魔术方法来实现的。 对于方法，是通过 `__call()` 方法。

#### 属性的注入

以读取为例，如果访问 `$Component->property1` ，Yii在幕后干了些什么呢？ 这个看看 `yii\base\Component::__get()`
```
public function __get($name)
{
    $getter = 'get' . $name;
    if (method_exists($this, $getter)) {
        return $this->$getter();
    } else {
        // 注意这个 else 分支的内容，正是与 yii\base\Object::__get() 的不同之处
        $this->ensureBehaviors();
        foreach ($this->_behaviors as $behavior) {
            if ($behavior->canGetProperty($name)) {
                return $behavior->$name;
            }
        }
    }
    if (method_exists($this, 'set' . $name)) {
        throw new InvalidCallException('Getting write-only property: ' .
            get_class($this) . '::' . $name);
    } else {
        throw new UnknownPropertyException('Getting unknown property: ' .
            get_class($this) . '::' . $name);
    }
}
```

重点来看 `yii\base\Compoent::__get()` 与 `yii\base\Object::__get()` 的不同之处。 就是在于对于未定义getter函数之后的处理， 
`yii\base\Object` 是直接抛出异常， 告诉你想要访问的属性不存在之类。 但是 `yii\base\Component` 则是在不存在getter之后，
还要看看是不是注入的行为的属性：

* 首先，调用了 `$this->ensureBehaviors()` 。这个方法已经在前面讲过了，主要是确保行为已经绑定。
* 在确保行为已经绑定后，开始遍历 `$this->_behaviors` 。 Yii将类所有绑定的行为都保存在 `yii\base\Compoent::$_behaviors[]` 数组中。
* 最后，通过行为的 `canGetProperty()` 判断这个属性， 是否是所绑定行为的可读属性，如果是，就返回这个行为的这个属性 `$behavior->name` 。 
完成属性的读取。 

对于setter，代码类似。

#### 方法的注入

与属性的注入通过 `__get()` 、 `__set()` 魔术方法类似， Yii通过 `Component::__call()` 魔术方法实现对行为中方法的注入:
```
public function __call($name, $params)
{
    $this->ensureBehaviors();
    foreach ($this->_behaviors as $object) {
        if ($object->hasMethod($name)) {
            return call_user_func_array([$object, $name], $params);
        }
    }
    throw new UnknownMethodException('Calling unknown method: ' . get_class($this) . "::$name()");
}
```

从上面的代码中可以看出，Yii还是先是调用了 `$this->ensureBehaviors()` 确保行为已经绑定。
然后，也是遍历 `yii\base\Component::$_behaviros[]` 数组。 通过 `hasMethod()` 方法判断方法是否存在。 
如果所绑定的行为中要调用的方法存在，则使用PHP的 `call_user_func_array()` 调用之。

#### 注入属性与方法的访问控制

在上面的内容，我们知道，一个属性可不可访问，主要看行为的 canGetProperty() 和 canSetProperty() 。 
而一个方法可不可调用，主要看行为的 hasMethod() 。 由于 yii\base\Behavior 继承自 yii\base\Object ，
所以上面提到的三个判断方法， 事实上代码都在 Object 中。我们一个一个来看:
```
public function canGetProperty($name, $checkVars = true)
{
    return method_exists($this, 'get' . $name) || $checkVars && property_exists($this, $name);
}

public function canSetProperty($name, $checkVars = true)
{
    return method_exists($this, 'set' . $name) || $checkVars && property_exists($this, $name);
}

public function hasMethod($name)
{
    return method_exists($this, $name);
}
```

对此，我们可以得出以下结论：

* 当向Component绑定的行为读取（写入）一个属性时，如果行为为该属性定义了一个getter (setter)，则可以访问。 
或者，如果行为确实具有该成员变量即可通过上面的判断，此时，该成员变量可为 public, private, protected。 
但最终只有 public 的成员变量才能正确访问。`$checkVars`是否检查成员变量，当为false时，只查看getter (setter)。
* 当调用Component绑定的行为的一个方法时，如果行为已经定义了该方法，即可通过上面的判断。 
此时，这个方法可以为 public, private, protected。 但最终只有 public 的方法才能正确调用。如果你理解了上一款的原因，那么这里也就理解了。

### 行为与继承和特性区别

从实现的效果看，你是不是会认为Yii真是多此一举？PHP中要达到这样的效果，可以使用继承呀，可以使用PHP新引入的特性（Traits）呀。但是，
行为具有继承和特性所没有的优点，从实际使用的角度讲，继承和特性更靠底层点。靠底层，就意味着开发效率低，运行效率高。行为的引入，
是以可以接受的运行效率牺牲为成本，谋取开发效率大提升的一种方法。

#### 行为与继承

首先来讲，拿行为与继承比较，从逻辑上是不对的，这两者是在完全不同的层面上的事物，是不对等的。
之所以进行比较，是因为在实现的效果上，两者有类似的地方。看起来，行为和继承都可以使一个类具有另一个类的属性和方法，从而达到扩充类的功能的目的。

相比较于使用继承的方式来扩充类功能，使用行为的方式，一是不必对现有类进行修改，二是PHP不支持多继承，
但是Yii可以绑定多个行为，从而达到类似多继承的效果。

从本质上来讲，行为只是一种设计模式，是解决问题的方法学。继承则是PHP作为编程语言所提供的特性。

#### 行为与特性（Traits）

特性是PHP5.4之后引入的一个新feature。从实现效果看，行为与特性都达到把自身的public 变量、属性、方法注入到当前类中去的目的。
在使用上，他们也各有所长，但总的原则可以按下面的提示进行把握。

倾向于使用行为的情况：

* 行为从本质上讲，也是PHP的类，因此一个行为可以继承自另一个行为，从而实现代码的复用。而特性只是PHP的一种语法，
效果上类似于把特性的代码导入到了类中从而实现代码的注入，特性是不支持继承的。
* 行为可以动态地绑定、解除，而不必要对类进行修改。但是特性必须在类中使用 use 语句，要解除特性时，则要删除这个语句。换句话说，需要对类进行修改。
* 行为还以在在配置阶段进行绑定，特性就不行了。
* 行为可以用于对事件进行反馈，而特性不行。
* 当出现命名冲突时，行为会自行排除冲突，自动使用先绑定的行为。而特性在发生冲突时，需要人为干预，修改发生冲突的变量名、属性名、方法名。

倾向于使用特性的情况：

* 特性比行为在效率上要高一点，因为行为其实是类的实例，需要时间和空间进行分配。
* 特性是PHP的语法，因此，IDE的支持要好一些。目前还没有IDE能支持行为。

### 实例分析

开发中碰到一个需求：需要统计用户多个特定操作的次数并返回。
这个需求我们就可以用行为实现，以最大限度减小对原程序的影响。
原来想到只用事件就可以实现，但又想到还要返回统计数，用事件无法返回数据，还需要一个获取统计数的方法，所以选用了行为。

先把行为类写好：
```php
<?php
namespace common\behaviors;

use common\models\UserActionStatis;
use Yii;
use yii\base\Behavior;
use yii\base\Event;

/**
 * 用户操作统计行为类
 * Class UserActionStatisBehavior
 * @package common\behaviors
 */
class UserActionStatisBehavior extends Behavior
{
    const UPDATE_ONE_OF_USER_ACTION_STATIS = "updateOneOfUserActionStatis";

    // 操作人id
    public $do_user_id;
    // 操作地址
    public $action_addr;

    /**
     * @return array
     */
    public function events()
    {
        return [
            self::UPDATE_ONE_OF_USER_ACTION_STATIS => [$this, "updateOneOfUserActionStatis"]
        ];
    }

    /**
     * 获取当前操作次数
     * @return int|mixed
     */
    public function getActionSatisNum()
    {
        $user_id = $this->do_user_id;
        $action_addr = $this->action_addr;
        if (empty($action_addr)) {
            $action_addr = $this->owner->id .'/' .$this->owner->action->id;
        }
        $action_hash = hash("md5", $action_addr);

        $model = UserActionStatis::find()
            ->andWhere("user_id = :user_id", [":user_id" => $user_id])
            ->andWhere("action_hash = :action_hash", [":action_hash" => $action_hash])
            ->one();

        if (!empty($model)) {
            return $model->num;
        }

        return 0;
    }

    /**
     * 更新用户操作统计
     * @param Event $event
     * @return bool
     */
    public function updateOneOfUserActionStatis(Event $event)
    {
        $user_id = $this->do_user_id;
        $action_addr = $event->sender->id .'/' .$event->sender->action->id;
        $action_hash = hash("md5", $action_addr);

        $model = UserActionStatis::find()
            ->andWhere("user_id = :user_id", [":user_id" => $user_id])
            ->andWhere("action_hash = :action_hash", [":action_hash" => $action_hash])
            ->one();

        if (empty($model)) {
            $model = new UserActionStatis;
            $model->user_id = $user_id;
            $model->action_addr = $action_addr;
            $model->action_hash = $action_hash;
            $model->num = 1;
            $model->created_time = $model->updated_time = time();
        } else {
            $model->num++;
            $model->updated_time = time();
        }

        return $model->save();
    }
}
```

UserActionStatis模型model类：
```php
<?php
namespace common\models;

use Yii;
use yii\db\ActiveRecord;

class UserActionStatis extends ActiveRecord
{
    public static function getDb()
    {
        return Yii::$app->db;
    }

    public static function tableName()
    {
        return 'user_action_statis';
    }
}
```

user_action_statis表结构：
```
CREATE TABLE `user_action_statis` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL DEFAULT '0' COMMENT '用户id',
  `action_addr` varchar(100) NOT NULL DEFAULT '' COMMENT '操作地址',
  `action_hash` varchar(64) NOT NULL DEFAULT '' COMMENT '操作hash',
  `num` int(11) NOT NULL DEFAULT '0' COMMENT '统计数',
  `created_time` int(11) NOT NULL DEFAULT '0' COMMENT '添加时间',
  `updated_time` int(11) NOT NULL DEFAULT '0' COMMENT '更新时间',
  PRIMARY KEY (`id`),
  KEY `idx_user_id` (`user_id`) USING BTREE,
  KEY `idx_action_hash` (`action_hash`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COMMENT='用户操作统计表';
```

例如我们要记录用户修改详情的次数，我们在控制器中使用上面的行为：
```php
<?php
namespace backend\controllers;

use Yii;
use yii\web\Controller;

class UserController extends Controller
{
    public function actionEditInfo()
    {
        /*保存操作*/
        
        // 附加行为
        $this->attachBehavior("userActionStatisBehavior", "\common\behaviors\UserActionStatisBehavior");
        $this->do_user_id = Yii::$app->user->id;
        
        // 触发事件
        $this->trigger(\common\behaviors\UserActionStatisBehavior::UPDATE_ONE_OF_USER_ACTION_STATIS);
        
        // 打印操作统计数
        echo $this->actionSatisNum;
    }
}
?>
```

## 源码

### `yii\base\BaseObject` 类

```php
<?php
/**
 * @link http://www.yiiframework.com/
 * @copyright Copyright (c) 2008 Yii Software LLC
 * @license http://www.yiiframework.com/license/
 */

namespace yii\base;

use Yii;

/**
 * BaseObject is the base class that implements the *property* feature.
 *
 * A property is defined by a getter method (e.g. `getLabel`), and/or a setter method (e.g. `setLabel`). For example,
 * the following getter and setter methods define a property named `label`:
 *
 * 
 * private $_label;
 *
 * public function getLabel()
 * {
 *     return $this->_label;
 * }
 *
 * public function setLabel($value)
 * {
 *     $this->_label = $value;
 * }
 * 
 *
 * Property names are *case-insensitive*.
 *
 * A property can be accessed like a member variable of an object. Reading or writing a property will cause the invocation
 * of the corresponding getter or setter method. For example,
 *
 * 
 * // equivalent to $label = $object->getLabel();
 * $label = $object->label;
 * // equivalent to $object->setLabel('abc');
 * $object->label = 'abc';
 * 
 *
 * If a property has only a getter method and has no setter method, it is considered as *read-only*. In this case, trying
 * to modify the property value will cause an exception.
 *
 * One can call [[hasProperty()]], [[canGetProperty()]] and/or [[canSetProperty()]] to check the existence of a property.
 *
 * Besides the property feature, BaseObject also introduces an important object initialization life cycle. In particular,
 * creating an new instance of BaseObject or its derived class will involve the following life cycles sequentially:
 *
 * 1. the class constructor is invoked;
 * 2. object properties are initialized according to the given configuration;
 * 3. the `init()` method is invoked.
 *
 * In the above, both Step 2 and 3 occur at the end of the class constructor. It is recommended that
 * you perform object initialization in the `init()` method because at that stage, the object configuration
 * is already applied.
 *
 * In order to ensure the above life cycles, if a child class of BaseObject needs to override the constructor,
 * it should be done like the following:
 *
 * 
 * public function __construct($param1, $param2, ..., $config = [])
 * {
 *     ...
 *     parent::__construct($config);
 * }
 * 
 *
 * That is, a `$config` parameter (defaults to `[]`) should be declared as the last parameter
 * of the constructor, and the parent implementation should be called at the end of the constructor.
 *
 * @author Qiang Xue <qiang.xue@gmail.com>
 * @since 2.0.13
 */
class BaseObject implements Configurable
{
    /**
     * Returns the fully qualified name of this class.
     * @return string the fully qualified name of this class.
     * @deprecated since 2.0.14. On PHP >=5.5, use `::class` instead.
     */
    public static function className()
    {
        return get_called_class();
    }

    /**
     * Constructor.
     *
     * The default implementation does two things:
     *
     * - Initializes the object with the given configuration `$config`.
     * - Call [[init()]].
     *
     * If this method is overridden in a child class, it is recommended that
     *
     * - the last parameter of the constructor is a configuration array, like `$config` here.
     * - call the parent implementation at the end of the constructor.
     *
     * @param array $config name-value pairs that will be used to initialize the object properties
     */
    public function __construct($config = [])
    {
        if (!empty($config)) {
            Yii::configure($this, $config);
        }
        $this->init();
    }

    /**
     * Initializes the object.
     * This method is invoked at the end of the constructor after the object is initialized with the
     * given configuration.
     */
    public function init()
    {
    }

    /**
     * Returns the value of an object property.
     *
     * Do not call this method directly as it is a PHP magic method that
     * will be implicitly called when executing `$value = $object->property;`.
     * @param string $name the property name
     * @return mixed the property value
     * @throws UnknownPropertyException if the property is not defined
     * @throws InvalidCallException if the property is write-only
     * @see __set()
     */
    public function __get($name)
    {
        $getter = 'get' . $name;
        if (method_exists($this, $getter)) {
            return $this->$getter();
        } elseif (method_exists($this, 'set' . $name)) {
            throw new InvalidCallException('Getting write-only property: ' . get_class($this) . '::' . $name);
        }

        throw new UnknownPropertyException('Getting unknown property: ' . get_class($this) . '::' . $name);
    }

    /**
     * Sets value of an object property.
     *
     * Do not call this method directly as it is a PHP magic method that
     * will be implicitly called when executing `$object->property = $value;`.
     * @param string $name the property name or the event name
     * @param mixed $value the property value
     * @throws UnknownPropertyException if the property is not defined
     * @throws InvalidCallException if the property is read-only
     * @see __get()
     */
    public function __set($name, $value)
    {
        $setter = 'set' . $name;
        if (method_exists($this, $setter)) {
            $this->$setter($value);
        } elseif (method_exists($this, 'get' . $name)) {
            throw new InvalidCallException('Setting read-only property: ' . get_class($this) . '::' . $name);
        } else {
            throw new UnknownPropertyException('Setting unknown property: ' . get_class($this) . '::' . $name);
        }
    }

    /**
     * Checks if a property is set, i.e. defined and not null.
     *
     * Do not call this method directly as it is a PHP magic method that
     * will be implicitly called when executing `isset($object->property)`.
     *
     * Note that if the property is not defined, false will be returned.
     * @param string $name the property name or the event name
     * @return bool whether the named property is set (not null).
     * @see https://www.php.net/manual/en/function.isset.php
     */
    public function __isset($name)
    {
        $getter = 'get' . $name;
        if (method_exists($this, $getter)) {
            return $this->$getter() !== null;
        }

        return false;
    }

    /**
     * Sets an object property to null.
     *
     * Do not call this method directly as it is a PHP magic method that
     * will be implicitly called when executing `unset($object->property)`.
     *
     * Note that if the property is not defined, this method will do nothing.
     * If the property is read-only, it will throw an exception.
     * @param string $name the property name
     * @throws InvalidCallException if the property is read only.
     * @see https://www.php.net/manual/en/function.unset.php
     */
    public function __unset($name)
    {
        $setter = 'set' . $name;
        if (method_exists($this, $setter)) {
            $this->$setter(null);
        } elseif (method_exists($this, 'get' . $name)) {
            throw new InvalidCallException('Unsetting read-only property: ' . get_class($this) . '::' . $name);
        }
    }

    /**
     * Calls the named method which is not a class method.
     *
     * Do not call this method directly as it is a PHP magic method that
     * will be implicitly called when an unknown method is being invoked.
     * @param string $name the method name
     * @param array $params method parameters
     * @throws UnknownMethodException when calling unknown method
     * @return mixed the method return value
     */
    public function __call($name, $params)
    {
        throw new UnknownMethodException('Calling unknown method: ' . get_class($this) . "::$name()");
    }

    /**
     * Returns a value indicating whether a property is defined.
     *
     * A property is defined if:
     *
     * - the class has a getter or setter method associated with the specified name
     *   (in this case, property name is case-insensitive);
     * - the class has a member variable with the specified name (when `$checkVars` is true);
     *
     * @param string $name the property name
     * @param bool $checkVars whether to treat member variables as properties
     * @return bool whether the property is defined
     * @see canGetProperty()
     * @see canSetProperty()
     */
    public function hasProperty($name, $checkVars = true)
    {
        return $this->canGetProperty($name, $checkVars) || $this->canSetProperty($name, false);
    }

    /**
     * Returns a value indicating whether a property can be read.
     *
     * A property is readable if:
     *
     * - the class has a getter method associated with the specified name
     *   (in this case, property name is case-insensitive);
     * - the class has a member variable with the specified name (when `$checkVars` is true);
     *
     * @param string $name the property name
     * @param bool $checkVars whether to treat member variables as properties
     * @return bool whether the property can be read
     * @see canSetProperty()
     */
    public function canGetProperty($name, $checkVars = true)
    {
        return method_exists($this, 'get' . $name) || $checkVars && property_exists($this, $name);
    }

    /**
     * Returns a value indicating whether a property can be set.
     *
     * A property is writable if:
     *
     * - the class has a setter method associated with the specified name
     *   (in this case, property name is case-insensitive);
     * - the class has a member variable with the specified name (when `$checkVars` is true);
     *
     * @param string $name the property name
     * @param bool $checkVars whether to treat member variables as properties
     * @return bool whether the property can be written
     * @see canGetProperty()
     */
    public function canSetProperty($name, $checkVars = true)
    {
        return method_exists($this, 'set' . $name) || $checkVars && property_exists($this, $name);
    }

    /**
     * Returns a value indicating whether a method is defined.
     *
     * The default implementation is a call to php function `method_exists()`.
     * You may override this method when you implemented the php magic method `__call()`.
     * @param string $name the method name
     * @return bool whether the method is defined
     */
    public function hasMethod($name)
    {
        return method_exists($this, $name);
    }
}
```

### `yii\base\Component` 类

```php
<?php
/**
 * @link http://www.yiiframework.com/
 * @copyright Copyright (c) 2008 Yii Software LLC
 * @license http://www.yiiframework.com/license/
 */

namespace yii\base;

use Yii;
use yii\helpers\StringHelper;

/**
 * Component is the base class that implements the *property*, *event* and *behavior* features.
 *
 * Component provides the *event* and *behavior* features, in addition to the *property* feature which is implemented in
 * its parent class [[\yii\base\BaseObject|BaseObject]].
 *
 * Event is a way to "inject" custom code into existing code at certain places. For example, a comment object can trigger
 * an "add" event when the user adds a comment. We can write custom code and attach it to this event so that when the event
 * is triggered (i.e. comment will be added), our custom code will be executed.
 *
 * An event is identified by a name that should be unique within the class it is defined at. Event names are *case-sensitive*.
 *
 * One or multiple PHP callbacks, called *event handlers*, can be attached to an event. You can call [[trigger()]] to
 * raise an event. When an event is raised, the event handlers will be invoked automatically in the order they were
 * attached.
 *
 * To attach an event handler to an event, call [[on()]]:
 *
 * 
 * $post->on('update', function ($event) {
 *     // send email notification
 * });
 * 
 *
 * In the above, an anonymous function is attached to the "update" event of the post. You may attach
 * the following types of event handlers:
 *
 * - anonymous function: `function ($event) { ... }`
 * - object method: `[$object, 'handleAdd']`
 * - static class method: `['Page', 'handleAdd']`
 * - global function: `'handleAdd'`
 *
 * The signature of an event handler should be like the following:
 *
 * 
 * function foo($event)
 * 
 *
 * where `$event` is an [[Event]] object which includes parameters associated with the event.
 *
 * You can also attach a handler to an event when configuring a component with a configuration array.
 * The syntax is like the following:
 *
 * 
 * [
 *     'on add' => function ($event) { ... }
 * ]
 * 
 *
 * where `on add` stands for attaching an event to the `add` event.
 *
 * Sometimes, you may want to associate extra data with an event handler when you attach it to an event
 * and then access it when the handler is invoked. You may do so by
 *
 * 
 * $post->on('update', function ($event) {
 *     // the data can be accessed via $event->data
 * }, $data);
 * 
 *
 * A behavior is an instance of [[Behavior]] or its child class. A component can be attached with one or multiple
 * behaviors. When a behavior is attached to a component, its public properties and methods can be accessed via the
 * component directly, as if the component owns those properties and methods.
 *
 * To attach a behavior to a component, declare it in [[behaviors()]], or explicitly call [[attachBehavior]]. Behaviors
 * declared in [[behaviors()]] are automatically attached to the corresponding component.
 *
 * One can also attach a behavior to a component when configuring it with a configuration array. The syntax is like the
 * following:
 *
 * 
 * [
 *     'as tree' => [
 *         'class' => 'Tree',
 *     ],
 * ]
 * 
 *
 * where `as tree` stands for attaching a behavior named `tree`, and the array will be passed to [[\Yii::createObject()]]
 * to create the behavior object.
 *
 * For more details and usage information on Component, see the [guide article on components](guide:concept-components).
 *
 * @property-read Behavior[] $behaviors List of behaviors attached to this component.
 *
 * @author Qiang Xue <qiang.xue@gmail.com>
 * @since 2.0
 */
class Component extends BaseObject
{
    /**
     * @var array the attached event handlers (event name => handlers)
     */
    private $_events = [];
    /**
     * @var array the event handlers attached for wildcard patterns (event name wildcard => handlers)
     * @since 2.0.14
     */
    private $_eventWildcards = [];
    /**
     * @var Behavior[]|null the attached behaviors (behavior name => behavior). This is `null` when not initialized.
     */
    private $_behaviors;


    /**
     * Returns the value of a component property.
     *
     * This method will check in the following order and act accordingly:
     *
     *  - a property defined by a getter: return the getter result
     *  - a property of a behavior: return the behavior property value
     *
     * Do not call this method directly as it is a PHP magic method that
     * will be implicitly called when executing `$value = $component->property;`.
     * @param string $name the property name
     * @return mixed the property value or the value of a behavior's property
     * @throws UnknownPropertyException if the property is not defined
     * @throws InvalidCallException if the property is write-only.
     * @see __set()
     */
    public function __get($name)
    {
        $getter = 'get' . $name;
        if (method_exists($this, $getter)) {
            // read property, e.g. getName()
            return $this->$getter();
        }

        // behavior property
        $this->ensureBehaviors();
        foreach ($this->_behaviors as $behavior) {
            if ($behavior->canGetProperty($name)) {
                return $behavior->$name;
            }
        }

        if (method_exists($this, 'set' . $name)) {
            throw new InvalidCallException('Getting write-only property: ' . get_class($this) . '::' . $name);
        }

        throw new UnknownPropertyException('Getting unknown property: ' . get_class($this) . '::' . $name);
    }

    /**
     * Sets the value of a component property.
     *
     * This method will check in the following order and act accordingly:
     *
     *  - a property defined by a setter: set the property value
     *  - an event in the format of "on xyz": attach the handler to the event "xyz"
     *  - a behavior in the format of "as xyz": attach the behavior named as "xyz"
     *  - a property of a behavior: set the behavior property value
     *
     * Do not call this method directly as it is a PHP magic method that
     * will be implicitly called when executing `$component->property = $value;`.
     * @param string $name the property name or the event name
     * @param mixed $value the property value
     * @throws UnknownPropertyException if the property is not defined
     * @throws InvalidCallException if the property is read-only.
     * @see __get()
     */
    public function __set($name, $value)
    {
        $setter = 'set' . $name;
        if (method_exists($this, $setter)) {
            // set property
            $this->$setter($value);

            return;
        } elseif (strncmp($name, 'on ', 3) === 0) {
            // on event: attach event handler
            $this->on(trim(substr($name, 3)), $value);

            return;
        } elseif (strncmp($name, 'as ', 3) === 0) {
            // as behavior: attach behavior
            $name = trim(substr($name, 3));
            $this->attachBehavior($name, $value instanceof Behavior ? $value : Yii::createObject($value));

            return;
        }

        // behavior property
        $this->ensureBehaviors();
        foreach ($this->_behaviors as $behavior) {
            if ($behavior->canSetProperty($name)) {
                $behavior->$name = $value;
                return;
            }
        }

        if (method_exists($this, 'get' . $name)) {
            throw new InvalidCallException('Setting read-only property: ' . get_class($this) . '::' . $name);
        }

        throw new UnknownPropertyException('Setting unknown property: ' . get_class($this) . '::' . $name);
    }

    /**
     * Checks if a property is set, i.e. defined and not null.
     *
     * This method will check in the following order and act accordingly:
     *
     *  - a property defined by a setter: return whether the property is set
     *  - a property of a behavior: return whether the property is set
     *  - return `false` for non existing properties
     *
     * Do not call this method directly as it is a PHP magic method that
     * will be implicitly called when executing `isset($component->property)`.
     * @param string $name the property name or the event name
     * @return bool whether the named property is set
     * @see https://www.php.net/manual/en/function.isset.php
     */
    public function __isset($name)
    {
        $getter = 'get' . $name;
        if (method_exists($this, $getter)) {
            return $this->$getter() !== null;
        }

        // behavior property
        $this->ensureBehaviors();
        foreach ($this->_behaviors as $behavior) {
            if ($behavior->canGetProperty($name)) {
                return $behavior->$name !== null;
            }
        }

        return false;
    }

    /**
     * Sets a component property to be null.
     *
     * This method will check in the following order and act accordingly:
     *
     *  - a property defined by a setter: set the property value to be null
     *  - a property of a behavior: set the property value to be null
     *
     * Do not call this method directly as it is a PHP magic method that
     * will be implicitly called when executing `unset($component->property)`.
     * @param string $name the property name
     * @throws InvalidCallException if the property is read only.
     * @see https://www.php.net/manual/en/function.unset.php
     */
    public function __unset($name)
    {
        $setter = 'set' . $name;
        if (method_exists($this, $setter)) {
            $this->$setter(null);
            return;
        }

        // behavior property
        $this->ensureBehaviors();
        foreach ($this->_behaviors as $behavior) {
            if ($behavior->canSetProperty($name)) {
                $behavior->$name = null;
                return;
            }
        }

        throw new InvalidCallException('Unsetting an unknown or read-only property: ' . get_class($this) . '::' . $name);
    }

    /**
     * Calls the named method which is not a class method.
     *
     * This method will check if any attached behavior has
     * the named method and will execute it if available.
     *
     * Do not call this method directly as it is a PHP magic method that
     * will be implicitly called when an unknown method is being invoked.
     * @param string $name the method name
     * @param array $params method parameters
     * @return mixed the method return value
     * @throws UnknownMethodException when calling unknown method
     */
    public function __call($name, $params)
    {
        $this->ensureBehaviors();
        foreach ($this->_behaviors as $object) {
            if ($object->hasMethod($name)) {
                return call_user_func_array([$object, $name], $params);
            }
        }
        throw new UnknownMethodException('Calling unknown method: ' . get_class($this) . "::$name()");
    }

    /**
     * This method is called after the object is created by cloning an existing one.
     * It removes all behaviors because they are attached to the old object.
     */
    public function __clone()
    {
        $this->_events = [];
        $this->_eventWildcards = [];
        $this->_behaviors = null;
    }

    /**
     * Returns a value indicating whether a property is defined for this component.
     *
     * A property is defined if:
     *
     * - the class has a getter or setter method associated with the specified name
     *   (in this case, property name is case-insensitive);
     * - the class has a member variable with the specified name (when `$checkVars` is true);
     * - an attached behavior has a property of the given name (when `$checkBehaviors` is true).
     *
     * @param string $name the property name
     * @param bool $checkVars whether to treat member variables as properties
     * @param bool $checkBehaviors whether to treat behaviors' properties as properties of this component
     * @return bool whether the property is defined
     * @see canGetProperty()
     * @see canSetProperty()
     */
    public function hasProperty($name, $checkVars = true, $checkBehaviors = true)
    {
        return $this->canGetProperty($name, $checkVars, $checkBehaviors) || $this->canSetProperty($name, false, $checkBehaviors);
    }

    /**
     * Returns a value indicating whether a property can be read.
     *
     * A property can be read if:
     *
     * - the class has a getter method associated with the specified name
     *   (in this case, property name is case-insensitive);
     * - the class has a member variable with the specified name (when `$checkVars` is true);
     * - an attached behavior has a readable property of the given name (when `$checkBehaviors` is true).
     *
     * @param string $name the property name
     * @param bool $checkVars whether to treat member variables as properties
     * @param bool $checkBehaviors whether to treat behaviors' properties as properties of this component
     * @return bool whether the property can be read
     * @see canSetProperty()
     */
    public function canGetProperty($name, $checkVars = true, $checkBehaviors = true)
    {
        if (method_exists($this, 'get' . $name) || $checkVars && property_exists($this, $name)) {
            return true;
        } elseif ($checkBehaviors) {
            $this->ensureBehaviors();
            foreach ($this->_behaviors as $behavior) {
                if ($behavior->canGetProperty($name, $checkVars)) {
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Returns a value indicating whether a property can be set.
     *
     * A property can be written if:
     *
     * - the class has a setter method associated with the specified name
     *   (in this case, property name is case-insensitive);
     * - the class has a member variable with the specified name (when `$checkVars` is true);
     * - an attached behavior has a writable property of the given name (when `$checkBehaviors` is true).
     *
     * @param string $name the property name
     * @param bool $checkVars whether to treat member variables as properties
     * @param bool $checkBehaviors whether to treat behaviors' properties as properties of this component
     * @return bool whether the property can be written
     * @see canGetProperty()
     */
    public function canSetProperty($name, $checkVars = true, $checkBehaviors = true)
    {
        if (method_exists($this, 'set' . $name) || $checkVars && property_exists($this, $name)) {
            return true;
        } elseif ($checkBehaviors) {
            $this->ensureBehaviors();
            foreach ($this->_behaviors as $behavior) {
                if ($behavior->canSetProperty($name, $checkVars)) {
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Returns a value indicating whether a method is defined.
     *
     * A method is defined if:
     *
     * - the class has a method with the specified name
     * - an attached behavior has a method with the given name (when `$checkBehaviors` is true).
     *
     * @param string $name the property name
     * @param bool $checkBehaviors whether to treat behaviors' methods as methods of this component
     * @return bool whether the method is defined
     */
    public function hasMethod($name, $checkBehaviors = true)
    {
        if (method_exists($this, $name)) {
            return true;
        } elseif ($checkBehaviors) {
            $this->ensureBehaviors();
            foreach ($this->_behaviors as $behavior) {
                if ($behavior->hasMethod($name)) {
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Returns a list of behaviors that this component should behave as.
     *
     * Child classes may override this method to specify the behaviors they want to behave as.
     *
     * The return value of this method should be an array of behavior objects or configurations
     * indexed by behavior names. A behavior configuration can be either a string specifying
     * the behavior class or an array of the following structure:
     *
     * ```php
     * 'behaviorName' => [
     *     'class' => 'BehaviorClass',
     *     'property1' => 'value1',
     *     'property2' => 'value2',
     * ]
     * ```
     *
     * Note that a behavior class must extend from [[Behavior]]. Behaviors can be attached using a name or anonymously.
     * When a name is used as the array key, using this name, the behavior can later be retrieved using [[getBehavior()]]
     * or be detached using [[detachBehavior()]]. Anonymous behaviors can not be retrieved or detached.
     *
     * Behaviors declared in this method will be attached to the component automatically (on demand).
     *
     * @return array the behavior configurations.
     */
    public function behaviors()
    {
        return [];
    }

    /**
     * Returns a value indicating whether there is any handler attached to the named event.
     * @param string $name the event name
     * @return bool whether there is any handler attached to the event.
     */
    public function hasEventHandlers($name)
    {
        $this->ensureBehaviors();

        if (!empty($this->_events[$name])) {
            return true;
        }

        foreach ($this->_eventWildcards as $wildcard => $handlers) {
            if (!empty($handlers) && StringHelper::matchWildcard($wildcard, $name)) {
                return true;
            }
        }

        return Event::hasHandlers($this, $name);
    }

    /**
     * Attaches an event handler to an event.
     *
     * The event handler must be a valid PHP callback. The following are
     * some examples:
     *
     * ```
     * function ($event) { ... }         // anonymous function
     * [$object, 'handleClick']          // $object->handleClick()
     * ['Page', 'handleClick']           // Page::handleClick()
     * 'handleClick'                     // global function handleClick()
     * ```
     *
     * The event handler must be defined with the following signature,
     *
     * ```
     * function ($event)
     * ```
     *
     * where `$event` is an [[Event]] object which includes parameters associated with the event.
     *
     * Since 2.0.14 you can specify event name as a wildcard pattern:
     *
     * ```php
     * $component->on('event.group.*', function ($event) {
     *     Yii::trace($event->name . ' is triggered.');
     * });
     * ```
     *
     * @param string $name the event name
     * @param callable $handler the event handler
     * @param mixed $data the data to be passed to the event handler when the event is triggered.
     * When the event handler is invoked, this data can be accessed via [[Event::data]].
     * @param bool $append whether to append new event handler to the end of the existing
     * handler list. If false, the new handler will be inserted at the beginning of the existing
     * handler list.
     * @see off()
     */
    public function on($name, $handler, $data = null, $append = true)
    {
        $this->ensureBehaviors();

        if (strpos($name, '*') !== false) {
            if ($append || empty($this->_eventWildcards[$name])) {
                $this->_eventWildcards[$name][] = [$handler, $data];
            } else {
                array_unshift($this->_eventWildcards[$name], [$handler, $data]);
            }
            return;
        }

        if ($append || empty($this->_events[$name])) {
            $this->_events[$name][] = [$handler, $data];
        } else {
            array_unshift($this->_events[$name], [$handler, $data]);
        }
    }

    /**
     * Detaches an existing event handler from this component.
     *
     * This method is the opposite of [[on()]].
     *
     * Note: in case wildcard pattern is passed for event name, only the handlers registered with this
     * wildcard will be removed, while handlers registered with plain names matching this wildcard will remain.
     *
     * @param string $name event name
     * @param callable $handler the event handler to be removed.
     * If it is null, all handlers attached to the named event will be removed.
     * @return bool if a handler is found and detached
     * @see on()
     */
    public function off($name, $handler = null)
    {
        $this->ensureBehaviors();
        if (empty($this->_events[$name]) && empty($this->_eventWildcards[$name])) {
            return false;
        }
        if ($handler === null) {
            unset($this->_events[$name], $this->_eventWildcards[$name]);
            return true;
        }

        $removed = false;
        // plain event names
        if (isset($this->_events[$name])) {
            foreach ($this->_events[$name] as $i => $event) {
                if ($event[0] === $handler) {
                    unset($this->_events[$name][$i]);
                    $removed = true;
                }
            }
            if ($removed) {
                $this->_events[$name] = array_values($this->_events[$name]);
                return true;
            }
        }

        // wildcard event names
        if (isset($this->_eventWildcards[$name])) {
            foreach ($this->_eventWildcards[$name] as $i => $event) {
                if ($event[0] === $handler) {
                    unset($this->_eventWildcards[$name][$i]);
                    $removed = true;
                }
            }
            if ($removed) {
                $this->_eventWildcards[$name] = array_values($this->_eventWildcards[$name]);
                // remove empty wildcards to save future redundant regex checks:
                if (empty($this->_eventWildcards[$name])) {
                    unset($this->_eventWildcards[$name]);
                }
            }
        }

        return $removed;
    }

    /**
     * Triggers an event.
     *
     * This method represents the happening of an event. It invokes all attached handlers for the event
     * including class-level handlers.
     *
     * @param string $name the event name
     * @param Event|null $event the event instance. If not set, a default [[Event]] object will be created.
     */
    public function trigger($name, Event $event = null)
    {
        $this->ensureBehaviors();

        $eventHandlers = [];
        foreach ($this->_eventWildcards as $wildcard => $handlers) {
            if (StringHelper::matchWildcard($wildcard, $name)) {
                $eventHandlers[] = $handlers;
            }
        }
        if (!empty($this->_events[$name])) {
            $eventHandlers[] = $this->_events[$name];
        }

        if (!empty($eventHandlers)) {
            $eventHandlers = call_user_func_array('array_merge', $eventHandlers);
            if ($event === null) {
                $event = new Event();
            }
            if ($event->sender === null) {
                $event->sender = $this;
            }
            $event->handled = false;
            $event->name = $name;
            foreach ($eventHandlers as $handler) {
                $event->data = $handler[1];
                call_user_func($handler[0], $event);
                // stop further handling if the event is handled
                if ($event->handled) {
                    return;
                }
            }
        }

        // invoke class-level attached handlers
        Event::trigger($this, $name, $event);
    }

    /**
     * Returns the named behavior object.
     * @param string $name the behavior name
     * @return null|Behavior the behavior object, or null if the behavior does not exist
     */
    public function getBehavior($name)
    {
        $this->ensureBehaviors();
        return isset($this->_behaviors[$name]) ? $this->_behaviors[$name] : null;
    }

    /**
     * Returns all behaviors attached to this component.
     * @return Behavior[] list of behaviors attached to this component
     */
    public function getBehaviors()
    {
        $this->ensureBehaviors();
        return $this->_behaviors;
    }

    /**
     * Attaches a behavior to this component.
     * This method will create the behavior object based on the given
     * configuration. After that, the behavior object will be attached to
     * this component by calling the [[Behavior::attach()]] method.
     * @param string $name the name of the behavior.
     * @param string|array|Behavior $behavior the behavior configuration. This can be one of the following:
     *
     *  - a [[Behavior]] object
     *  - a string specifying the behavior class
     *  - an object configuration array that will be passed to [[Yii::createObject()]] to create the behavior object.
     *
     * @return Behavior the behavior object
     * @see detachBehavior()
     */
    public function attachBehavior($name, $behavior)
    {
        $this->ensureBehaviors();
        return $this->attachBehaviorInternal($name, $behavior);
    }

    /**
     * Attaches a list of behaviors to the component.
     * Each behavior is indexed by its name and should be a [[Behavior]] object,
     * a string specifying the behavior class, or an configuration array for creating the behavior.
     * @param array $behaviors list of behaviors to be attached to the component
     * @see attachBehavior()
     */
    public function attachBehaviors($behaviors)
    {
        $this->ensureBehaviors();
        foreach ($behaviors as $name => $behavior) {
            $this->attachBehaviorInternal($name, $behavior);
        }
    }

    /**
     * Detaches a behavior from the component.
     * The behavior's [[Behavior::detach()]] method will be invoked.
     * @param string $name the behavior's name.
     * @return null|Behavior the detached behavior. Null if the behavior does not exist.
     */
    public function detachBehavior($name)
    {
        $this->ensureBehaviors();
        if (isset($this->_behaviors[$name])) {
            $behavior = $this->_behaviors[$name];
            unset($this->_behaviors[$name]);
            $behavior->detach();
            return $behavior;
        }

        return null;
    }

    /**
     * Detaches all behaviors from the component.
     */
    public function detachBehaviors()
    {
        $this->ensureBehaviors();
        foreach ($this->_behaviors as $name => $behavior) {
            $this->detachBehavior($name);
        }
    }

    /**
     * Makes sure that the behaviors declared in [[behaviors()]] are attached to this component.
     */
    public function ensureBehaviors()
    {
        if ($this->_behaviors === null) {
            $this->_behaviors = [];
            foreach ($this->behaviors() as $name => $behavior) {
                $this->attachBehaviorInternal($name, $behavior);
            }
        }
    }

    /**
     * Attaches a behavior to this component.
     * @param string|int $name the name of the behavior. If this is an integer, it means the behavior
     * is an anonymous one. Otherwise, the behavior is a named one and any existing behavior with the same name
     * will be detached first.
     * @param string|array|Behavior $behavior the behavior to be attached
     * @return Behavior the attached behavior.
     */
    private function attachBehaviorInternal($name, $behavior)
    {
        if (!($behavior instanceof Behavior)) {
            $behavior = Yii::createObject($behavior);
        }
        if (is_int($name)) {
            $behavior->attach($this);
            $this->_behaviors[] = $behavior;
        } else {
            if (isset($this->_behaviors[$name])) {
                $this->_behaviors[$name]->detach();
            }
            $behavior->attach($this);
            $this->_behaviors[$name] = $behavior;
        }

        return $behavior;
    }
}
```

### `yii\base\Behavior` 类

```php
<?php
/**
 * @link http://www.yiiframework.com/
 * @copyright Copyright (c) 2008 Yii Software LLC
 * @license http://www.yiiframework.com/license/
 */

namespace yii\base;

/**
 * Behavior is the base class for all behavior classes.
 *
 * A behavior can be used to enhance the functionality of an existing component without modifying its code.
 * In particular, it can "inject" its own methods and properties into the component
 * and make them directly accessible via the component. It can also respond to the events triggered in the component
 * and thus intercept the normal code execution.
 *
 * For more details and usage information on Behavior, see the [guide article on behaviors](guide:concept-behaviors).
 *
 * @author Qiang Xue <qiang.xue@gmail.com>
 * @since 2.0
 */
class Behavior extends BaseObject
{
    /**
     * @var Component|null the owner of this behavior
     */
    public $owner;

    /**
     * @var array Attached events handlers
     */
    private $_attachedEvents = [];


    /**
     * Declares event handlers for the [[owner]]'s events.
     *
     * Child classes may override this method to declare what PHP callbacks should
     * be attached to the events of the [[owner]] component.
     *
     * The callbacks will be attached to the [[owner]]'s events when the behavior is
     * attached to the owner; and they will be detached from the events when
     * the behavior is detached from the component.
     *
     * The callbacks can be any of the following:
     *
     * - method in this behavior: `'handleClick'`, equivalent to `[$this, 'handleClick']`
     * - object method: `[$object, 'handleClick']`
     * - static method: `['Page', 'handleClick']`
     * - anonymous function: `function ($event) { ... }`
     *
     * The following is an example:
     *
     * ```php
     * [
     *     Model::EVENT_BEFORE_VALIDATE => 'myBeforeValidate',
     *     Model::EVENT_AFTER_VALIDATE => 'myAfterValidate',
     * ]
     * ```
     *
     * @return array events (array keys) and the corresponding event handler methods (array values).
     */
    public function events()
    {
        return [];
    }

    /**
     * Attaches the behavior object to the component.
     * The default implementation will set the [[owner]] property
     * and attach event handlers as declared in [[events]].
     * Make sure you call the parent implementation if you override this method.
     * @param Component $owner the component that this behavior is to be attached to.
     */
    public function attach($owner)
    {
        $this->owner = $owner;
        foreach ($this->events() as $event => $handler) {
            $this->_attachedEvents[$event] = $handler;
            $owner->on($event, is_string($handler) ? [$this, $handler] : $handler);
        }
    }

    /**
     * Detaches the behavior object from the component.
     * The default implementation will unset the [[owner]] property
     * and detach event handlers declared in [[events]].
     * Make sure you call the parent implementation if you override this method.
     */
    public function detach()
    {
        if ($this->owner) {
            foreach ($this->_attachedEvents as $event => $handler) {
                $this->owner->off($event, is_string($handler) ? [$this, $handler] : $handler);
            }
            $this->_attachedEvents = [];
            $this->owner = null;
        }
    }
}
```

<br/><br/><br/><br/><br/>
## 参考资料

深入理解Yii2.0 » Yii 基础 » 行为（Behavior）  <http://www.digpage.com/behavior.html>

array_fill_keys <https://www.php.net/manual/zh/function.array-fill-keys.php>

property_exists <https://www.php.net/manual/zh/function.property-exists.php>

method_exists <https://www.php.net/manual/zh/function.method-exists.php>

Yii 2.0 权威指南 关键概念（Key Concepts）: 行为（Behaviors） <https://www.yiichina.com/doc/guide/2.0/concept-behaviors>

PHP 手册 语言参考 类与对象 Trait <https://www.php.net/traits>
 
 