---
layout: post
categories: Yii2
title: 深入理解Yii2.0 请求
meta: 请求
---
* content
{:toc}

## 正文

### 获取用户请求

PHP并未提供集中的、统一的界面以获取用户请求，而是分散在 `$_SERVER` 、 `$_POST` 等变量和其他代码中。 这种局面Yii是怎么处理的呢？

那么对于任何Yii应用而言，初始化后第一件正事，就是获取用户请求。 这个代码在 `yii\base\Application::run()` 中:
```
public function run()
{
    try {

        $this->state = self::STATE_BEFORE_REQUEST;
        $this->trigger(self::EVENT_BEFORE_REQUEST);

        $this->state = self::STATE_HANDLING_REQUEST;

        // 获取用户请求，并进行处理，处理的过程也是产生响应内容的过程
        $response = $this->handleRequest($this->getRequest());

        $this->state = self::STATE_AFTER_REQUEST;
        $this->trigger(self::EVENT_AFTER_REQUEST);

        $this->state = self::STATE_SENDING_RESPONSE;

        // 将响应内容发送回用户
        $response->send();

        $this->state = self::STATE_END;

        return $response->exitStatus;

    } catch (ExitException $e) {
        $this->end($e->statusCode, isset($response) ? $response : null);
        return $e->statusCode;
    }
}
```

你可能会说`$this->getRequest()` 就是用于获取用户请求的。其实这是一个getter，用于获取Application的request组件 (component) 。
Yii用这个组件来代表用户请求， 他承载着所有的用户输入信息。

我们知道，Yii应用有命令行(Console)应用和Web应用之分。因此，这个Request类其实涉及到了以下的类：

* `yii\base\Request` Request类基类
* `yii\console\Request` 表示Console应用的的Request
* `yii\web\Request` 表示Web应用的Request

### 基类Request

基类是对Console应用和Web应用Request的抽象，他仅仅定义了两个属性和一个抽象函数:
```
namespace yii\base;

use Yii;

abstract class Request extends Component
{
    // 属性scriptFile，用于表示入口脚本
    private $_scriptFile;

    // 属性isConsoleRequest，用于表示是否是命令行应用
    private $_isConsoleRequest;


    // 抽象函数，要求子类来实现
    // 这个函数的功能主要是为了把Request解析成路由和相应的参数
    abstract public function resolve();

    // isConsoleRequest属性的getter函数
    // 使用 PHP_SAPI 常量判断当前应用是否是命令行应用
    public function getIsConsoleRequest()
    {
        // PHP_SAPI 不为 'cli' 的，则不是命令行
        return $this->_isConsoleRequest !== null ? $this->_isConsoleRequest : PHP_SAPI === 'cli';
    }

    // isConsoleRequest属性的setter函数
    public function setIsConsoleRequest($value)
    {
        $this->_isConsoleRequest = $value;
    }

    // scriptFile属性的getter函数
    // 通过 $_SERVER['SCRIPT_FILENAME'] 来获取入口脚本名
    public function getScriptFile()
    {
        if ($this->_scriptFile === null) {
            if (isset($_SERVER['SCRIPT_FILENAME'])) {
                $this->setScriptFile($_SERVER['SCRIPT_FILENAME']);
            } else {
                throw new InvalidConfigException('Unable to determine the entry script file path.');
            }
        }

        return $this->_scriptFile;
    }

    // scriptFile属性的setter函数
    public function setScriptFile($value)
    {
        $scriptFile = realpath(Yii::getAlias($value));
        if ($scriptFile !== false && is_file($scriptFile)) {
            $this->_scriptFile = $scriptFile;
        } else {
            throw new InvalidConfigException('Unable to determine the entry script file path.');
        }
    }
}
```

`yii\base\Request` 通过getter和setter提供了两个可读写的属性， isConsoleRequest 和 scriptFile 。 
同时，要求子类实现一个 `resolve()` 方法。

基类的代码相对简单，主要涉及到PHP的一些知识，如 `PHP_SAPI` 、 `$_SERVER['SCRIPT_FILENAME']` 等。

### 命令行应用Request

命令行应用Request由 `yii\console\Request` 负责实现，相比较于 `yii\base\Request` 稍有丰富:
```
namespace yii\console;

class Request extends \yii\base\Request
{
    // 属性 params，用于表示命令行参数
    private $_params;

    // params属性的getter函数
    // 通过 $_SERVER['argv'] 来获取命令行参数
    public function getParams()
    {
        if (!isset($this->_params)) {
            if (isset($_SERVER['argv'])) {
                $this->_params = $_SERVER['argv'];

                // 删除数组的第一个元素，这个元素是PHP脚本名。
                // 因此，属性params中全部是参数，不带脚本名
                array_shift($this->_params);
            } else {
                $this->_params = [];
            }
        }

        return $this->_params;
    }

    // params属性的setter函数
    public function setParams($params)
    {
        $this->_params = $params;
    }

    // 父类抽象函数的实现
    public function resolve()
    {
        // 获取全部的命令行参数
        $rawParams = $this->getParams();

        // 第一个命令行参数作为路由
        if (isset($rawParams[0])) {
            $route = $rawParams[0];
            array_shift($rawParams);
        } else {
            $route = '';
        }

        $params = [];

        // 遍历剩余的全部命令行参数
        foreach ($rawParams as $param) {

            // 正则匹配每一个参数
            if (preg_match('/^--(\w+)(=(.*))?$/', $param, $matches)) {

                // 参数名
                $name = $matches[1];

                // yii\console\Application::OPTION_APPCONFIG = 'appconfig'
                if ($name !== Application::OPTION_APPCONFIG) {
                    $params[$name] = isset($matches[3]) ? $matches[3] : true;
                }

            // 无名参数，直接作为参数值
            } else {
                $params[] = $param;
            }
        }

        return [$route, $params];
    }
}
```

相比较于 `yii\base\Request` ， `yii\console\Request` 提供了一个 params 属性， 该属性以数组形式保存了入口脚本 Yii 的命令行参数。
这是通过 `$_SERVER['argv']` 获取的。 注意 params 属性不保存入口脚本名。入口脚本名由基类的 scriptName 属性保存。

同时， `yii\console\Request` 还实现了父类的 `resolve()` 抽象函数， 这个函数主要做了这么几件事：

* 将 params 属性的第一个元素作为路由。如果入口脚本未提供任何参数，也即 params 是个空数组， 那么将路由置为一个空字符串。
* 遍历 params 中剩余的参数，使用正则匹配Yii应用的参数名和参数值，看看是不是 `--参数名=参数值` 形式。 
  其中，以 `--` 打头的任意字母、数字、下划线的组合，就是参数名。 紧跟参数名的 = 后面的内容，则为参数值。 
  对于仅有参数名，没有参数值的，视参数值为 true 。
* 如果正则匹配不成功，则将这个命令行参数作为Yii应用的一个无名参数的值。
* 如果第二步中的参数名为 appconfig 则忽略该参数，Console Application会专门针对该参数进行处理。
* 上面步骤中的参数和参数值，被保存进一个数组中。数组的键表示参数名，数组的值表示参数值。
* 最终 `resolve()` 返回一个数组，第一个元素是一个表示路由的字符串，第二元素则是参数数组。 该方法由Application在处理Request时调用。

关于 appconfig 参数的问题，只要在调用 yii 时，指定了 appconfig 参数， 就表明不使用默认的参数配置文件，
而使用该参数所指定的配置文件。相关的代码在 `yii\console\Application` 中:
```
// 定义一个常量
const OPTION_APPCONFIG = 'appconfig';

// yii\console\Application类的构造函数
public function __construct($config = [])
{
    // 重点看这句，会调用loadConfig() 成员函数
    $config = $this->loadConfig($config);
    parent::__construct($config);
}

// 如果指定的配置文件存在，那么返回其配置数组
// 否则，返回构造函数调用时的数组
protected function loadConfig($config)
{
    if (!empty($_SERVER['argv'])) {

        // 设定了一个字符串 "--appconfig="
        $option = '--' . self::OPTION_APPCONFIG . '=';

        // 遍历所有命令行参数，看看能不能找到上面说的这个字符串
        foreach ($_SERVER['argv'] as $param) {
            if (strpos($param, $option) !== false) {

                // 截取参数值部分
                $path = substr($param, strlen($option));
                if (!empty($path) && is_file($file = Yii::getAlias($path))) {

                    // 将指定文件的内容引入进来
                    return require($file);
                } else {
                    die("The configuration file does not exist: $path\n");
                }
            }
        }
    }

    return $config;
}
```

讲完了Request基类和命令行应用的Request只是热身而已，接下来要讲的Web应用Request才是重头。 

## 路由处理

在 `yii\base\Application::run()` 中:
```
// 获取用户请求，并进行处理，处理的过程也是产生响应内容的过程
$response = $this->handleRequest($this->getRequest());
```

`handleRequest()` 在 `yii\base\Application::run()` 中是一个 `abstract`类，由继承类实现：
```
/**
 * Handles the specified request.
 *
 * This method should return an instance of [[Response]] or its child class
 * which represents the handling result of the request.
 *
 * @param Request $request the request to be handled
 * @return Response the resulting response
 */
abstract public function handleRequest($request);
```

### web访问实现

在 `yii\web\Application` 中:
```
/**
 * Handles the specified request.
 * @param Request $request the request to be handled
 * @return Response the resulting response
 * @throws NotFoundHttpException if the requested route is invalid
 */
public function handleRequest($request)
{
    if (empty($this->catchAll)) {
        try {
            list($route, $params) = $request->resolve();
        } catch (UrlNormalizerRedirectException $e) {
            $url = $e->url;
            if (is_array($url)) {
                if (isset($url[0])) {
                    // ensure the route is absolute
                    $url[0] = '/' . ltrim($url[0], '/');
                }
                $url += $request->getQueryParams();
            }

            return $this->getResponse()->redirect(Url::to($url, $e->scheme), $e->statusCode);
        }
    } else {
        $route = $this->catchAll[0];
        $params = $this->catchAll;
        unset($params[0]);
    }
    try {
        Yii::debug("Route requested: '$route'", __METHOD__);
        $this->requestedRoute = $route;
        $result = $this->runAction($route, $params);
        if ($result instanceof Response) {
            return $result;
        }

        $response = $this->getResponse();
        if ($result !== null) {
            $response->data = $result;
        }

        return $response;
    } catch (InvalidRouteException $e) {
        throw new NotFoundHttpException(Yii::t('yii', 'Page not found.'), $e->getCode(), $e);
    }
}
```

在 `yii\web\Request` 中`resolve()`解析请求，返回 `$route`路由 和 `$params`请求参数:
```
/**
 * Resolves the current request into a route and the associated parameters.
 * @return array the first element is the route, and the second is the associated parameters.
 * @throws NotFoundHttpException if the request cannot be resolved.
 */
public function resolve()
{
    $result = Yii::$app->getUrlManager()->parseRequest($this);
    if ($result !== false) {
        list($route, $params) = $result;
        if ($this->_queryParams === null) {
            $_GET = $params + $_GET; // preserve numeric keys
        } else {
            $this->_queryParams = $params + $this->_queryParams;
        }

        return [$route, $this->getQueryParams()];
    }

    throw new NotFoundHttpException(Yii::t('yii', 'Page not found.'));
}
```

`Yii::$app->getUrlManager()->parseRequest($this)` 就是 调用 `yii\web\UrlManager` 的 `parseRequest()` 解析请求：
```
/**
 * Parses the user request.
 * @param Request $request the request component
 * @return array|bool the route and the associated parameters. The latter is always empty
 * if [[enablePrettyUrl]] is `false`. `false` is returned if the current request cannot be successfully parsed.
 */
public function parseRequest($request)
{
    if ($this->enablePrettyUrl) {
        /* @var $rule UrlRule */
        foreach ($this->rules as $rule) {
            $result = $rule->parseRequest($this, $request);
            if (YII_DEBUG) {
                Yii::debug([
                    'rule' => method_exists($rule, '__toString') ? $rule->__toString() : get_class($rule),
                    'match' => $result !== false,
                    'parent' => null,
                ], __METHOD__);
            }
            if ($result !== false) {
                return $result;
            }
        }

        if ($this->enableStrictParsing) {
            return false;
        }

        Yii::debug('No matching URL rules. Using default URL parsing logic.', __METHOD__);

        $suffix = (string) $this->suffix;
        $pathInfo = $request->getPathInfo();
        $normalized = false;
        if ($this->normalizer !== false) {
            $pathInfo = $this->normalizer->normalizePathInfo($pathInfo, $suffix, $normalized);
        }
        if ($suffix !== '' && $pathInfo !== '') {
            $n = strlen($this->suffix);
            if (substr_compare($pathInfo, $this->suffix, -$n, $n) === 0) {
                $pathInfo = substr($pathInfo, 0, -$n);
                if ($pathInfo === '') {
                    // suffix alone is not allowed
                    return false;
                }
            } else {
                // suffix doesn't match
                return false;
            }
        }

        if ($normalized) {
            // pathInfo was changed by normalizer - we need also normalize route
            return $this->normalizer->normalizeRoute([$pathInfo, []]);
        }

        return [$pathInfo, []];
    }

    Yii::debug('Pretty URL not enabled. Using default URL parsing logic.', __METHOD__);
    $route = $request->getQueryParam($this->routeParam, '');
    if (is_array($route)) {
        $route = '';
    }

    return [(string) $route, []];
}
```

里面 `$rule->parseRequest($this, $request)` 再调用 `yii\web\UrlRule` 的 `parseRequest()`：
```
/**
 * Parses the given request and returns the corresponding route and parameters.
 * @param UrlManager $manager the URL manager
 * @param Request $request the request component
 * @return array|bool the parsing result. The route and the parameters are returned as an array.
 * If `false`, it means this rule cannot be used to parse this path info.
 */
public function parseRequest($manager, $request)
{
    if ($this->mode === self::CREATION_ONLY) {
        return false;
    }

    if (!empty($this->verb) && !in_array($request->getMethod(), $this->verb, true)) {
        return false;
    }

    $suffix = (string) ($this->suffix === null ? $manager->suffix : $this->suffix);
    $pathInfo = $request->getPathInfo();
    $normalized = false;
    if ($this->hasNormalizer($manager)) {
        $pathInfo = $this->getNormalizer($manager)->normalizePathInfo($pathInfo, $suffix, $normalized);
    }
    if ($suffix !== '' && $pathInfo !== '') {
        $n = strlen($suffix);
        if (substr_compare($pathInfo, $suffix, -$n, $n) === 0) {
            $pathInfo = substr($pathInfo, 0, -$n);
            if ($pathInfo === '') {
                // suffix alone is not allowed
                return false;
            }
        } else {
            return false;
        }
    }

    if ($this->host !== null) {
        $pathInfo = strtolower($request->getHostInfo()) . ($pathInfo === '' ? '' : '/' . $pathInfo);
    }

    if (!preg_match($this->pattern, $pathInfo, $matches)) {
        return false;
    }
    $matches = $this->substitutePlaceholderNames($matches);

    foreach ($this->defaults as $name => $value) {
        if (!isset($matches[$name]) || $matches[$name] === '') {
            $matches[$name] = $value;
        }
    }
    $params = $this->defaults;
    $tr = [];
    foreach ($matches as $name => $value) {
        if (isset($this->_routeParams[$name])) {
            $tr[$this->_routeParams[$name]] = $value;
            unset($params[$name]);
        } elseif (isset($this->_paramRules[$name])) {
            $params[$name] = $value;
        }
    }
    if ($this->_routeRule !== null) {
        $route = strtr($this->route, $tr);
    } else {
        $route = $this->route;
    }

    Yii::debug("Request parsed with URL rule: {$this->name}", __METHOD__);

    if ($normalized) {
        // pathInfo was changed by normalizer - we need also normalize route
        return $this->getNormalizer($manager)->normalizeRoute([$route, $params]);
    }

    return [$route, $params];
}
```

在 `yii\web\Application` 的 `handleRequest()` 中 `$result = $this->runAction($route, $params);` 运行 `yii\base\Module` 的处理方法:
```
/**
 * Runs a controller action specified by a route.
 * This method parses the specified route and creates the corresponding child module(s), controller and action
 * instances. It then calls [[Controller::runAction()]] to run the action with the given parameters.
 * If the route is empty, the method will use [[defaultRoute]].
 * @param string $route the route that specifies the action.
 * @param array $params the parameters to be passed to the action
 * @return mixed the result of the action.
 * @throws InvalidRouteException if the requested route cannot be resolved into an action successfully.
 */
public function runAction($route, $params = [])
{
    $parts = $this->createController($route);
    if (is_array($parts)) {
        /* @var $controller Controller */
        list($controller, $actionID) = $parts;
        $oldController = Yii::$app->controller;
        Yii::$app->controller = $controller;
        $result = $controller->runAction($actionID, $params);
        if ($oldController !== null) {
            Yii::$app->controller = $oldController;
        }

        return $result;
    }

    $id = $this->getUniqueId();
    throw new InvalidRouteException('Unable to resolve the request "' . ($id === '' ? $route : $id . '/' . $route) . '".');
}

/**
 * Creates a controller instance based on the given route.
 *
 * The route should be relative to this module. The method implements the following algorithm
 * to resolve the given route:
 *
 * 1. If the route is empty, use [[defaultRoute]];
 * 2. If the first segment of the route is found in [[controllerMap]], create a controller
 *    based on the corresponding configuration found in [[controllerMap]];
 * 3. If the first segment of the route is a valid module ID as declared in [[modules]],
 *    call the module's `createController()` with the rest part of the route;
 * 4. The given route is in the format of `abc/def/xyz`. Try either `abc\DefController`
 *    or `abc\def\XyzController` class within the [[controllerNamespace|controller namespace]].
 *
 * If any of the above steps resolves into a controller, it is returned together with the rest
 * part of the route which will be treated as the action ID. Otherwise, `false` will be returned.
 *
 * @param string $route the route consisting of module, controller and action IDs.
 * @return array|bool If the controller is created successfully, it will be returned together
 * with the requested action ID. Otherwise `false` will be returned.
 * @throws InvalidConfigException if the controller class and its file do not match.
 */
public function createController($route)
{
    if ($route === '') {
        $route = $this->defaultRoute;
    }

    // double slashes or leading/ending slashes may cause substr problem
    $route = trim($route, '/');
    if (strpos($route, '//') !== false) {
        return false;
    }

    if (strpos($route, '/') !== false) {
        list($id, $route) = explode('/', $route, 2);
    } else {
        $id = $route;
        $route = '';
    }

    // module and controller map take precedence
    if (isset($this->controllerMap[$id])) {
        $controller = Yii::createObject($this->controllerMap[$id], [$id, $this]);
        return [$controller, $route];
    }
    $module = $this->getModule($id);
    if ($module !== null) {
        return $module->createController($route);
    }

    if (($pos = strrpos($route, '/')) !== false) {
        $id .= '/' . substr($route, 0, $pos);
        $route = substr($route, $pos + 1);
    }

    $controller = $this->createControllerByID($id);
    if ($controller === null && $route !== '') {
        $controller = $this->createControllerByID($id . '/' . $route);
        $route = '';
    }

    return $controller === null ? false : [$controller, $route];
}
```

`yii\base\Controller` 中：
```
/**
 * Runs an action within this controller with the specified action ID and parameters.
 * If the action ID is empty, the method will use [[defaultAction]].
 * @param string $id the ID of the action to be executed.
 * @param array $params the parameters (name-value pairs) to be passed to the action.
 * @return mixed the result of the action.
 * @throws InvalidRouteException if the requested action ID cannot be resolved into an action successfully.
 * @see createAction()
 */
public function runAction($id, $params = [])
{
    $action = $this->createAction($id);
    if ($action === null) {
        throw new InvalidRouteException('Unable to resolve the request: ' . $this->getUniqueId() . '/' . $id);
    }

    Yii::debug('Route to run: ' . $action->getUniqueId(), __METHOD__);

    if (Yii::$app->requestedAction === null) {
        Yii::$app->requestedAction = $action;
    }

    $oldAction = $this->action;
    $this->action = $action;

    $modules = [];
    $runAction = true;

    // call beforeAction on modules
    foreach ($this->getModules() as $module) {
        if ($module->beforeAction($action)) {
            array_unshift($modules, $module);
        } else {
            $runAction = false;
            break;
        }
    }

    $result = null;

    if ($runAction && $this->beforeAction($action)) {
        // run the action
        $result = $action->runWithParams($params);

        $result = $this->afterAction($action, $result);

        // call afterAction on modules
        foreach ($modules as $module) {
            /* @var $module Module */
            $result = $module->afterAction($action, $result);
        }
    }

    if ($oldAction !== null) {
        $this->action = $oldAction;
    }

    return $result;
}
```

`yii\base\Action` 中：
```
/**
 * Runs this action with the specified parameters.
 * This method is mainly invoked by the controller.
 *
 * @param array $params the parameters to be bound to the action's run() method.
 * @return mixed the result of the action
 * @throws InvalidConfigException if the action class does not have a run() method
 */
public function runWithParams($params)
{
    if (!method_exists($this, 'run')) {
        throw new InvalidConfigException(get_class($this) . ' must define a "run()" method.');
    }
    $args = $this->controller->bindActionParams($this, $params);
    Yii::debug('Running action: ' . get_class($this) . '::run(), invoked by '  . get_class($this->controller), __METHOD__);
    if (Yii::$app->requestedParams === null) {
        Yii::$app->requestedParams = $args;
    }
    if ($this->beforeRun()) {
        $result = call_user_func_array([$this, 'run'], $args);
        $this->afterRun();

        return $result;
    }

    return null;
}
```

## 附图

![]({{site.baseurl}}/images/20200506/20200506160924.png)

<br/><br/><br/><br/><br/>
## 参考资料

深入理解Yii2.0 » 请求与响应(TBD) » 请求(Reqeust) 

<http://www.digpage.com/request.html>

<https://www.kancloud.cn/kancloud/yii-in-depth/50782>

$_SERVER['argv'] <https://www.php.net/manual/zh/reserved.variables.server.php>

preg_match <https://www.php.net/manual/zh/function.preg-match.php>