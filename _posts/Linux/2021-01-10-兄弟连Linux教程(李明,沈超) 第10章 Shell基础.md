---
layout: post
categories: Linux
title: 兄弟连Linux教程(李明,沈超) 第10章 Shell基础
meta: 兄弟连Linux教程(李明,沈超) 第10章 Shell基础
---
* content
{:toc}

## 正文

### 10.1 Shell概述

1、Shell是什么

Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，
用户可以用Shell来启动、挂起、停止甚至是编写一些程序。

![]({{site.baseurl}}/images/20210403/20210403114391.png)

Shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。
Shell是解释执行的脚本语言，在Shell中可以直接调用Linux系统命令。

2、Shell的分类

Bourne Shell：从1979起Unix就开始使用Bourne Shell，Bourne Shell的主文件名为sh。

C Shell： C Shell主要在BSD版的Unix系统中使用，其语法和C语言相类似而得名

Shell的两种主要语法类型有Bourne和C，这两种语法彼此不兼容。
Bourne家族主要包括sh、ksh、Bash、psh、zsh；C家族主要包括：csh、tcsh

Bash： Bash与sh兼容，现在使用的Linux就是使用Bash作为用户的基本Shell。

3、Linux支持的Shell

/etc/shells

```
/bin/sh
/bin/bash
/sbin/nologin
/bin/dash
```

### 10.2 Shell脚本的执行方式

1、echo输出命令

```
[root@localhost ~]# echo [选项] [输出内容]
选项：
    -e：    支持反斜线控制的字符转换
```

```
控制字符     作用
\\    输出\本身
\a    输出警告音
\b    退格键，也就是向左删除键
\c    取消输出行末的换行符。和“-n”选项一致
\e    ESCAPE键
\f    换页符
\n    换行符
\r    回车键
\t    制表符，也就是Tab键
\v    垂直制表符
\0nnn    按照八进制ASCII码表输出字符。其中0为数字零，nnn是三位八进制数
\xhh    按照十六进制ASCII码表输出字符。其中hh是两位十六进制数
```

```
[root@localhost ~]# echo -e "ab\bc"
#删除左侧字符

ac

[root@localhost ~]# echo -e "a\tb\tc\nd\te\tf"
#制表符与换行符

a    b    c
d    e    f
```

```
[root@localhost ~]# echo -e   \
"\x61\t\x62\t\x63\n\x64\t\x65\t\x66"
#按照十六进制ASCII码也同样可以输出

a    b    c
d    e    f
```

```
[root@localhost ~]# echo -e "\e[1;31m  abcd \e[0m"
#输出颜色
#30m=黑色，31m=红色，32m=绿色，33m=黄色
#34m=蓝色，35m=洋红，36m=青色，37m=白色
```

2、第一个脚本

```
[root@localhost sh]# vi hello.sh
#!/bin/Bash
#The first program
# Author: shenchao （E-mail: shenchao@lampbrother.net）

echo -e "Mr. Shen Chao is the most honest man in LampBrother"
```

3、脚本执行

赋予执行权限，直接运行
```
chmod 755 hello.sh
./hello.sh
```

通过Bash调用执行脚本
```
bash hello.sh
```

### 10.3 Bash的基本功能

#### 10.3.1 历史命令与命令补全

1、历史命令

```
[root@localhost ~]# history [选项] [历史命令保存文件]
选项：
    -c：        清空历史命令
    -w：    把缓存中的历史命令写入历史命令保存文件
            ~/.bash_history
```

历史命令默认会保存1000条,可以在环境变量配置文件/etc/profile中进行修改

```
HISTSIZE=1000
```

**历史命令的调用**

使用上、下箭头调用以前的历史命令

使用“!n”重复执行第n条历史命令

使用“!!”重复执行上一条命令

使用“!字串”重复执行最后一条以该字串开头的命令

2、命令与文件补全

在Bash中，命令与文件补全是非常方便与常用的功能，我们只要在输入命令或文件时，按“Tab”键就会自动进行补全

#### 10.3.2 命令别名与常用快捷键

1、命令别名

```
[root@localhost ~]# alias 别名='原命令'
#设定命令别名

[root@localhost ~]# alias
#查询命令别名
```

```
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
alias ls='ls --color=auto'
alias vi='vim'
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'
```

命令执行时顺序

1. 第一顺位执行用绝对路径或相对路径执行的命令。
2. 第二顺位执行别名。
3. 第三顺位执行Bash的内部命令。
4. 第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令。

```
echo $PATH

/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/composer:/home/vagrant/bin
```

让别名永久生效，修改家目录下的`.bashrc`文件：
```
[root@localhost ~]# vi /root/.bashrc
```

```
# .bashrc

# User specific aliases and functions

alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'

# Source global definitions
if [ -f /etc/bashrc ]; then
        . /etc/bashrc
fi
```

删除别名
```
[root@localhost ~]# unalias 别名
```

2、Bash常用快捷键

```
快捷键    作     用
ctrl+A    把光标移动到命令行开头。如果我们输入的命令过长，想要把光标移动到命令行开头时使用。
ctrl+E    把光标移动到命令行结尾。
ctrl+C    强制终止当前的命令。
ctrl+L    清屏，相当于clear命令。
ctrl+U    删除或剪切光标之前的命令。我输入了一行很长的命令，不用使用退格键一个一个字符的删除，使用这个快捷键会更加方便
ctrl+K    删除或剪切光标之后的内容。
ctrl+Y    粘贴ctrl+U或ctrl+K剪切的内容。
ctrl+R    在历史命令中搜索，按下ctrl+R之后，就会出现搜索界面，只要输入搜索内容，就会从历史命令中搜索。
ctrl+D    退出当前终端。
ctrl+Z    暂停，并放入后台。这个快捷键牵扯工作管理的内容，我们在系统管理章节详细介绍。
ctrl+S    暂停屏幕输出。
ctrl+Q    恢复屏幕输出。
```


#### 10.3.3 输入输出重定向

1、标准输入输出

在Linux系统中，所有的内容（包括硬件）都是文件。

```
设备    设备文件名    文件描述符    类型
键盘    /dev/stdin    0    标准输入
显示器    /dev/stdout    1    标准输出
显示器    /dev/stderr    2    标准错误输出
```

数字0代表标准输入；1代表标准输出；2代表标准错误输出。

2、输出重定向

在Linux中执行某一命令的输出结果，本应该输出到屏幕（显示器），
输出重定向指的就是把这个输出结果，重定向输出到其他指定的文件或设备中。

1）标准输出重定向

前提条件：命令有输出，且命令输出的结果是正确输出。

```
基本的命令格式    作用
命令 > 文件        以覆盖的方式，将命令的正确输出，重定向输出到指定的文件或设备中。
命令 >> 文件        以追加的方式，将命令的正确输出，重定向输出到指定的文件或设备中。
```

如果该文件之前不存在，就会自动创建。

示例：
```
[root@localhost ~]# date > a
#date命令的标准输出将不会输出到屏幕，而是重定向写入到a文件中，并覆盖该文件中的原有内容。

[root@localhost ~]# date >> a
#date命令的标准输出将不会输出到屏幕，而是重定向追加到a文件中，不会覆盖该文件中的原有内容。
```

说明：覆盖符号（>）或追加符号（>>）前后的空格，都可以省略，但习惯加上空格。

2）标准错误输出重定向

前提条件：命令有输出，且命令输出的结果是错误输出。

```
基本的命令格式      作用
错误命令 2> 文件    以覆盖的方式，将命令的错误输出，重定向输出到指定的文件或设备中。
错误命令 2>> 文件    以追加的方式，将命令的错误输出，重定向输出到指定的文件或设备中。
```

如果该文件之前不存在，就会自动创建。

注意：数字2后面不能有空格，后面必须紧跟大于号。

示例：
```
[root@localhost ~]# lst 2> a.txt
#将错误命令lst的输出，以覆盖的方式，输出到该文件中。
```

3）正确输出和错误输出同时重定向

前提条件：命令有输出。

无论命令的输出是正确输出还是错误输出，都可以用这种重定向。

```
基本的命令格式    作用
命令 > 文件 2>&1    以覆盖的方式，将正确输出和错误输出都保存到同一个文件中。
命令 >> 文件 2>&1    以追加的方式，将正确输出和错误输出都保存到同一个文件中。
命令 &> 文件    以覆盖的方式，将正确输出和错误输出都保存到同一个文件中。
命令 &>> 文件    以追加的方式，将正确输出和错误输出都保存到同一个文件中。
命令 >> 文件1 2>>文件2    如果命令是正确的，以追加的方式，把输出保存到文件1中；如果命令是错误的，以追加的方式，把输出保存到文件2中。
命令 &> /dev/null    直接将输出丢弃到垃圾箱（相当于不保存任何输出结果）。
```

示例：
```
[root@localhost ~]# date &> /dev/null       
#无论date命令正确与否，都将输出直接丢弃到垃圾箱，即没有任何输出。 
```

3、输入重定向

输入重定向用的很少，了解即可。

输入重定向一般有两种格式：

    命令 < 文件 

把文件作为命令相关参数的输入。

    命令 << 标识符 **输入的内容 标识符

第一个标识符为起始标识符，可以为任意字符串，后面应回车。

第二个标识符为结束标识符，应位于最后一行的行首。

两个标识符应相同，中间的内容才是要输入的内容。

```
[root@localhost ~]# wc [选项] [文件名]
选项：
-c  统计字符数
-w  统计单词数
-l  统计行数
```

#### 10.3.4 多命令顺序执行与管道符

1、多命令顺序执行

```
多命令执行符    格式                   作用
；            命令1 ；命令2           多个命令顺序执行，命令之间没有任何逻辑联系
&&            命令1 && 命令2           逻辑与
                                       当命令1正确执行，则命令2才会执行
                                       当命令1执行不正确，则命令2不会执行
||            命令1 || 命令2           逻辑或
                                       当命令1 执行不正确，则命令2才会执行
                                       当命令1正确执行，则命令2不会执行
```

例子：
```
[root@localhost ~]# ls ; date ; cd /user ; pwd
```

```
[root@localhost ~]# dd if=输入文件 of=输出文件 bs=字节数 count=个数

选项：
    if=输入文件        指定源文件或源设备
    of=输出文件        指定目标文件或目标设备
    bs=字节数        指定一次输入/输出多少字节，即把这些字节看做一个数据块
    count=个数        指定输入/输出多少个数据块

例子：
[root@localhost ~]# date ; dd if=/dev/zero of=/root/testfile bs=1k count=100000 ; date

[root@localhost ~]# ls anaconda-ks.cfg && echo yes

[root@localhost ~]# ls /root/test || echo no 

[root@localhost ~]# 命令 && echo yes || echo no
```

2、管道符

命令格式：
```
[root@localhost ~]# 命令1  |  命令2
#命令1的正确输出作为命令2的操作对象
颜色显示
```

例子：
```
[root@localhost ~]# ll -a /etc/  | more

[root@localhost ~]# netstat -an | grep "ESTABLISHED"
```

```
[root@localhost ~]# grep [选项] "搜索内容" 文件名
选项：
    -i：        忽略大小写
    -n：        输出行号
    -v：        反向查找
    --color=auto    搜索出的关键字用颜色显示
```

#### 10.3.5 通配符与其他特殊符号

1、通配符

```
通配符    作用
?      匹配一个任意字符
*        匹配0个或任意多个任意字符，也就是可以匹配任何内容
[]      匹配中括号中任意一个字符。例如：[abc]代表一定匹配一个字符，或者是a，或者是b，或者是c。
[-]      匹配中括号中任意一个字符，-代表一个范围。例如：[a-z]代表匹配一个小写字母。
[^]      逻辑非，表示匹配不是中括号内的一个字符。例如：[^0-9]代表匹配一个不是数字的字符。
```

```
[root@localhost ~]# cd /tmp/
[root@localhost tmp]# rm -rf *
[root@localhost tmp]# touch abc
[root@localhost tmp]# touch abcd
[root@localhost tmp]# touch 012
[root@localhost tmp]# touch 0abc
[root@localhost tmp]# ls ?abc
[root@localhost tmp]# ls [0-9]*
[root@localhost tmp]# ls [^0-9]*
```

2、Bash中其他特殊符号

```
符号    作用
''      单引号。在单引号中所有的特殊符号，如“$”和“`”(反引号)都没有特殊含义。
""      双引号。在双引号中特殊符号都没有特殊含义，但是“$”、“`”和“\”是例外，拥有“调用变量的值”、“引用命令”和“转义符”的特殊含义。
``      反引号。反引号括起来的内容是系统命令，在Bash中会先执行它。和$()作用一样，不过推荐使用$()，因为反引号非常容易看错。
$()      和反引号作用一样，用来引用系统命令。
#      在Shell脚本中，#开头的行代表注释。
$      用于调用变量的值，如需要调用变量name的值时，需要用$name的方式得到变量的值。
\      转义符，跟在\之后的特殊符号将失去特殊含义，变为普通字符。如\$将输出“$”符号，而不当做是变量引用。
```

反引号与`$()`

```
[root@localhost ~]# echo `ls`

[root@localhost ~]# echo $(date)
```

单引号与双引号

```
[root@localhost ~]# name=sc
[root@localhost ~]# echo '$name'
[root@localhost ~]# echo "$name"
[root@localhost ~]# echo ‘$(date)'
[root@localhost ~]# echo “$(date)"
```

### 10.4 Bash的变量

#### 10.4.1 用户自定义变量

1、什么是变量

变量是计算机内存的单元，其中存放的值可以改变。当Shell脚本需要保存一些信息时，如一个文件名或是一个数字，就把它存放在一个变量中。
每个变量有一个名字，所以很容易引用它。使用变量可以保存有用信息，使系统获知用户相关设置，变量也可以用于保存暂时信息。

2、变量设置规则

变量名称可以由字母、数字和下划线组成，但是不能以数字开头。如果变量名是`“2name”`则是错误的。

在Bash中，变量的默认类型都是字符串型，如果要进行数值运算，则必修指定变量类型为数值型。

变量用等号连接值，等号左右两侧不能有空格。

变量的值如果有空格，需要使用单引号或双引号包括。

在变量的值中，可以使用`“\”`转义符。

如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含`“$变量名”`或用`${变量名}`包含。

如果是把命令的结果作为变量值赋予变量，则需要使用反引号或`$()`包含命令。

环境变量名建议大写，便于区分。

3、变量分类

用户自定义变量

环境变量：这种变量中主要保存的是和系统操作环境相关的数据。

位置参数变量：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。

预定义变量：是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。

4、本地变量

```
变量定义
[root@localhost ~]# name="shen chao"

变量叠加
[root@localhost ~]# aa=123
[root@localhost ~]# aa="$aa"456
[root@localhost ~]# aa=${aa}789

变量调用
[root@localhost ~]# echo $name

变量查看
[root@localhost ~]# set

变量删除
[root@localhost ~]# unset name
```


#### 10.4.2 环境变量


#### 10.4.3 位置参数变量


#### 10.4.4 预定义变量


### 10.5 Bash的运算符

#### 10.5.1 数值运算与运算符

1、declare声明变量类型

```
[root@localhost ~]# declare [+/-][选项] 变量名
选项：
    -：        给变量设定类型属性
    +：        取消变量的类型属性
    -i：        将变量声明为整数型（integer）
    -x：        将变量声明为环境变量
    -p：        显示指定变量的被声明的类型
```

2、数值运算

方法1

```
[root@localhost ~]# aa=11
[root@localhost ~]# bb=22
#给变量aa和bb赋值
[root@localhost ~]# declare -i cc=$aa+$bb
```

方法2：expr或let数值运算工具

```
[root@localhost ~]# aa=11
[root@localhost ~]# bb=22
#给变量aa和变量bb赋值
[root@localhost ~]# dd=$(expr $aa + $bb)
#dd的值是aa和bb的和。注意“+”号左右两侧必须有空格
```

方法3：“$((运算式))”或“$[运算式]”

```
[root@localhost ~]# aa=11
[root@localhost ~]# bb=22
[root@localhost ~]# ff=$(( $aa+$bb ))
[root@localhost ~]# gg=$[ $aa+$bb ]
```

3、运算符

```
优先级    运算符    说明
13    -, +    单目负、单目正
12    !, ~    逻辑非、按位取反或补码
11    * , / , %    乘、除、取模
10    +, -    加、减
9    << , >>    按位左移、按位右移
8    < =, > =,  < , >    小于或等于、大于或等于、小于、大于
7    == , !=    等于、不等于
6    &    按位与
5    ^    按位异或
4    |    按位或
3    &&    逻辑与
2    ||    逻辑或
1    =,+=,-=,*=,/=,%=,&=, ^=, |=, <<=, >>=    赋值、运算且赋值
```

```
[root@localhost ~]# aa=$(( (11+3)*3/2 )) 
#虽然乘和除的优先级高于加，但是通过小括号可以调整运算优先级

[root@localhost ~]# bb=$(( 14%3 )) 
#14不能被3整除，余数是2

[root@localhost ~]# cc=$(( 1 && 0 ))
#逻辑与运算只有想与的两边都是1，与的结果才是1，否则与的结果是0
```

#### 10.5.2 变量测试与内容替换

```
变量置换方式        变量y没有设置        变量y为空值        变量y设置值
x=${y-新值}        x=新值                x为空                x=$y
x=${y:-新值}       x=新值                x=新值               x=$y
x=${y+新值}        x为空                 x=新值               x=新值
x=${y:+新值}       x为空                 x为空                x=新值
x=${y=新值}        x=新值 y=新值         x为空 y值不变          x=$y y值不变 
x=${y:=新值}       x=新值 y=新值         x=新值 y=新值          x=$y y值不变
x=${y?新值}   新值输出到标准错误输出（就是屏幕）    x为空          x=$y
x=${y:?新值}  新值输出到标准错误输出       新值输出到标准错误输出   x=$y
```

例子1：测试x=${y-新值}

```
[root@localhost ~]# unset y
#删除变量y
[root@localhost ~]# x=${y-new}
#进行测试
[root@localhost ~]# echo $x
new
#因为变量y不存在，所以x=new

[root@localhost ~]# y=""
#给变量y赋值为空
[root@localhost ~]# x=${y-new}
#进行测试
[root@localhost ~]# echo $x

[root@localhost ~]# y=old
#给变量y赋值
[root@localhost ~]# x=${y-new}
#进行测试
[root@localhost ~]# echo $x   
old
```

### 10.6 环境变量配置文件

#### 10.6.1 环境变量配置文件简介

1、source命令

```
[root@localhost ~]# source 配置文件
或
[root@localhost ~]# . 配置文件
```

2、环境变量配置文件简介

环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量，比如PATH、HISTSIZE、PS1、HOSTNAME等默认环境变量。

```
/etc/profile
/etc/profile.d/*.sh
~/.bash_profile
~/.bashrc
/etc/bashrc
```

#### 10.6.2 环境变量配置文件作用

```
/etc/profile
/etc/profile.d/*.sh
~/.bash_profile
~/.bashrc
/etc/bashrc
```

![]({{site.baseurl}}/images/20210403/20210403114393.png)

`/etc/profile`的作用：

    USER变量：
    LOGNAME变量：
    MAIL变量：
    PATH变量：
    HOSTNAME变量：
    HISTSIZE变量：
    umask：
    调用/etc/profile.d/*.sh文件

`~/.bash_profile`的作用

    调用了`~/.bashrc`文件。
    在PATH变量后面加入了`“:$HOME/bin”`这个目录

`~/.bashrc`的作用

    定义默认别名
    调用`/etc/bashrc`

`/etc/bashrc`的作用
    
    PS1变量
    umask
    PATH变量
    调用/etc/profile.d/*.sh文件


#### 10.6.3 其他配置文件和登录信息

1、注销时生效的环境变量配置文件

    ~/.bash_logout

2、其他配置文件

    ~/bash_history

3、Shell登录信息

本地终端欢迎信息： /etc/issue

```
转义符    作用
\d    显示当前系统日期
\s    显示操作系统名称
\l    显示登录的终端号，这个比较常用。
\m    显示硬件体系结构，如i386、i686等
\n    显示主机名
\o    显示域名
\r    显示内核版本
\t    显示当前系统时间
\u    显示当前登录用户的序列号
```

远程终端欢迎信息： /etc/issue.net

    转义符在/etc/issue.net文件中不能使用
    是否显示此欢迎信息，由ssh的配置文件/etc/ssh/sshd_config决定，加入“Banner /etc/issue.net”行才能显示（记得重启SSH服务）

登陆后欢迎信息：/etc/motd

    不管是本地登录，还是远程登录，都可以显示此欢迎信息


<br/><br/><br/><br/><br/>
## 参考资料




