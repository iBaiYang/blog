---
layout: post
categories: Linux
title: deepin系统安装
meta: deepin系统安装
---
* content
{:toc}

### 正文

#### deepin安装

在官方网站下载稳定版安装包，然后制作启动U盘。

安装前，做好电脑的资料备份工作。然后，以U盘启动，基本都是回车操作，有一个安装模式选择：

简单：

![]({{site.baseurl}}/images/20201114/20201114104555.jpg)

高级：

![]({{site.baseurl}}/images/20201114/20201114104614.jpg)

全盘安装：

![]({{site.baseurl}}/images/20190524/20190524110934.jpg)

是新手，那就选择全盘安装，或者简单安装。关于“高级”安装中磁盘分割的技巧，等熟悉linux后自己随便折腾吧。

这里选择全盘安装，安装好后看一下磁盘分割：

![]({{site.baseurl}}/images/20190524/20190524110945.jpg)

还有挂载点：

![]({{site.baseurl}}/images/20201113/20201113165738.png)

sda1：EFI    挂载点/boot/efi

sda2：primary  swap内存交换分区

sda3：Deepin15.10 Root系统盘    挂载点/

sda4：Home 家目录       挂载点/home

sda5：_dde_data 数据盘     挂载点/media/baiyang/_dde_data

其中 sda5 以及后面你在电脑上的可拔插U盘、硬盘等 名为sdb1、sdb2、sdc等，都挂载在 `/media/baiyang`目录下，baiyang是用户名。

如果系统被搞坏了，需要重装系统，你选择 简单安装 到 sda3 区，你会发现其他盘数据内容都没有变动，还是旧数据，
这说明我们可以把需要的软件和服务环境都放在sda4家目录、或sda5数据盘下，这样系统坏了重装时，服务软件及环境不需要重装。

![]({{site.baseurl}}/images/20201113/20201113151447.png)

![]({{site.baseurl}}/images/20201113/20201113145311.png)

![]({{site.baseurl}}/images/20201113/20201113151648.png)

#### Firefox浏览器安装

Firefox有中国版和国际版，国际版中又有一个ESR版本。中国版和国际版账号不通用，看你的账号在那。

中国版安装，直接在应用商店搜索安装，然后登录火狐账号同步书签信息等。

ESR版本安装： `sudo apt install firefox-esr-l10n-zh-cn`

#### Git安装

git可以用apt安装：`sudo apt install git`

安装完成后设置git用户名和邮箱：

`git config --global user.name kuangtang`

`git config --global user.email kuangtang@dudu.com`

#### Sublime Text安装

在应用商店中搜索 sublime text ，然后点击自己想安装的版本。

#### PhpStorm安装

在官网下载软件包：https://www.jetbrains.com/phpstorm/

然后放到 `/home/baiyang/worksoft` 目录下，解压： `tar xvf PhpStorm-2020.2.3.tar.gz`

移动重命名一下：`mv PhpStorm-202.7660.42 ./PhpStorm`

创建一个软件启动软连接：`sudo ln -s /home/baiyang/worksoft/PhpStorm/bin/phpstorm.sh /usr/local/bin/phpstorm`

然后就可以启动PhpStorm了：`phpstorm`

启动后在启动器软件图标一栏就有phpstorm的图标了，我们鼠标右击选择发送到桌面，以后在桌面点击图标启动使用。

补充信息，旧的版本可能没有实现部署自动化，下面我们说一下。

使用命令行phpstorm启动的方式，关闭命令行窗口，软件就会被关掉，不方便，我们要让软件在后台运行。

编辑.bashrc文件：`vim ~/.bashrc`

写入：
```
alias phpstorm='nohup sh /home/baiyang/worksoft/PhpStorm/bin/phpstorm.sh >/dev/null >/dev/null 2>&1 &'
```

更新.bashrc，执行命令：`source ~/.bashrc`

这样命令行执行phpstorm启动软件，关闭命令行也不会关闭phpstorm了。

为了方便日后使用，我们最好创建一个桌面图标。

`cd /usr/share/applications/` 

`sudo touch phpstorm.desktop`

`sudo vim phpstorm.desktop`

写入内容：
```
[Desktop Entry]
Type=Application
Version=2019.2
Name=phpstorm
Comment=phpstorm ide
Exec=phpstorm
Icon=/home/baiyang/worksoft/PhpStorm/bin/phpstorm.svg
Terminal=false
Categories=Development;IDE;
StartupNotify=true
```

保存，就可以在启动器软件一栏中看到phpstorm的图标了。

#### DBeaver安装

DBeaver是一个通用的数据库管理工具和SQL客户端，支持 MySQL、PostgreSQL、Oracle、 DB2、MSSQL、 Sybase、 Mime、 HSQLDB、Derby以及其他兼容 JDBC 的数据库。
DBeaver 提供一个图形界面用来查看数据库结构、执行SQL查询和脚本，浏览和导出数据，处理BLOB/CLOB数据，修改数据库结构等。

可以直接在应用商店搜索DBeaver下载。

#### PuTTY安装

PuTTY是一套远程登陆工具，它可以连接上支持SSH、Telnet联机的站台，并且可自动取得对方的系统指纹码。建立联机以后，所有的通讯内容都是以加密的方式传输。
自带SSH Forwarding的功能，具有完全模拟xterm、VT102及ECMA-48终端机的能力，支持公钥认证。

可以直接在应用商店搜索PuTTY下载。

#### Postman安装

在官网下载：https://www.postman.com/downloads/

然后放到 `/home/baiyang/worksoft` 目录下，解压：`tar xvf Postman-linux-x64-7.34.0.tar.gz`

进入解压后的 Postman文件夹打开终端，启动 Postman： `./Postman/Postman`

创建一个软件启动软连接：`sudo ln -s /home/baiyang/worksoft/Postman/Postman /usr/local/bin/postman`

创建启动图标Postman.desktop，便于快速启动：

`cd /usr/share/applications/` 

`sudo touch postman.desktop`

`sudo vim postman.desktop`

写入内容：
```
[Desktop Entry]
Type=Application
Name=Postman
GenericName=Postman
Exec=postman
Icon=/home/baiyang/worksoft/Postman/app/resources/app/assets/icon.png
Terminal=false
Categories=Network;
```

保存，就可以在启动器软件一栏中看到Postman的图标了。

点击运行，sign in登录，同步数据。

#### RedisPlus安装

RedisPlus是为Redis可视化管理开发的一款开源免费的桌面客户端软件，支持Windows 、Linux、Mac三大系统平台，
RedisPlus提供更加高效、方便、快捷的使用体验，有着更加现代化的用户界面风格。该软件支持单机、集群模式连接，同时还支持SSH（单机、集群）通道连接。

可以直接在应用商店搜索RedisPlus下载。

#### Docker安装

Docker 的旧版本被称为 docker，docker.io 或 docker-engine 。如果已安装，请卸载它们:
> sudo apt-get remove docker docker-engine docker.io containerd runc

更新 apt 包索引:
> sudo apt-get update

安装 apt 依赖包，用于通过HTTPS来获取仓库:
```
sudo apt-get install  apt-transport-https  ca-certificates  curl  gnupg-agent  software-properties-common
```

添加 Docker 的官方 GPG 密钥:
```
curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add -
```

通过搜索指纹的最后8个字符，验证您现在拥有指纹9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88的密钥:
> sudo apt-key fingerprint 0EBFCD88

输出：
```
pub   rsa4096 2017-02-22 [SCEA]
      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88
uid           [ unknown] Docker Release (CE deb) <docker@docker.com>
sub   rsa4096 2017-02-22 [S]
```

设置docker稳定版储存库，我们可以把源直接写进配置了：
> sudo vim /etc/apt/sources.list

把下面内容补充进去，保存并退出：
```
# 官方源
# deb [arch=amd64] https://download.docker.com/linux/debian wheezy stable
# 国内中科大源
deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/debian stretch stable
```

上面把软件储存库设置好了，下面我们进行安装。

更新 apt 包索引：
> sudo apt-get update

列出可用版本：
> apt-cache madison docker-ce

我们可以安装上面看到的指定版本， 例如 5:19.03.13~3-0~debian-stretch 版：
```
sudo apt-get install docker-ce=5:19.03.13~3-0~debian-stretch docker-ce-cli=5:19.03.13~3-0~debian-stretch containerd.io
```

或者我们可以通过下面的命令直接安装最新版，不过有可能不是稳定版：
> sudo apt-get install docker-ce docker-ce-cli containerd.io

通过以上步骤，Docker就安装好了。

查看一下安装的docker版本：
> sudo docker version

输出：
```
Client: Docker Engine - Community
 Version:           19.03.13
 API version:       1.40
 Go version:        go1.13.15
 Git commit:        4484c46d9d
 Built:             Wed Sep 16 17:03:03 2020
 OS/Arch:           linux/amd64
 Experimental:      false

Server: Docker Engine - Community
 Engine:
  Version:          19.03.13
  API version:      1.40 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       4484c46d9d
  Built:            Wed Sep 16 17:01:33 2020
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.3.7
  GitCommit:        8fba4e9a7d01810a393d5d25a3621dc101981175
 runc:
  Version:          1.0.0-rc10
  GitCommit:        dc9208a3303feef5b3839f4323d9beb36df0a9dd
 docker-init:
  Version:          0.18.0
  GitCommit:        fec3683
```

Docker是虚拟化容器引擎，我们可以运行hello world映像，验证Docker引擎是否正确安装：
> sudo docker run hello-world

输出：
```
Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
0e03bdcc26d7: Pull complete 
Digest: sha256:8c5aeeb6a5f3ba4883347d3747a7249f491766ca1caa47e5da5dfcf6b9b717c0
Status: Downloaded newer image for hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
```

此命令下载测试映像并在容器中运行它。当容器运行时，它会打印一条信息性消息并退出。

查看一下docker本地镜像有哪些：
> sudo docker images

输出：
```
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              bf756fb1ae65        10 months ago       13.3kB
```

查看一下docker默认的远程镜像仓库地址：
> sudo docker info

输出：
```
Client:
 Debug Mode: false

Server:
 Containers: 1
  Running: 0
  Paused: 0
  Stopped: 1
 Images: 1
 Server Version: 19.03.13
 Storage Driver: overlay2
  Backing Filesystem: extfs
  Supports d_type: true
  Native Overlay Diff: true
 Logging Driver: json-file
 Cgroup Driver: cgroupfs
 Plugins:
  Volume: local
  Network: bridge host ipvlan macvlan null overlay
  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog
 Swarm: inactive
 Runtimes: runc
 Default Runtime: runc
 Init Binary: docker-init
 containerd version: 8fba4e9a7d01810a393d5d25a3621dc101981175
 runc version: dc9208a3303feef5b3839f4323d9beb36df0a9dd
 init version: fec3683
 Security Options:
  apparmor
  seccomp
   Profile: default
 Kernel Version: 4.15.0-30deepin-generic
 Operating System: Deepin 15
 OSType: linux
 Architecture: x86_64
 CPUs: 4
 Total Memory: 7.679GiB
 Name: pc
 ID: B7VV:SXQH:LLSD:GYZ7:JTCS:XW7J:QVMD:7JM3:BU62:KQBL:EC73:GNNP
 Docker Root Dir: /var/lib/docker
 Debug Mode: false
 Registry: https://index.docker.io/v1/
 Labels:
 Experimental: false
 Insecure Registries:
  127.0.0.0/8
 Live Restore Enabled: false

WARNING: No swap limit support
```

看到 Registry 非国内，为了提升下载速度，我们需要修改docker远程镜像仓库地址：
> vim /etc/docker/daemon.json

写入：
```
{"registry-mirrors": ["https://registry.docker-cn.com"], "live-restore": true}
```

如果daemon.json这个文件不存在的话，我们需要新建，然后再写入：
> sudo touch /etc/docker/daemon.json

重启docker服务：
> service docker restart

再查看一下docker详情，输出：
```
Client:
 Debug Mode: false

Server:
 Containers: 1
  Running: 0
  Paused: 0
  Stopped: 1
 Images: 1
 Server Version: 19.03.13
 Storage Driver: overlay2
  Backing Filesystem: extfs
  Supports d_type: true
  Native Overlay Diff: true
 Logging Driver: json-file
 Cgroup Driver: cgroupfs
 Plugins:
  Volume: local
  Network: bridge host ipvlan macvlan null overlay
  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog
 Swarm: inactive
 Runtimes: runc
 Default Runtime: runc
 Init Binary: docker-init
 containerd version: 8fba4e9a7d01810a393d5d25a3621dc101981175
 runc version: dc9208a3303feef5b3839f4323d9beb36df0a9dd
 init version: fec3683
 Security Options:
  apparmor
  seccomp
   Profile: default
 Kernel Version: 4.15.0-30deepin-generic
 Operating System: Deepin 15
 OSType: linux
 Architecture: x86_64
 CPUs: 4
 Total Memory: 7.679GiB
 Name: pc
 ID: B7VV:SXQH:LLSD:GYZ7:JTCS:XW7J:QVMD:7JM3:BU62:KQBL:EC73:GNNP
 Docker Root Dir: /var/lib/docker
 Debug Mode: false
 Registry: https://index.docker.io/v1/
 Labels:
 Experimental: false
 Insecure Registries:
  127.0.0.0/8
 Registry Mirrors:
  https://registry.docker-cn.com/
 Live Restore Enabled: true

WARNING: No swap limit support
```

可以看到最下面增加了 Registry Mirrors 那一行。

现在我们docker相关命令都要用root身份运行，原因参考下面资料。

##### MySQL安装

下载mysql镜像：
> sudo docker pull mysql:5.7

把-v与容器挂载的目录准备好：
> mkdir -p /home/baiyang/web/mysql /home/baiyang/web/mysql/data /home/baiyang/web/mysql/conf.d /home/baiyang/web/mysql/logs 

创建容器并运行：
```
sudo docker run \
  --name server-mysql \
  -p 3306:3306 \
  -e MYSQL_ROOT_PASSWORD=root \
  -v /home/baiyang/web/mysql/data:/var/lib/mysql \
  -v /home/baiyang/web/mysql/conf.d:/etc/mysql/conf.d \
  -v /home/baiyang/web/mysql/logs:/logs \
  -v /etc/localtime:/etc/localtime:ro \
  -d mysql:5.7
```

单行写法：
```
sudo docker run  --name server-mysql   -p 3306:3306   -e MYSQL_ROOT_PASSWORD=root   -v /home/baiyang/web/mysql/data:/var/lib/mysql   -v /home/baiyang/web/mysql/conf.d:/etc/mysql/conf.d   -v /home/baiyang/web/mysql/logs:/logs  -v /etc/localtime:/etc/localtime:ro  -d mysql:5.7
```

MYSQL_ROOT_PASSWORD 是 root 用户连接数据库服务的密码。 

/home/baiyang/web/mysql/data 目录将映射为mysql容器配置的数据文件存放路径

/home/baiyang/web/mysql/conf.d 目录里的配置文件将映射为mysql容器的配置文件

/home/baiyang/web/mysql/logs 目录将映射为mysql容器的日志目录

`-v /etc/localtime:/etc/localtime:ro` 因为容器内的时间会跟宿主机相差 8 个小时，加载这个目录是为了校正时间跟宿主机时间一致。

查看容器运行状态：
> sudo docker ps -a

输出：
```
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                         PORTS                               NAMES
ff5f62aa1f77        mysql:5.7           "docker-entrypoint.s…"   13 seconds ago      Up 11 seconds                  0.0.0.0:3306->3306/tcp, 33060/tcp   server-mysql
af13727aafbb        hello-world         "/hello"                 About an hour ago   Exited (0) About an hour ago                                       objective_kapitsa
```

###### 新建用户和数据库

接下来可以新建用户和新建库：

进入mysql容器：
> sudo docker exec -it server-mysql /bin/bash

首先用root登录mysql
> mysql -u root -p

输入密码，进入。

**创建用户**，语法：
```
CREATE USER 'username'@'host' IDENTIFIED BY 'password';
```

user_name：要创建用户的名字。

host：表示要这个新创建的用户允许从哪台机登陆，如果只允许从本机登陆，则 填　`localhost` ，如果允许从远程登陆，则填 `%`

password：新创建用户的登陆数据库密码，如果没密码可以不写。

如：
```
CREATE USER 'dog'@'%' IDENTIFIED BY '123456';
```

**创建数据库**：
> CREATE DATABASE IF NOT EXISTS dog DEFAULT CHARSET utf8mb4 COLLATE utf8mb4_general_ci;

**用户数据库赋权**，语法：

`GRANT privileges ON databasename.tablename TO 'username'@'host';`

privileges：表示要授予什么权力，例如可以有 select ， insert ，delete，update等，如果要授予全部权力，则填 ALL

databasename.tablename：表示用户的权限能用在哪个库的哪个表中，如果想要用户的权限很作用于所有的数据库所有的表，则填 `*.*`，`*`是一个通配符，表示全部。

`'username'@'host'`：表示授权给哪个用户。

如：
```
GRANT  ALL  ON  dog.*  TO  'dog'@'%';
```

注意：

用以上命令授权的用户不能给其他用户授权，如果想这个用户能够给其他用户授权，就要在后面加上  WITH GRANT OPTION

如： 
```
GRANT  ALL  ON   *.*   TO  'aaa'@'%'  WITH GRANT OPTION;
```

##### PHP安装

下载镜像：
> sudo docker pull php:7.1.30-fpm

把-v与容器挂载的目录准备好：

```
mkdir -p /home/baiyang/web/php-fpm/etc /home/baiyang/www
```

创建容器并运行：
```
sudo docker run \
  --name server-phpfpm \ 
  -p 9000:9000 \
  -v /home/baiyang/web/php-fpm/etc:/usr/local/etc/php \
  -v /home/baiyang/www:/var/www/html \
  -v /etc/localtime:/etc/localtime:ro \
  -d php:7.1.30-fpm
```

单行写法：
```
sudo docker run --name server-phpfpm -p 9000:9000 -v /home/baiyang/web/php-fpm/etc:/usr/local/etc/php -v /home/baiyang/www:/var/www/html -v /etc/localtime:/etc/localtime:ro  -d php:7.1.30-fpm
```

查看容器运行状态：
> sudo docker ps -a

输出：
```
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES
9fd6690caa6c        php:7.1.30-fpm      "docker-php-entrypoi…"   4 seconds ago       Up 3 seconds        0.0.0.0:9000->9000/tcp              server-phpfpm
75b3ca90a714        mysql:5.7           "docker-entrypoint.s…"   43 minutes ago      Up 43 minutes       0.0.0.0:3306->3306/tcp, 33060/tcp   server-mysql
```

默认的 php 镜像中不带有 mysqli 模块，我们需要给容器内的 php 安装 mysqli 模块：
> sudo docker exec -it server-phpfpm /bin/bash

我们进入后先看一下容器内php的拓展：
> php -m

输出：
```
[PHP Modules]
Core
ctype
curl
date
dom
fileinfo
filter
ftp
hash
iconv
json
libxml
mbstring
mysqli
mysqlnd
openssl
pcre
PDO
pdo_mysql
pdo_sqlite
Phar
posix
readline
Reflection
session
SimpleXML
SPL
sqlite3
standard
tokenizer
xml
xmlreader
xmlwriter
zlib

[Zend Modules]
```

如果没有，输入：
> docker-php-ext-install mysqli

最后可能会报错：
```
Installing shared extensions:     /usr/local/lib/php/extensions/no-debug-non-zts-20160303/
Installing header files:          /usr/local/include/php/
/usr/local/bin/docker-php-ext-enable: 108: /usr/local/bin/docker-php-ext-enable: cannot create /usr/local/etc/php/conf.d/docker-php-ext-mysqli.ini: Directory nonexistent
```

是说`/usr/local/etc/php/conf.d/docker-php-ext-mysqli.ini`创建失败，查询原因后发现`/usr/local/etc/php/conf.d/`目录不存在导致的，
我们需要创建这个目录：
> mkdir -p /usr/local/etc/php/conf.d

然后再运行上面的命令。

我们还需要安装pdo_mysql拓展：

> docker-php-ext-install pdo_mysql

可以看到 `/usr/local/etc/php/conf.d` 这个目录下多了一个文件：docker-php-ext-pdo_mysql.ini

然后退出容器，回到宿主服务器：
> exit

重启server-phpfpm服务：
> docker stop server-phpfpm

> docker start server-phpfpm

如果这个phpfpm容器支持度不好，我们可以停止这个容器运行，然后删除，然后重新建一个容器：
```
# 停止运行
sudo docker stop server-phpfpm     
# 删除容器
sudo docker rm -f server-phpfpm
```

###### amqp拓展安装

Docker 中的PHP容器安装扩展的方式有：
1. 通过pecl方式安装
2. 通过php 容器中自带的几个特殊命令来安装，这些特殊命令可以在Dockerfile中的RUN命令中进行使用。

这里讲一下第2种方式。

如果像上面直接运行`docker-php-ext-install amqp`，会报错：
```
error: /usr/src/php/ext/amqp does not exist

usage: /usr/local/bin/docker-php-ext-install [-jN] ext-name [ext-name ...]
   ie: /usr/local/bin/docker-php-ext-install gd mysqli
       /usr/local/bin/docker-php-ext-install pdo pdo_mysql
       /usr/local/bin/docker-php-ext-install -j5 gd mbstring mysqli pdo pdo_mysql shmop

if custom ./configure arguments are necessary, see docker-php-ext-configure

Possible values for ext-name:
bcmath bz2 calendar ctype curl dba dom enchant exif fileinfo filter ftp gd gettext gmp hash iconv imap interbase intl json ldap mbstring mcrypt mysqli oci8 odbc opcache pcntl pdo pdo_dblib pdo_firebird pdo_mysql pdo_oci pdo_odbc pdo_pgsql pdo_sqlite pgsql phar posix pspell readline recode reflection session shmop simplexml snmp soap sockets spl standard sysvmsg sysvsem sysvshm tidy tokenizer wddx xml xmlreader xmlrpc xmlwriter xsl zip

Some of the above modules are already compiled into PHP; please check
the output of "php -i" to see which modules are already loaded.
```

说`/usr/src/php/ext/amqp`不存在，我们看一下`/usr/src/php/ext`下有哪些：
> ls -l /usr/src/php/ext

输出：
```
total 308
drwxr-xr-x  4 1000 1000 4096 May 28  2019 bcmath
drwxr-xr-x  3 1000 1000 4096 May 28  2019 bz2
drwxr-xr-x  3 1000 1000 4096 May 28  2019 calendar
drwxr-xr-x  3 1000 1000 4096 May 28  2019 com_dotnet
drwxr-xr-x  3 1000 1000 4096 May 28  2019 ctype
drwxr-xr-x  3 1000 1000 4096 May 28  2019 curl
drwxr-xr-x  4 1000 1000 4096 May 28  2019 date
drwxr-xr-x  6 1000 1000 4096 May 28  2019 dba
drwxr-xr-x  4 1000 1000 4096 May 28  2019 dom
drwxr-xr-x  4 1000 1000 4096 May 28  2019 enchant
drwxr-xr-x  3 1000 1000 4096 May 28  2019 exif
-rwxr-xr-x  1 1000 1000 8652 May 28  2019 ext_skel
-rw-r--r--  1 1000 1000 1165 May 28  2019 ext_skel_win32.php
drwxr-xr-x  4 1000 1000 4096 May 28  2019 fileinfo
drwxr-xr-x  4 1000 1000 4096 May 28  2019 filter
drwxr-xr-x  3 1000 1000 4096 May 28  2019 ftp
drwxr-xr-x  4 1000 1000 4096 May 28  2019 gd
drwxr-xr-x  3 1000 1000 4096 May 28  2019 gettext
drwxr-xr-x  3 1000 1000 4096 May 28  2019 gmp
drwxr-xr-x  3 1000 1000 4096 May 28  2019 hash
drwxr-xr-x  3 1000 1000 4096 May 28  2019 iconv
drwxr-xr-x  3 1000 1000 4096 May 28  2019 imap
drwxr-xr-x  3 1000 1000 4096 May 28  2019 interbase
drwxr-xr-x 21 1000 1000 4096 May 28  2019 intl
drwxr-xr-x  3 1000 1000 4096 May 28  2019 json
drwxr-xr-x  3 1000 1000 4096 May 28  2019 ldap
drwxr-xr-x  3 1000 1000 4096 May 28  2019 libxml
drwxr-xr-x  6 1000 1000 4096 May 28  2019 mbstring
drwxr-xr-x  3 1000 1000 4096 May 28  2019 mcrypt
drwxr-xr-x  3 1000 1000 4096 May 28  2019 mysqli
drwxr-xr-x  2 1000 1000 4096 May 28  2019 mysqlnd
drwxr-xr-x  3 1000 1000 4096 May 28  2019 oci8
drwxr-xr-x  3 1000 1000 4096 May 28  2019 odbc
drwxr-xr-x  4 1000 1000 4096 May 28  2019 opcache
drwxr-xr-x  3 1000 1000 4096 May 28  2019 openssl
drwxr-xr-x  3 1000 1000 4096 May 28  2019 pcntl
drwxr-xr-x  4 1000 1000 4096 May 28  2019 pcre
drwxr-xr-x  3 1000 1000 4096 May 28  2019 pdo
drwxr-xr-x  3 1000 1000 4096 May 28  2019 pdo_dblib
drwxr-xr-x  3 1000 1000 4096 May 28  2019 pdo_firebird
drwxr-xr-x  3 1000 1000 4096 May 28  2019 pdo_mysql
drwxr-xr-x  3 1000 1000 4096 May 28  2019 pdo_oci
drwxr-xr-x  3 1000 1000 4096 May 28  2019 pdo_odbc
drwxr-xr-x  3 1000 1000 4096 May 28  2019 pdo_pgsql
drwxr-xr-x  3 1000 1000 4096 May 28  2019 pdo_sqlite
drwxr-xr-x  3 1000 1000 4096 May 28  2019 pgsql
drwxr-xr-x  4 1000 1000 4096 May 28  2019 phar
drwxr-xr-x  3 1000 1000 4096 May 28  2019 posix
drwxr-xr-x  3 1000 1000 4096 May 28  2019 pspell
drwxr-xr-x  3 1000 1000 4096 May 28  2019 readline
drwxr-xr-x  3 1000 1000 4096 May 28  2019 recode
drwxr-xr-x  3 1000 1000 4096 May 28  2019 reflection
drwxr-xr-x  3 1000 1000 4096 May 28  2019 session
drwxr-xr-x  3 1000 1000 4096 May 28  2019 shmop
drwxr-xr-x  4 1000 1000 4096 May 28  2019 simplexml
drwxr-xr-x  3 1000 1000 4096 May 28  2019 skeleton
drwxr-xr-x  3 1000 1000 4096 May 28  2019 snmp
drwxr-xr-x  4 1000 1000 4096 May 28  2019 soap
drwxr-xr-x  3 1000 1000 4096 May 28  2019 sockets
drwxr-xr-x  5 1000 1000 4096 May 28  2019 spl
drwxr-xr-x  4 1000 1000 4096 May 28  2019 sqlite3
drwxr-xr-x  4 1000 1000 4096 May 28  2019 standard
drwxr-xr-x  3 1000 1000 4096 May 28  2019 sysvmsg
drwxr-xr-x  3 1000 1000 4096 May 28  2019 sysvsem
drwxr-xr-x  3 1000 1000 4096 May 28  2019 sysvshm
drwxr-xr-x  4 1000 1000 4096 May 28  2019 tidy
drwxr-xr-x  3 1000 1000 4096 May 28  2019 tokenizer
drwxr-xr-x  3 1000 1000 4096 May 28  2019 wddx
drwxr-xr-x  3 1000 1000 4096 May 28  2019 xml
drwxr-xr-x  4 1000 1000 4096 May 28  2019 xmlreader
drwxr-xr-x  4 1000 1000 4096 May 28  2019 xmlrpc
drwxr-xr-x  4 1000 1000 4096 May 28  2019 xmlwriter
drwxr-xr-x  3 1000 1000 4096 May 28  2019 xsl
drwxr-xr-x  5 1000 1000 4096 May 28  2019 zip
drwxr-xr-x  3 1000 1000 4096 May 28  2019 zlib
```

看到了好多拓展包，我们也要把amqp的拓展包放到这个目录下。

有时`/usr/src/php`目录可能不存在，我们使用下面命令创建：
> docker-php-source extract 

要删除`/usr/src/php`目录，可以使用：
> docker-php-source delete 

amqp依赖rabbitmq-c，所以需要先安装rabbitmq-c。

###### redis拓展安装

从上面，我们看到`/usr/src/php/ext`目录下也没有redi目录，我们需要下载redis拓展，然后放到这个目录下，再执行命令。

下载：
> curl -L -o /tmp/redis.tar.gz https://github.com/phpredis/phpredis/archive/3.1.3.tar.gz

解压：
> tar xfz /tmp/redis.tar.gz
 
删除包：
> rm -r /tmp/redis.tar.gz

如果`/usr/src/php/ext`目录不存在，我们要新建：
> mkdir -p /usr/src/php/ext

移动：
> mv phpredis-3.1.3 /usr/src/php/ext/redis
 
安装：
> docker-php-ext-install redis

退出容器，重启php容器，然后就可以使用了。

##### Nginx安装

下载镜像：
> sudo docker pull nginx

把-v与容器挂载的目录和文件准备好：
```
mkdir -p /home/baiyang/web/nginx/conf /home/baiyang/web/nginx/conf/vhost /home/baiyang/web/nginx/logs
```

创建容器并运行：
```
sudo docker run \
  --name server-nginx \
  -p 80:80 \
  -v /home/baiyang/web/nginx/conf/vhost:/etc/nginx/conf.d \
  -v /home/baiyang/web/nginx/logs:/var/log/nginx \
  -v /home/baiyang/www:/usr/share/nginx/html \
  -v /etc/localtime:/etc/localtime:ro \
  --link server-phpfpm:php \
  -d nginx
```

单行写法：
```
sudo docker run --name server-nginx -p 80:80 -v /home/baiyang/web/nginx/conf/vhost:/etc/nginx/conf.d  -v /home/baiyang/web/nginx/logs:/var/log/nginx  -v /home/baiyang/www:/usr/share/nginx/html  -v /etc/localtime:/etc/localtime:ro  --link server-phpfpm:php  -d nginx
```

执行后查看下容器的运行状态。

期间容器运行发生错误异常关闭，我们可以通过日志查看原因：
> sudo docker logs server-nginx

##### web项目搭建

我们上面已经运行了nginx容器，但这个容器并无法调用php脚本服务，我们需要做相应配置。

我们可以在 `/home/baiyang/web/nginx/conf/vhost/` 目录下写域名项目配置文件：

test.com.conf文件内容：
```
server {
    listen       80;
    server_name  test.com www.test.com;

    #charset koi8-r;
    #access_log  /var/log/nginx/host.access.log  main;

    location / {
        root   /usr/share/nginx/html/test;
        index  index.html index.htm index.php;
    }

    #error_page  404              /404.html;

    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    #location = /50x.html {
    #   root   /usr/share/nginx/html;
    #}

    # proxy the PHP scripts to Apache listening on 127.0.0.1:80
    #
    #location ~ \.php$ {
    #    proxy_pass   http://127.0.0.1;
    #}

    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
    #
    location ~ \.php$ {
        root           /var/www/html/test;
        fastcgi_pass   php:9000;
        fastcgi_index  index.php;
        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
        include        fastcgi_params;
    }

    # deny access to .htaccess files, if Apache's document root
    # concurs with nginx's one
    #
    #location ~ /\.ht {
    #    deny  all;
    #}
}
```

写上面这个配置文件时，要意识到这个文件是容器中的配置文件。
其中`location / {...}`定位的是静态文件，里面的root是nginx容器中的地址，
`location ~ \.php$ {...}`定位的是动态脚本，里面的root是php容器中的地址。

然后把 域名/服务器 配置好：
> sudo vim /etc/hosts

补充一行：
```
127.0.0.1     test.com
```

然后我们重启上面运行的nginx容器，让我们修改的配置文件生效：
> sudo docker restart server-nginx

可以看出我们test项目的代码在宿主服务器文件夹 /home/baiyang/www/test 下，我们把项目内容发布到这个文件夹下就可以了。
然后我们就可以用 test.com 访问项目了。 

同样，其他项目我们也可以像test项目这样部署，共用nginx和php容器。

##### composer安装

我们就在php容器内使用php脚本命令，理论上我们也在php容器内安装composer，
但是发现容器内composer安装好后，composer要使用git，
容器内git的安装却不顺利：apt安装需要PUBKEY，写入PUBKEY有需要gnupg2，用不了apt那就只能自己下载包安装，gnupg2又依赖gnupg，发现gnupg又依赖十几个包。
算了，只能说这个容器内不能安装和使用composer。理论上来说，这个容器内只提供web服务，也不应该有其他的东西。那我们就新建composer容器来实现。

使用docker hub中的composer镜像，发现依赖于宿主机中的php，还是用不了。

看来我们要通过centos镜像自建composer服务容器了。

下载镜像：
> sudo docker pull centos:6.7

创建容器并运行：
```
sudo docker run \
  --name composer \ 
  -v /home/baiyang/www:/var/www/html \
  -v /etc/localtime:/etc/localtime:ro \
  -itd centos:6.7
```

单行写法：
```
sudo docker run --name composer -v /home/baiyang/www:/var/www/html -v /etc/localtime:/etc/localtime:ro -itd centos:6.7
```

进入容器：
> sudo docker exec -it composer /bin/bash

更新yum源：
> rpm -Uvh https://mirror.webtatic.com/yum/el6/latest.rpm

更新软件包缓存：
> yum clean all 
>
> yum makecache

搜索可用php版本：
> yum list php*

发现没看到php71w，先安装php7.1看看：
> yum install -y php71w

不过看到安装了mod_php71w，印象中mod_php71w是作为apache模块运行的，查阅文档后发现原来mod_php71w提供php71w、 mod_php、 php71w-zts。

安装基础拓展包：
> yum install -y php71w-common

php71w-common 提供了下面这些，也是其他拓展包所依赖的，需要先安装好：
```
php-api, php-bz2, php-calendar, php-ctype, php-curl, php-date, php-exif, php-fileinfo, php-filter, 
php-ftp, php-gettext, php-gmp, php-hash, php-iconv, php-json, php-libxml, php-openssl, php-pcre, php-pecl-Fileinfo, 
php-pecl-phar, php-pecl-zip, php-reflection, php-session, php-shmop, php-simplexml, php-sockets, php-spl, 
php-tokenizer, php-zend-abi, php-zip, php-zlib
```

安装cli拓展：
> yum install -y php71w-cli

查看php版本：
> php -v

输出：
```
PHP 7.1.33 (cli) (built: Oct 26 2019 11:22:12) ( NTS )
Copyright (c) 1997-2018 The PHP Group
Zend Engine v3.1.0, Copyright (c) 1998-2018 Zend Technologies
```

mbstring这个包经常用到(如yii2)，也可以安装好：
> yum install php71w-mbstring

下载composer安装包：
> cd /usr/local/src

`php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');" `

安装：
> php composer-setup.php

移除安装包：
`php -r "unlink('composer-setup.php');" `

直接移动到环境搜索目录下，重命名为composer：
> mv composer.phar /usr/local/bin/composer

设置包源：
> composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/

也可以是这个镜像`https://packagist.phpcomposer.com`，不过服务不稳定。

查看当前源地址：
> composer config -g -l repo.packagist

查看版本：
> composer -v

到项目下就可以使用了。
> cd /var/www/html/test
>
> composer update

不过发现docker容器中的composer更新包后，在用户环境下是不属于当前用户的，如果修改文件权限，又会导致git捕获变化。
看来composer还是要安装在用户环境中，这也就是说在用户环境下还需要安装php-cli，与docker容器中已有的php需求重复了。
我们需要想清楚docker容器中应该安装什么和不必要安装什么。一般而言，版本更新不频繁，不会造成用户环境软件混乱的可以直接安装在用户环境中，
版本更新频繁或者需求版本比较多的，就要考虑安装在docker容器中了。

###### php7.0安装

安装php7.0：
> yum install php70w

最后输出：
```
Installed:
  php70w.x86_64 0:7.0.33-1.w6                                                                                                                                                 

Dependency Installed:
  apr.x86_64 0:1.3.9-5.el6_9.1                             apr-util.x86_64 0:1.3.9-3.el6_0.1                      apr-util-ldap.x86_64 0:1.3.9-3.el6_0.1                    
  httpd.x86_64 0:2.2.15-69.el6.centos                      httpd-tools.x86_64 0:2.2.15-69.el6.centos              hwdata.noarch 0:0.233-20.1.el6                            
  initscripts.x86_64 0:9.03.61-1.el6.centos                iproute.x86_64 0:2.6.32-57.el6                         iptables.x86_64 0:1.4.7-19.el6                            
  iputils.x86_64 0:20071127-24.el6                         libdrm.x86_64 0:2.4.65-2.el6                           libedit.x86_64 0:2.11-4.20080712cvs.1.el6                 
  libpciaccess.x86_64 0:0.13.4-1.el6                       libsemanage.x86_64 0:2.0.43-5.1.el6                    mailcap.noarch 0:2.1.31-2.el6                             
  mingetty.x86_64 0:1.08-5.el6                             module-init-tools.x86_64 0:3.9-26.el6                  php70w-cli.x86_64 0:7.0.33-1.w6                           
  php70w-common.x86_64 0:7.0.33-1.w6                       plymouth.x86_64 0:0.8.3-29.el6.centos                  plymouth-core-libs.x86_64 0:0.8.3-29.el6.centos           
  plymouth-scripts.x86_64 0:0.8.3-29.el6.centos            policycoreutils.x86_64 0:2.0.83-30.1.el6_8             psmisc.x86_64 0:22.6-24.el6                               
  redhat-logos.noarch 0:60.0.14-12.el6.centos              sysvinit-tools.x86_64 0:2.87-6.dsf.el6                 udev.x86_64 0:147-2.74.el6_10                             
  upstart.x86_64 0:0.6.5-17.el6                            util-linux-ng.x86_64 0:2.17.2-12.28.el6_9.2           

Dependency Updated:
  libblkid.x86_64 0:2.17.2-12.28.el6_9.2                                                 libuuid.x86_64 0:2.17.2-12.28.el6_9.2                                                

Complete!
```

可以看到同时安装好了：`php70w-common、 php70w-cli`等。

###### 失败记录

下载镜像：
> sudo docker pull centos:7

创建容器并运行：
```
sudo docker run \
  --name composer \ 
  -v /home/baiyang/www:/var/www/html \
  -v /etc/localtime:/etc/localtime:ro \
  -itd centos:7
```

单行写法：
```
sudo docker run --name composer -v /home/baiyang/www:/var/www/html -v /etc/localtime:/etc/localtime:ro -itd centos:7
```

进入容器：
> sudo docker exec -it composer /bin/bash

改为国内源。
先备份下：
> cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak

删除文件，重新编辑：
> rm -f /etc/yum.repos.d/CentOS-Base.repo
>
> vi /etc/yum.repos.d/CentOS-Base.repo

写入下面内容后，保存退出：
```
# CentOS-Base.repo
#
# The mirror system uses the connecting IP address of the client and the
# update status of each mirror to pick mirrors that are updated to and
# geographically close to the client.  You should use this for CentOS updates
# unless you are manually picking other mirrors.
#
# If the mirrorlist= does not work for you, as a fall back you can try the
# remarked out baseurl= line instead.
#
#

[base]
name=CentOS-$releasever - Base
baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/os/$basearch/
#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=os
enabled=1
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-7

#released updates
[updates]
name=CentOS-$releasever - Updates
baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/updates/$basearch/
#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=updates
enabled=1
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-7

#additional packages that may be useful
[extras]
name=CentOS-$releasever - Extras
baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/extras/$basearch/
#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=extras
enabled=1
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-7

#additional packages that extend functionality of existing packages
[centosplus]
name=CentOS-$releasever - Plus
baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/centosplus/$basearch/
#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=centosplus
gpgcheck=1
enabled=0
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-7
```

更新软件包缓存：
> yum clean all 
>
> yum makecache

或者这样更新yum源：
> rpm -Uvh https://mirror.webtatic.com/yum/el6/latest.rpm

搜索可用php版本：
> yum list php*

发现没看到php71w，不过看到了mod_php71w，印象中mod_php71w是作为apache模块运行的，查阅文档后发现原来mod_php71w提供php71w、 mod_php、 php71w-zts。
安装php7.1：
> yum install -y php71w

安装基础拓展包：
> yum install -y php71w-common

php71w-common 提供了下面这些，也是其他拓展包所依赖的，需要先安装好：
```
php-api, php-bz2, php-calendar, php-ctype, php-curl, php-date, php-exif, php-fileinfo, php-filter, 
php-ftp, php-gettext, php-gmp, php-hash, php-iconv, php-json, php-libxml, php-openssl, php-pcre, php-pecl-Fileinfo, 
php-pecl-phar, php-pecl-zip, php-reflection, php-session, php-shmop, php-simplexml, php-sockets, php-spl, 
php-tokenizer, php-zend-abi, php-zip, php-zlib
```

可能会报错：
```
Processing Dependency: libgmp.so.3()(64bit) for package: php71w-common-7.1.33-1.w6.x86_64
```

说需要libgmp.so.3()，我们应该有这个包，只是名称不是这个，在根目录下搜索看看：
> find -name libgmp.so.*

输出：
```
./usr/lib64/libgmp.so.10
./usr/lib64/libgmp.so.10.2.0
./usr/lib64/fipscheck/libgmp.so.10.2.0.hmac
./usr/lib64/fipscheck/libgmp.so.10.hmac
```

看到有，我们只需要新建软链就可以。不幸的是实验下来不可行。是centos7的问题，还是安装centos6.7吧。

##### 其他

现在在deepin终端中无法直接运行容器内的php命令，如果有这个需求，可以参考下 [基于docker的php命令行](https://xiejindou.com/2018/06/24/%E5%9F%BA%E4%BA%8Edocker%E7%9A%84php%E5%91%BD%E4%BB%A4%E8%A1%8C/)

等docker玩的很熟练了后，用docker搭建环境过程还是挺复杂的，想一键快捷管理，可以考虑下 [宝塔](https://www.bt.cn/download/linux.html)


<br/><br/><br/><br/><br/>
### 参考资料

深度科技社区 <https://www.deepin.org>

深度启动盘制作工具 <https://www.deepin.org/original/deepin-boot-maker/>

深度系统（Deepin Linux）U盘安装教程 <http://tangwumo.com/%E6%B7%B1%E5%BA%A6%E7%B3%BB%E7%BB%9F%EF%BC%88deepin-linux%EF%BC%89u%E7%9B%98%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B.html>

deepin15.8安装过程(详细) <https://segmentfault.com/a/1190000017033590>

Linux docker安装配置 <https://ibaiyang.github.io/blog/linux/2019/12/19/linux-docker%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE.html>

Docker php安装扩展步骤详解 <https://www.cnblogs.com/yinguohai/p/11329273.html>

解决非root用户没有权限运行docker命令的问题 <https://blog.csdn.net/icodestechnology/article/details/97170540>

深度 linux 搭建 php 开发环境 <https://www.jianshu.com/p/d44e912bf1b7>

linux(deepin)在启动器上制作启动图标 <https://blog.csdn.net/zhangjingao/article/details/76546363>

Deepin 15.7 安装 Postman  <http://php-note.com/article/detail/b529a43aa3f94eda93c2fd59956bb1e6>

Deepin 安装 Postman <https://blog.yoyoyo.me/index.php/archives/63/>

深度Deepin系统中，自己安装Firefox <https://www.jianshu.com/p/86d5be359cf5>

Linux安装navicat， 并解决中文乱码 <https://blog.csdn.net/qq_38276669/article/details/82288870>

基于docker的php命令行 <https://xiejindou.com/2018/06/24/%E5%9F%BA%E4%BA%8Edocker%E7%9A%84php%E5%91%BD%E4%BB%A4%E8%A1%8C/>

Docker php安装扩展步骤详解 <https://www.cnblogs.com/yinguohai/p/11329273.html>

为docker下的php容器安装php-redis扩展【编译安装】 <https://www.cnblogs.com/wyaokai/p/11904701.html>

docker hub composer <https://hub.docker.com/_/composer>

docker run的--rm选项详解 <https://blog.csdn.net/nzjdsds/article/details/81981732>

清华开源软件镜像站 <https://mirrors.cnnic.cn/>

centos7配置国内yum源 <https://blog.csdn.net/xiaojin21cen/article/details/84726193>

<http://www.xiaoshu168.com/linux/31.html>

