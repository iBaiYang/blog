---
layout: post
categories: Redis
title: Redis 常见面试题
meta: Redis 常见面试题
---
* content
{:toc}

## 正文

1、什么是 Redis?.

2、Redis 的数据类型？

3、使用 Redis 有哪些好处？

4、Redis 相比 Memcached 有哪些优势？

5、Memcache 与 Redis 的区别都有哪些？

6、Redis 是单进程单线程的？

7、一个字符串类型的值能存储最大容量是多少？

8、Redis 的持久化机制是什么？各自的优缺点？

9、Redis 常见性能问题和解决方案：

10、redis 过期键的删除策略？

11、Redis 的回收策略（淘汰策略）?

12、为什么 Redis 需要把所有数据放到内存中？

13、Redis 的同步机制了解么？

14、Pipeline 有什么好处，为什么要用 pipeline？

15、是否使用过 Redis 集群，集群的原理是什么？

16、Redis 集群方案什么情况下会导致整个集群不可用？

17、Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？

18、Jedis 与 Redisson 对比有什么优缺点？

19、Redis 如何设置密码及验证密码？

20、说说 Redis 哈希槽的概念？

21、Redis 集群的主从复制模型是怎样的？

22、Redis 集群会有写操作丢失吗？为什么？

23、Redis 集群之间是如何复制的？

24、Redis 集群最大节点个数是多少？

25、Redis 集群如何选择数据库？

26、怎么测试 Redis 的连通性？

27、怎么理解 Redis 事务？

28、Redis 事务相关的命令有哪几个？

29、Redis key 的过期时间和永久有效分别怎么设置？

30、Redis 如何做内存优化？

31、Redis 回收进程如何工作的？

32、都有哪些办法可以降低 Redis 的内存使用情况呢？

33、Redis 的内存用完了会发生什么？

34、一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set他们最多能存放多少元素？

35、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证redis 中的数据都是热点数据？

36、Redis 最适合的场景？

37、假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？

38、如果有大量的 key 需要设置同一时间过期，一般需要注意什么？

39、使用过 Redis 做异步队列么，你是怎么用的？

40、使用过 Redis 分布式锁么，它是什么回事？

![]({{site.baseurl}}/images/20211013/20211013171543.jpg)

### 1、什么是 Redis？

Redis是一个基于内存实现的key-value数据结构的的NoSQL开源数据库。

Redis 是完全开源免费的，遵守 BSD 协议，是一个高性能的 key-value 数据库。可以用作分布式缓存中间件。

Redis 与其他 key - value 缓存产品相比有以下三个特点：
* Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
* Redis 不仅仅支持简单的 key-value 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。
* Redis 支持数据的备份，即 master-slave 模式的数据备份。

Redis 优势：
* 性能极高：Redis 能读的速度是 110000 次/s，写的速度是 81000 次/s。
* 丰富的数据类型：Redis 支持二进制案例的 Strings，Lists，Hashes，Sets 及 Ordered Sets 数据类型操作。
* 原子：Redis 的所有操作都是原子性的，意思就是要么成功执行、要么失败完全不执行。单个操作是原子性的。
多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。
* 丰富的特性：Redis 还支持 publish/subscribe，通知，key 过期等等特性。

Redis 与其他 key-value 存储有什么不同？

Redis 有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。
Redis 的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。

Redis 运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。
在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，
这样 Redis 可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。

### 2、Redis 的数据类型？

Redis 支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及 zset（sorted set有序集合）。

我们实际项目中比较常用的是 string，hash。 如果你是 Redis 中高级用户，还需要加上下面几种数据结构 HyperLogLog、Geo、Pub/Sub。

如果你说还玩过 Redis Module，像 BloomFilter，RedisSearch，Redis-ML，面试官的眼睛就开始发亮了。

### 3、使用 Redis 有哪些好处？

速度快，因为数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)

支持丰富数据类型，支持 string，list，set，Zset，hash 等

支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行

丰富的特性，可用于缓存，消息，按 key 设置过期时间，过期后将会自动删除

### 4、Redis 相比 Memcached 有哪些优势？

Memcached 所有的值均是简单的字符串，Redis 作为其替代者，支持更为丰富的数据类

Redis 的速度比 Memcached 快很多

Redis 可以持久化其数据

### 5、Memcache 与 Redis 的区别都有哪些？

存储方式 Memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis 有部分存在硬盘上，这样能保证数据的持久性。

数据支持类型 Memcache 对数据类型支持相对简单。Redis 有复杂的数据类型。

使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis 直接自己构建了 VM 机制 ，
因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

### 6、Redis 是单进程单线程的？

Redis 是单进程单线程的，Redis 利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。

### 7、一个字符串类型的智能存储最大容量是多少？

512M。

### 8、Redis 的持久化机制是什么？各自的优缺点？

Redis提供两种持久化机制 RDB 和 AOF 机制：

RDB（Redis DataBase）持久化方式：是指用数据集快照的方式半持久化模式记录 Redis 数据库的所有键值对，
在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。

优点：
* 只有一个文件 dump.rdb，方便持久化。
* 容灾性好，一个文件可以保存到安全的磁盘。
* 性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。
使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis的高性能。
* 相对于数据集大时，比 AOF 的启动效率更高。

缺点：
* 数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候

AOF（Append-only file）持久化方式：是指所有的命令行记录以 Redis 命令请求协议的格式完全持久化存储保存为 aof 文件。

优点：
* 数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次命令操作就记录到 aof 文件中一次。
* 通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。
* AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）

缺点：
* AOF 文件比 RDB 文件大，且恢复速度慢。
* 数据集大的时候，比 RDB 启动效率低。

### 9、Redis 常见性能问题和解决方案

Master 最好不要写内存快照，如果 Master 写内存快照，save 命令调度 rdbSave函数，会阻塞主线程的工作，
当快照比较大时对性能影响是非常大的，会间断性暂停服务。

如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一。

为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网。

尽量避免在压力很大的主库上增加从。

主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1<- Slave2 <- Slave3……这样的结构方便解决单点故障问题，
实现 Slave 对 Master 的替换。如果 Master 挂了，可以立刻启用 Slave1 做 Master，其他不变。

### 10、Redis 过期键的删除策略？

定时删除：在设置键的过期时间的同时，创建一个定时器 timer。让定时器在键的过期时间来临时，立即执行对键的删除操作。

惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。

定期删除：每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。

### 11、Redis 的回收策略（淘汰策略）？

在Redis的内存达到最大设置值时就会进行淘汰策略。

volatile-lru：(Least Recently Used) 从已设置过期时间的数据集（server.db[i].expires）中挑选**最近**-**最少**使用的数据淘汰

volatile-ttl：(time to live) 从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰

volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰

allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰

allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰

no-enviction（驱逐）：禁止驱逐数据

注意这里的 6 种机制，volatile 和 allkeys 规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，
后面的 lru、ttl 以及 random 是三种不同的淘汰策略，再加上一种 no-enviction 永不回收的策略。

使用策略规则：
* 如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 allkeys-lru
* 如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用 allkeys-random

总结起来有以下：
1. Random算法
2. TTL算法
3. LRU算法
4. LFU算法

LFU算法 与 LRU算法 相似，在LRU算法基础上做了优化，使用了两个双向链表，形成一个二维双向链表，
一个是访问频率，另一个是访问频率相同的元素。

### 12、为什么 Redis 需要把所有数据放到内存中？

Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以 Redis 具有快速和数据持久化的特征。
如果不将数据放在内存中，磁盘 I/O 速度为严重影响 Redis 的性能。在内存越来越便宜的今天，Redis 将会越来越受欢迎。
如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。

### 13、Redis 的同步机制了解么？

Redis 可以使用主从同步，从从同步。第一次同步时，主节点做一次 bgsave，并同时将后续修改操作记录到内存 buffer，
待完成后将 rdb 文件全量同步到复制节点，复制节点接收完成后将 rdb 镜像加载到内存。
加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。

### 14、Pipeline 有什么好处，为什么要用 Pipeline？

可以将多次 IO 往返的时间缩减为一次，前提是 Pipeline 执行的指令之间没有因果相关性。
使用 redis-benchmark 进行压测的时候可以发现影响 Redis 的 QPS 峰值的一个重要因素是 Pipeline 批次指令的数目。

### 15、是否使用过 Redis 集群，集群的原理是什么？

Redis 主从复制，一主多从，有一个Master节点和多个Slave节点，Master节点负责数据的读写，Slave节点负责数据的读取。
Master 数据变更会同步到 Slave节点上实现数据的同步。通过该架构实现读写分离，提升数据的查询效率。
但不提供容错和数据恢复的功能。Master结构挂了后，不会选取出新Master，导致所有的写请求失败。

Redis Sentinal 哨兵模式，是主从复制的升级，着眼于高可用，哨兵会监控Master节点的状态，
在 Master 宕机时会自动选取出一个 Slave 作为Master，继续提供服务。但没有解决在线扩容的问题。

Redis Cluster 模式，多主多从，着眼于扩展性，在单个 Redis 内存不足时，使用 Cluster 进行分片存储。
引入了Slot槽，来实现数据分片。Solt的整体取值范围是 0-16383，2的12次方，每个节点分配一个Solt区间。
数据存储时，Redis会根据key计算得到一个slot的值，然后找到对应的节点进行数据的读写。
在高可用方面引入了主从复制，一个Master节点对应一个或多个Slave节点。
在 Master 宕机时会自动选取出一个 Slave 作为Master，继续提供服务。
Redis Cluster 虽然解决了在线扩容以及故障转移的能力，但也有缺点：
1. 客户端的实现会更加复杂
2. Slave节点只是一个冷备节点不提供分担读操作的压力
3. 对于Redis里面的批量操作指令会有限制

### 16、Redis 集群方案什么情况下会导致整个集群不可用？

有 A，B，C 三个节点的集群，在没有复制模型的情况下，如果节点 B 失败了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。

### 17、Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？

Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。

### 18、Jedis 与 Redisson 对比有什么优缺点？

Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持；
Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，
功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性。

Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。

### 19、Redis 如何设置密码及验证密码？

设置密码：config set requirepass 123456

授权密码：auth 123456

### 20、说说 Redis 哈希槽的概念？

Redis 集群没有使用一致性 hash，而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽（2的14次方），
每个 key 通过 CRC16 校验后对 16384 取模（`CRC16（key）&16383`）来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。

### 21、Redis 集群的主从复制模型是怎样的？

为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有 N-1 个复制品。

### 22、Redis 集群会有写操作丢失吗？为什么？

Redis 并不能保证数据的强一致性，这意味着在实际中集群在特定的条件下可能会丢失写操作。

### 23、Redis 集群之间是如何复制的？

异步复制。

### 24、Redis 集群最大节点个数是多少？

16384 个。  （2的14次方）

### 25、Redis 集群如何选择数据库？

Redis 集群目前无法做数据库选择，默认在 0 数据库。

### 26、怎么测试 Redis 的连通性？

使用 ping 命令。

### 27、怎么理解 Redis 事务？

事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。

事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。

### 28、Redis 事务相关的命令有哪几个？

Redis 中提供下面四种命令来保证事务执行：
* MULTI：开启一个事务，执行后客户端可以向服务器发送任意多条命令，这些命令并不会立即执行，
而是放到一个队列中，当执行EXEC命令才开始执行，当客户端处于事务状态，执行所有的命令会返回QUEUED。
* EXEC ：执行事务。
* DISCARD ：清空事务队列，并放弃事务。
* WATCH：类似于乐观锁，可以监听多个值，当监控的值在WATCH执行后，EXEC命令执行前，修改了该值，那么redis执行当前事务将失败。

参阅 <https://zhuanlan.zhihu.com/p/522274500> 、<https://www.cnblogs.com/tandabao/p/17061739.html> 、
 <https://www.php.cn/faq/549211.html>

### 29、Redis key 的过期时间和永久有效分别怎么设置？

EXPIRE 和 PERSIST 命令。

### 30、Redis 如何做内存优化？

尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，
所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的 Web 系统中有一个用户对象，
不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key，而是应该把这个用户的所有信息存储到一张散列表里面。

### 31、Redis 回收进程如何工作的？

一个客户端运行了新的命令，添加了新的数据。Redis 检查内存使用情况，如果大于 max memory 的限制，则根据设定好的策略进行回收。
一个新的命令被执行，等等。所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。
如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。

### 32、都有哪些办法可以降低 Redis 的内存使用情况呢？

如果你使用的是 32 位的 Redis 实例，可以好好利用 Hash，list，sorted set，set等集合类型数据，
因为通常情况下很多小的 Key-Value 可以用更紧凑的方式存放到一起。

### 33、Redis 的内存用完了会发生什么？

如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可以正常返回。）
或者你可以将 Redis 当缓存来使用配置淘汰机制，当 Redis 达到内存上限时会冲刷掉旧的内容。

### 34、一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？

理论上 Redis 可以处理多达 2^32 的 keys，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。
我们正在测试一些较大的值。任何 list、set、和 sorted set 都可以放 2^32 个元素。换句话说，Redis 的存储极限是系统中的可用内存值。

### 35、MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据？

Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。

相关知识：Redis 提供 6 种数据淘汰策略：

volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰

volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰

volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰

allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰

allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰

no-enviction（驱逐）：禁止驱逐数据

### 36、Redis 最适合的场景？

**会话缓存（Session Cache）**，最常用的一种使用 Redis 的情景是会话缓存（session cache）。
用 Redis 缓存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。
当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？
幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。
甚至广为人知的商业平台Magento 也提供 Redis 的插件。

**全页缓存（FPC）**，除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。
回到一致性问题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，
这是一个极大改进，类似 PHP 本地 FPC。再次以 Magento 为例，Magento提供一个插件来使用 Redis 作为全页缓存后端。
此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。

**队列**，Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis能作为一个很好的消息队列平台来使用。
Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push/pop 操作。
如果你快速地在 Google中搜索“Redis queues”，你马上就能找到大量的开源项目，
这些项目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。
例如，Celery 有一个后台就是使用 Redis 作为 broker，你可以从这里去查看。

**排行榜/计数器**，Redis 在内存中对数字进行递增或递减的操作实现的非常好。
集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。
所以，我们要从排序集合中获取到排名最靠前的 10 个用户——我们称之为“user_scores”，我们只需要像下面一样执行即可：
当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，
你需要这样执行：`ZRANGE user_scores 0 10 WITHSCORES Agora Games` 就是一个很好的例子，
用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可以在这里看到。

**发布/订阅**，最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。
我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用 Redis 的发布/订阅功能来建立聊天系统！
命令有：
* publish：发布消息 。语法：publish channel名称 "消息的内容"
* subscribe：订阅消息。 语法：subscribe channel名称
* psubscribe：使用通配符来订阅消息。 语法：psubscribe channe1*名称

### 37、假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？

使用 keys 指令可以扫出指定模式的 key 列表。

对方接着追问：如果这个 Redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问题？

这个时候你要回答 Redis 关键的一个特性：Redis 的单线程的。keys 指令会导致线程阻塞一段时间，线上服务会停顿，
直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指令，scan 指令可以无阻塞地提取出指定模式的 key 列表，
但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。

### 38、如果有大量的 key 需要设置同一时间过期，一般需要注意什么？

如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，Redis 可能会出现短暂的卡顿现象。
一般需要在时间上加一个随机值，使得过期时间分散一些。

### 39、使用过 Redis 做异步队列么，你是怎么用的？

答：一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。
如果对方追问可不可以不用 sleep 呢？list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。
如果对方追问能不能生产一次消费多次呢？使用 pub/sub 主题订阅者模式，可以实现1:N 的消息队列。

如果对方追问 pub/sub 有什么缺点？

在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 RabbitMQ等。

如果对方追问 Redis 如何实现延时队列？

我估计现在你很想把面试官一棒打死，如果你手上有一根棒球棍的话，怎么问得这么详细。但是你很克制，然后神态自若地回答道：
使用 sorted set，拿时间戳作为score，消息内容作为 key 调用 zadd 来生产消息，
消费者用 zrange by score 指令获取 N 秒之前的数据轮询进行处理。

到这里，面试官暗地里已经对你竖起了大拇指。

### 40、使用过 Redis 分布式锁么，它是什么回事？

先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。

这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行 expire之前进程意外 crash 或者要重启维护了，那会怎么样？
这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己的脑袋，故作思考片刻，
好像接下来的结果是你主动思考出来的，然后回答：我记得 set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和expire 合成一条指令来用的！

对方这时会显露笑容，心里开始默念：摁，这小子还不错。

### 41、Redis 八股文 

参阅地址 <https://github.com/sudotty/reading_note/issues/31>

Redis 八股文 原理篇 1

    Redis 是单线程还是多线程？为什么这么设计？
    Redis 中的字符串对象和 C 语言中的字符串有什么区别？
    Redis 中是如何实现链表的？
    Redis 中是如何实现字典的？
    Redis 中的字典是如何进行动态扩容的？
    Redis 中的跳表是如何实现的？

Redis 八股文 原理篇 2

    STR/LIST/HASH/SET/ZSET 底层都是使用什么数据结构实现的？
    ZSET 什么时候使用 Ziplist 实现，什么时候使用 Skiplist 实现？
    ZSET 为什么不用 BST/AVL/B-Tree/红黑树，而使用跳表？
    Redis 的过期键删除策略是什么？
    Redis 的主从服务器是如何同步过期键的？

Redis 八股文 原理篇 3

    AOF 和 RDB 持久化有什么区别？
    Redis 的主从是如何进行同步的？
    如何解决长时间使用后 AOF 文件过大的问题？
    Redis 的哨兵机制是如何实现的？
    Redis 的集群方案有哪些？

Redis 八股文 原理篇 4

    Redis 的整体架构是什么样的，从客户端发出命令，到客户端接收到结果，这整个流程是什么样的？
    Redis 是如何实现 LRU 机制的？
    Redis 是如何实现 LFU 机制的？

Redis 八股文 应用篇 1

    Redis 有哪些数据结构，分别有什么使用场景？
    Redis ZSET 相同 score 如何排序？
    在爬虫中，如何使用 Redis 做 URL 去重？
    Redis 是否支持事务？
    Redis 中的 WATCH 命令是做什么的？
    Redis 是如何保证高可用的？
    如何使用 Redis 来实现分布式锁？Redlock？

Redis 只推荐看 @huangz1990 的《Redis 设计与实现》这本书，配合 Redis 的源码来看，这本书的源代码基于3.0，基本上就没什么问题了。

另外一本《Redis 5设计与源码分析》基于5.0源码。

### Memcached 与 Redis 实现的对比

参阅 <https://cloud.tencent.com/developer/article/1004377>

### redis同步

redis 是如何进行同步的，同步的方式，同步回滚怎么办，数据异常怎么办，同时会问 MYSQL 的同步方式和相关异常情况。

redis 集群主从同步的简单原理

Redis 的复制功能是基于内存快照的持久化策略基础上的，也就是说无论你的持久化策略选择的是什么，
只要用到了 Redis 的复制功能，就一定会有内存快照发生。

当 Slave 启动并连接到 Master 之后，它将主动发送一个 SYNC 命令 (首先 Master 会启动一个后台进程，
将数据快照保存到文件中 `[rdb 文件]` ，Master 会给 Slave 发送一个Ping 命令来判断 Slave 的存活状态，
当存活时 Master 会将数据文件发送给 Slave 并将所有写命令发送到 Slave )。

Slave 首先会将数据文件保存到本地，之后再将 数据 加载到内存中。

当第一次链接或者是故障后重新连接都会先判断 Slave 的存活状态，再做全部数据的同步， 
之后只会同步 Master 的写操作 (将命令发送给 Slave)

问题：

当 Master 同步数据时，若数据量较大而 Master 本身只会启用一个后台进程来对多个 Slave 进行同步 ， 
这样 Master 就会压力过大，而且 Slave 恢复的时间也会很慢！

redis 主从复制的优点：
* (1)在一个Redis集群中，master负责写请求，slave负责读请求，
这么做一方面通过将读请求分散到其他机器从而大大减少了master服务器的压力，另一方面slave专注于提供读服务从而提高了响应和读取速度。
* (2) 在一个 Redis 集群中，如果 master 宕机，slave 可以介入并取代 master 的位置，
因此对于整个 Redis 服务来说不至于提供不了服务，这样使得整个 Redis 服务足够安全。
* (3) 水平增加 Slave 机器可以提高性能

参阅 <https://blog.csdn.net/hxpjava1/article/details/78347890/> 、<https://www.cnblogs.com/zhao-blog/p/6131524.html>

### redis同步过程

Redis的同步过程，特别是主从复制，是确保数据一致性和高可用性的关键机制。以下是Redis同步过程的详细步骤，结合了参考文章中的信息：

#### 1. 初始化连接阶段

* **配置slaveof属性**：在Redis的配置文件中，需要为从节点（Slave）配置`slaveof`属性，指定主节点（Master）的IP和端口。
* **发送连接请求**：从节点向主节点发送`slaveof`命令（在Redis 4.0+版本中可能是`REPLCONF`命令），请求建立连接。
* **身份验证（可选）**：如果主节点配置了密码，从节点需要发送`auth password`命令进行身份验证。
* **保存连接信息**：从节点保存主节点的IP和端口信息，并基于这些信息建立Socket连接。

#### 2. 数据同步阶段

2.1 全量复制（Full Replication）

* **发送SYNC或PSYNC命令**：Redis 2.8及以前版本，从节点发送`SYNC`命令请求全量同步；Redis 2.8及以后版本，
从节点发送`PSYNC`命令，根据主从节点当前状态的不同，可能是全量复制或增量复制。
* **生成RDB文件**：主节点接收到同步请求后，执行`BGSAVE`命令生成RDB（Redis DataBase）快照文件。
* **发送RDB文件**：主节点将RDB文件发送给从节点。
* **从节点加载RDB文件**：从节点接收到RDB文件后，将其加载到内存中，完成数据的全量同步。

2.2 增量复制（Partial Replication）

* **发送偏移量信息**：从节点在完成RDB数据恢复后，会发送自己的复制偏移量给主节点，请求发送从上次同步之后主节点执行的写命令。
* **主节点发送写命令**：主节点将复制积压缓冲区（Replication Backlog）中从节点请求偏移量之后的写命令发送给从节点。
* **从节点执行写命令**：从节点接收到写命令后，按照接收的顺序执行这些命令，完成数据的增量同步。

#### 3. 同步状态维护

* **心跳检测**：主从节点之间会定期发送心跳消息（通常是PING/PONG命令），以检测连接状态和数据一致性。
* **故障转移（哨兵模式）**：在哨兵模式下，哨兵节点会监控主节点的状态。
如果主节点出现故障，哨兵会选举新的主节点，并将从节点重定向到新的主节点，确保系统的高可用性。

#### 总结

Redis的同步过程是一个复杂但高效的过程，通过主从复制和哨兵模式等机制，确保了数据的一致性和系统的可用性。
在实际应用中，可以根据具体需求和数据量等因素，选择合适的同步方式和参数配置。

### redis主从复制，主库写，从库读，会不会读取时获取不到最新的数据

在Redis的主从复制模型中，确实存在一种可能性，即从库在读取数据时可能无法获取到主库上最新的数据。这种情况主要是由于数据同步的延迟导致的。

以下是可能导致从库读取不到最新数据的一些原因：

1. **复制延迟**：当主库写入新数据时，它首先会将写命令记录在自己的日志（通常是AOF或RDB）中，
然后将这些命令异步地发送给从库。从库在接收到这些命令后，会按照顺序执行它们来更新自己的数据集。
这个过程需要时间，特别是当网络延迟较高、主库写入负载较重或从库数量较多时，复制延迟可能会变得更为明显。
2. **异步复制**：Redis的主从复制是异步的，这意味着主库在写入数据后不会等待从库确认已接收到数据再进行其他操作。
这种机制可以提高系统的吞吐量，但也增加了数据不一致性的风险。
3. **故障恢复**：在从库故障并重新连接到主库时，它可能需要从主库重新同步数据。这个同步过程可能需要一些时间，
具体取决于数据集的大小和网络带宽。在此期间，从库可能无法提供最新的数据。

为了降低从库读取不到最新数据的风险，可以采取以下措施：

1. **监控复制延迟**：通过Redis提供的`INFO replication`命令或其他监控工具来监控主从复制的状态和延迟情况。
当发现延迟较高时，可以考虑增加从库数量、优化网络环境或调整主库的写入负载。
2. **使用读写分离中间件**：如ProxySQL、Codis等，这些中间件可以根据一定的策略（如轮询、随机、一致性哈希等）
将读请求路由到不同的从库上，从而减轻单个从库的负载并提高系统的整体性能。
3. **半同步复制**：虽然Redis本身不直接支持半同步复制，但可以通过一些第三方解决方案
（如Redis Sentinel配合半同步复制插件）来实现。半同步复制可以在一定程度上提高数据的一致性，但也会降低系统的写入性能。
4. **设置合理的从库数量**：根据系统的实际需求和硬件资源来设置合理的从库数量。
过多的从库可能会增加主库的负载和复制延迟，而过少的从库则可能无法满足系统的读需求。
5. **定期检查从库数据**：定期从主库上导出数据集，并与从库上的数据集进行比较，以确保它们之间的一致性。
如果发现不一致的情况，可以采取相应的措施进行修复。

### 如果就是要在从库读取到最新的数据呢

在Redis的主从复制模型中，要确保从库能够读取到主库上的最新数据，可以采取以下几种策略：

1. **使用等待（Wait）命令**：

虽然Redis本身没有提供直接的“等待”命令来确保从库数据是最新的，但你可以在应用层实现这种逻辑。
例如，在写入主库后，你可以等待一段时间（根据预期的复制延迟来决定），然后再从从库读取数据。
但这并不是一个严格的保证，只是一种降低读取旧数据的概率的方法。

2. **监控复制状态**：

你可以通过Redis的`INFO replication`命令来监控主从复制的状态和延迟。如果你的应用能够获取这些信息，
它可以基于这些信息来决定是否从从库读取数据，或者是否需要等待一段时间再读取。

3. **使用Redis的半同步复制**：

虽然Redis的官方版本默认是异步复制的，但有一些第三方解决方案（如Redis Sentinel配合半同步复制插件）可以实现半同步复制。
这意味着在确认主库写操作成功之前，会等待至少一个从库确认已经接收到了写命令。这可以提高数据的一致性，但也会降低写操作的性能。

4. **使用Redis的Pipeline特性**：

虽然这与直接读取最新数据不直接相关，但你可以使用Redis的Pipeline特性来批量发送和接收命令，从而减少网络延迟和开销。
这可以使你的应用更加高效地与Redis进行交互。

5. **优化网络和硬件**：
确保主从库之间的网络连接是稳定和高速的。使用高速的网络设备和低延迟的网络连接可以减少复制延迟。
此外，确保主从库的硬件资源（如CPU、内存、磁盘I/O）是充足的，以避免性能瓶颈。

6. **使用更复杂的解决方案**：

如果你需要更严格的数据一致性保证，并且可以接受一些额外的复杂性和开销，你可以考虑使用更复杂的解决方案，
如Redis Cluster结合一致性哈希算法，或者使用其他支持强一致性的键值存储系统。

7. **设置合理的复制策略**：

根据你的应用需求和数据一致性要求，设置合理的复制策略。例如，你可以增加从库的数量来分担复制负载，
或者调整复制缓冲区的大小和超时设置来优化复制性能。

8. **重试逻辑**：

在你的应用代码中实现重试逻辑。如果在从库上读取到的数据不是最新的，你可以尝试重新从主库读取，
或者等待一段时间后再次尝试从从库读取。这种策略可以在一定程度上提高读取到最新数据的概率。

请注意，没有一种方法可以100%保证从库上读取到的数据总是最新的，因为网络延迟、硬件故障或其他因素都可能导致数据不一致。
因此，在选择解决方案时，你需要根据你的应用需求和数据一致性要求来权衡各种因素。

### redis的AOF和RDB怎么使用

Redis提供了两种主要的持久化方式：AOF（Append Only File）和RDB（Redis DataBase）。以下是关于如何使用这两种持久化方式的详细解释：

#### AOF（Append Only File）

**1. 简介**

AOF通过保存Redis服务器所执行的写命令来记录数据库状态。当Redis重启时，它会读取AOF文件并重新执行其中的写命令来恢复数据。

**2. 配置**

在`redis.conf`配置文件中，与AOF相关的配置项主要包括：

* `appendonly`: 默认值为`no`，表示Redis默认使用RDB方式持久化。如果想要开启AOF持久化，需要将其修改为`yes`。
* `appendfilename`: AOF文件名，默认是`appendonly.aof`。
* `appendfsync`: AOF持久化策略的配置。
	+ `no`：不执行fsync，由操作系统保证数据同步到磁盘，速度最快但不太安全。
	+ `always`：每次写入都执行fsync，以保证数据同步到磁盘，效率很低。
	+ `everysec`：每秒执行一次fsync，可能会导致丢失这1s的数据。通常选择`everysec`以兼顾安全性和效率。
* `no-appendfsync-on-rewrite`: 在AOF重写或写入RDB文件时，执行fsync可能会造成阻塞。设置为`yes`表示在重写期间对新写操作不执行fsync，默认为`no`。

**3. 操作**

* AOF持久化流程：
	1. 客户端的写命令被追加到AOF缓冲区中。
	2. AOF缓冲区根据`appendfsync`配置将数据同步到磁盘的AOF文件中。
	3. 当AOF文件大小超过重写策略或手动触发重写时，会对AOF文件进行重写以压缩其容量。
	4. Redis服务重启时，会重新加载AOF文件中的写操作以恢复数据。

#### RDB（Redis DataBase）

**1. 简介**

RDB通过保存数据库中的键值对来记录数据库状态。在指定的时间间隔内，将内存中的数据集快照写入磁盘。

**2. 配置**

在`redis.conf`配置文件中，与RDB相关的配置项主要包括：

* `save`: 用于配置触发RDB持久化的条件。例如，`save 900 1`表示在900秒内如果有至少1个key被改变，则触发RDB持久化。
* `dbfilename`: RDB文件名，默认为`dump.rdb`。

**3. 操作**

* RDB持久化流程：
	1. Redis通过fork()创建一个子进程。
	2. 子进程将数据写入到一个临时文件中。
	3. 待持久化过程结束后，用临时文件替换旧的RDB文件。
	4. Redis完成RDB持久化。

#### 使用建议

* 官方推荐同时启用AOF和RDB，以确保数据的安全性。
* 如果对数据不敏感，或可以接受一定程度的数据丢失，可以选择单独使用RDB。
* 不建议单独使用AOF，因为可能会出现一些bug。
* 在配置持久化策略时，需要根据实际的应用场景和硬件资源来选择合适的配置选项。

### 同时启用AOF和RDB

要同时启用Redis的AOF（Append Only File）和RDB（Redis DataBase）持久化方式，你需要按照以下步骤进行配置：

**1. 创建或修改Redis配置文件**

首先，你需要找到Redis的配置文件（通常是`redis.conf`）。你可以复制一份原始的配置文件并重命名，
例如`redis-aof-rdb.conf`，以便保留原始配置文件的完整性。

**2. 修改配置文件以启用AOF和RDB**

AOF配置

* 找到`appendonly`配置项，并将其值从`no`更改为`yes`，以启用AOF持久化。
* 设置AOF文件的名称和位置。你可以使用`appendfilename`配置项来指定AOF文件的名称，通常设置为`appendonly.aof`。
同时，使用`dir`配置项来指定AOF文件存储的目录。
* 配置AOF的持久化策略。使用`appendfsync`配置项来设置AOF的持久化策略，可选值有`always`、`everysec`和`no`。
根据你的需求选择合适的策略。

RDB配置

* 找到`save`配置项，它定义了RDB持久化的触发条件。你可以设置多个条件，例如`save 900 1`表示在900秒内如果有1个key被修改，则触发RDB持久化。
* 设置RDB文件的名称和位置。使用`dbfilename`配置项来指定RDB文件的名称，通常设置为`dump.rdb`。
同时，确保`dir`配置项与AOF文件的目录一致，以便所有持久化文件都存储在同一位置。

**3. 重启Redis服务**

在修改完配置文件后，你需要重启Redis服务以使更改生效。根据你的操作系统和Redis安装方式，使用相应的命令来重启Redis服务。

**示例配置（基于参考文章）**

在`redis-aof-rdb.conf`文件中：

```conf
# AOF配置
appendonly yes
appendfilename "appendonly.aof"
appendfsync everysec

# RDB配置
save 900 1
save 300 10
save 60 10000
dbfilename dump.rdb
dir /path/to/your/redis/data
```

**注意事项**

* 确保在修改配置文件时遵循正确的语法和格式。
* 在重启Redis服务之前，最好备份现有的配置文件和数据文件，以防万一出现意外情况。
* 根据你的实际需求和系统性能，选择合适的AOF持久化策略和RDB触发条件。

### redis存在线程安全问题吗

服务端层面本身是一个线程安全的K-V数据库，在服务端的所有操作都在一个线程中完成，因此不存在多个线程相互影响的问题，
而不需要考虑线程安全性问题。同时，Redis还提供了一些安全的API，如事务性的操作，支持所有的持久化操作都具有线程安全性。

客户端层面来说，如果有多个客户端同时对redis操作，就无法保证原子性，但可以通过以下方式避免：
1. 尽司能使用Redis里面的原子指令，如 SETNX、GETSET、INCR、DECR、MSET、MSETNX 等
2. 对多个客户端的资源访问加锁
3. 通过Lua脚本来实现多个指令的操作

总结：Redis服务端是线程安全的，但客户端是非线程安全的，需要做好防护。

### Redis的Lua脚本是什么

Redis的Lua脚本是一种使用Lua语言编写的自定义脚本，可以在Redis数据库中执行。
Redis允许用户通过EVAL命令将Lua脚本发送到Redis服务器执行，从而实现更复杂的逻辑和数据处理。

使用Lua脚本可以带来以下好处：

* 原子性：Lua脚本在Redis中是原子执行的，这意味着在执行过程中不会被其他命令干扰，保证了数据的一致性。
* 减少网络开销：通过将多个命令封装在Lua脚本中，可以减少网络传输的次数，提高处理效率。
* 灵活性：Lua脚本支持使用Redis的所有命令，并且支持条件判断、循环等逻辑，可以实现更复杂的操作。

下面是一个简单的示例，演示了如何使用Lua脚本实现一个自增计数器：

lua
```
-- 获取当前值  
local current = redis.call('GET', KEYS[1])  
  
-- 如果当前值为nil，则初始化为0  
if current == false then  
    current = 0  
end  
  
-- 自增并设置新值  
local new = tonumber(current) + 1  
redis.call('SET', KEYS[1], new)  
  
-- 返回新值  

return new
```

通过EVAL命令将该脚本发送到Redis服务器执行：

redis
```
EVAL "local current = redis.call('GET', KEYS[1]) if current == false then current = 0 end local new = tonumber(current) + 1 redis.call('SET', KEYS[1], new) return new" 1 mycounter
```

上述示例中，Lua脚本通过redis.call函数调用了Redis的GET和SET命令，实现了自增计数器的功能。
通过EVAL命令将脚本发送到Redis服务器执行，并传递了一个键名作为参数。

需要注意的是，使用Lua脚本需要谨慎处理数据类型转换和错误处理，以确保脚本的正确性和稳定性。

### Redis加锁和释放锁怎么实现

在Redis中，可以使用SETNX命令实现加锁，使用DEL命令实现释放锁。

SETNX：SETNX是 "Set if Not Exists"（如果不存在则设置）的缩写，用于设置键-值对，仅在键不存在时才设置该键。 
操作后返回影响的条数（保存成功返回1，否则返回0）。

DEL：用于删除已存在的键。不存在的 key 会被忽略。操作后返回影响的条数（1或0）。

EXISTS：用于检查给定 key 是否存在。若 key 存在返回 1 ，否则返回 0 。 

具体实现步骤如下：

加锁：使用SETNX命令尝试在Redis中设置一个唯一的key和value，表示该锁已经被占用。如果设置成功，表示获取到了锁；
如果设置失败，表示锁已经被其他客户端占用。
```
SETNX lock_key lock_value
```

释放锁：使用DEL命令删除Redis中的锁key，表示释放锁。
```
DEL lock_key
```

需要注意的是，为了避免在多个客户端之间出现竞态条件，需要在获取锁和释放锁的过程中添加一些逻辑控制。
例如，可以在获取锁时添加一个过期时间，避免因为某个客户端异常而无法释放锁。
同时，也可以在释放锁时添加一个判断条件，避免重复释放同一个锁。

设置过期时间：使用SET命令的EX参数为键设置过期时间，表示锁的有效期
```
SET lock_key lock_value EX lock_timeout
```

释放锁之前，需要添加一个判断条件，判断该锁是否还存在。可以使用EXISTS命令判断该键是否存在，
如果存在则执行删除操作，否则不执行任何操作：
```
IF EXISTS lock_key THEN  
    DEL lock_key  
END
```

### Redis 如何应对并发访问

Redis如果在业务中运用那么肯定需要考虑并发问题，如多个用户对同一个商品进行扣减，这时并发执行很可能导致商品数量不对，
那么Redis如何来避免这些问题呢？一般分为两种解决方案分布式锁以及原子性操作。

对于分布式锁显然是可以解决上述问题的，但这不是最优因为分布式锁降低了系统的效率，
还需要额外加锁解锁的操作，这里暂不讨论加锁这种方案。

那么对于原子性操作Redis如何实现呢？我们可以先思考并发访问中是对什么进行加锁呢？

以商品库存扣减为例，一般分为三个步骤
1. 读取商品库存数量
2. 将商品库存数量减一
3. 将扣减后的数量写回Redis中

这个流程简称为RMW也就是读取-修改-写回，当进行这三个中的任何一步时我们都需要保证互斥，
不允许其它用户读取到商品库存的中间状态，这样才能避免并发导致的库存不正确性。

**Redis事务处理**

那Redis如何保证RMW的互斥性呢？大多数人这里的第一想法应该是事务，事务去保证要不都成功要不都失败，Redis中的事务怎么玩呢？

redis中提供下面四种命令来保证事务执行
* MULTI：开启一个事务，执行后客户端可以向服务器发送任意多条命令，这些命令并不会立即执行，
而是放到一个队列中，当执行EXEC命令才开始执行，当客户端处于事务状态，执行所有的命令会返回QUEUED。
* EXEC ：执行事务。
* DISCARD ：清空事务队列，并放弃事务。
* WATCH：类似于乐观锁，当监控的值在WATCH执行后，EXEC命令执行前，修改了该值，那么redis执行当前事务将失败。

简单演示事务操作：
```
-- 开启事务
127.0.0.1:6379> MULTI
OK
-- 会将命令加入到事务队列中，后续exec统一执行
127.0.0.1:6379(TX)> set name zhangsan
QUEUED
127.0.0.1:6379(TX)> get name
QUEUED
127.0.0.1:6379(TX)> set age 12
QUEUED
127.0.0.1:6379(TX)> DECR age
QUEUED
-- 执行事务
127.0.0.1:6379(TX)> EXEC
1) OK
2) "zhangsan"
3) OK
4) (integer) 11
```

Redis命令不会立即执行，而是先进入一个先进先出的事务队列，直到事务被提交。QUEUED 表示这个命令已经入了事务队列。
当执行 exec 命令时，Redis 根据客户端所保存的事务队列， 以先进先出的方式执行事务队列中的命令：
最先入队的命令最先执行， 而最后入队的命令最后执行。执行 exec 命令后，
Redis 将结果存储在回复队列中并将该队列发送给客户端。客户端从事务状态退出，一个事务执行完毕。

丢弃事务：
```
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379(TX)> set name zhangsan
QUEUED
-- 丢弃事务
127.0.0.1:6379(TX)> DISCARD
OK
-- get事务中添加的值，为空
127.0.0.1:6379> get name
(nil)
```

discard 取消一个事务的命令，表示这个事务被取消，回到非事务状态。

WATCH乐观锁：
```
-- 客户端1，中添加age值为12
127.0.0.1:6379> set age 12
OK 
-- 开启监控
127.0.0.1:6379> WATCH age
OK
127.0.0.1:6379> MULTI
127.0.0.1:6379(TX)> set name zhagnsan
QUEUED
-- 事务执行失败
127.0.0.1:6379(TX)> EXEC
(nil)
127.0.0.1:6379> keys *
1) "age"
127.0.0.1:6379> get age
"11"
```

```
-- 同时开启客户端2，将监控的age值改为11
127.0.0.1:6379(TX)> DECR age
```

在客户端1进入事务时，监控了age键，但该事务尚未提交。客户端2设置 age 的 值减1。客户端1提交事务后返回的结果为 nil，
但调用 get 命令可以得到 age 的值为 11。这意味着当 age 键被其他客户端改变后，事务将被取消，不会执行，并返回失败。

watch 命令在事务开始之前监视任意数量的键：当调用 exce 命令执行事务时，
如果任意一个被监视的键已经被其他客户端修改了，那么整个事务不再执行，直接返回失败。

事务能保证原子性吗？这是不确定的，一般我们熟知的事务遇到错误就会回滚，但Redis是分情况来讨论。

**事务中的错误**

Redis事务中的错误分为两种
* 事务在执行EXEC命令之前，入队命令出错，比如命令产生语法错误（参数错误、参数名错误等等），
或者一些更加严重的错误如内存不足（Redis设置maxmemory最大内存限制的前提）。
* 命令在EXEC调用失败后，举个例子，事务命令可能处理了错误类型的键，列表命令用在字符串键上。

模拟EXEC命令执行之前出现错误：
```
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379(TX)> set name zhangsan
QUEUED
127.0.0.1:6379(TX)> seta age 1
(error) ERR unknown command `seta`, with args beginning with: `age`, `1`, 
-- EXEC执行前出现异常，放弃事务
127.0.0.1:6379(TX)> EXEC
(error) EXECABORT Transaction discarded because of previous errors.
127.0.0.1:6379> get name
(nil)
```

事务中命令异常属于语法错误，将导致事务无法执行。

模拟EXEC命令执行之后出现错误：
```
-- 开启事务前先设置一个String类型的键值
127.0.0.1:6379> set name zhangsan
OK
127.0.0.1:6379> MULTI
OK
-- 采用hash方式获取string类型的键值，语法没错
127.0.0.1:6379(TX)> hget name 1
QUEUED
127.0.0.1:6379(TX)> set sex 2
QUEUED
127.0.0.1:6379(TX)> EXEC
-- 执行报错
1) (error) WRONGTYPE Operation against a key holding the wrong kind of value
2) OK
-- 事务没有放弃，执行部分事务
127.0.0.1:6379> get sex
"2"
```

所以，在EXEC执行之前的错误，Redis会将事务回滚，但是EXEC执行后产生的错误，Redis不会丢弃事务。
因为Redis认为在EXEC执行后发生错误一般是语法错误，这个失败是编程造成的，这些错误在开发时就应该被发现，
而不是应该出现在生产环境，而且不需要对回滚进行支持，所以Redis能保持简单而且快速。

综上严格意义上来讲Redis的事务不支持原子性。

原子意味着要么一起成功执行，要么一起失败回滚。Redis 提供的所有 API 都是原子操作。
那么 Redis 事务只要保证在一批操作中保证原子性，但是在运行时异常中，在一个事务中一个命令出现异常，
其他命令还是会继续执行，事务没有回滚机制，所以 Redis 事务是不保证原子性的。

既然Redis事务不能支持原子性，那么还能如何保证并发一致性呢？这里还有两种方案。

**Redis两种原子操作方法**

1、单命令操作

简单来讲就是将多个操作集成到一个命令上，因为Redis单命令操作是会阻塞主线程的，也就是说是互斥的，
在命令执行过程中其它命令不会执行，这种命令形如INCR、DECR，例如库存扣减有三个步骤简称RMW，可以通过单命令DECR一次执行。

2、Lua脚本

Redis从2.6.0版本开始支持Lua脚本，Lua脚本的多样性一般是实现原子操作的最佳选择，Redis会把整个Lua脚本作为一个整体执行，
在执行过程中不会被其他命令所打断，从而保证Lua脚本的原子性，如果我们存在多个操作要执行，
又无法使用单命令操作实现，那么就可以试试Lua脚本。

Lua脚本简单演示：
```
-- 形如命令 set name zhangsan
127.0.0.1:6379> EVAL "return redis.call('set',KEYS[1],ARGV[1])" 1 name zhangsan
OK
127.0.0.1:6379> get name
"zhangsan"
-- 形如命令 get name
127.0.0.1:6379> EVAL "return redis.call('get',KEYS[1])" 1 name
"zhangsan"
-- 清空预加载lua脚本
127.0.0.1:6379> SCRIPT FLUSH
OK
-- 加载脚本，可以自动生成一个字符串，不需要每次传输脚本，提升传输速度
127.0.0.1:6379> SCRIPT LOAD "return redis.call('set',KEYS[1],ARGV[1])"
"c686f316aaf1eb01d5a4de1b0b63cd233010e63d"
-- 执行预加载脚本
127.0.0.1:6379> EVALSHA "c686f316aaf1eb01d5a4de1b0b63cd233010e63d" 1 age 1
OK
127.0.0.1:6379> get age
"1"
-- 判断预加载脚本是否存在
127.0.0.1:6379> SCRIPT EXISTS "c686f316aaf1eb01d5a4de1b0b63cd233010e63d"
1) (integer) 1
```

### 商品抢购中如何避免超卖

一般碰到类似双十一等的节日时会进行抢购类活动，开发中如何避免超卖呢？

**方式一，事务**

可以使用 事务，watch 用来监听商品总量 total，在事务中对 total 数进行判断，
如果 total < 0 了就 DISCARD，否则 total 进行 -1，然后 EXEC 执行事务，
如果 其他客户端修改了 total，该次事务就会执行失败。

```
-- 开启监控 ，假设现在剩余量有 100
> WATCH total
OK
> 
> MULTI
OK
> 
-- 丢弃事务
> if (total < 0) { DISCARD }
OK
> 
-- 逻辑操作
> ...
> 
-- 自减一
> DECR total
QUEUED
> 
-- 执行事务
> EXEC
1) (integer) 99
```

**方式二，上锁**

```
if (redis.setnx('do_sale', 'ok') == 1) {
    // 如果保存成功，说明不存在这个键
    
    /* 售卖逻辑 */ 
    ...
    
    // 删除该键
    redis.del('do_sale')
}
```

### Redis 事务的 ACID

**原子性**

原子意味着要么一起成功执行，要么一起失败回滚。Redis 提供的所有 API 都是原子操作。
那么 Redis 事务只要保证在一批操作中保证原子性，但是在运行时异常中，在一个事务中一个命令出现异常，
其他命令还是会继续执行，事务没有回滚机制，所以 Redis 事务是不保证原子性的。

**一致性**

事务异常：如果命令错误，事务无法执行，如果是运行时异常，Redis 会将错误包含在返回结果中，
并不影响后续执行，所以事务是一致性的。

Redis 进程被终结：在纯内存模式下，Redis 没有做持久化，重启之后数据库是空白的，所以是事务一致性的。

在 RDB 模式下，事务并不会在中途执行保存 RDB 文件的工作，只有在事务执行完后，RDB 工作才可能会开始。
所以在事务执行过程中 Redis 进程被杀死，不管成功多少都不会保存到 RDB 文件中，所以是一致性的。

在 AOF 模式下，事务部分语句被写入 AOF 文件并保存成功，不完整的事务被保存到了 AOF 文件，
当重启 Redis 时，检查 AOF 文件不完整，Redis 退出并报错。需要把这段不完整的事务删除后才能重启成功，所以是一致性的。

在 AOF 模式下，事务并未被写入 AOF 文件，所以重启后 Redis 数据库是最近一次成功保存到 AOF 文件中的数据。
并没有这次事务的数据，所以是以一致性的。

**隔离性**

Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。
所以事务是带有隔离性的。

**持久**

在纯内存模式下，事务肯定不是持续性的。

在 RDB 模式下，服务器可能在事务执行之后、RDB 文件更新之前的这段时间失败，所以 RDB 模式下的事务也是不持久的。

在 AOF 模式下，将命令添加到 AOF 文件中，但是对文件进行写入并不会马上写到磁盘上，而是先存储到缓冲区。
所以数据保存到磁盘上有一段非常小的时间间隔。这种模式下事务也不是持久的。

### Redis 事务可以保证原子性吗

Redis 的事务（transactions）在概念上与其他数据库系统的事务类似，但它们有一些重要的区别，特别是当涉及到原子性时。

Redis 的事务是通过 `MULTI`、`EXEC`、`DISCARD` 和一系列 Redis 命令的组合来实现的。
当一个事务开始时（通过 `MULTI` 命令），后续的 Redis 命令会被入队，但不会立即执行。
当 `EXEC` 命令被调用时，队列中的所有命令会按照它们被添加的顺序依次执行。
如果在事务执行期间出现错误，Redis 不会回滚事务中的任何命令，而是继续执行后续命令。

关于 Redis 事务的原子性，这里有几个关键点需要注意：

1. **部分原子性**：Redis 事务在单个 Redis 命令的执行上是原子的，但整个事务中的所有命令并不是作为一个单独的原子操作来执行的。
如果事务中的某个命令失败（例如，由于语法错误或数据类型错误），其他命令仍然会被执行。Redis 不会中断事务来回滚已执行的命令。
2. **错误处理**：如果在事务中某个命令失败（不是语法错误或数据类型错误，
而是例如由于 `SETNX` 或 `INCR` 等命令的特定条件未满足），该命令将返回错误，但事务的其他命令仍会继续执行。
3. **网络问题**：如果客户端在 `MULTI` 和 `EXEC` 之间与 Redis 服务器的连接断开，事务中的所有命令都不会被执行。
但是，如果连接在 `EXEC` 之后断开，那么事务中的所有命令都已经被执行了。
4. **Lua 脚本**：Lua 脚本在 Redis 中提供了更高级别的原子性保证。使用 `EVAL` 或 `EVALSHA` 命令执行的 Lua 脚本是原子执行的，
即如果脚本中的任何命令失败，整个脚本都会失败，并且不会有任何命令的效果被持久化。

因此，虽然 Redis 的事务在某些方面提供了类似于其他数据库系统的功能，但它们并不完全等同于传统意义上的事务。
特别是，Redis 事务不提供 ACID（原子性、一致性、隔离性和持久性）属性中的“隔离性”和“持久性”保证。
如果你需要这些更高级别的保证，可能需要考虑使用其他数据库系统或使用 Redis 的 Lua 脚本功能。

### Redis 事务可以保证一致性吗

Redis 事务在一致性（Consistency）方面有其特定的行为。一致性在数据库系统中通常指的是事务将数据库从一个一致的状态转换到另一个一致的状态。
在 Redis 的上下文中，我们需要考虑以下几点来讨论其一致性保证：

1. **单个命令的原子性**：Redis 中的每个命令（如 `SET`, `GET`, `INCR` 等）都是原子执行的，
这意味着这些命令要么完全执行，要么完全不执行，从外部看不会看到中间状态。

2. **事务的一致性**：Redis 的事务通过 `MULTI`、`EXEC` 等命令提供了一组命令的批量执行机制。
虽然 Redis 不支持传统意义上的回滚（即撤销已执行的命令），但由于每个命令的原子性，事务中的命令要么全部成功执行，
要么全部不执行（在 `EXEC` 命令之前客户端断开连接的情况）。因此，从这个角度来看，Redis 的事务可以保证一致性，
因为它不会在事务中留下部分执行的状态。

3. **隔离性**：Redis 的事务不支持传统意义上的隔离性。在事务执行期间，其他客户端仍然可以修改数据库。
但是，由于 Redis 的单线程模型，事务内的命令是按照它们被添加到事务队列中的顺序来串行执行的，因此不会存在事务内的命令交叉执行的情况。

4. **持久性**：Redis 的持久性是通过持久化策略（如 RDB 快照或 AOF 日志）来实现的，而不是由事务本身来保证的。
即使事务中的所有命令都成功执行，如果 Redis 没有被配置为持久化，那么一旦 Redis 服务器重启，事务所做的更改将会丢失。

5. **Lua 脚本的原子性**：使用 Lua 脚本（通过 `EVAL` 或 `EVALSHA` 命令）可以在 Redis 中实现更复杂的原子操作。
这些脚本在 Redis 中是原子执行的，即脚本中的命令要么全部成功执行，要么全部不执行。

综上所述，Redis 的事务在一定程度上可以保证一致性，因为事务中的命令是按照它们被添加到事务队列中的顺序来串行执行的，
并且每个命令都是原子执行的。但是，由于 Redis 的事务不支持传统意义上的回滚和隔离性，因此在设计应用时需要考虑到这些因素。
此外，持久性是由 Redis 的持久化策略来保证的，而不是由事务本身来保证的。

### Redis 事务可以保证隔离性吗

Redis 的事务并不提供传统数据库管理系统（RDBMS）中那种强隔离性（Isolation）的保证。
在 Redis 中，事务的隔离性是非常有限的，主要原因在于 Redis 的单线程模型以及它的事务执行机制。

首先，Redis 是单线程的，这意味着它一次只能处理一个命令。但是，这并不意味着 Redis 的事务提供了隔离性。
在 Redis 的事务执行过程中，其他客户端仍然可以向 Redis 发送命令，并且这些命令可能会在事务执行的过程中被处理。
Redis 不会为事务提供锁或其他机制来阻止其他客户端的访问或修改。

其次，Redis 的事务在 `EXEC` 命令之前只是将命令入队，而不会实际执行这些命令。
但是，这并不意味着这些命令在 `EXEC` 之前是不可见的或不可访问的。在 `EXEC` 命令执行之前，
如果有其他客户端修改了与事务相关的数据，那么事务中的命令可能会看到这些修改后的数据。

此外，Redis 的事务不支持回滚（Rollback）。如果事务中的某个命令失败了（例如，由于语法错误或数据类型错误），
Redis 不会中断事务或回滚已执行的命令。它会继续执行事务中的后续命令，即使这些命令可能会依赖于之前失败的命令的结果。

因此，Redis 的事务并不提供传统意义上的隔离性保证。在需要强隔离性的场景中，可能需要考虑使用其他机制
（如 Redis 的 Lua 脚本、分布式锁等）来实现所需的数据一致性和隔离性。但是，请注意，这些机制可能会增加系统的复杂性和性能开销。

### Redis 事务可以保证持久性吗

Redis 事务本身并不直接保证持久性（Persistence）。持久性是指即使系统崩溃或重启，数据也能够得以保存和恢复的能力。
在 Redis 中，事务的持久性取决于 Redis 使用的持久化策略。

Redis 提供了两种主要的持久化方式：

1. **RDB（Redis DataBase）持久化**：RDB 持久化通过创建 Redis 数据的一个快照（snapshot）来保存数据。
当满足某个配置的条件时（如指定的时间间隔、指定的写操作次数等），Redis 会将数据写入磁盘上的一个 RDB 文件中。
但是，这种持久化方式是在事务执行之后进行的，所以它不能保证事务的即时持久化。
如果 Redis 在事务提交之后但在下一次 RDB 快照创建之前崩溃，那么事务所做的更改可能会丢失。

2. **AOF（Append Only File）持久化**：AOF 持久化通过记录服务器接收到的每一个写命令（包括事务中的命令），
并在接收到写命令时立即将这些命令追加到 AOF 文件中来保存数据。这样，即使 Redis 崩溃，
也可以通过重新执行 AOF 文件中的命令来恢复数据。但是，AOF 持久化并不保证事务的即时持久化，
因为命令的追加操作是异步进行的，并且可能需要等待一段时间才能将命令写入磁盘。此外，AOF 文件可能会变得非常大，
因为它记录了所有的写命令，包括那些已经被覆盖或删除的数据。为了解决这个问题，Redis 提供了 AOF 重写（rewrite）机制，
它可以在不中断服务的情况下创建一个新的、包含更少命令的 AOF 文件。

因此，Redis 事务的持久性取决于 Redis 的持久化策略以及这些策略的配置。如果你需要确保事务的即时持久化，
可以考虑使用 AOF 持久化并将 `appendfsync` 配置选项设置为 `always`，但这可能会降低 Redis 的性能。
另外，你还可以考虑在应用程序中实现额外的机制来确保数据的持久性，例如使用分布式锁或定期将数据备份到外部存储系统中。






<br/><br/><br/><br/><br/>
## 参考资料

面试还搞不懂redis，快看看这40道面试题 <https://blog.csdn.net/Design407/article/details/103242874>

面试 Redis 没底？这 40 道面试题让你不再慌 <https://mp.weixin.qq.com/s/guK3En5D1s0QpxGAQxHFbQ>

Redis 面试视频解说  <https://www.bilibili.com/video/BV1oG4y1o7cg>
