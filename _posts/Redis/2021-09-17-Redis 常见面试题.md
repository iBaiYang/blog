---
layout: post
categories: Redis
title: Redis 常见面试题
meta: Redis 常见面试题
---
* content
{:toc}

## 正文

1、什么是 Redis?.

2、Redis 的数据类型？

3、使用 Redis 有哪些好处？

4、Redis 相比 Memcached 有哪些优势？

5、Memcache 与 Redis 的区别都有哪些？

6、Redis 是单进程单线程的？

7、一个字符串类型的值能存储最大容量是多少？

8、Redis 的持久化机制是什么？各自的优缺点？

9、Redis 常见性能问题和解决方案：

10、redis 过期键的删除策略？

11、Redis 的回收策略（淘汰策略）?

12、为什么 Redis 需要把所有数据放到内存中？

13、Redis 的同步机制了解么？

14、Pipeline 有什么好处，为什么要用 pipeline？

15、是否使用过 Redis 集群，集群的原理是什么？

16、Redis 集群方案什么情况下会导致整个集群不可用？

17、Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？

18、Jedis 与 Redisson 对比有什么优缺点？

19、Redis 如何设置密码及验证密码？

20、说说 Redis 哈希槽的概念？

21、Redis 集群的主从复制模型是怎样的？

22、Redis 集群会有写操作丢失吗？为什么？

23、Redis 集群之间是如何复制的？

24、Redis 集群最大节点个数是多少？

25、Redis 集群如何选择数据库？

26、怎么测试 Redis 的连通性？

27、怎么理解 Redis 事务？

28、Redis 事务相关的命令有哪几个？

29、Redis key 的过期时间和永久有效分别怎么设置？

30、Redis 如何做内存优化？

31、Redis 回收进程如何工作的？

32、都有哪些办法可以降低 Redis 的内存使用情况呢？

33、Redis 的内存用完了会发生什么？

34、一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set他们最多能存放多少元素？

35、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证redis 中的数据都是热点数据？

36、Redis 最适合的场景？

37、假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？

38、如果有大量的 key 需要设置同一时间过期，一般需要注意什么？

39、使用过 Redis 做异步队列么，你是怎么用的？

40、使用过 Redis 分布式锁么，它是什么回事？

![]({{site.baseurl}}/images/20211013/20211013171543.jpg)

### 1、什么是 Redis？

Redis是一个基于内存实现的key-value数据结构的的NoSQL开源数据库。

Redis 是完全开源免费的，遵守 BSD 协议，是一个高性能的 key-value 数据库。可以用作分布式缓存中间件。

Redis 与其他 key - value 缓存产品相比有以下三个特点：
* Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
* Redis 不仅仅支持简单的 key-value 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。
* Redis 支持数据的备份，即 master-slave 模式的数据备份。

Redis 优势：
* 性能极高：Redis 能读的速度是 110000 次/s，写的速度是 81000 次/s。
* 丰富的数据类型：Redis 支持二进制案例的 Strings，Lists，Hashes，Sets 及 Ordered Sets 数据类型操作。
* 原子：Redis 的所有操作都是原子性的，意思就是要么成功执行、要么失败完全不执行。单个操作是原子性的。
多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。
* 丰富的特性：Redis 还支持 publish/subscribe，通知，key 过期等等特性。

Redis 与其他 key-value 存储有什么不同？

Redis 有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。
Redis 的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。

Redis 运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。
在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，
这样 Redis 可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。

### 2、Redis 的数据类型？

Redis 支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及 zset（sorted set有序集合）。

我们实际项目中比较常用的是 string，hash。 如果你是 Redis 中高级用户，还需要加上下面几种数据结构 HyperLogLog、Geo、Pub/Sub。

如果你说还玩过 Redis Module，像 BloomFilter，RedisSearch，Redis-ML，面试官的眼睛就开始发亮了。

### 3、使用 Redis 有哪些好处？

速度快，因为数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)

支持丰富数据类型，支持 string，list，set，Zset，hash 等

支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行

丰富的特性，可用于缓存，消息，按 key 设置过期时间，过期后将会自动删除

### 4、Redis 相比 Memcached 有哪些优势？

Memcached 所有的值均是简单的字符串，Redis 作为其替代者，支持更为丰富的数据类

Redis 的速度比 Memcached 快很多

Redis 可以持久化其数据

### 5、Memcache 与 Redis 的区别都有哪些？

存储方式 Memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis 有部分存在硬盘上，这样能保证数据的持久性。

数据支持类型 Memcache 对数据类型支持相对简单。Redis 有复杂的数据类型。

使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis 直接自己构建了 VM 机制 ，
因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

### 6、Redis 是单进程单线程的？

Redis 是单进程单线程的，Redis 利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。

### 7、一个字符串类型的智能存储最大容量是多少？

512M。

### 8、Redis 的持久化机制是什么？各自的优缺点？

Redis提供两种持久化机制 RDB 和 AOF 机制：

RDB（Redis DataBase）持久化方式：是指用数据集快照的方式半持久化模式记录 Redis 数据库的所有键值对，
在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。

优点：
* 只有一个文件 dump.rdb，方便持久化。
* 容灾性好，一个文件可以保存到安全的磁盘。
* 性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。
使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis的高性能。
* 相对于数据集大时，比 AOF 的启动效率更高。

缺点：
* 数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候

AOF（Append-only file）持久化方式：是指所有的命令行记录以 Redis 命令请求协议的格式完全持久化存储保存为 aof 文件。

优点：
* 数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次命令操作就记录到 aof 文件中一次。
* 通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。
* AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）

缺点：
* AOF 文件比 RDB 文件大，且恢复速度慢。
* 数据集大的时候，比 RDB 启动效率低。

### 9、Redis 常见性能问题和解决方案

Master 最好不要写内存快照，如果 Master 写内存快照，save 命令调度 rdbSave函数，会阻塞主线程的工作，
当快照比较大时对性能影响是非常大的，会间断性暂停服务。

如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一。

为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网。

尽量避免在压力很大的主库上增加从。

主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1<- Slave2 <- Slave3……这样的结构方便解决单点故障问题，
实现 Slave 对 Master 的替换。如果 Master 挂了，可以立刻启用 Slave1 做 Master，其他不变。

### 10、Redis 过期键的删除策略？

定时删除：在设置键的过期时间的同时，创建一个定时器 timer。让定时器在键的过期时间来临时，立即执行对键的删除操作。

惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。

定期删除：每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。

### 11、Redis 的回收策略（淘汰策略）？

在Redis的内存达到最大设置值时就会进行淘汰策略。

volatile-lru：(Least Recently Used) 从已设置过期时间的数据集（server.db[i].expires）中挑选**最近**-**最少**使用的数据淘汰

volatile-ttl：(time to live) 从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰

volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰

allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰

allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰

no-enviction（驱逐）：禁止驱逐数据

注意这里的 6 种机制，volatile 和 allkeys 规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，
后面的 lru、ttl 以及 random 是三种不同的淘汰策略，再加上一种 no-enviction 永不回收的策略。

使用策略规则：
* 如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 allkeys-lru
* 如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用 allkeys-random

总结起来有以下：
1. Random算法
2. TTL算法
3. LRU算法
4. LFU算法

LFU算法 与 LRU算法 相似，在LRU算法基础上做了优化，使用了两个双向链表，形成一个二维双向链表，
一个是访问频率，另一个是访问频率相同的元素。

### 12、为什么 Redis 需要把所有数据放到内存中？

Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以 Redis 具有快速和数据持久化的特征。
如果不将数据放在内存中，磁盘 I/O 速度为严重影响 Redis 的性能。在内存越来越便宜的今天，Redis 将会越来越受欢迎。
如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。

### 13、Redis 的同步机制了解么？

Redis 可以使用主从同步，从从同步。第一次同步时，主节点做一次 bgsave，并同时将后续修改操作记录到内存 buffer，
待完成后将 rdb 文件全量同步到复制节点，复制节点接收完成后将 rdb 镜像加载到内存。
加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。

### 14、Pipeline 有什么好处，为什么要用 Pipeline？

可以将多次 IO 往返的时间缩减为一次，前提是 Pipeline 执行的指令之间没有因果相关性。
使用 redis-benchmark 进行压测的时候可以发现影响 Redis 的 QPS 峰值的一个重要因素是 Pipeline 批次指令的数目。

### 15、是否使用过 Redis 集群，集群的原理是什么？

Redis 主从复制，一主多从，有一个Master节点和多个Slave节点，Master节点负责数据的读写，Slave节点负责数据的读取。
Master 数据变更会同步到 Slave节点上实现数据的同步。通过该架构实现读写分离，提升数据的查询效率。
但不提供容错和数据恢复的功能。Master结构挂了后，不会选取出新Master，导致所有的写请求失败。

Redis Sentinal 哨兵模式，是主从复制的升级，着眼于高可用，哨兵会监控Master节点的状态，
在 Master 宕机时会自动选取出一个 Slave 作为Master，继续提供服务。但没有解决在线扩容的问题。

Redis Cluster 模式，多主多从，着眼于扩展性，在单个 Redis 内存不足时，使用 Cluster 进行分片存储。
引入了Slot槽，来实现数据分片。Solt的整体取值范围是 0-16383，2的12次方，每个节点分配一个Solt区间。
数据存储时，Redis会根据key计算得到一个slot的值，然后找到对应的节点进行数据的读写。
在高可用方面引入了主从复制，一个Master节点对应一个或多个Slave节点。
在 Master 宕机时会自动选取出一个 Slave 作为Master，继续提供服务。
Redis Cluster 虽然解决了在线扩容以及故障转移的能力，但也有缺点：
1. 客户端的实现会更加复杂
2. Slave节点只是一个冷备节点不提供分担读操作的压办
3. 对于Redis里面的批量操作指令会有限制

### 16、Redis 集群方案什么情况下会导致整个集群不可用？

有 A，B，C 三个节点的集群，在没有复制模型的情况下，如果节点 B 失败了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。

### 17、Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？

Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。

### 18、Jedis 与 Redisson 对比有什么优缺点？

Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持；
Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，
功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性。

Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。

### 19、Redis 如何设置密码及验证密码？

设置密码：config set requirepass 123456

授权密码：auth 123456

### 20、说说 Redis 哈希槽的概念？

Redis 集群没有使用一致性 hash，而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽（2的14次方），
每个 key 通过 CRC16 校验后对 16384 取模（`CRC16（key）&16383`）来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。

### 21、Redis 集群的主从复制模型是怎样的？

为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有 N-1 个复制品。

### 22、Redis 集群会有写操作丢失吗？为什么？

Redis 并不能保证数据的强一致性，这意味着在实际中集群在特定的条件下可能会丢失写操作。

### 23、Redis 集群之间是如何复制的？

异步复制。

### 24、Redis 集群最大节点个数是多少？

16384 个。  （2的14次方）

### 25、Redis 集群如何选择数据库？

Redis 集群目前无法做数据库选择，默认在 0 数据库。

### 26、怎么测试 Redis 的连通性？

使用 ping 命令。

### 27、怎么理解 Redis 事务？

事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。

事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。

### 28、Redis 事务相关的命令有哪几个？

Redis 通过 multi，exec，discard，watch 实现事务功能。

    multi：开始事务
    exec：提交事务并执行
    discard：取消事务
    watch：事务开始之前监视任意数量的键
    
参阅 <https://www.cnblogs.com/tandabao/p/17061739.html> 、 <https://www.php.cn/faq/549211.html>

### 29、Redis key 的过期时间和永久有效分别怎么设置？

EXPIRE 和 PERSIST 命令。

### 30、Redis 如何做内存优化？

尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，
所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的 Web 系统中有一个用户对象，
不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key，而是应该把这个用户的所有信息存储到一张散列表里面。

### 31、Redis 回收进程如何工作的？

一个客户端运行了新的命令，添加了新的数据。Redis 检查内存使用情况，如果大于 max memory 的限制，则根据设定好的策略进行回收。
一个新的命令被执行，等等。所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。
如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。

### 32、都有哪些办法可以降低 Redis 的内存使用情况呢？

如果你使用的是 32 位的 Redis 实例，可以好好利用 Hash，list，sorted set，set等集合类型数据，
因为通常情况下很多小的 Key-Value 可以用更紧凑的方式存放到一起。

### 33、Redis 的内存用完了会发生什么？

如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可以正常返回。）
或者你可以将 Redis 当缓存来使用配置淘汰机制，当 Redis 达到内存上限时会冲刷掉旧的内容。

### 34、一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？

理论上 Redis 可以处理多达 2^32 的 keys，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。
我们正在测试一些较大的值。任何 list、set、和 sorted set 都可以放 2^32 个元素。换句话说，Redis 的存储极限是系统中的可用内存值。

### 35、MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据？

Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。

相关知识：Redis 提供 6 种数据淘汰策略：

volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰

volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰

volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰

allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰

allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰

no-enviction（驱逐）：禁止驱逐数据

### 36、Redis 最适合的场景？

**会话缓存（Session Cache）**，最常用的一种使用 Redis 的情景是会话缓存（session cache）。
用 Redis 缓存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。
当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？
幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。
甚至广为人知的商业平台Magento 也提供 Redis 的插件。

**全页缓存（FPC）**，除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。
回到一致性问题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，
这是一个极大改进，类似 PHP 本地 FPC。再次以 Magento 为例，Magento提供一个插件来使用 Redis 作为全页缓存后端。
此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。

**队列**，Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis能作为一个很好的消息队列平台来使用。
Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push/pop 操作。
如果你快速地在 Google中搜索“Redis queues”，你马上就能找到大量的开源项目，
这些项目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。
例如，Celery 有一个后台就是使用 Redis 作为 broker，你可以从这里去查看。

**排行榜/计数器**，Redis 在内存中对数字进行递增或递减的操作实现的非常好。
集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。
所以，我们要从排序集合中获取到排名最靠前的 10 个用户——我们称之为“user_scores”，我们只需要像下面一样执行即可：
当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，
你需要这样执行：`ZRANGE user_scores 0 10 WITHSCORES Agora Games` 就是一个很好的例子，
用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可以在这里看到。

**发布/订阅**，最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。
我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用 Redis 的发布/订阅功能来建立聊天系统！
命令有：
* pub11sh：发布消息 。语法：publish channel名称 "消息的内容"
* subscribe：订阅消息。 语法：subscribe channel名称
* psubscribe：使用通配符来订阅消息。 语法：psubscribe channe1*名称

### 37、假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？

使用 keys 指令可以扫出指定模式的 key 列表。

对方接着追问：如果这个 Redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问题？

这个时候你要回答 Redis 关键的一个特性：Redis 的单线程的。keys 指令会导致线程阻塞一段时间，线上服务会停顿，
直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指令，scan 指令可以无阻塞地提取出指定模式的 key 列表，
但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。

### 38、如果有大量的 key 需要设置同一时间过期，一般需要注意什么？

如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，Redis 可能会出现短暂的卡顿现象。
一般需要在时间上加一个随机值，使得过期时间分散一些。

### 39、使用过 Redis 做异步队列么，你是怎么用的？

答：一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。
如果对方追问可不可以不用 sleep 呢？list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。
如果对方追问能不能生产一次消费多次呢？使用 pub/sub 主题订阅者模式，可以实现1:N 的消息队列。

如果对方追问 pub/sub 有什么缺点？

在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 RabbitMQ等。

如果对方追问 Redis 如何实现延时队列？

我估计现在你很想把面试官一棒打死，如果你手上有一根棒球棍的话，怎么问得这么详细。但是你很克制，然后神态自若地回答道：
使用 sorted set，拿时间戳作为score，消息内容作为 key 调用 zadd 来生产消息，
消费者用 zrange by score 指令获取 N 秒之前的数据轮询进行处理。

到这里，面试官暗地里已经对你竖起了大拇指。

### 40、使用过 Redis 分布式锁么，它是什么回事？

先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。

这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行 expire之前进程意外 crash 或者要重启维护了，那会怎么样？
这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己的脑袋，故作思考片刻，
好像接下来的结果是你主动思考出来的，然后回答：我记得 set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和expire 合成一条指令来用的！

对方这时会显露笑容，心里开始默念：摁，这小子还不错。

### 41、Redis 八股文 

参阅地址 <https://github.com/sudotty/reading_note/issues/31>

Redis 八股文 原理篇 1

    Redis 是单线程还是多线程？为什么这么设计？
    Redis 中的字符串对象和 C 语言中的字符串有什么区别？
    Redis 中是如何实现链表的？
    Redis 中是如何实现字典的？
    Redis 中的字典是如何进行动态扩容的？
    Redis 中的跳表是如何实现的？

Redis 八股文 原理篇 2

    STR/LIST/HASH/SET/ZSET 底层都是使用什么数据结构实现的？
    ZSET 什么时候使用 Ziplist 实现，什么时候使用 Skiplist 实现？
    ZSET 为什么不用 BST/AVL/B-Tree/红黑树，而使用跳表？
    Redis 的过期键删除策略是什么？
    Redis 的主从服务器是如何同步过期键的？

Redis 八股文 原理篇 3

    AOF 和 RDB 持久化有什么区别？
    Redis 的主从是如何进行同步的？
    如何解决长时间使用后 AOF 文件过大的问题？
    Redis 的哨兵机制是如何实现的？
    Redis 的集群方案有哪些？

Redis 八股文 原理篇 4

    Redis 的整体架构是什么样的，从客户端发出命令，到客户端接收到结果，这整个流程是什么样的？
    Redis 是如何实现 LRU 机制的？
    Redis 是如何实现 LFU 机制的？

Redis 八股文 应用篇 1

    Redis 有哪些数据结构，分别有什么使用场景？
    Redis ZSET 相同 score 如何排序？
    在爬虫中，如何使用 Redis 做 URL 去重？
    Redis 是否支持事务？
    Redis 中的 WATCH 命令是做什么的？
    Redis 是如何保证高可用的？
    如何使用 Redis 来实现分布式锁？Redlock？

Redis 只推荐看 @huangz1990 的《Redis 设计与实现》这本书，配合 Redis 的源码来看，这本书的源代码基于3.0，基本上就没什么问题了。

另外一本《Redis 5设计与源码分析》基于5.0源码。

### 42 Memcached 与 Redis 实现的对比

参阅 <https://cloud.tencent.com/developer/article/1004377>

### 43 redis 同步

redis 是如何进行同步的，同步的方式，同步回滚怎么办，数据异常怎么办，同时会问 MYSQL 的同步方式和相关异常情况。

redis 集群主从同步的简单原理

Redis 的复制功能是基于内存快照的持久化策略基础上的，也就是说无论你的持久化策略选择的是什么，
只要用到了 Redis 的复制功能，就一定会有内存快照发生。

当 Slave 启动并连接到 Master 之后，它将主动发送一个 SYNC 命令 (首先 Master 会启动一个后台进程，
将数据快照保存到文件中 `[rdb 文件]` ，Master 会给 Slave 发送一个Ping 命令来判断 Slave 的存活状态，
当存活时 Master 会将数据文件发送给 Slave 并将所有写命令发送到 Slave )。

Slave 首先会将数据文件保存到本地，之后再将 数据 加载到内存中。

当第一次链接或者是故障后重新连接都会先判断 Slave 的存活状态，再做全部数据的同步， 
之后只会同步 Master 的写操作 (将命令发送给 Slave)

问题：

当 Master 同步数据时，若数据量较大而 Master 本身只会启用一个后台进程来对多个 Slave 进行同步 ， 
这样 Master 就会压力过大，而且 Slave 恢复的时间也会很慢！

redis 主从复制的优点：
* (1)在一个Redis集群中，master负责写请求，slave负责读请求，
这么做一方面通过将读请求分散到其他机器从而大大减少了master服务器的压力，另一方面slave专注于提供读服务从而提高了响应和读取速度。
* (2) 在一个 Redis 集群中，如果 master 宕机，slave 可以介入并取代 master 的位置，
因此对于整个 Redis 服务来说不至于提供不了服务，这样使得整个 Redis 服务足够安全。
* (3) 水平增加 Slave 机器可以提高性能

参阅 <https://blog.csdn.net/hxpjava1/article/details/78347890/> 、<https://www.cnblogs.com/zhao-blog/p/6131524.html>

### 44 redis 存在线程安全问题吗

服务端层面本身是一个线程安全的K-V数据库，在服务端的所有操作都在一个线程中完成，因此不存在多个线程相互影响的问题，
而不需要考虑线程安全性问题。同时，Redis还提供了一些安全的API，如事务性的操作，支持所有的持久化操作都具有线程安全性。

客户端层面来说，如果有多个客户端同时对redis操作，就无法保证原子性，但可以通过以下方式避免：
1. 尽司能使用Redis里面的原子指令，如 SETNX、GETSET、INCR、DECR、MSET、MSETNX 等
2. 对多个客户端的资源访问加锁
3. 通过Lua脚本来实现多个指令的操作

总结：Redis服务端是线程安全的，但客户端是非线程安全的，需要做好防护。

### 45 Redis的Lua脚本是什么

Redis的Lua脚本是一种使用Lua语言编写的自定义脚本，可以在Redis数据库中执行。
Redis允许用户通过EVAL命令将Lua脚本发送到Redis服务器执行，从而实现更复杂的逻辑和数据处理。

使用Lua脚本可以带来以下好处：

* 原子性：Lua脚本在Redis中是原子执行的，这意味着在执行过程中不会被其他命令干扰，保证了数据的一致性。
* 减少网络开销：通过将多个命令封装在Lua脚本中，可以减少网络传输的次数，提高处理效率。
* 灵活性：Lua脚本支持使用Redis的所有命令，并且支持条件判断、循环等逻辑，可以实现更复杂的操作。

下面是一个简单的示例，演示了如何使用Lua脚本实现一个自增计数器：

lua
```
-- 获取当前值  
local current = redis.call('GET', KEYS[1])  
  
-- 如果当前值为nil，则初始化为0  
if current == false then  
    current = 0  
end  
  
-- 自增并设置新值  
local new = tonumber(current) + 1  
redis.call('SET', KEYS[1], new)  
  
-- 返回新值  

return new
```

通过EVAL命令将该脚本发送到Redis服务器执行：

redis
```
EVAL "local current = redis.call('GET', KEYS[1]) if current == false then current = 0 end local new = tonumber(current) + 1 redis.call('SET', KEYS[1], new) return new" 1 mycounter
```

上述示例中，Lua脚本通过redis.call函数调用了Redis的GET和SET命令，实现了自增计数器的功能。
通过EVAL命令将脚本发送到Redis服务器执行，并传递了一个键名作为参数。

需要注意的是，使用Lua脚本需要谨慎处理数据类型转换和错误处理，以确保脚本的正确性和稳定性。

### Redis加锁和释放锁怎么实现

在Redis中，可以使用SETNX命令实现加锁，使用DEL命令实现释放锁。

具体实现步骤如下：

加锁：使用SETNX命令尝试在Redis中设置一个唯一的key和value，表示该锁已经被占用。如果设置成功，表示获取到了锁；
如果设置失败，表示锁已经被其他客户端占用。
```
SETNX lock_key lock_value
```

释放锁：使用DEL命令删除Redis中的锁key，表示释放锁。
```
DEL lock_key
```

需要注意的是，为了避免在多个客户端之间出现竞态条件，需要在获取锁和释放锁的过程中添加一些逻辑控制。
例如，可以在获取锁时添加一个过期时间，避免因为某个客户端异常而无法释放锁。
同时，也可以在释放锁时添加一个判断条件，避免重复释放同一个锁。

设置过期时间：使用SET命令的EX参数为键设置过期时间，表示锁的有效期
```
SET lock_key lock_value EX lock_timeout
```

释放锁之前，需要添加一个判断条件，判断该锁是否还存在。可以使用EXISTS命令判断该键是否存在，
如果存在则执行删除操作，否则不执行任何操作：
```
IF EXISTS lock_key THEN  
    DEL lock_key  
END
```

### Redis 主从复制的原理

1、全量复制

发生在初始化阶段。Slave 发送 SYNC 到 Master，Master生成数据快照，把数据快照发送给Slave，Slave丢弃旧的数据，
载入新数据，对外提供服务。并没有采用数据的强一致性，会有一定时间的延迟。

2、增量复制

Master数据变更后，会把变更的数据同步给Slave。Master和Slave都有一个offset数据偏移量，
用来标记Masterl向Slave传递的字节数量，同步时都会增加对应的字节数量。









<br/><br/><br/><br/><br/>
## 参考资料

面试还搞不懂redis，快看看这40道面试题 <https://blog.csdn.net/Design407/article/details/103242874>

面试 Redis 没底？这 40 道面试题让你不再慌 <https://mp.weixin.qq.com/s/guK3En5D1s0QpxGAQxHFbQ>

Redis 面试视频解说  <https://www.bilibili.com/video/BV1oG4y1o7cg>
