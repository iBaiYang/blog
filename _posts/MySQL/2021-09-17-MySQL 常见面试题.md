---
layout: post
categories: MySQL
title: MySQL 常见面试题
meta: MySQL 常见面试题
---
* content
{:toc}

## 正文

### 1 UNION ALL 与 UNION 的区别

UNION和UNION ALL关键字都是将两个结果集合并为一个。

UNION在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。

而UNION ALL只是简单的将两个结果合并后就返回。

由于UNION需要排序去重，所以 UNION ALL 的效率比 UNION 好很多。

### 2 TRUNCATE 与 DELETE 区别

TRUNCATE 是DDL语句，而 DELETE 是DML语句。

TRUNCATE 是先把整张表drop调，然后重建该表。而 DELETE 是一行一行的删除，所以 TRUNCATE 的速度肯定比 DELETE 速度快。

TRUNCATE 不可以回滚，DELETE 可以。

TRUNCATE 执行结果只是返回0 rows affected，可以解释为没有返回结果。

TRUNCATE 会重置水平线（自增长列起始位），DELETE 不会。

TRUNCATE 只能清理整张表，DELETE 可以按照条件删除。

一般情景下，TRUNCATE性能比DELETE好一点。

### 3 TIMESTAMP 与 DATETIME 的区别

相同点：

TIMESTAMP 列的显示格式与 DATETIME 列相同。显示列宽固定在19字符，并且格式为YYYY-MM-DD HH:MM:SS。

不同点：

TIMESTAMP

4个字节存储，时间范围：1970-01-01 08:00:01~2038-01-19 11:14:07。

值以UTC格式保存，涉及时区转化，存储时对当前的时区进行转换，检索时再转换回当前的时区。

DATETIME

8个字节存储，时间范围：1000-10-01 00:00:00~9999-12-31 23:59:59。

实际格式存储，与时区无关。

### 4 什么是联合索引

两个或更多个列上的索引被称作联合索引，联合索引又叫复合索引。

### 5 为什么要使用联合索引

减少开销：建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。减少磁盘空间的开销。

覆盖索引：对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。
那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。覆盖索引是主要的提升性能的优化手段之一。

效率高：索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，
有如下sql `select from table where col1=1 and col2=2 and col3=3`，假设假设每个条件可以筛选出10%的数据，
如果只有单值索引，那么通过该索引能筛选出1000W * 10%=100w条数据，然后再回表从100w条数据中找到符合`col2=2 and col3= 3`的数据，
然后再排序，再分页；如果是联合索引，通过索引筛选出1000w * 10% * 10% * 10%=1w，效率得到明显提升。

### 6 MySQL 联合索引最左匹配原则

在 MySQL 建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。

MySQL 会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，
比如`a = 1 and b = 2 and c > 3 and d = 4` 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，
如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

= 和 in 可以乱序，比如`a = 1 and b = 2 and c = 3` 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。

### 7 什么是聚集和非聚集索引

聚集索引就是以主键创建的索引。

非聚集索引就是以非主键创建的索引。

### 8 什么是覆盖索引

覆盖索引（covering index）指一个查询语句的执行只用从索引页中就能够取得（如果不是聚集索引，叶子节点存储的是主键+列值，
最终还是要回表，也就是要通过主键再查找一次），避免了查到索引后，再做回表操作，减少I/O提高效率。

可以结合第10个问题更容易理解。

### 9 什么是前缀索引

前缀索引就是对文本的前几个字符（具体是几个字符在创建索引时指定）创建索引，这样创建起来的索引更小。
但是MySQL不能在ORDER BY或GROUP BY中使用前缀索引，也不能把它们用作覆盖索引。

创建前缀索引的语法：
```
ALTER TABLE table_name ADD
KEY(column_name(prefix_length))
```

### 10 InnoDB 与 MyISAM 索引存储结构的区别

MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。

而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。
这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引，所以必须有主键，
如果没有显示定义，自动为生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。

InnoDB的辅助索引（Secondary Index，也就是非主键索引）存储的只是主键列和索引列，如果主键定义的比较大，其他索引也将很大。

MyISAM引擎使用B+Tree作为索引结构，索引文件叶节点的data域存放的是数据记录的地址，指向数据文件中对应的值，每个节点只有该索引列的值。

MyISAM主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，辅助索引可以重复，
（由于MyISAM辅助索引在叶子节点上存储的是数据记录的地址，和主键索引一样，所以不需要再遍历一次主键索引）。

简单的说：

主索引的区别：InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。

辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。

### 11 为什么尽量选择单调递增数值类型的主键

InnoDB中数据记录本身被存于主索引（B+树）的叶子节点上。
这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，
因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的结点和位置，
如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页。

如果使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引结点的后续位置，当一页写满，就会自动开辟一个新的页，
这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，
因此效率很高，也不会增加很多开销在维护索引上。

如果使用非自增主键，由于每次插入主键的值近似于随机，因此每次新纪录都要被插入到现有索引页的中间某个位置，
此时MySQL不得不为了将新记录查到合适位置而移动元素，甚至目标页可能已经被回写到磁盘上而从缓存中清掉，
此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，
得到了不够紧凑的索引结构，后续不得不通过 OPTIMIZE TABLE 来重建表并优化填充页面。

简单的说：

索引树只能定位到某一页，每一页内的插入还是需要通过比较、移动插入的。所以有序主键可以提升插入效率。

### 12 建表时，int 后面的长度的意义

int占多少个字节，已经是固定的了，长度代表了显示的最大宽度。如果不够会用0在左边填充，
但必须搭配zerofill使用。也就是说，int的长度并不影响数据的存储精度，长度只和显示有关。

### 13 SHOW INDEX 结果字段代表什么意

`SHOW INDEX from table_name`

| Table   | Non_unique  | Key_name  | Seq_in_index  | Column_name  | Collation  | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | 
| ------- | -----  | ----  | ----  | ----  | -----  | ----  | ----  | ----  | -----  | ----  | ----  | ----  |
| user    | 0    | PRIMARY    | 1    | id    | A    | 669   |        |      |   | BTREE  |    |    | 
| user    | 1    | username  | 1 | username  | A    | 268   |       |      | YES | BTREE   |    |    | 

解说

**Table**：

表名。

**Non_unique**：

0：该索引不含重复值。

1：该索引可含有重复值。

**Key_name**：

索引名称，如果是主键索引，名称总是为`PRIMARY`。

**Seq_in_index**：

该列在索引中的序号，从 1 开始。例如：存在联合索引 `idx_a_b_c (a,b,c)`，则 a 的 Seq_in_index=1，b=2，c=3。

**Column_name**：

列名。

**Collation**：

索引的排列顺序：A（ascending），D (descending)，NULL (not sorted)。

**Cardinality**：

一个衡量该索引的唯一程度的值，可以使用ANALYZE TABLE（INNODB） 或者 myisamchk -a（MyISAM）更新该值。

如果表记录太少，该字段的意义不大。一般情况下，该值越大，索引效率越高。

**Sub_part**：

对于前缀索引，用于索引的字符个数。如果整个字段都加上了索引，则显示为NULL。

**Null**：

`YES`：该列允许NULL值。

`''`：该列不允许NULL值。

**Index_type**：

索引类型，包括(BTREE, FULLTEXT, HASH, RTREE)。

### 14 MySQL高效分页

存在SQL：`SELECT * FROM ttl_product_info ORDER BY id LIMIT N,M`。
其中 LIMIT N,M 存在的问题最大：取出N+M行，丢弃前N行，返回 N ~ N+M 行的记录，
如果N值非常大，效率极差（表记录1500w，N=10000000,M=30 需要9秒）。

解决办法：SQL：`SELECT id FROM ttl_product_info WHERE id > N LIMIT M`，id 列是索引列，id > N属于 range 级别，效率自然高，
然后从位置开始取30条记录，效率极高（表记录1500w，N=10000000,M=30，需要0.9毫秒）。

当然想要实现上述效果的前提是：

id是唯一索引，而且单调递增。

N 的值是上一次查询的记录的最后一条id，（需要前端保存一下，不能直接用传统的方法获得）

不支持跨页查询，只能按照第1，2，3，4页这样查询逐页查询。

### 15 LIKE问题

如何解决`like '%字符串%'`时索引失效？

LIKE问题：like 以通配符开头 (`'%abc…'`)，mysql索引失效会变成全表扫描的操作。

罪魁祸首是`%`，不是LIKE，LIKE 条件是 type = range 级别

`%xxx%`：全表扫描

`%xxx`：全表扫描

`xxx%`：range

解决办法：

使用覆盖索引，可以由 ALL 变为INDEX，为啥呢？覆盖索引之后就能使用索引进行全表扫描。
这里要注意一下，使用符合索引的时候，命中一个字段就可以，不用全部命中。

### 16 索引类型

<https://zhuanlan.zhihu.com/p/344773786>

<https://zhuanlan.zhihu.com/p/394429932>

<https://zhuanlan.zhihu.com/p/78982303>

<https://zhuanlan.zhihu.com/p/313422544>

<https://zhuanlan.zhihu.com/p/410715538>

MySQL 支持多种索引类型，以下是一些常见的索引类型。

按数据结构分类：
* B-Tree索引(B+树)：B-Tree（平衡多路查找树）是 MySQL 最常用的索引类型，几乎所有的存储引擎都支持这种索引。
Mysql官方叫做B-Tree索引，但采用的是B+树数据结构。
它适用于全值匹配和范围查找。在 InnoDB、Memory、MyISAM 和 Archive 等存储引擎中都可以使用。
* 哈希索引（Hash Index）：哈希索引基于哈希算法，适用于等值查询。目前只有 MEMORY 存储引擎支持哈希索引。
* 空间索引（Spatial Index）：空间索引（R-Tree）基于 R-Tree 数据结构，是一种专门用于处理地理空间数据的索引。
目前只有 MEMORY 存储引擎支持哈希索引。
* 位图索引（Bitmap Index）：位图索引是对数据进行位图标记的一种索引，适用于数据在取值范围上比较集中的情况。
主要用于高维数据和大规模数据的处理。它使用位图数据结构来表示索引数据。MySQL 的 Archive 存储引擎支持位图索引。
* 全文索引（Full-Text Index）：全文索引是专门用于全文搜索的索引。它基于倒排索引实现，提供了一种高效的搜索方式，
用于在大量的文本数据中进行关键词搜索。全文索引主要用于 MyISAM 和 InnoDB 存储引擎。
* 复合索引（Composite Index）：复合索引是由多个列组成的索引，它可以同时满足多个查询条件，从而提高查询效率。
在设计和使用时需要谨慎，以避免过度冗余和性能下降。复合索引在 InnoDB、Memory、MyISAM 等存储引擎中都支持。
* 前缀索引（Prefix Index）：前缀索引是一种基于列前缀的索引类型，它可以减小索引的大小，从而提高查询效率。
但需要注意的是，前缀索引可能会降低查询的覆盖率。前缀索引在 InnoDB、Memory、MyISAM 等存储引擎中都支持。
* 唯一索引（Unique Index）：唯一索引确保索引列的值在表中的唯一性。它允许列中的值为空（NULL）。
唯一索引在 InnoDB、Memory、MyISAM 等存储引擎中都支持。

按物理存储分类：
* 聚簇索引（Clustered Index）：聚簇索引将数据按照索引的顺序物理存储，即数据存储和索引是紧密关联的。
也就是说，一个表只有一个聚簇索引。它通常与主键相关联。InnoDB 存储引擎默认使用聚簇索引。
聚簇索引不是一种索引，而是一种数据存储组织方式。
* 非聚簇索引：非聚簇索引与数据的物理存储顺序无关，它可以根据索引列的值来组织数据。
非聚簇索引可以包含多个列，并且一个表可以有多个非聚簇索引。非聚簇索引的查询效率比聚簇索引低，
因为需要先通过二级索引找到主键，再通过主键找到数据。MyISAM 和 InnoDB 存储引擎都支持二级索引。

按字段特性分类：
* 主键索引（PRIMARY KEY）：主键索引是建立在主键上的索引，一张数据表只能有一个主键索引。
主键索引的索引列值不允许为空，且必须唯一。通常在创建表时与表一起创建。
* 唯一索引（UNIQUE）：唯一索引是建立在UNIQUE字段上的索引，一张表可以有多个唯一索引。
唯一索引的索引列值不允许为空，但允许有一个NULL值。
* 普通索引（INDEX）：普通索引是建立在普通字段上的索引，没有主键和唯一索引的限制，可以重复。
* 全文索引（FULLTEXT）：全文索引是一种特殊的索引类型，主要用于文本搜索和自然语言查询。
它基于倒排索引实现，适用于大量的文本数据的查询操作。

按字段个数分类：
* 单列索引：单列索引是建立在单个列上的索引，它只能用于查询该列的数据。
* 联合索引（复合索引、组合索引）：联合索引是建立在多个列上的索引，它用于查询多个列的数据。
联合索引可以提高多个列同时查询的效率。

按查询实现分类：
* 覆盖索引（Covering Index）：覆盖索引是一种特殊类型的索引，它包含了需要查询的列数据，因此无需回表查询。
这可以提高查询性能，特别是对于只查询少量数据的查询。
* 前缀索引：前缀索引是一种基于列前缀的索引类型，它可以减小索引的大小，从而提高查询效率。但需要注意的是，前缀索引可能会降低查询的覆盖率。
* 函数索引：函数索引是一种特殊类型的索引，它允许在索引列上使用函数或表达式。函数索引可以提高特定函数查询的效率。


#### 17 索引失效

MySQL 中的索引可能会失效的几种情况如下：
* 没有查询条件，或者查询条件没有建立索引：这种情况下，查询无法利用索引，会导致全表扫描，从而使得查询效率降低。
* 在查询条件上没有使用引导列：如果查询条件中没有使用引导列，那么索引也无法发挥作用。
* 查询的数量是大表的大部分，应该是30％以上：在大数据表中，如果查询的数量只占表的一小部分，那么索引的效率可能会降低。
* 索引本身失效：例如，在非唯一索引列上使用聚合函数或者使用不匹配的查询条件等，都可能导致索引失效。
* 查询条件使用函数在索引列上：如果查询条件中使用了函数，那么在索引列上使用该函数时，索引也会失效。
* 在索引列上使用“IS NULL”或“IS NOT NULL”操作：在索引列上使用这些操作也会导致索引失效。
* 在索引字段上使用“not”，“<>”，“!=”，“or”等等：在索引字段上使用这些操作符进行查询时，索引也会失效。
* 查询时，在索引字段like查询以 “%” 开头，破坏了最左匹配原则，从而使得索引失效。
* 隐式转换导致索引失效：由于表的字段定义与查询条件中的数据类型不符，可能会导致隐式转换，从而使得索引失效。
* 估计全表扫描会比索引快，索引也会失效。





<br/><br/><br/><br/><br/>
## 参考资料

SQL面试题，快问快答！ <https://mp.weixin.qq.com/s/I8IcSbLV7tor8L84x19A4g>

Mysql联合索引最左匹配原则 <https://segmentfault.com/a/1190000015416513>

数据库为什么要用B+树结构 <https://blog.csdn.net/bigtree_3721/article/details/73151472>
