---
layout: post
categories: MySQL
title: MySQL 常见面试题
meta: MySQL 常见面试题
---
* content
{:toc}

## 正文

### 1 UNION ALL 与 UNION 的区别

UNION和UNION ALL关键字都是将两个结果集合并为一个。

UNION在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。

而UNION ALL只是简单的将两个结果合并后就返回。

由于UNION需要排序去重，所以 UNION ALL 的效率比 UNION 好很多。

### 2 TRUNCATE 与 DELETE 区别

TRUNCATE 是DDL语句，而 DELETE 是DML语句。

TRUNCATE 是先把整张表drop调，然后重建该表。而 DELETE 是一行一行的删除，所以 TRUNCATE 的速度肯定比 DELETE 速度快。

TRUNCATE 不可以回滚，DELETE 可以。

TRUNCATE 执行结果只是返回0 rows affected，可以解释为没有返回结果。

TRUNCATE 会重置水平线（自增长列起始位），DELETE 不会。

TRUNCATE 只能清理整张表，DELETE 可以按照条件删除。

一般情景下，TRUNCATE性能比DELETE好一点。

### 3 TIMESTAMP 与 DATETIME 的区别

相同点：

TIMESTAMP 列的显示格式与 DATETIME 列相同。显示列宽固定在19字符，并且格式为YYYY-MM-DD HH:MM:SS。

不同点：

TIMESTAMP

4个字节存储，时间范围：1970-01-01 08:00:01~2038-01-19 11:14:07。

值以UTC格式保存，涉及时区转化，存储时对当前的时区进行转换，检索时再转换回当前的时区。

DATETIME

8个字节存储，时间范围：1000-10-01 00:00:00~9999-12-31 23:59:59。

实际格式存储，与时区无关。

### 4 什么是联合索引

两个或更多个列上的索引被称作联合索引，联合索引又叫复合索引。

### 5 为什么要使用联合索引

减少开销：建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。减少磁盘空间的开销。

覆盖索引：对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。
那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。覆盖索引是主要的提升性能的优化手段之一。

效率高：索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，
有如下sql `select from table where col1=1 and col2=2 and col3=3`，假设假设每个条件可以筛选出10%的数据，
如果只有单值索引，那么通过该索引能筛选出1000W * 10%=100w条数据，然后再回表从100w条数据中找到符合`col2=2 and col3= 3`的数据，
然后再排序，再分页；如果是联合索引，通过索引筛选出1000w * 10% * 10% * 10%=1w，效率得到明显提升。

### 6 MySQL 联合索引最左匹配原则

在 MySQL 建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。

MySQL 会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，
比如`a = 1 and b = 2 and c > 3 and d = 4` 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，
如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

= 和 in 可以乱序，比如`a = 1 and b = 2 and c = 3` 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。

### 7 什么是聚集和非聚集索引

聚集索引就是以主键创建的索引。

非聚集索引就是以非主键创建的索引。

### 8 什么是覆盖索引

覆盖索引（covering index）指一个查询语句的执行只用从索引页中就能够取得（如果不是聚集索引，叶子节点存储的是主键+列值，
最终还是要回表，也就是要通过主键再查找一次），避免了查到索引后，再做回表操作，减少I/O提高效率。

可以结合第10个问题更容易理解。

### 9 什么是前缀索引

前缀索引就是对文本的前几个字符（具体是几个字符在创建索引时指定）创建索引，这样创建起来的索引更小。
但是MySQL不能在ORDER BY或GROUP BY中使用前缀索引，也不能把它们用作覆盖索引。

创建前缀索引的语法：
```
ALTER TABLE table_name ADD
KEY(column_name(prefix_length))
```

### 10 InnoDB 与 MyISAM 索引存储结构的区别

MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。

而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。
这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引，所以必须有主键，
如果没有显示定义，自动为生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。

InnoDB的辅助索引（Secondary Index，也就是非主键索引）存储的只是主键列和索引列，如果主键定义的比较大，其他索引也将很大。

MyISAM引擎使用B+Tree作为索引结构，索引文件叶节点的data域存放的是数据记录的地址，指向数据文件中对应的值，每个节点只有该索引列的值。

MyISAM主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，辅助索引可以重复，
（由于MyISAM辅助索引在叶子节点上存储的是数据记录的地址，和主键索引一样，所以不需要再遍历一次主键索引）。

简单的说：

主索引的区别：InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。

辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。

### 11 为什么尽量选择单调递增数值类型的主键

InnoDB中数据记录本身被存于主索引（B+树）的叶子节点上。
这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，
因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的结点和位置，
如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页。

如果使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引结点的后续位置，当一页写满，就会自动开辟一个新的页，
这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，
因此效率很高，也不会增加很多开销在维护索引上。

如果使用非自增主键，由于每次插入主键的值近似于随机，因此每次新纪录都要被插入到现有索引页的中间某个位置，
此时MySQL不得不为了将新记录查到合适位置而移动元素，甚至目标页可能已经被回写到磁盘上而从缓存中清掉，
此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，
得到了不够紧凑的索引结构，后续不得不通过 OPTIMIZE TABLE 来重建表并优化填充页面。

简单的说：

索引树只能定位到某一页，每一页内的插入还是需要通过比较、移动插入的。所以有序主键可以提升插入效率。

### 12 建表时，int 后面的长度的意义

int占多少个字节，已经是固定的了，长度代表了显示的最大宽度。如果不够会用0在左边填充，
但必须搭配zerofill使用。也就是说，int的长度并不影响数据的存储精度，长度只和显示有关。

### 13 SHOW INDEX 结果字段代表什么意

`SHOW INDEX from table_name`

| Table   | Non_unique  | Key_name  | Seq_in_index  | Column_name  | Collation  | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | 
| ------- | -----  | ----  | ----  | ----  | -----  | ----  | ----  | ----  | -----  | ----  | ----  | ----  |
| user    | 0    | PRIMARY    | 1    | id    | A    | 669   |        |      |   | BTREE  |    |    | 
| user    | 1    | username  | 1 | username  | A    | 268   |       |      | YES | BTREE   |    |    | 

解说

**Table**：

表名。

**Non_unique**：

0：该索引不含重复值。

1：该索引可含有重复值。

**Key_name**：

索引名称，如果是主键索引，名称总是为`PRIMARY`。

**Seq_in_index**：

该列在索引中的序号，从 1 开始。例如：存在联合索引 `idx_a_b_c (a,b,c)`，则 a 的 Seq_in_index=1，b=2，c=3。

**Column_name**：

列名。

**Collation**：

索引的排列顺序：A（ascending），D (descending)，NULL (not sorted)。

**Cardinality**：

一个衡量该索引的唯一程度的值，可以使用ANALYZE TABLE（INNODB） 或者 myisamchk -a（MyISAM）更新该值。

如果表记录太少，该字段的意义不大。一般情况下，该值越大，索引效率越高。

**Sub_part**：

对于前缀索引，用于索引的字符个数。如果整个字段都加上了索引，则显示为NULL。

**Null**：

`YES`：该列允许NULL值。

`''`：该列不允许NULL值。

**Index_type**：

索引类型，包括(BTREE, FULLTEXT, HASH, RTREE)。

### 14 MySQL高效分页

存在SQL：`SELECT * FROM ttl_product_info ORDER BY id LIMIT N,M`。
其中 LIMIT N,M 存在的问题最大：取出N+M行，丢弃前N行，返回 N ~ N+M 行的记录，
如果N值非常大，效率极差（表记录1500w，N=10000000,M=30 需要9秒）。

解决办法：SQL：`SELECT id FROM ttl_product_info WHERE id > N LIMIT M`，id 列是索引列，id > N属于 range 级别，效率自然高，
然后从位置开始取30条记录，效率极高（表记录1500w，N=10000000,M=30，需要0.9毫秒）。

当然想要实现上述效果的前提是：

id是唯一索引，而且单调递增。

N 的值是上一次查询的记录的最后一条id，（需要前端保存一下，不能直接用传统的方法获得）

不支持跨页查询，只能按照第1，2，3，4页这样查询逐页查询。

### 15 LIKE问题

如何解决`like '%字符串%'`时索引失效？

LIKE问题：like 以通配符开头 (`'%abc…'`)，mysql索引失效会变成全表扫描的操作。

罪魁祸首是`%`，不是LIKE，LIKE 条件是 type = range 级别

`%xxx%`：全表扫描

`%xxx`：全表扫描

`xxx%`：range

解决办法：

使用覆盖索引，可以由 ALL 变为INDEX，为啥呢？覆盖索引之后就能使用索引进行全表扫描。
这里要注意一下，使用符合索引的时候，命中一个字段就可以，不用全部命中。

### 16 索引类型

<https://zhuanlan.zhihu.com/p/344773786>

<https://zhuanlan.zhihu.com/p/394429932>

<https://zhuanlan.zhihu.com/p/78982303>

<https://zhuanlan.zhihu.com/p/313422544>

<https://zhuanlan.zhihu.com/p/410715538>

MySQL 支持多种索引类型，以下是一些常见的索引类型。

按数据结构分类：
* B-Tree索引(B+树)：B-Tree（平衡多路查找树）是 MySQL 最常用的索引类型，几乎所有的存储引擎都支持这种索引。
Mysql官方叫做B-Tree索引，但采用的是B+树数据结构。
它适用于全值匹配和范围查找。在 InnoDB、Memory、MyISAM 和 Archive 等存储引擎中都可以使用。
* 哈希索引（Hash Index）：哈希索引基于哈希算法，适用于等值查询。目前只有 MEMORY 存储引擎支持哈希索引。
* 空间索引（Spatial Index）：空间索引（R-Tree）基于 R-Tree 数据结构，是一种专门用于处理地理空间数据的索引。
目前只有 MEMORY 存储引擎支持哈希索引。
* 位图索引（Bitmap Index）：位图索引是对数据进行位图标记的一种索引，适用于数据在取值范围上比较集中的情况。
主要用于高维数据和大规模数据的处理。它使用位图数据结构来表示索引数据。MySQL 的 Archive 存储引擎支持位图索引。
* 全文索引（Full-Text Index）：全文索引是专门用于全文搜索的索引。它基于倒排索引实现，提供了一种高效的搜索方式，
用于在大量的文本数据中进行关键词搜索。全文索引主要用于 MyISAM 和 InnoDB 存储引擎。
* 复合索引（Composite Index）：复合索引是由多个列组成的索引，它可以同时满足多个查询条件，从而提高查询效率。
在设计和使用时需要谨慎，以避免过度冗余和性能下降。复合索引在 InnoDB、Memory、MyISAM 等存储引擎中都支持。
* 前缀索引（Prefix Index）：前缀索引是一种基于列前缀的索引类型，它可以减小索引的大小，从而提高查询效率。
但需要注意的是，前缀索引可能会降低查询的覆盖率。前缀索引在 InnoDB、Memory、MyISAM 等存储引擎中都支持。
* 唯一索引（Unique Index）：唯一索引确保索引列的值在表中的唯一性。它允许列中的值为空（NULL）。
唯一索引在 InnoDB、Memory、MyISAM 等存储引擎中都支持。

按物理存储分类：
* 聚簇索引（Clustered Index）：聚簇索引将数据按照索引的顺序物理存储，即数据存储和索引是紧密关联的。
也就是说，一个表只有一个聚簇索引。它通常与主键相关联。InnoDB 存储引擎默认使用聚簇索引。
聚簇索引不是一种索引，而是一种数据存储组织方式。
* 非聚簇索引：非聚簇索引与数据的物理存储顺序无关，它可以根据索引列的值来组织数据。
非聚簇索引可以包含多个列，并且一个表可以有多个非聚簇索引。非聚簇索引的查询效率比聚簇索引低，
因为需要先通过二级索引找到主键，再通过主键找到数据。MyISAM 和 InnoDB 存储引擎都支持二级索引。

按字段特性分类：
* 主键索引（PRIMARY KEY）：主键索引是建立在主键上的索引，一张数据表只能有一个主键索引。
主键索引的索引列值不允许为空，且必须唯一。通常在创建表时与表一起创建。
* 唯一索引（UNIQUE）：唯一索引是建立在UNIQUE字段上的索引，一张表可以有多个唯一索引。
唯一索引的索引列值不允许为空，但允许有一个NULL值。
* 普通索引（INDEX）：普通索引是建立在普通字段上的索引，没有主键和唯一索引的限制，可以重复。
* 全文索引（FULLTEXT）：全文索引是一种特殊的索引类型，主要用于文本搜索和自然语言查询。
它基于倒排索引实现，适用于大量的文本数据的查询操作。

按字段个数分类：
* 单列索引：单列索引是建立在单个列上的索引，它只能用于查询该列的数据。
* 联合索引（复合索引、组合索引）：联合索引是建立在多个列上的索引，它用于查询多个列的数据。
联合索引可以提高多个列同时查询的效率。

按查询实现分类：
* 覆盖索引（Covering Index）：覆盖索引是一种特殊类型的索引，它包含了需要查询的列数据，因此无需回表查询。
这可以提高查询性能，特别是对于只查询少量数据的查询。
* 前缀索引：前缀索引是一种基于列前缀的索引类型，它可以减小索引的大小，从而提高查询效率。但需要注意的是，前缀索引可能会降低查询的覆盖率。
* 函数索引：函数索引是一种特殊类型的索引，它允许在索引列上使用函数或表达式。函数索引可以提高特定函数查询的效率。


### 17 索引失效

MySQL 中的索引可能会失效的几种情况如下：
* 没有查询条件，或者查询条件没有建立索引：这种情况下，查询无法利用索引，会导致全表扫描，从而使得查询效率降低。
* 在查询条件上没有使用引导列：如果查询条件中没有使用引导列，那么索引也无法发挥作用。
* 查询的数量是大表的大部分，应该是30％以上：在大数据表中，如果查询的数量只占表的一小部分，那么索引的效率可能会降低。
* 索引本身失效：例如，在非唯一索引列上使用聚合函数或者使用不匹配的查询条件等，都可能导致索引失效。
* 查询条件使用函数在索引列上：如果查询条件中使用了函数，那么在索引列上使用该函数时，索引也会失效。
* 在索引列上使用“IS NULL”或“IS NOT NULL”操作：在索引列上使用这些操作也会导致索引失效。
* 在索引字段上使用“not”，“<>”，“!=”，“or”等等：在索引字段上使用这些操作符进行查询时，索引也会失效。
* 查询时，在索引字段like查询以 “%” 开头，破坏了最左匹配原则，从而使得索引失效。
* 隐式转换导致索引失效：由于表的字段定义与查询条件中的数据类型不符，可能会导致隐式转换，从而使得索引失效。
* 估计全表扫描会比索引快，索引也会失效。

### 18 SQL优化步骤

<https://ibaiyang.github.io/blog/mysql/2021/09/18/图解-MySQL-优化.html>

查看服务器状态信息：
> show status

查看并开启慢查询日志：
> show variables like "%slow%";
>
> set global slow_query_log='ON';

查看当前正在进行的线程，包括线程的状态、是否锁表等：
> show processlist

查看索引的使用情况：
> show status like 'Handler_read%';

查看执行计划：
> explain sql语句

分析表：
> analyze table 表名;

检查表：
> check table 表名;

优化表：
> optimize table 表名;

### 19 优化原理

<https://ibaiyang.github.io/blog/mysql/2021/04/23/MySQL-优化原理.html>

### 20 八股文

<https://ibaiyang.github.io/blog/mysql/2021/03/29/MySQL-八股文.html>

### 21 各类锁

**常见锁类型**

MySQL中有多种类型的锁，这些锁主要用于控制并发操作对数据库的访问，以避免数据不一致和其他并发问题。
以下是MySQL中常见的一些锁类型：
* 共享锁（Shared Lock）：也被称为读锁（Read Lock）。当一个事务持有一个共享锁时，其他事务也可以持有共享锁，
但其他事务不能获取写锁。当一个事务读取数据时，它可以使用共享锁来防止其他事务同时修改这些数据。
* 排他锁（Exclusive Lock）：也被称为写锁（Write Lock）。当一个事务持有一个排他锁时，
其他事务不能获取任何类型的锁，包括共享锁和排他锁。只有拥有排他锁的事务才能修改数据。
* 意向共享锁（Intent Shared Lock）：这种锁表示事务打算在读取数据时使用共享锁。
如果一个事务持有意向共享锁，其他事务也可以获取共享锁，但不能获取排他锁。
* 意向排他锁（Intent Exclusive Lock）：这种锁表示事务打算在修改数据时使用排他锁。
如果一个事务持有意向排他锁，其他事务不能获取共享锁或意向共享锁，但可以获取排他锁。
* 乐观锁（Optimistic Lock）：这种锁假设在大多数情况下，多个事务不会同时尝试修改同一行数据。
因此，它不会立即锁定数据，而是在提交事务时检查是否有其他事务已经修改了数据。如果其他事务已经修改了数据，则事务会失败并回滚。
* 悲观锁（Pessimistic Lock）：与乐观锁相反，悲观锁假设在大多数情况下，多个事务会尝试修改同一行数据。
因此，它会立即锁定数据，防止其他事务修改数据。
* 间隙锁（Gap Lock）：在InnoDB中，为了实现唯一索引或主键的并发控制，引入了间隙锁。
当事务对某个范围进行查询时，为了防止其他事务插入新的记录到这个范围，事务会持有这个范围的间隙锁，从而保护这个范围的数据。

这些锁在MySQL的InnoDB存储引擎中实现。另外，MySQL还提供了多种其他的锁定机制，如页面锁、行级锁等，以满足不同的并发控制需求。

**间隙锁**

MySQL中的间隙锁（Gap Lock）是一种锁机制，它防止其他事务插入新的记录到特定的范围，从而保护该范围内的数据不被其他事务修改。

在MySQL的InnoDB存储引擎中，为了实现唯一索引或主键的并发控制，引入了间隙锁。当事务对某个范围进行查询时，
为了防止其他事务插入新的记录到这个范围，事务会持有这个范围的间隙锁，从而保护这个范围的数据。
这样可以避免幻读（Phantom Read）和不可重复读（Non-repeatable Read）的问题。

间隙锁与排他锁（Exclusive Lock）和共享锁（Shared Lock）不同。排他锁会锁定整行数据，
而共享锁允许其他事务同时读取数据，但不能修改数据。而间隙锁则是锁定一个范围，防止其他事务插入新的记录到这个范围。

间隙锁的实现是通过在索引上维护一个锁定位图（Locking Bitmap）来实现的。当事务对某个范围进行查询时，
会将这个范围的锁定位图标记为锁定状态，表示其他事务不能插入新的记录到这个范围。
当事务提交时，会将这个范围的锁定位图标记为解锁状态。

间隙锁可以与排他锁和共享锁一起使用，以实现更细粒度的并发控制。在使用间隙锁时，需要注意避免死锁和其他并发问题。

**锁定粒度**

按锁定对象的粒度划分，有以下类型锁：
* 行锁（Row Lock）：行锁是针对数据库中的某一行数据进行锁定，防止其他事务对该行数据进行修改。
行锁是最细粒度的锁，可以保证数据的并发一致性。
* 页面锁（Page Lock）：页面锁是针对数据库中的某一页数据进行锁定，防止其他事务对该页数据进行修改。
页面锁的粒度较粗，相比行锁对并发访问的影响较大。页面锁是一种较低级别的锁，它锁定的是物理数据库页。
当使用页面锁时，可以防止其他事务修改被锁定的页，但不会阻止查询操作。
页面锁主要用于一些低并发的情况，因为它的粒度较大，对并发访问的影响较大。
* 表锁（Table Lock）：表锁是针对整个表进行锁定，防止其他事务对整个表进行修改。表锁的粒度最粗，对并发访问的影响最大。
* 事务锁（Transaction Lock）：事务锁是一种内部锁，用于保护事务的并发执行。
事务锁会锁定事务涉及的所有数据，确保在事务执行期间，其他事务不能对这些数据进行修改。
事务锁与行锁、表锁等不同，它不是用户直接控制的，而是由数据库系统自动管理。

这些锁类型的主要区别在于锁定对象的粒度不同。行锁是最细粒度的锁，页面锁和表锁的粒度较粗，而事务锁是一种内部锁，不直接由用户控制。

在并发控制中，根据不同的业务需求和并发情况选择合适的锁类型是非常重要的。
行锁适用于高并发读写的情况，页面锁和表锁适用于读操作较多、写操作较少的情况，而事务锁则用于保护事务的并发执行。

需要注意的是，不同的锁类型可能会产生死锁或其他并发问题，因此在使用时需要谨慎处理，避免过度锁定或冲突。

### 22 事务隔离级别

**隔离级别**

MySQL中事务的隔离级别包括以下四种：
* 读未提交（Read Uncommitted）：这是事务隔离级别的最低级别。在这种隔离级别下，一个事务可以看到其他未提交事务的变动。
这种隔离级别会导致很多问题，如脏读（Dirty Read），即一个事务读取了另一个未提交事务的数据。
* 读提交（Read Committed）：这是事务隔离级别的第二个级别。在这个隔离级别下，一个事务只能看到其他事务已经提交的变动。
这种隔离级别解决了脏读问题，但可能会出现不可重复读（Non-repeatable Read），即在同一事务中，多次读取同一数据返回的结果有所不同。
* 可重复读（Repeatable Read）：这是事务隔离级别的第三个级别。在这个隔离级别下，同一事务中多次读取同一数据会返回相同的结果，
除非本事务自己改变它。这种隔离级别可以解决不可重复读的问题，但仍可能会产生幻读（Phantom Read）现象，
即在一个事务内部无法看到其他事务插入的新记录。
* 串行化（Serializable）：这是事务隔离级别的最高级别。在这个隔离级别下，事务串行化顺序执行，
可以避免脏读、不可重复读与幻读的问题。但是这种隔离级别效率低下，因为事务通常需要等待前一个事务完成，才能继续执行。

需要注意的是，这些隔离级别是层层递增的，即串行化的隔离级别最高，而读未提交的隔离级别最低。
不同的隔离级别可以解决不同的问题，但也会影响数据库的并发性能。在实际应用中，需要根据具体情况选择合适的隔离级别。

**幻读解读**

在MySQL的事务中，幻读（Phantom Read）是一种并发控制问题，是指在事务内部执行相同的查询语句，却返回了不同的结果。
在可重复读（Repeatable Read）隔离级别下，事务保持一致性的一个关键假设是，多次相同的查询会返回相同的结果。
然而，幻读破坏了这一假设，因为在事务执行过程中，其他事务可以插入新的记录，从而在再次执行查询时返回新的记录，导致结果集发生变化。

举个例子来说明幻读现象：假设有一个表，其中包含职工的工资信息。同时开启两个事务，事务A和事务B。
在事务A中，一个职工的工资被修改为1000元。在事务B中，有一个查询语句获取工资大于500元的职工信息，该查询语句返回了事务A修改前的职工信息。
当事务A提交后，事务B再次执行相同的查询语句，返回的结果集发生了变化，这就是幻读现象。

为了解决幻读问题，可以将事务的隔离级别提高到串行化（Serializable）级别，这样可以确保事务的执行是串行的，
避免了幻读和其他并发控制问题。但是，这种隔离级别的并发性能较低，因为事务通常需要等待前一个事务完成才能继续执行。
因此，在实际应用中，需要权衡隔离级别和并发性能，选择合适的隔离级别来解决幻读问题。

解决办法参阅 <https://baijiahao.baidu.com/s?id=1759957900969624056>

方法一：采用锁机制

在MySQL中，可以使用锁机制解决幻读问题。锁机制可以将一些资源标记为独占状态，
防止其他事务对该资源进行修改，从而确保数据的一致性。

MySQL中提供了两种锁机制：行锁和表锁。行锁可以锁定指定行，而表锁可以锁定整个表。
如果只需要保护某一行不被其他事务修改，可以采用行锁；如果需要保护整个表不被修改，可以采用表锁。

在使用锁机制时，需要注意以下几点：
* 尽量缩小锁的范围，避免对整个表进行锁定；
* 锁定的时间应该尽量短，以免影响其他事务的执行；
* 避免死锁的产生。

方法二：采用MVCC机制

MySQL中还提供了MVCC（多版本并发控制）机制，可以有效地解决幻读问题。MVCC机制会为每个事务创建一个可见性视图，
用于记录每个事务可以看到的数据版本。当一个事务查询数据时，会根据自己的可见性视图获取相应的数据版本，从而避免幻读问题的出现。

在使用MVCC机制时，需要注意以下几点：
* 尽量使用InnoDB存储引擎，因为MyISAM不支持MVCC；
* 在事务中执行多个查询时，要使用相同的一致性级别，以保证数据的一致性；
* 避免长时间的事务执行，以免占用过多的资源。

**幻读解决案例**

下面我们将通过一个实际的案例来说明如何使用锁机制和MVCC机制解决幻读问题。

假设我们有一个名为orders的表，包含如下字段：

    id：订单ID
    user_id：用户ID
    amount：订单金额

现在我们有两个并发事务，分别为事务A和事务B。事务A要插入一条记录，事务B要查询所有用户的订单总金额。
如果不采取任何措施，就可能出现幻读问题。

一、使用锁机制解决幻读问题

我们可以在事务A执行插入操作时，对整个表进行排它锁定。这样一来，事务B就无法执行查询操作，直到事务A释放锁。

以下是示例代码：
```
-- 事务A
BEGIN;
SELECT * FROM orders WHERE user_id = 1 FOR UPDATE;
INSERT INTO orders (user_id, amount) VALUES (1, 100);
COMMIT;

-- 事务B
BEGIN;
SELECT SUM(amount) FROM orders;
COMMIT;
```

在事务A执行`SELECT * FROM orders WHERE user_id = 1 FOR UPDATE;`语句时，会对orders表进行排它锁定。
这样一来，事务B执行查询操作时就无法读取数据，直到事务A释放锁。这样就可以避免幻读问题的出现。

二、使用MVCC机制解决幻读问题

我们可以在事务B执行查询操作时，指定一致性级别为“可重复读”，这样就可以避免事务A对数据的修改对事务B造成干扰。

以下是示例代码：
```
-- 事务A
BEGIN;
INSERT INTO orders (user_id, amount) VALUES (1, 100);
COMMIT;

-- 事务B
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN;
SELECT SUM(amount) FROM orders;
COMMIT;
```

在事务B执行查询操作时，通过`SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;`语句设置一致性级别为“可重复读”。
这样一来，事务B就能够读取到之前的数据版本，而不受事务A的修改影响，从而避免幻读问题的出现。





<br/><br/><br/><br/><br/>
## 参考资料

SQL面试题，快问快答！ <https://mp.weixin.qq.com/s/I8IcSbLV7tor8L84x19A4g>

Mysql联合索引最左匹配原则 <https://segmentfault.com/a/1190000015416513>

数据库为什么要用B+树结构 <https://blog.csdn.net/bigtree_3721/article/details/73151472>
