---
layout: post
categories: MySQL
title: MySQL 索引与优化
meta: 细细研究。
---
* content
{:toc}

## 正文

细细研究
 
![]({{site.baseurl}}/images/20200330/20200330191563.jpeg)

### 索引的类型

索引是在存储引擎中实现的，而不是在服务器层中实现的。所以，每种存储引擎的索引都不一定完全相同，并不是所有的存储引擎都支持所有的索引类型。

#### B-Tree索引

假设有如下一个表：
```
CREATE TABLE People (
   last_name varchar(50)    not null,
   first_name varchar(50)    not null,
   dob        date           not null,
   gender     enum('m', 'f') not null,
   key(last_name, first_name, dob)
);
```

其索引包含表中每一行的last_name、first_name和dob列。其结构大致如下：

![]({{site.baseurl}}/images/20210507/20210507161148.png)

索引存储的值按索引列中的顺序排列。可以利用B-Tree索引进行全关键字、关键字范围和关键字前缀查询，
当然，如果想使用索引，你必须保证按索引的最左边前缀(leftmost prefix of the index)来进行查询。

(1)匹配全值(Match the full value)：对索引中的所有列都指定具体的值。例如，上图中索引可以帮助你查找出生于1960-01-01的Cuba Allen。

(2)匹配最左前缀(Match a leftmost prefix)：你可以利用索引查找last name为Allen的人，仅仅使用索引中的第1列。

(3)匹配列前缀(Match a column prefix)：例如，你可以利用索引查找last name以J开始的人，这仅仅使用索引中的第1列。

(4)匹配值的范围查询(Match a range of values)：可以利用索引查找last name在Allen和Barrymore之间的人，仅仅使用索引中第1列。

(5)匹配部分精确而其它部分进行范围匹配(Match one part exactly and match a range on another part)：可以利用索引查找last name为Allen，而first name以字母K开始的人。

(6)仅对索引进行查询(Index-only queries)：如果查询的列都位于索引中，则不需要读取元组的值。

由于B-树中的节点都是顺序存储的，所以可以利用索引进行查找(找某些值)，也可以对查询结果进行ORDER BY。当然，使用B-tree索引有以下一些限制：

(1) 查询必须从索引的最左边的列开始。关于这点已经提了很多遍了。例如你不能利用索引查找在某一天出生的人。

(2) 不能跳过某一索引列。例如，你不能利用索引查找last name为Smith且出生于某一天的人。

(3) 存储引擎不能使用索引中范围条件右边的列。例如，如果你的查询语句为`WHERE last_name="Smith" AND first_name LIKE 'J%' AND dob='1976-12-23'`，
则该查询只会使用索引中的前两列，因为LIKE是范围查询。

#### Hash索引

MySQL中，只有Memory存储引擎显示支持hash索引，是Memory表的默认索引类型，尽管Memory表也可以使用B-Tree索引。
Memory存储引擎支持非唯一hash索引，这在数据库领域是罕见的，如果多个值有相同的hash code，索引把它们的行指针用链表保存到同一个hash表项中。

假设创建如下一个表：
```
CREATE TABLE testhash (
    fname VARCHAR(50) NOT NULL,
    lname VARCHAR(50) NOT NULL,
    KEY USING HASH(fname)
) ENGINE=MEMORY;
```

![]({{site.baseurl}}/images/20210507/20210507161900.png)

Slots是有序的，但是记录不是有序的。当你执行`mysql> SELECT lname FROM testhash WHERE fname='Peter';`，
MySQL会计算’Peter’的hash值，然后通过它来查询索引的行指针。因为f('Peter') = 8784，MySQL会在索引中查找8784，得到指向记录3的指针。
因为索引自己仅仅存储很短的值，所以，索引非常紧凑。Hash值不取决于列的数据类型，一个TINYINT列的索引与一个长字符串列的索引一样大。

Hash索引有以下一些限制：

(1)由于索引仅包含hash code和记录指针，所以，MySQL不能通过使用索引避免读取记录。但是访问内存中的记录是非常迅速的，不会对性造成太大的影响。

(2)不能使用hash索引排序。

(3)Hash索引不支持键的部分匹配，因为是通过整个索引值来计算hash值的。

(4)Hash索引只支持等值比较，例如使用=，IN( )和<=>。对于WHERE price>100并不能加速查询。

#### 空间(R-Tree)索引

MyISAM支持空间索引，主要用于地理空间数据类型，例如GEOMETRY。

#### 全文(Full-text)索引

全文索引是MyISAM的一个特殊索引类型，主要用于全文检索。

### 高性能的索引策略

参见 <https://www.cnblogs.com/hustcat/archive/2009/10/28/1591648.html> ， 待整理

### key 与 index 的区别

KEY通常是INDEX同义词。

Key即键值，是关系模型理论中的一部份，比如有主键（Primary Key)，外键（Foreign Key）等，用于数据完整性检否与唯一性约束等。

而Index则处于实现层面，比如可以对表的任意列建立索引，那么当建立索引的列处于SQL语句中的Where条件中时，就可以得到快速的数据定位，从而快速检索。

#### key

key 是数据库的物理结构，它包含两层意义和作用：

    一是约束（偏重于约束和规范数据库的结构完整性），
    二是索引（辅助查询用的）。

包括primary key, unique key, foreign key 等。

##### primary key

primary key 有两个作用，一是约束作用（constraint），用来规范一个存储主键和唯一性，但同时也在此key上建立了一个主键索引；

PRIMARY KEY 约束：唯一标识数据库表中的每条记录；

    主键必须包含唯一的值；
    主键列不能包含 NULL 值；
    每个表都应该有一个主键，并且每个表只能有一个主键。

（PRIMARY KEY 拥有自动定义的 UNIQUE 约束）

##### unique key

unique key 也有两个作用，一是约束作用（constraint），规范数据的唯一性，但同时也在这个key上建立了一个唯一索引；

UNIQUE 约束：唯一标识数据库表中的每条记录。

    UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。
    （每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束）

##### foreign key

foreign key 也有两个作用，一是约束作用（constraint），规范数据的引用完整性，但同时也在这个key上建立了一个index；

可见，mysql的key是同时具有constraint和index的意义，这点和其他数据库表现的可能有区别。

（至少在Oracle上建立外键，不会自动建立index），因此创建key也有如下几种方式：

（1）在字段级以key方式建立， 如 `create table t (id int not null primary key);`

（2）在表级以constraint方式建立，如`create table t(id int, CONSTRAINT pk_t_id PRIMARY key (id));`

（3）在表级以key方式建立，如`create table t(id int, primary key (id));`

其它key创建类似，但不管那种方式，既建立了constraint，又建立了index，只不过index使用的就是这个constraint或key。

#### index

index是数据库的物理结构，它只是辅助查询的，它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储。
索引要分类的话，分为前缀索引、全文本索引等；

因此，索引只是索引，它不会去约束索引的字段的行为（那是key要做的事情）。
如 `create table test(id int, index idx_id (id));`

### 增加索引

一种是在表创建时就增加索引，如：
```
CREATE TABLE `complaint_channel` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `workorder_id` int(11) NOT NULL COMMENT '工单ID',
  `channel_type` tinyint(4) NOT NULL DEFAULT '0' COMMENT '投诉渠道类型，1：400电话，2：公众号/app留言，3：公众号/app投诉建议，99：其他',
  `created_time` int(11) NOT NULL COMMENT '添加时间',
  PRIMARY KEY (`id`),
  KEY `idx_workorder_id` (`workorder_id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='投诉渠道记录表';
```

idx_workorder_id 就是增加的 索引。

一种是后期新增，如：
```
ALTER TABLE `workorder` ADD INDEX idx_type_id (`type_id`) ;
```

idx_type_id 就是增加的 索引。

### 读取提速

一种读取慢的可能是分页查询，第一页1s以内，第二页2s，第三页3s，第四页4s......随着页数增加，读取时间越来越长，
这是MySQl底层决定的，查询后面页码数据时，会先过一遍前几页的数据，所以时间变长了。
解决的办法是第2页查询时，改成第1页查询的语句结构。

如，获取第6页;
`SELECT id FROM user WHERE status = 1 limit 500 100;`

改为：
`SELECT id FROM user WHERE status = 1 AND id > 1275 limit 0 100;`

把第5页获取到的最后一个id，作为下一页查询的过滤条件。

### alert用法

1：删除列

ALTER TABLE 【表名字】 DROP 【列名称】

2：增加列

ALTER TABLE 【表名字】 ADD 【列名称】 INT NOT NULL  COMMENT '注释说明'

3：修改列的类型信息

ALTER TABLE 【表名字】 CHANGE 【列名称】【新列名称（这里可以用和原来列同名即可）】 BIGINT NOT NULL  COMMENT '注释说明'

4：重命名列

ALTER TABLE 【表名字】 CHANGE 【列名称】【新列名称】 BIGINT NOT NULL  COMMENT '注释说明'

5：重命名表

ALTER TABLE 【表名字】 RENAME 【表新名字】

6：删除表中主键

Alter TABLE 【表名字】 drop primary key

7：添加主键

ALTER TABLE sj_resource_charges ADD CONSTRAINT PK_SJ_RESOURCE_CHARGES PRIMARY KEY (resid,resfromid)

8：添加索引

ALTER TABLE sj_resource_charges add index INDEX_NAME (name);

9: 添加唯一限制条件索引

ALTER TABLE sj_resource_charges add unique emp_name2(cardnumber);

10: 删除索引

alter table tablename drop index emp_name;


删除列

alter table test.hat_area drop column area3

alter table test.hat_area drop add_area

更名

alter table test.hat_area change area2 area3 int

增加列

alter table test.hat_area add add_area int not null comment 'new add'

更改列的信息

alter table test.hat_area change father lenth bigint null

重命名表

ALTER TABLE 【表名字】 RENAME 【表新名字】

删除表中主键

Alter TABLE 【表名字】 drop primary key

时自增长的以1为开始

Alter table tb change id id int(10) not null auto_increment=1;

删除自增长

alter table test.hat_area change id id int(10)

删除主键

alter table test.hat_area drop primary key

增加主键

alter table test.hat_area add primary key(id,areaid)

 添加索引

alter table test.hat_area add index new_index2(id)

删除索引

alter table test.hat_area drop index new_index2;

添加唯一限制条件索引

alter table test.hat_area add unique emp_name2(id);


添加主键约束：

alter table 表名 add constraint 主键 （形如：PK_表名） primary key 表名(主键字段);

添加外键约束：

alter table 从表 add constraint 外键（形如：FK_从表_主表） foreign key 从表(外键字段) references 主表(主键字段);

删除主键约束：

alter table 表名 drop primary key;

删除外键约束：

alter table 表名 drop foreign key 外键（区分大小写）;

添加列：

alter table 表名 add column 列名 varchar(30);

删除列：

alter table 表名 drop column 列名;

修改列名MySQL：

alter table bbb change nnnnn hh int;

修改列属性：

alter table t_book modify name varchar(22);

外键约束对子表的含义:    如果在父表中找不到候选键,则不允许在子表上进行insert/update

外键约束对父表的含义:    在父表上进行update/delete以更新或删除在子表中有一条或多条对应匹配行的候选键时,父表的行为取决于：在定义子表的外键时指定的on update/on delete子句

1

InnoDB支持５种方式, 分列如下

cascade方式 在父表上update/delete记录时，同步update/delete掉子表的匹配记录 On delete cascade从mysql3.23.50开始可用; on update cascade从mysql4.0.8开始可用 

2

set null方式 在父表上update/delete记录时，将子表上匹配记录的列设为null 要注意子表的外键列不能为not null On delete set null从mysql3.23.50开始可用; on update set null从mysql4.0.8开始可用 

3

No action方式 如果子表中有匹配的记录,则不允许对父表对应候选键进行update/delete操作 这个是ANSI SQL-92标准,从mysql4.0.8开始支持 

4

Restrict 方式 同no action, 都是立即检查外键约束    . Set default方式 解析器认识这个action,但Innodb不能识别，不知道是什么意思．．．      注意：trigger不会受外键cascade行为的影响,即不会解发trigger





<br/><br/><br/><br/><br/>
## 参考资料 

理解MySQL——索引与优化 <https://www.cnblogs.com/hustcat/archive/2009/10/28/1591648.html>

Mysql中key 、primary key 、unique key 与index区别 <https://www.cnblogs.com/zjfjava/p/6922494.html>

MySQL 索引 <https://www.runoob.com/mysql/mysql-index.html>

mysql索引总结----mysql 索引类型以及创建 <http://blog.csdn.net/xluren/article/details/32746183>

MySQL之alter语句用法总结 <http://blog.sina.com.cn/s/blog_6aba78b40102wi0k.html>

mysql 索引(index)  <http://blog.sina.com.cn/s/blog_9707fac301016xmp.html>

