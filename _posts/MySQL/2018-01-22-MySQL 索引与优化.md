---
layout: post
categories: MySQL
title: MySQL 索引与优化
meta: 细细研究。
---
* content
{:toc}

## 正文

细细研究
 
![]({{site.baseurl}}/images/20200330/20200330191563.jpeg)

### 索引的类型

索引是在存储引擎中实现的，而不是在服务器层中实现的。所以，每种存储引擎的索引都不一定完全相同，并不是所有的存储引擎都支持所有的索引类型。

#### B-Tree索引

假设有如下一个表：
```
CREATE TABLE People (
   last_name varchar(50)    not null,
   first_name varchar(50)    not null,
   dob        date           not null,
   gender     enum('m', 'f') not null,
   key(last_name, first_name, dob)
);
```

其索引包含表中每一行的last_name、first_name和dob列。其结构大致如下：

![]({{site.baseurl}}/images/20210507/20210507161148.png)

索引存储的值按索引列中的顺序排列。可以利用B-Tree索引进行全关键字、关键字范围和关键字前缀查询，
当然，如果想使用索引，你必须保证按索引的最左边前缀(leftmost prefix of the index)来进行查询。

(1)匹配全值(Match the full value)：对索引中的所有列都指定具体的值。例如，上图中索引可以帮助你查找出生于1960-01-01的Cuba Allen。

(2)匹配最左前缀(Match a leftmost prefix)：你可以利用索引查找last name为Allen的人，仅仅使用索引中的第1列。

(3)匹配列前缀(Match a column prefix)：例如，你可以利用索引查找last name以J开始的人，这仅仅使用索引中的第1列。

(4)匹配值的范围查询(Match a range of values)：可以利用索引查找last name在Allen和Barrymore之间的人，仅仅使用索引中第1列。

(5)匹配部分精确而其它部分进行范围匹配(Match one part exactly and match a range on another part)：可以利用索引查找last name为Allen，而first name以字母K开始的人。

(6)仅对索引进行查询(Index-only queries)：如果查询的列都位于索引中，则不需要读取元组的值。

由于B-树中的节点都是顺序存储的，所以可以利用索引进行查找(找某些值)，也可以对查询结果进行ORDER BY。当然，使用B-tree索引有以下一些限制：

(1) 查询必须从索引的最左边的列开始。关于这点已经提了很多遍了。例如你不能利用索引查找在某一天出生的人。

(2) 不能跳过某一索引列。例如，你不能利用索引查找last name为Smith且出生于某一天的人。

(3) 存储引擎不能使用索引中范围条件右边的列。例如，如果你的查询语句为`WHERE last_name="Smith" AND first_name LIKE 'J%' AND dob='1976-12-23'`，
则该查询只会使用索引中的前两列，因为LIKE是范围查询。

#### Hash索引

MySQL中，只有Memory存储引擎显示支持hash索引，是Memory表的默认索引类型，尽管Memory表也可以使用B-Tree索引。
Memory存储引擎支持非唯一hash索引，这在数据库领域是罕见的，如果多个值有相同的hash code，索引把它们的行指针用链表保存到同一个hash表项中。

假设创建如下一个表：
```
CREATE TABLE testhash (
    fname VARCHAR(50) NOT NULL,
    lname VARCHAR(50) NOT NULL,
    KEY USING HASH(fname)
) ENGINE=MEMORY;
```

![]({{site.baseurl}}/images/20210507/20210507161900.png)

Slots是有序的，但是记录不是有序的。当你执行`mysql> SELECT lname FROM testhash WHERE fname='Peter';`，
MySQL会计算’Peter’的hash值，然后通过它来查询索引的行指针。因为f('Peter') = 8784，MySQL会在索引中查找8784，得到指向记录3的指针。
因为索引自己仅仅存储很短的值，所以，索引非常紧凑。Hash值不取决于列的数据类型，一个TINYINT列的索引与一个长字符串列的索引一样大。

Hash索引有以下一些限制：

(1)由于索引仅包含hash code和记录指针，所以，MySQL不能通过使用索引避免读取记录。但是访问内存中的记录是非常迅速的，不会对性造成太大的影响。

(2)不能使用hash索引排序。

(3)Hash索引不支持键的部分匹配，因为是通过整个索引值来计算hash值的。

(4)Hash索引只支持等值比较，例如使用=，IN( )和<=>。对于WHERE price>100并不能加速查询。

#### 空间(R-Tree)索引

MyISAM支持空间索引，主要用于地理空间数据类型，例如GEOMETRY。

#### 全文(Full-text)索引

全文索引是MyISAM的一个特殊索引类型，主要用于全文检索。

### 高性能的索引策略

参见 <https://www.cnblogs.com/hustcat/archive/2009/10/28/1591648.html> ， 待整理

### key 与 index 的区别

KEY通常是INDEX同义词。

Key即键值，是关系模型理论中的一部份，比如有主键（Primary Key)，外键（Foreign Key）等，用于数据完整性检否与唯一性约束等。

而Index则处于实现层面，比如可以对表的任意列建立索引，那么当建立索引的列处于SQL语句中的Where条件中时，就可以得到快速的数据定位，从而快速检索。

#### key

key 是数据库的物理结构，它包含两层意义和作用：

    一是约束（偏重于约束和规范数据库的结构完整性），
    二是索引（辅助查询用的）。

包括primary key, unique key, foreign key 等。

##### primary key

primary key 有两个作用，一是约束作用（constraint），用来规范一个存储主键和唯一性，但同时也在此key上建立了一个主键索引；

PRIMARY KEY 约束：唯一标识数据库表中的每条记录；

    主键必须包含唯一的值；
    主键列不能包含 NULL 值；
    每个表都应该有一个主键，并且每个表只能有一个主键。

（PRIMARY KEY 拥有自动定义的 UNIQUE 约束）

##### unique key

unique key 也有两个作用，一是约束作用（constraint），规范数据的唯一性，但同时也在这个key上建立了一个唯一索引；

UNIQUE 约束：唯一标识数据库表中的每条记录。

    UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。
    （每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束）

##### foreign key

foreign key 也有两个作用，一是约束作用（constraint），规范数据的引用完整性，但同时也在这个key上建立了一个index；

可见，mysql的key是同时具有constraint和index的意义，这点和其他数据库表现的可能有区别。

（至少在Oracle上建立外键，不会自动建立index），因此创建key也有如下几种方式：

（1）在字段级以key方式建立， 如 create table t (id int not null primary key);

（2）在表级以constraint方式建立，如create table t(id int, CONSTRAINT pk_t_id PRIMARY key (id));

（3）在表级以key方式建立，如create table t(id int, primary key (id));

其它key创建类似，但不管那种方式，既建立了constraint，又建立了index，只不过index使用的就是这个constraint或key。

#### index

index是数据库的物理结构，它只是辅助查询的，它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储。
索引要分类的话，分为前缀索引、全文本索引等；

因此，索引只是索引，它不会去约束索引的字段的行为（那是key要做的事情）。
如 `create table test(id int, index idx_id (id));`

### 增加索引

一种是在表创建时就增加索引，如：
```
CREATE TABLE `complaint_channel` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `workorder_id` int(11) NOT NULL COMMENT '工单ID',
  `channel_type` tinyint(4) NOT NULL DEFAULT '0' COMMENT '投诉渠道类型，1：400电话，2：公众号/app留言，3：公众号/app投诉建议，99：其他',
  `created_time` int(11) NOT NULL COMMENT '添加时间',
  PRIMARY KEY (`id`),
  KEY `idx_workorder_id` (`workorder_id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='投诉渠道记录表';
```

idx_workorder_id 就是增加的 索引。

一种是后期新增，如：
```
ALTER TABLE `workorder` ADD INDEX idx_type_id (`type_id`) ;
```

idx_type_id 就是增加的 索引。

### 读取提速

一种读取慢的可能是分页查询，第一页1s以内，第二页2s，第三页3s，第四页4s......随着页数增加，读取时间越来越长，
这是MySQl底层决定的，查询后面页码数据时，会先过一遍前几页的数据，所以时间变长了。
解决的办法是第2页查询时，改成第1页查询的语句结构。

如，获取第6页;
`SELECT id FROM user WHERE status = 1 limit 500 100;`

改为：
`SELECT id FROM user WHERE status = 1 AND id > 1275 limit 0 100;`

把第5页获取到的最后一个id，作为下一页查询的过滤条件。

<br/><br/><br/><br/><br/>
## 参考资料 

理解MySQL——索引与优化 <https://www.cnblogs.com/hustcat/archive/2009/10/28/1591648.html>

Mysql中key 、primary key 、unique key 与index区别 <https://www.cnblogs.com/zjfjava/p/6922494.html>

MySQL 索引 <https://www.runoob.com/mysql/mysql-index.html>

mysql索引总结----mysql 索引类型以及创建 <http://blog.csdn.net/xluren/article/details/32746183>



