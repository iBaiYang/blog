---
layout: post
categories: IT技术
title: TCP图解
meta: TCP图解
---
* content
{:toc}

### 正文

![]({{site.baseurl}}/images/20210325/20210325193755.jpg)

#### 问题来了

#### 丢包问题

#### 效率问题

#### 顺序问题

#### 流量问题

#### 拥塞问题

#### 连接问题

TCP 的三次握手，是需要**确认**双方的两样能力: **发送的能力**和**接收的能力**。于是便会有下面的三次握手的过程:

![]({{site.baseurl}}/images/20210325/20210325193417.jpg)

**为什么不是两次？**

根本原因: 无法确认客户端的接收能力。

分析如下:

如果是两次，你现在发了 SYN 报文想握手，但是这个包滞留在了当前的网络中迟迟没有到达，
TCP 以为这是丢了包，于是重传，两次握手建立好了连接。

看似没有问题，但是连接关闭后，如果这个滞留在网路中的包到达了服务端呢？这时候由于是两次握手，
服务端只要接收到然后发送相应的数据包，就默认建立连接，但是现在客户端已经断开了。

看到问题的吧，这就带来了连接资源的浪费。

**为什么不是四次？**

三次握手的目的是确认双方发送和接收的能力，那四次握手可以嘛？

当然可以，100 次都可以。但为了解决问题，三次就足够了，再多用处就不大了。

**三次握手过程中可以携带数据么？**

第三次握手的时候，可以携带。前两次握手不能携带数据。

如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，
那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险。

第三次握手的时候，客户端已经处于ESTABLISHED状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。

**同时打开会怎样？**

如果双方同时发 SYN报文，状态变化会是怎样的呢？

这是一个可能会发生的情况。

状态变迁如下:

![]({{site.baseurl}}/images/20210325/20210325194913.jpg)

在发送方给接收方发SYN报文的同时，接收方也给发送方发SYN报文，两个人刚上了!

发完SYN，两者的状态都变为SYN-SENT。

在各自收到对方的SYN后，两者状态都变为SYN-REVD。

接着会回复对应的ACK + SYN，这个报文在对方接收之后，两者状态一起变为ESTABLISHED。

这就是同时打开情况下的状态变迁。

#### 总结

TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。
上面过程中需要传输的信息，就体现在 TCP 协议的头部，TCP 协议头：

![]({{site.baseurl}}/images/20210205/20210205183704.png)

面向连接、可靠，这两个词通过上面的讲述很容易理解，那什么叫做基于字节流呢？很简单，TCP 在建立连接时，需要告诉对方 MSS（最大报文段大小）。
也就是说，如果要发送的数据很大，在 TCP 层是需要按照 MSS 来切割成一个个的 TCP 报文段 的。切割的时候我才不管你原来的数据表示什么意思，
需要在哪里断句啥的，我就把它当成一串毫无意义的字节，在我想要切割的地方咔嚓就来一刀，标上序号，
只要接收方再根据这个序号拼成最终想要的完整数据就行了。在我 TCP 传输这里，我就把它当做一个个的字节，也就是基于字节流的含义了。


<br/><br/><br/><br/><br/>
### 参考资料

图解  原来这就是TCP <https://cnblogs.com/flashsun/p/14322660.html>

TCP协议面试10连问，网友直呼太强！  <https://mp.weixin.qq.com/s/BRVJWcXZvQjKBCs_dQzSjw>

图解  原来这就是网络 <https://www.cnblogs.com/flashsun/p/14266148.html>