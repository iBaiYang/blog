---
layout: post
categories: IT技术
title: IT心得整理
meta: IT心得整理
---
* content
{:toc}
  
## 引言

在学习技术的过程中，看一篇材料，会觉得自己理解了，也做了记录，
但过段时间却不知道曾经看过什么，在解决一个问题时要用什么技术了。

所以有了这篇IT心得整理，旨在时时提醒自己和随时查阅学习心得。

这里只记录心得，具体技术内容翻阅记录文档。

## 2023.01.03

TCP、UDP，从本质上来说，都是把信息发送到对端，TCP也并没有持续占用网线一说，
只是在系统软件层面来说，TCP实现了下一次发送是基于上一次信息接受成功的基础上。
从这个角度而言，我们也完全可以用UDP实现TCP的特性：发送端发送信息，接收端接受信息；
当接收端接受到信息时，发送接受成功通知给发送端；如果持续一段时间，发送端还没有收到接收端接受成功的通知，就再发送一次；
同理，三次握手、四次挥手也可以用这种方式实现。

## 2023.01.04

提前说一下开闭原则：软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的。

下面说一下四种工厂模式的异同。

简单工厂模式：一个工厂用来生产同一等级结构中的多款产品。不符合开闭原则，无法新增产品。
如在工厂中传入参数获取电视、手机。

静态工厂模式：和简单工厂相似，只是产品获取方法换成了静态方法。获取产品时，不需要实例化工厂了。

工厂方法模式：多个工厂获取对应工厂的一个产品（同一等级结构）。符合开闭原则，但无法在旧工厂中增删产品。
支持增加产品，新增产品时也新建该产品的生产工厂。
如奥克斯空调厂只能生产奥克斯空调，格力空调厂只能生产格力空调；
从工厂来说，奥克斯空调厂和格力空调厂都是空调厂；
从产品来说，奥克斯空调和格力空调都是空调。
如果新增了海尔空调，就需要新建海尔空调厂。

抽象工厂模式：多个工厂获取对应工厂的一族产品。符合开闭原则，但无法在旧工厂中新增产品，
不过可以新增一族产品，然后组建相应的新工厂。
如奔驰厂生产带格力空调的奔驰车，宝马厂生产带海尔空调的宝马车。
格力空调 + 奔驰车 是一个产品族，海尔空调 + 宝马车 是一个产品族；
格力空调和海尔空调都是空调，奔驰车和宝马车都是车；
奔驰厂和宝马厂就是相应的工厂。
如果新增了奥克斯空调，不能换到奔驰厂中去，不过如果新增了奥迪车，
可以新建一个奥迪厂，用来生产带奥克斯空调的奥迪车。
一个工厂中不一定非要获取一条流水线上出来的产品，如最终的成品车，
也可以获取不同的产品，如获取这个工厂用了什么空调、轮胎等。
当然上面的车厂不一定非要生产汽车，也可以同时生产轮船。

**工厂方法模式与抽象工厂模式的区别**

工厂方法模式：
1. 一个抽象产品类，可以派生出多个具体产品类。
2. 一个抽象工厂类，可以派生出多个具体工厂类。
3. 每个具体工厂类只能创建一个具体产品类的实例。

抽象工厂模式：
1. 多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。
2. 一个抽象工厂类，可以派生出多个具体工厂类。
3. 每个具体工厂类可以创建多个具体产品类的实例。

<https://ibaiyang.github.io/blog/php/2019/07/30/PHP-创建型模式.html#简单工厂模式simple-factory>

建造者模式：建造者可以说就是工厂，只是对比工厂模式多了一个导演类（依赖注入一个建造者类）。
工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品。
而建造者模式中，建造者类一般只提供产品类中**各个组件**的建造，而将**完整建造**过程交付给导演类。

## 2023.01.05

同步：我去询问交代的事是否处理完成。阻塞：我不去做其他事。

异步：交代的事情处理完后通知我。非阻塞：我去做其他事了。

IO多路复用：多路是指多个客户端连接socket，复用就是指复用少数几个进程。
多路复用本身依然隶属于同步通信方式，只是表现出的结果看起来像异步。

多路复用三种常用的方案：
* select，最早的解决方案，同步的。
* poll，算是select的升级版。
* epoll，目前的最终解决版，解决c10k问题的功臣，epoll是同步的，而不是异步。

select 有信息过来，轮询查看是哪个socket连接可以读写了。

epoll 直接对客户端socket连接进行监听，有信息过来，进行处理。

<https://ibaiyang.github.io/blog/php/2020/07/01/PHP-Socket初探.html>

## 2023.01.06

PHP 用 yield 来实现协程。yield返回的是一个叫做Generator（中文名就是生成器）的object对象，
而这个生成器是实现了Iterator（迭代器）接口。

<https://ibaiyang.github.io/blog/php/2020/07/01/PHP-Socket初探.html#17-php中的yield上>

## 2023.01.09

ReactPHP是事件驱动的，非阻塞I/O的PHP，它和Node.js都是采用单进程和单线程的方式，适用于I/O密集型，不适用于计算密集型。 

客户端请求时，使用异步模式发起请求，然后继续向下执行，等服务端返回处理结果后再对这个结果做处理；
一个文件中客户端可以先后发起多个请求。

服务端处理时，接收到一个客户端请求，然后把这个请求移交给处理函数，接下来继续等待下一个客户端请求，
处理函数处理完成后直接把处理结果发送给客户端。

<https://ibaiyang.github.io/blog/php/2020/06/22/ReactPHP实践.html>

## 2023.01.11

在依赖注入和依赖注入容器中会讲到：依赖倒置原则、控制反转、依赖注入、控制反转容器、服务定位器。

依赖倒置原则是说上层定义接口，下层实现这个接口，这样所依赖的下层类就必须按照上层类定义的接口来编程。

但什么叫控制反转呢？里面说到控制反转的核心是将类（上层）所依赖的单元（下层）的实例化过程交由第三方来实现。
过去一直没想明白，突然一下有感觉了：控制反转就是说上层类只管从第三方来获取依赖类（下层类），
而不用去不管下层类具体怎样实现。原来的过程是从下层类开始一步一步实例化类，然后注入到上层类中，
由下层决定提供什么给上层.

依赖注入指的是把依赖的对象注入目标对象中去，但这与上面的那几个词有什么关系呢？
在没有依赖注入时，我们要在目标对象中直接实例化所依赖的类，这样就破坏了控制反转，或者说不存在控制反转这个词了：
控制反转讲的就是上层类要去获取所依赖的类，而不是在自己内部实例化。

<https://ibaiyang.github.io/blog/yii2/2019/06/28/深入理解Yii2.0-依赖注入和依赖注入容器.html#有关概念>

## 2023.01.13

在面向对象编程中，属性和成员变量并不是一个概念，成员变量是一个“内”概念，反映的是类的结构构成。
属性是一个“外”概念，反映的是类的逻辑意义。

一般要让成员变量对外不可见。如果成员变量对外可见，就失去了类的封装性。
现在图一时痛快，但以后项目代码的修改会是个麻烦事。

<https://ibaiyang.github.io/blog/yii2/2019/06/19/深入理解Yii2.0-属性.html>

## 2023.01.15

在PHP项目开发中，碰到一个封装好的HTTP客户端：guzzlehttp/guzzle 包，可以轻松发送 HTTP 请求并轻松与 Web 服务集成。

用于构建查询字符串、POST 请求、流式传输大型上传、流式传输大型下载、使用 HTTP cookie、上传 JSON 数据等的简单界面…

可以使用相同的接口发送同步和异步请求。

对请求、响应和流使用 PSR-7 接口，允许在 Guzzle 中使用其他 PSR-7 兼容库。
支持 PSR-18，允许其他 PSR-18 HTTP 客户端之间的互操作性。

在开发中可以用这个包很好的替换掉Curl函数族。

<https://ibaiyang.github.io/blog/php/2022/05/12/guzzle包使用.html>

## 2023.01.17

在一次回顾“服务器最多能支持多少个TCP连接”的内容时，想到两个问题：
1. 为什么TCP连接中要有服务器的临时端口？
2. TCP/IP连接中的源IP/源端口是什么，与服务器的临时源端口有什么区别？

第1个问题，因为Linux中一切皆文件，连接也是文件，如果没有服务器的临时端口，
怎样把同一个客户端同时对服务器同一个服务的多个不同请求区分开呢。

第2个问题，TCP/IP是操作系统实现的，TCP/IP连接中的源IP/源端口也是操作系统处理的，服务器服务回复数据时发到这个源IP/源端口；
服务器的临时源端口只作为连接的文件描述符中存在。

另外，对不同的 `目标IP地址:目标端口号`，同一个 `源IP地址` 可以建立无数的连接。

<https://ibaiyang.github.io/blog/it技术/2021/09/16/最多能创建多少个-TCP-连接.html>



