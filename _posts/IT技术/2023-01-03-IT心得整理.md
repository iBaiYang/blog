---
layout: post
categories: IT技术
title: IT心得整理
meta: IT心得整理
---
* content
{:toc}
  
## 引言

在学习技术的过程中，看一篇材料，会觉得自己理解了，也做了记录，
但过段时间却不知道曾经看过什么，在解决一个问题时要用什么技术了。

所以有了这篇IT心得整理，旨在时时提醒自己和随时查阅学习心得。

这里只记录心得，具体技术内容翻阅记录文档。

## 2023.01.03

TCP、UDP，从本质上来说，都是把信息发送到对端，TCP也并没有持续占用网线一说，
只是在系统软件层面来说，TCP实现了下一次发送是基于上一次信息接受成功的基础上。
从这个角度而言，我们也完全可以用UDP实现TCP的特性：发送端发送信息，接收端接受信息；
当接收端接受到信息时，发送接受成功通知给发送端；如果持续一段时间，发送端还没有收到接收端接受成功的通知，就再发送一次；
同理，三次握手、四次挥手也可以用这种方式实现。

## 2023.01.04

下面说一下四种工厂模式的异同。

简单工厂模式：一个工厂用来生产同一等级结构中的多款产品。不符合开闭原则，无法新增产品。
如在工厂中传入参数获取电视、手机。

静态工厂模式：和简单工厂相似，只是产品获取方法换成了静态方法。获取产品时，不需要实例化工厂了。

工厂方法模式：多个工厂获取对应工厂的一个产品（同一等级结构）。不符合开闭原则，无法在旧工厂中增删产品。
支持增加产品，新增产品时也新建该产品的生产工厂。
如奥克斯空调厂只能生产奥克斯空调，格力空调厂只能生产格力空调；
从工厂来说，奥克斯空调厂和格力空调厂都是空调厂；
从产品来说，奥克斯空调和格力空调都是空调。
如果新增了海尔空调，就需要新建海尔空调厂。

抽象工厂模式：多个工厂获取对应工厂的一族产品。不符合开闭原则，无法在旧工厂中新增产品，
不过可以新增一族产品，然后组建相应的新工厂。
如奔驰厂生产带格力空调的奔驰车，宝马厂生产带海尔空调的宝马车。
格力空调 + 奔驰车 是一个产品族，海尔空调 + 宝马车 是一个产品族；
格力空调和海尔空调都是空调，奔驰车和宝马车都是车；
奔驰厂和宝马厂就是相应的工厂。
如果新增了奥克斯空调，不能换到奔驰厂中去，不过如果新增了奥迪车，
可以新建一个奥迪厂，用来生产带奥克斯空调的奥迪车。
一个工厂中不一定非要获取一条流水线上出来的产品，如最终的成品车，
也可以获取不同的产品，如获取这个工厂用了什么空调、轮胎等。
当然上面的车厂不一定非要生产汽车，也可以同时生产轮船。

**工厂方法模式与抽象工厂模式的区别**

工厂方法模式：
1. 一个抽象产品类，可以派生出多个具体产品类。
2. 一个抽象工厂类，可以派生出多个具体工厂类。
3. 每个具体工厂类只能创建一个具体产品类的实例。

抽象工厂模式：
1. 多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。
2. 一个抽象工厂类，可以派生出多个具体工厂类。
3. 每个具体工厂类可以创建多个具体产品类的实例。

<https://ibaiyang.github.io/blog/php/2019/07/30/PHP-创建型模式.html#简单工厂模式simple-factory>

建造者模式：对比工厂模式多了一个导演类（依赖注入一个建造者类）。
工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品。
而建造者模式中，建造者类一般只提供产品类中各个组件的建造，而将完整建造过程交付给导演类。

## 2023.01.05

* select，最早的解决方案
* poll，算是select的升级版
* epoll，目前的最终解决版，解决c10k问题的功臣


<https://ibaiyang.github.io/blog/php/2020/07/01/PHP-Socket初探.html>

## 2023.01.06

ReactPHP是事件驱动的，非阻塞I/O的PHP，它和Node.js都是采用单进程和单线程的方式，适用于I/O密集型，不适用于计算密集型。 

客户端请求时，使用异步模式发起请求，然后继续向下执行，等服务端返回后再继续处理；一个文件中客户端可以先后发起多个请求。

服务端处理时，接收到一个客户端请求，把这个请求给处理函数，然后继续等待下一个客户端请求，
处理函数处理完成后直接把处理结果发送给客户端。

<https://ibaiyang.github.io/blog/php/2020/06/22/ReactPHP实践.html>




