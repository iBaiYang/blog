---
layout: post
categories: IT技术
title: 计算机是怎样跑起来的
meta: 计算机是怎样跑起来的，作者：矢泽久雄
---
* content
{:toc}
 
## 前言

我从 10 年前开始担任企业培训的讲师。培训的对象有时是新入职的员工，有时是入职了多年的骨干员工。
这期间通过与一些勉强算是计算机专家的年轻工程师接触，我感到与过去的工程师（计算机发烧友）相比，他们对技术的兴趣少得可怜。
并不是说所有的培训对象都如此，但这样的工程师确实占多数。这并不是大吼着命令他们继续学习或用激将法嘲讽他们的专业性就能解决的问题。
究其根源，是因为计算机对他们来说，并没有有意思到可以令他们废寝忘食的地步。为什么他们会觉得计算机没意思呢？
通过和多名培训对象的交流，我渐渐找到了答案。因为他们不了解计算机。然而，又是什么造成了他们的“不了解”呢？

今天，计算机正在以惊人的速度发展变化着，变得越来越复杂，而这期间产生了许多技术，
但是人们并没有过多的时间去深入学习每一门技术，这就是问题的根源。稍微看了看技术手册，只学到了表层的使用方法，
觉得自己“反正已经达到目的了”，这就是现状。如果仅仅把技术当作一个黑盒，只把时间花在学习其表面上，
而并没有探索到其本质，就绝不应该认为自己已经“懂”了。不懂的话，做起来就会感到没意思，也就更不会产生想要深入学习的欲望了。
若每日使用的都是些不知其所以然的技术，就会渐渐不安起来。令人感到遗憾的是，还有一些人在计算机行业遇到挫折后，
就选择了离开这个行业。身为一名教授计算机技术的讲师，我由衷地感到自己应该想办法改变这种现状。

对于笔者以及昔日的计算机发烧友而言，虽然大家现在都已经 40 岁左右了，但即使是面对复杂的最新技术，
似乎也还是可以轻松掌握的。其原因在于，从可以轻松买到最初的 8 比特微型计算机的那个时候开始，我们就幸运地接触到了计算机。
面对为数不多的技术，我们可以从容地把时间花在学习计算机的基础知识上。而这些基础知识，即使到了今天也完全没有变化。
因此，即便面对的是复杂的最新技术，一旦把它们回归到计算机的基础知识上，就变得可以轻松理解了。
就算是和年轻的工程师们阅读同样的技术手册，我们领会其中的要点、抓住其本质的速度也要快得多。

其实不仅是计算机，其他学问亦是如此。首先要划出一个“知识的范围”，精通一门学问所必知必会的知识都在这个范围内。
其次是掌握该范围内每个知识点中“基础中的基础知识”。最后是能独当一面的“目标”，即掌握了这些知识可以做什么。
下面就以学习音乐为例说明这三点。首先，划出的“知识范围”是节奏、旋律、和弦这三个知识点。所谓“基础中的基础知识”，
对于节奏来说就是四拍子（大、大、大、大），对于旋律来说就是 C 大调（do re mi fa so la si do），
对于和弦来说就是大三和弦（do mi so）。以四拍子为基础就能理解更加复杂的三拍子或五拍子；
以 C 大调为基础就能理解更加复杂的降 B 小调；以大三和弦为基础就能理解更加复杂的减三和弦。
而最终的“目标”就是能够自己作曲并演奏，尽管这时仅能完成很简单的曲子。

本书的目的是想让诸位了解有关计算机技术的知识范围，掌握其基础中的基础知识，设定目标；
同时又想让那些打算用计算机做点什么，却又因难以下手而犹豫不决的人，以及虽然就职于计算机行业，
却又因追赶不上最新技术而苦恼的人，能够了解计算机的本质。其实计算机非常简单，谁都能掌握。
只要掌握了，计算机就会越来越有趣。

【矢泽久雄】
 
## 关键词

本书将要讲解的主要关键词

![]({{site.baseurl}}/images/20220821/20220821112507.png)

## 本书结构

本书共分为 12 章，每章由热身问答、本章要点和正文三部分构成。全书还穿插了 2 个专栏。

* 热身问答

在各章的开头部分设有简单的问题作为热身活动，请诸位务必挑战一下。设置这一部分的目的，是为了让诸位能带着问题阅读正文的内容。

* 本章重点

各章的本章要点部分揭示了正文的主题。诸位可以读一读，以确认这一章中是否有想要了解的内容。

* 正文

正文部分会以讲座的方式，从各章要点中提到的角度出发，对计算机的运行机制予以解释说明。
其中还会出现用 Visual Basic 或 C 语言等编程语言编写的示例程序，编写时已力求精简，即便是没有编程经验的读者也能看懂。

* 专栏“来自企业培训现场”

专栏部分将会与诸位分享笔者自担任讲师以来，从培训现场收集来的各种各样的轶事。
诸位可以时而站在讲师的角度、时而站在听众的角度读一读这部分。专栏部分不仅有严肃认真的话题，更有有趣逗乐的笑话，想必会对诸位有所帮助。


## 第 1 章 计算机的三大原则

* 热身问答

在阅读本章内容前，让我们先回答下面的几个问题来热热身吧。

问题

初级问题

硬件和软件的区别是什么？

中级问题

存储字符串“中国”需要几个字节？

高级问题

什么是编码（Code）？

怎么样？被这么一问，是不是发现有一些问题无法简单地解释清楚呢？下面，笔者就公布答案并解释。

* 答案

初级问题：硬件是看得见摸得着的设备，比如计算机主机、显示器、键盘等。而软件是计算机所执行的程序，即指令和数据。软件本身是看不见的。

中级问题：在 GBK 字符编码下，存储“中国”需要 4 个字节。

高级问题：通常将为了便于计算机处理而经过数字化处理的信息称作编码。

* 解释

初级问题：硬件（Hardware）代表“硬的东西”，而软件（Software）代表“软的东西”。是硬的还是软的取决于眼睛能否看得到，或者实际上能否用手摸到。

中级问题：存储汉字时，字符编码不同，汉字所占用的字节数也就不同。在 GBK 字符编码下，一个汉字占用 2 个字节。而在 UTF-8 字符编码下，一个汉字占用 3 个字节。

高级问题：计算机内部会把所有的信息都当成数字来处理，尽管有些信息本来不是数字。用于表示字符的数字是“字符编码”，用于表示颜色的数字是“颜色编码”。

* 本章重点

现在的计算机看起来好像是种高度复杂的机器，可是其基本的构造却简单得令人惊讶。从大约 50 年前的第一代计算机到现在，计算机并没有发生什么改变。在认识计算机时，需要把握的最基础的要点只有三个，我们就将这三个要点称为“计算机的三大原则”吧。无论是多么高深、多么难懂的最新技术，都可以对照着这三大原则来解释说明。

只要了解了计算机的三大原则，就会感到眼前豁然开朗了，计算机也比以往更加贴近自己了，就连新技术接连不断诞生的原因也明白了。本书以本章介绍的计算机的三大原则为基础，内容延伸至硬件和软件、编程、数据库、网络以及计算机系统。在阅读之后的章节时，也请诸位时常将计算机的三大原则放在心上。

1.1 计算机的三个根本性基础

下面就赶紧开始介绍计算机的三大原则吧。

1. 计算机是执行输入、运算、输出的机器
2. 程序是指令和数据的集合
3. 计算机的处理方式有时与人们的思维习惯不同

计算机是由硬件和软件组成的。诸位可以把硬件和软件的区别理解成游戏机（硬件）和收录在 CD-ROM 中的游戏（软件）的区别。这样就能理解硬件和软件各自的基础了（三大原则中的第一点和第二点）。

在此之上，计算机有计算机的处理方式也是一条重要的原则。而且请诸位注意，计算机的处理方式往往不符合人们的思维习惯（三大原则中的第三点）。

计算机三大原则中的每一条，都是从事计算机行业 20 余年的笔者深切领悟出来的。诸位可以把这本书拿给你周围了解计算机的朋友看，他们应该会对你说“确实是这样的啊”“当然是这样的了”这类话。过去的计算机发烧友们在不知不觉中就能逐渐领悟出计算机的三大原则。而对于那些打算从今日开始深入接触计算机的普通人来说，三大原则中的有些地方也许一时半会儿难以理解，但是不要担心，因为下面的解释会力求让诸位都能理解三大原则的具体含义。

1.2 输入、运算、输出是硬件的基础

首先从硬件的基础开始介绍。从硬件上来看，可以说计算机是执行输入、运算、输出三种操作的机器。
计算机的硬件由大量的 IC（Integrated Circuit，集成电路）组成（如图 1.1 所示）。每块 IC 上都带有许多引脚。
这些引脚有的用于输入，有的用于输出。IC 会在其内部对外部输入的信息进行运算，并把运算结果输出到外部。
运算这个词听起来也许有些难以理解，但实际上就是计算的意思。
计算机所做的事就是“输入”数据 1 和 2，然后对它们执行加法“运算”，最后“输出”计算结果 3。

![]({{site.baseurl}}/images/20220821/20220821112509.png)

图 1.1 IC 的引脚中有些用于输入，有些用于输出

小型的 IC 自不必说，就连在观察银行的在线系统这类巨型系统时，或是编写复杂的程序时，也要时常把输入、运算、输出这三者想成是一套流程，这一点很重要。其实计算机就是台简单的机器，因为它只能做这三件事。

“你说得不对，计算机能做的事远比这些多得多。”也许会有人这样反驳笔者。的确，计算机可以做各种各样的事，比如玩游戏、处理文字、核算报表、绘图、收发电子邮件、浏览网页，等等。但是无论是多么复杂的功能，都是通过组合一个又一个由输入、运算、输出构成的流程单位来实现的，这是毋庸置疑的事实。如果打算用计算机做点什么的话，就要考虑该如何进行输入、如何获取输出以及进行怎样的运算才能从输入得到输出。

输入、运算、输出三者必须成套出现，缺一不可。这样说的原因有几点。
首先，现在的计算机还没有发展到能通过自发的思考创造出信息的地步。因此不输入信息，计算机就不能工作。
所以，输入是必不可少的。其次，计算机不可能不执行任何运算。如果只是使输入的信息绕过运算环节直接输出，
那么这就是电线而不是计算机了。可以说不进行运算，计算机也就没有什么存在的意义。
最后，输入的信息如果经过了运算，那么运算结果就必然要输出。如果不输出结果，
那么这也不是计算机而只是堆积信息的垃圾箱了。因此，输出也必不可少。

![]({{site.baseurl}}/images/20220821/20220821112511.png)

图 1.2 计算机只会输入、运算、输出

1.3 软件是指令和数据的集合

下面介绍软件，即程序的基础。所谓程序，其实非常简单，只不过是指令和数据的集合。无论程序多么高深、多么复杂，其内容也都是指令和数据。所谓指令，就是控制计算机进行输入、运算、输出的命令。把向计算机发出的指令一条条列出来，就得到了程序。这里成套出现的输入、运算、输出，就是之前在硬件的基础一节中说明过的流程。向计算机发出的指令与计算机硬件上的行为一一对应是理所当然的。

在程序设计中，会为一组指令赋予一个名字，可以称之为“函数”“语句”“方法”“子例程”“子程序”等。这里稍微说些题外话，在计算机行业，明明是同一个东西，却可以用各种各样的术语来指代它，这种现象请诸位注意。如果只想用一个名字的话，一般情况下笔者推荐称之为函数，因为这个名字通俗易懂。

程序中的数据分为两类，一类是作为指令执行对象的输入数据，一类是从指令的执行结果得到的输出数据。在编程时程序员会为数据赋予名字，称其为“变量”。看到变量和函数，诸位也许会联想到数学吧。正如数学中函数的表记方法那样，在很多编程语言中都使用着类似于下面的这种语法。

```
y = f(x)
```

这句话表示若把变量 x 输入到函数 f 中，经过函数内部的某种运算后，其结果就会输出到变量 y 中。因为计算机是先把所有的信息都表示成数字后才对其进行运算的，所以编程语言的语法类似数学算式也就不足为奇了。但是在程序中有一点与数学不同的是，变量和函数的名字都可以由一个以上的字符构成，比如下面这种情况。

```
output = operate(input)
```

也就是说，使用由多个字符构成的长名字也是可以的。甚至可以说，写成这样的情况更加普遍。

下面我们就举一个例子作为证据来证明程序是指令和数据的集合。请诸位看代码清单 1.1。这里列出了一段用名为 C 语言的编程语言编写的程序。C 语言中要在每条指令的末尾写一个分号“;”。第一行的“int a, b, c;”表示接下来要使用名为 a、b、c 的整数变量，其中 int 是 integer（整数）的缩写，用于告诉计算机“要用的是整数”。下一行的“a = 10”表示把整数 10 赋值给变量 a。同样地，“b = 20;”表示把整数 20 赋值给变量 b。等号“=”是赋值给变量的指令。再来看最后一行的“c = Average(a, b);”，这一行表示把变量 a 和 b 传给函数的参数，并将运算结果赋值给变量 c。其中使用了一个名为 Average 的神秘函数，它的作用是返回两个参数的平均值。通过上面这个例子，诸位就应该能明白程序确实只是由指令和数据构成的了吧。

代码清单 1.1 C 语言的程序示例片段
```
int a, b ,c;
a = 10;
b = 20;
c = Average(a, b);
```

虽然程序就是这样，但是那些稍微有些编程经验的人也许会说：代码清单 1.1 所示的程序逻辑简单，而真正的程序是使用了各种各样的语法、比这复杂得多得多的东西，绝不是用指令和数据的集合就能解释清楚的。其实并不是像他们想的那样，无论是多么复杂的程序，都只不过是指令和数据的集合。下面我们再拿出一个证据。

在一般的编程过程中，都要先编译再执行。所谓编译就是把用 C 语言等编程语言编写的文件（源文件）转换成用机器语言（原生代码）编写的文件。假设我们先把代码清单 1.1 中的代码保存到文件 MyProg.c 中，然后经过编译就可以生成可执行的程序文件 MyProg.exe 了。接下来使用能查看文件内容的工具查看 MyProg.exe，其内容应该与代码清单 1.2 类似。可以看到里面仅仅是数值的罗列（这里用十六进制数表示）。

代码清单 1.2 机器语言的程序示例
```
C7 45 FC 01 00 00 00 C7 45 F8 02 00 00 00 8B 45
F8 50 8B 4D FC 51 E8 82 FF FF FF 83 C4 08 89 45
F4 8B 55 F4 52 68 1C 30 42 00 E8 B9 03 00 00 83
```

请选择一个代码清单 1.2 中的数值，随便哪个都可以。这个数值代表什么呢？是表示赋值或加法等指令的种类呢，还是表示将成为指令执行对象的数据呢？也有这样的可能（不过这终归是想象），第一个数值 C7 表示指令，第二个数值 45 表示数据。在诸位所使用的 Windows 个人计算机中，应该会有若干个以 .exe 为扩展名的可执行程序文件。无论是哪个程序，其内容都是数值的罗列，每个数值要么是指令，要么是数据。

1.4 对计算机来说什么都是数字

计算机有计算机的处理方法，这是三大原则中的最后一点。计算机本身只不过是为我们处理特定工作的机器。如果计算机能自己干活的话，那么笔者一定会买几百台，让它们先替自己完成一整年的工作。但是，并没有这种会挣钱的计算机，计算机终究只是受人支配的工具。

迄今为止，使用计算机的目的就是为了提高手工作业的效率。例如，文字处理软件可以提高编写文档的效率；电子邮件可以提高传统邮件寄送的效率。总之，作为可以提高工作效率的工具，有些靠手工作业完成的业务可以直接交给计算机处理。但是也有很多手工作业无法直接由计算机处理。也就是说，在用计算机替代手工作业的过程中，要想顺应计算机的处理方法，有时就要违背人们的思维习惯。请诸位特别留心这一点。

用数字表示所有信息，这就是一个很具有代表性的计算机式的处理方法，这一点也正是和人类的思维习惯最不一样的地方。例如，人们会用“蓝色”“红色”之类的词语描述有关颜色的信息。可是换作计算机的话，就不得不用数字表示颜色信息。例如，用“0,0,255”表示蓝色，用“255,0,0”表示红色，用“255,0,255”表示由蓝色和红色混合而成的紫色。不光是颜色，计算机对文字的处理也是如此。计算机内部会先把文字转换成相应的数字再做处理，这样的数字叫作“字符编码”。总之计算机会把什么都用数字来表示。

熟悉计算机的人经常会说出一些令人费解的话，例如“在这里打开文件，获得文件句柄”“把用公钥加密后的文件用私钥解密”。那么，他们所说的“文件句柄”是什么呢？ —— 是数字。“公钥”是什么呢？——是数字。“私钥”呢？——当然还是数字。无论计算机所处理的信息是什么形式，只要把它们都当成是数字就可以了。虽然这有些违背人们的思维习惯，但是处理数字对计算机来说却是非常简单的。

下面笔者就讲一件自己年轻时的糗事吧。事情发生在一次与老程序员探讨问题时，我问他：“用某某程序处理的某某数据，在计算机内部也是用数字表示的吧？”老程序员听后，吃惊得张开了嘴，回了一句：“这不是明摆着吗 !”

1.5 只要理解了三大原则，即使遇到难懂的最新技术，也能轻松应对

有关计算机三大原则的说明到此结束。只要理解了这三大原则，即使遇到难懂的最新技术，也能轻松应对。下面就给诸位看一个具体的例子。这里摘录了一段有关 .NET 技术的介绍，.NET 是微软公司率先提出的一种新技术。如果要正式地介绍 .NET 技术，就会像下面这样进行说明。

【有关 .NET 的说明之一】

微软公司率先提出了作为新一代互联网平台的 .NET 技术。作为 .NET 核心的 XML Web 服务使用通用技术 SOAP、XML，促使企业间的计算机协同工作。

真是不好理解的一段话啊。可是如果把 .NET 的核心技术对照着计算机三大原则再介绍一遍的话，就会像下面这样进行说明。

【有关 .NET 的说明之二】

计算机是执行程序的机器。程序是指令和数据的集合。为了使互联网上相互连接的计算机能通过程序协同工作，微软公司采用了 SOAP 以及 XML 规范。SOAP 是关于调用指令的规范，XML 则是定义数据格式的规范。

只要定义出了指令和数据的规范，装有符合规范的程序的计算机自然就可以相互协作了。所谓计算机的协同工作指的是，输入到一台计算机中的数据，可以通过互联网传送到与这台计算机相连的其他计算机上执行运算，运算所输出的结果再返回给这台计算机。像这样部署在其他计算机上能执行某种运算的程序就叫作 XML Web 服务。

这回怎么样？应该变得容易理解了吧？如果又想到了其他的问题，比如“为什么不得不遵循 SOAP 和 XML 的规范呢？”或者“实际看了看 SOAP 和 XML 的规范，才发现也很复杂。”那么就可以把答案归结为“因为那些都是适合计算机的处理方式”。

1.6 为了贴近人类，计算机在不断地进化

围绕着计算机的技术正在以狂奔般的速度不断进化，与其说是日新月异，倒不如说是“秒新分异”。虽然也许有人会觉得眼前的已经够用了，希望能停留在现有的技术水平上。但是计算机的进化是不会停止的，因为计算机还远远没有到达完善的地步。

计算机进化的目的只有一个——与人类更加相近。要想贴近人类，就必须从计算机的处理方式中摒弃不符合人们思维习惯的部分。请对照着计算机三大原则之一的“计算机有自己的处理方式”来记忆这个结论。

举例来说，键盘这种不好用的输入设备进化成了好用的鼠标。平面的 2D（二维）游戏进化成了立体的 3D（三维）游戏。无论是哪一种进化，都是为了使计算机的处理方式更加贴近人类。

这样发展下去的话，也许计算机进化的最终形态就是机器人了，有着与人类一样的外表，可以使用人类的语言。例如在 1985 年茨城县筑波市举办的筑波世博会上，就展示出了一台用 CCD 照相机识别乐谱，弹奏钢琴的机器人。也许有人会觉得：“数码音乐什么的用个人计算机不是也能完成吗？”但是这个发明的意义在于机器人能和人类做相同的事了。就在不久前，本田公司开发出的两足步行机器人也成为了热议的话题。也许又有人会觉得：“为什么非要特地用两只脚行走呢，装上轮子能动起来不也一样吗？”但是这个发明的意义还是在于机器人能和人类做相同的事了。有乐谱和钢琴就能演奏，人能走的道路或台阶它也能走，这样的机器人无疑才能更加方便地应用于人类社会。

若与十几年前相比，诸位身边的个人计算机也在逐渐贴近人类。20 世纪 80 年代中期盛行的个人计算机操作系统是 MS-DOS，
其操作方法是靠在全黑的画面上敲入字符，把命令传给计算机。进入 90 年代后，MS-DOS 进化成了 Windows，
用户可以在图形界面上通过鼠标的操作直观地下达命令（如图 1.3 所示）。开发出 Windows 的美国微软公司，
正将目标锁定在用户体验（User Experience）上，旨在开发出超过现有 Windows、更加贴近人类的用户界面（计算机的操作方法）。
Windows XP 和 Office XP 末尾的 XP，代表的就是 Experience（体验）。Windows 若能这样不断进化下去，
早晚会有一天，面向个人计算机的语音输入和手写输入等技术将变得极为普及。

![]({{site.baseurl}}/images/20220821/20220821112513.png)

图 1.3 为了贴近人类，个人计算机操作系统也在进化

诸位读者当中应该也有对编程感兴趣的人吧。编程方法也在进化，进化的成果是诞生了两种编程方法，面向组件编程（Component Based Programming）和面向对象编程（Object Oriented Programming）。这两者的进化目标一致，都是使程序员可以在编程中继续沿用人类创造事物时的方法。面向组件编程的方法是通过将组件（程序的零件）组装到一起完成程序；面向对象编程的方法是先如实地对现实世界的业务建模，之后再把模型搬到程序中。使用符合人类思维习惯的编程方法，可以实现高效率的开发。

但是，偏偏有这类程序员，他们对面向组件编程敬而远之，明明有各种各样现成的组件可供使用，却什么功能都要自己亲手做，仿佛不这样编程就不舒心。还有的程序员误认为面向对象编程难以理解。像这样的程序员人数还不少，特别是在昔日的计算机发烧友当中。总之就是因为他们太习惯于配合计算机的处理方式了，反倒认为计算机贴近人类这一发展趋势是在添乱。

笔者则认为，无论是刚入行的技术人员，还是有资历的老工程师，都应该由衷地欢迎技术的进化，坦率地接受新技术。如果是用祖传技艺制作出来的传统手工艺品的话，也许还有价值，但是没有人会稀罕靠一成不变的方法编写出的程序。

1.7 稍微预习一下第 2 章

作为第 2 章的预习，在本章的最后先来简单地介绍一下计算机（特别是个人计算机）硬件的组成要素。这里讲得不会很难，请先看一下图 1.4，体会一下图中的要点。如图所示，计算机内部主要由被称作 IC 的元件组成。虽然在 IC 家族当中有功能各异的各种 IC，但是在这里希望诸位记住的只有三种：CPU（处理器）、内存以及 I/O。

![]({{site.baseurl}}/images/20220821/20220821112515.png)

图 1.4 计算机硬件的组成要素

CPU 是计算机的大脑，在其内部可对数据执行运算并控制内存和 I/O。内存用于存储指令和数据。I/O 负责把键盘、鼠标、显示器等周边设备和主机连接在一起，实现数据的输入与输出。

在诸位所使用的 Windows 个人计算机中，多数都只装有一枚名为 Pentium（奔腾）的 CPU 吧。内存的数量则会根据所需存储的大小（少则 32MB，多则 256MB）装有多条。I/O 也会根据周边设备的多少装配有多个。可以认为个人计算机背板上有多少个插孔就有多少个 I/O。

只要用电路把 CPU、内存以及 I/O 上的引脚相互连接起来，为每块 IC 提供电源，再为 CPU 提供时钟信号，
硬件上的计算机就组装起来了，还是非常简单的吧。所谓时钟信号，
就是由内含晶振（一种利用石英晶体（又称水晶）的压电效应产生高精度振荡频率的电子元件）的、被称作时钟发生器的元件发出的滴答滴答的电信号。
如果是 Pentium CPU 的话，所使用的时钟信号会从几百 MHz 到 2GHz 不等。

☆   ☆   ☆

诸位辛苦了，至此第 1 章就结束了。想必诸位都已经理解了计算机的三大原则以及计算机为什么要进化了吧。因为这些知识真的非常重要，所以如果第一遍没有读懂，就请再反复多读几遍。也可以叫上公司的同事、学校的同学一起讨论本章的内容。如果能让有资历的老工程师也加入讨论，那么效果会更加显著。

在接下来的第 2 章中，我们将尝试着动手“制造”一台计算机。说是制造，也只不过是在纸上进行的“模拟体验”，而且笔者会带着诸位做，所以请不要担心。敬请期待！

## 第 2 章 试着制造一台计算机吧

热身问答

在阅读本章内容前，让我们先回答下面的几个问题来热热身吧。

问题

初级问题

CPU 是什么的缩写？

中级问题

Hz 是表示什么的单位？

高级问题

Z80 CPU 是多少比特的 CPU ？

怎么样？被这么一问，是不是发现有一些问题无法简单地解释清楚呢？下面，笔者就公布答案并解释。

答案

初级问题：CPU 是 Central Processing Unit（中央处理器）的缩写。

中级问题：Hz（赫兹）是频率的单位。

高级问题：Z80 CPU 是 8 比特的 CPU。

解释

初级问题：CPU 是计算机的大脑，负责解释、执行程序的内容。有时也将 CPU 称作“处理器”。

中级问题：通常用 Hz 来表示驱动 CPU 运转的时钟信号的频率。1 秒发出 1 次时钟信号就是 1Hz，所以 100MHz（兆赫兹）的话就是 100×100 万 = 1 亿次／秒。M（兆）代表 100 万。

高级问题：CPU 上数据总线的条数，或者 CPU 内部参与运算的寄存器的容量，都可以作为衡量 CPU 性能的比特数。在 Z80 CPU 中，无论是数据总线的条数还是寄存器的容量都是 8 比特，所以 Z80 CPU 是一款 8 比特的 CPU。而在 Windows 个人计算机中广泛使用的 Pentium（奔腾）CPU 则是 32 比特的 CPU。

本章重点

要想彻底掌握计算机的工作原理，最好的方法就是自己搜集零件，试着组装一台微型计算机。微型计算机（MicroCom）是 Micro Computer 的缩写，字面含义是微小的计算机，但一般也可用于指代 IC 元件外露的、用于控制的计算机。因为要制作一台真正的微型计算机既花时间又花金钱，所以本章就在纸上体验一下微型计算机的制作过程吧。需要让诸位准备的只有如图 2.1 所示的电路图和一根红铅笔。将电路图复印下来后，请诸位一边想象着元件之间传输的信号的作用，一边用红铅笔描画出笔者所介绍的电路，以此来代替实际的布线环节。当所有的电路都描红了，微型计算机也就完成了。

别看只是描了描线，却一样能学到很多知识，甚至可以说不费吹灰之力就能了解计算机的工作原理。从此之后不但消除了对硬件的恐惧感，而且还会感到和计算机更加亲近了。请诸位一定要借此机会体验微型计算机的制作过程。

2.1 制作微型计算机所必需的元件

首先让我们来收集元件吧。制作微型计算机所需的基础元件只有 3 个，CPU、内存和 I/O，每种元件都是作为一块独立的 IC 在市场上出售的。CPU 是计算机的大脑，负责解释、执行程序。内存负责存储程序和数据。I/O 是 Input/Output（输入／输出）的缩写，负责将计算机和外部设备（周边设备）连接在一起。

这里我们使用 Z80 CPU 作为微型计算机的 CPU、TC5517 作为内存、Z80 PIO 作为 I/O。Z80 CPU 是一款古老的 CPU，在 NEC 的 PC-8801、SHARP 的 MZ-80 等 8 比特计算机广泛应用的时代，曾以爆炸般的速度普及过。TC5517 是可以存储 2K 的 8 比特数据的内存。在计算机的世界里，K 表示 210 = 1024。TC5517 的容量是 8 比特 ×2×1024 = 16384 比特，即 2K 字节。虽然这点容量与诸位所使用的个人计算机比起来相差悬殊，但是对于用于学习的微型计算机来说是绰绰有余了。Z80 PIO 作为 I/O，经常与 Z80 CPU 一起使用。正如其名，PIO（Parallel I/O，并行输入／输出）可以在微型计算机和外部设备之间并行地（一排一排地）输入输出 8 比特的数据。在计算机爱好者们沉浸在制作微型计算机的那个年代，这些元件都是常见的 IC。这里要先跟诸位打声招呼，这里制作的微型计算机终归只是用于学习的模型，并没有什么实用的价值。

![]({{site.baseurl}}/images/20220821/20220821112521.jpg)

图 2.1 Z80 微型计算机的电路图

为了制作微型计算机，除了 CPU、内存和 I/O，还需要若干辅助元件。

为了驱动 CPU 运转，称为“时钟信号”的电信号必不可少。这种电信号就好像带有一个时钟，滴答滴答地每隔一定时间就变换一次电压的高低（如图 2.2 所示）。输出时钟信号的元件叫作“时钟发生器”。时钟发生器中带有晶振，根据其自身的频率（振动的次数）产生时钟信号。时钟信号的频率可以衡量 CPU 的运转速度。这里使用的是 2.5MHz（兆赫兹）的时钟发生器。

![]({{site.baseurl}}/images/20220821/20220821112523.png)

图 2.2 时钟信号的波形图

用于输入程序的装置也是必不可少的。在这里我们通过拨动指拨开关来输入程序，指拨开关是一种由 8 个开关并排连在一起构成的元件（如照片 2.1(a) 所示）。输出程序执行结果的装置是 8 个 LED（发光二极管）。到此为止，主要的元件就都备齐了。

剩下的就都是些细碎的元件了。表 2.1 是所需元件的一览表，里面也包含了之前介绍过的元件。请诸位粗略地浏览一遍。所需元件表中的 74367 和 7404 也是 IC，用于提高连接外部设备时的稳定性。

表 2.1 本次用到的制作微型计算机的元件

![]({{site.baseurl}}/images/20220821/20220821112525.png)

电阻是用于阻碍电流流动、降低电压值的元件。为了省去布线的麻烦，这里也会使用将 8 个电阻集成到 1 个元件中的集成电阻（如照片 2.1(b) 所示）。电阻的单位是 Ω（欧姆）。电容是存储电荷的元件，衡量存储电荷能力的单位是 F（法拉）。要让微型计算机运转起来，5V（伏特）的直流电源是必不可少的。于是还需要使用一个叫作“开关式稳压电源”的装置，将 220V 的交流电变成 5V 的直流电。

![]({{site.baseurl}}/images/20220821/20220821112527.png)

照片 2.1 指拨开关和集成电阻

2.2 电路图的读法

在开始布线之前，先来介绍一下电路图的读法。在电路图中，用连接着各种元件符号的直线表示如何布线。电路中有些地方有交叉，但若只是交叉在一起的话，并不表示电路在交叉处构成通路。只有在交叉处再画上一个小黑点才表示构成通路。

![]({{site.baseurl}}/images/20220821/20220821112529.png)

图 2.3 判断电路交叉时是否构成通路

![]({{site.baseurl}}/images/20220821/20220821112531.png)

图 2.4 电源的表示方法

本次制作的微型计算机工作在 +5V 的直流电下。虽然在实际的电路中要把 +5V 和 0V 连接到各个元件的各个引脚上，但是如果在电路图中也把这些地方都一一标示出来的话，就会因为到处都是 +5V 和 0V 的布线而显得混乱不堪了。所以要使用如图 2.4 所示的两种电路图符号来分别表示电路连接到 +5V 和连接到 0V 的情况。

IC 的引脚（所谓引脚就是 IC 边缘露出的像蜈蚣腿一样的部分）按照逆时针方向依次带有一个从 1 开始递增的序号。数引脚序号时，要先把表示正方向的标志，比如半圆形的缺口，朝向左侧。举例来说，带有 14 个引脚的 7404，其引脚序号就如图 2.5 所示。

![]({{site.baseurl}}/images/20220821/20220821112533.png)

图 2.5 如何数 IC 的引脚序号

如果按照引脚序号的排列顺序来画 IC 的电路图符号，那么标示如何布线时就会很不方便。
所以通常所绘制的电路图都不受引脚实际排布的限制（有时也会遵循引脚序号的顺序绘制电路图，这样的电路图叫作实物布线图）。
画图时，在引脚的旁边写上引脚的序号，在表示 IC 的矩形符号中写上表明该引脚作用的代号。
代号就是像 RD（Read）表示执行读取操作，WR（Write）表示执行写入操作这样的代表了某种操作的符号。
各个代号的含义等到为引脚布线时再一一说明（写在引脚旁边的代号，其含义会写在 IC 生产厂商发布的资料中，
但在这里为了保持文章的通俗易懂，改变了一部分代号的写法，这一点还望诸位谅解。
例如，在厂商的资料中 TC5517 的第 20 个引脚的代号是 OE（Output Enable，输出使能），在这里则改为了含义相同的 RD（Read，读取）。）。

2.3 连接电源、数据和地址总线

下面就开始布线吧。请假想自己正在制作微型计算机，并按照如下的说明用红铅笔在电路图中描画相应的电路。

首先连接电源。IC 与普通的电器一样，只有接通了电源才能工作。Z80 CPU、TC5517 和 Z80 PIO 上都分别带有 Vcc 引脚和 GND 引脚。Vcc 和 GND 这一对儿引脚用于为 IC 供电。下面请先将 +5V 电源连接到各个 IC 的 Vcc 引脚上，然后将 0V 电源连接到各个 IC 的 GND 引脚上。接下来还需要将 +5V 和 0V 连接到时钟发生器上。接通电源后这些 IC 和时钟发生器就可以工作了。

微型计算机所使用的 IC 属于数字 IC。在数字 IC 中，每个引脚上的电压要么是 0V、要么是 +5V，通过这两个电压与其他的 IC 进行电信号的收发。用于给 IC 供电的 Vcc 引脚和 GND 引脚上的电压是恒定不变的 +5V 和 0V，但是其他引脚上的电压，会随着计算机的操作在 +5V 和 0V 之间不断地变化。

稍微说一点题外话，只要想成 0V 表示数字 0、+5V 表示数字 1，那么数字 IC 就是在用二进制数的形式收发信息。也正因为如此，二进制数在计算机当中才如此重要。有关二进制的内容，本书并不会详细介绍，但是请先记住以下知识点：通常将 1 个二进制数（也就是数字 IC 上 1 个引脚所能表示的 0 或者 1）所表示的信息称作“1 比特”，将 8 个二进制数（也就是 8 比特）称作“1 字节”。比特是信息的最小单位，字节是信息的基本单位。这里制作的微型计算机是一台 8 比特微型计算机，因此是以 8 比特为一个单位收发信息的。

下面回到正题。计算机以 CPU 为中心运转。CPU 可以与内存或 I/O 进行数据的输入输出。为了指定输入输出数据时的源头或目的地，CPU 上备有“地址总线引脚”。Z80 CPU 的地址总线引脚共有 16 个，用代号 A0～A15 表示，其中的 A 表示 Address（地址）。后面的数字 0～15 表示一个 16 位的二进制数中各个数字的位置，0 对应最后一位、15 对应第一位。16 个地址总线引脚所能指定的地址共有 65536 个，用二进制数表示的话就是 0000000000000000～1111111111111111。因此 Z80 CPU 可以指定 65536 个数据存取单元（内存存储单元或 I/O 地址），进行信息的输入输出。

一旦指定了存取数据的地址，就可以使用数据总线引脚进行数据的输入输出了。Z80 CPU 的数据总线引脚共有 8 个，用代号 D0～D7 表示。其中的 D 表示 Data（数据），后面的数字 0～7 与地址总线引脚代号的规则相同，也表示二进制数中各个数字的位置。Z80 CPU 可以一次性地输入输出 8 比特的数据，这就意味着如果想要输入输出位数（比特数）大于 8 比特的数据，就要以 8 比特为单位切分这个数据。

作为内存的 TC5517 上也有地址总线引脚（A0～A10）和数据总线引脚（D0～D7）。这些引脚需要同 Z80 CPU 上带有相同代号的引脚相连。一块 TC5517 上可以存储 2048 个 8 比特的数据（如图 2.6 所示）。可是由于用于输入程序的指拨开关是以 8 比特为一个单位指定内存地址的，所以我们只使用 TC5517 上的 A0～A7 这 8 个引脚，并把剩余的 A8～A10 引脚连接到 0V 上（这些引脚上的值永远是 0）。虽然总共有 2048 个存储单元，最终却只能使用其中的 256 个，稍微有些浪费。下面就请诸位用红铅笔把 Z80 CPU 和 TC5517 的 D0～D7 以 及 A0～A7 引脚分别连接起来。

![]({{site.baseurl}}/images/20220821/20220821112535.png)

图 2.6 TC5517 的内部构造

2.4 连接 I/O

下面开始连接 I/O。只有了解了作为 I/O 的 Z80 PIO 的结构，才能理解为什么要这样布线。诸位都知道“寄存器”这个词吗？寄存器是位于 CPU 和 I/O 中的数据存储器。Z80 PIO 上共有 4 个寄存器。2 个用于设定 PIO 本身的功能，2 个用于存储与外部设备进行输入输出的数据。

这 4 个寄存器分别叫作端口 A 控制、端口 A 数据、端口 B 控制和端口 B 数据。所谓端口就是 I/O 与外部设备之间输入输出数据的场所，可以把端口（Port）想象成是轮船装卸货物的港口。Z80 PIO 有 2 个端口，端口 A 和端口 B，最多可以连接 2 个用于输入输出 8 比特数据的外部设备（如图 2.7 所示）。

![]({{site.baseurl}}/images/20220821/20220821112537.png)

图 2.7 Z80 PIO 的内部构造

既然已经大体上了解了 Z80 PIO 的结构，下面就开始布线吧。因为 Z80 PIO 上也有 D0～D7 的数据总线引脚，所以先把它们和 Z80 CPU 中带有同样代号的引脚连接起来。这样 CPU 和 PIO 就能使用这 8 个引脚交换数据了。

接下来要把 Z80 PIO 的 和 引脚分别连接到 Z80 CPU 的地址总线引脚 A0 和 A1 上。若表示 IC 引脚作用的代号上划有横线，则表示通过赋予该引脚 0（0V）可使之有效，反之若没有横线，则表示通过赋予该引脚 1（+5V）可使之有效。因此若赋予 引脚 1 则表示选中 B，反之赋予 0 则表示选中 A。同样地，若赋予 引脚 1 则表示选中的是 C（C 即 Control，表示控制模式）；反之赋予 0 则表示选中的是 D（D 即 Data，表示数据模式）。

通过 Z80 CPU 的 A0～A7（00000000～11111111 共 256 个地址）地址总线引脚可以选择内存（TC5517）中的存储单元。同样地，使用 Z80 CPU 的 A0～A1（00～11 共 4 个地址）地址总线引脚也可以选择 I/O（Z80 PIO）中的寄存器。

Z80 CPU 的 A8～A15 地址总线引脚尚未使用，所以什么都不连接。在电路图中可以用代号 NC（No Connection，未连接）表示引脚什么都不连接。IC 上的引脚有些只用于输出，有些只用于输入，还有些是输入输出两用的。对于只用于输出的引脚，不需要使用时的处理方法是这个引脚什么都不连接；而对于只用于输入或输入输出两用的引脚，不需要使用时的处理方法则是把这个引脚上的电压固定成是 +5V 或 0V。

2.5 连接时钟信号

正如前文所述，Z80 CPU 和 Z80 PIO 的运转离不开时钟信号。为了传输时钟信号，就需要把时钟发生器的 8 号引脚和 Z80 CPU 的 CLK（CLK 即 Clock，时钟）引脚、Z80 PIO 的 CLK 引脚分别连接起来。时钟发生器的 8 号引脚与 +5V 之间的电阻用于清理时钟信号。

再插入一段题外话。诸位可以把 Z80 CPU 和 Z80 PIO 在时钟信号下运转的情景，想象成是它们在跟随着滴答滴答响的时钟同步做动作。据说 19 世纪英国的查尔斯·巴贝奇（Charles Babbage）曾向制造计算机的原型——分析机发起过挑战。分析机由齿轮组成，因当时科技水平的限制并未制造完成。可是如果把分析机改用电子元件制造出来的话，就是今天的计算机。

2.6 连接用于区分读写对象是内存还是 I/O 的引脚

至此，我们已经先后把 Z80 CPU 连接到了 TC5517 和 Z80 PIO 上，这两次连接都使用了地址总线引脚 A0 和 A1。如果仅仅这样连接，就会导致一个问题，当地址的最后两位是 00、01、10 和 11 时，CPU 就无法区分访问的是 TC5517 中的存储单元，还是 Z80 PIO 中的寄存器了。

Z80 CPU 上的 （即 Memory Request，内存请求）引脚和 （即 I/O Request，I/O 请求）引脚解决了这个问题。当 Z80 CPU 和内存之间有数据输入输出时， 引脚上的值是 0，反之则是 1。当 Z80 CPU 和 I/O 之间有数据输入输出时， 引脚上的值是 0，反之则是 1。

若把 TC5517 的 （即 Chip Enable，选通芯片）引脚设成 0，则 TC5517 在电路中被激活，若设成 1 则从电路中隔离，因为此时 TC5517 进入了高阻抗状态，所以即便它上面的引脚已经接入了电路也不会接收任何电信号。在 Z80 PIO 中，则是通过将 引脚和 引脚同时设为 0 或 1，来达到与 TC5517 的 引脚相同的效果。若同时设为 0，则 Z80 PIO 在电路中被激活，若同时设为 1 则从电路中隔离（之所以使用两个引脚是因为这样更适合使用了多个 I/O 的情况）。

按照上面的讲解，下面需要把 Z80 CPU 的 引脚连接到 TC5517 的 引脚上。然后把 Z80 CPU 的 引脚连接到 Z80 PIO 的 引脚和 引脚上。请诸位先用红铅笔把这些引脚分别连接起来吧。

对内存和 I/O 而言，还必须要分清 CPU 是要输入数据还是输出数据。为此就要用到 Z80 CPU 的 引脚（即 Read，表示输入，为 0 时执行输入操作）和 引脚（即 Write，表示输出，为 0 时执行输出操作）了。请把 Z80 CPU 的 引脚和 TC 5517 的 引脚，Z80 CPU 的 引脚和 TC 5517 的 引脚分别连接起来。Z80 PIO 虽然只有 引脚，但由于数字 IC 引脚上的值要么是 0 要么是 1，所以只用 1 个 引脚也能区分是输入还是输出，0 的话是输入，1 的话就是输出（如表 2.2 所示）。

表 2.2 与读写内存、I/O 相关的引脚上的值

![]({{site.baseurl}}/images/20220821/20220821114354.png)

2.7 连接剩余的控制引脚

CPU、内存、I/O 中不但有地址总线引脚、数据总线引脚，还有其他引脚，通常把这些引脚统称为“控制引脚”。之所以这样命名是因为这些引脚上输入输出的电信号具有控制 IC 的功能。现在 Z80 CPU 上只剩下 9 个控制引脚没有连接了，那么就再加把劲，继续用红铅笔把它们也连接到电路中吧。

首先把 Z80 CPU 的 引脚（即 Machine Cycle 1，机器周期 1）和 引脚（即 Interrupt，中断）与 Z80 PIO 上标有相同代号的引脚连接起来。 是用于同步的引脚， 引脚是用于从 Z80 PIO 向 Z80 CPU 发出中断请求的引脚。所谓中断就是让 CPU 根据外部输入的数据执行特定的程序。有关中断的详细内容将在第 4 章介绍，这里只需要先记住 I/O 可以中断 CPU 正在执行的程序的处理流程就可以了。

一旦把 Z80 CPU 的 引脚（即 Reset，重置）上的值先设成 0 再还原成 1，CPU 就会被重置，重新从内存 0 号地址上的指令开始顺序往下执行。重置 CPU 可以通过按键开关完成。按键开关需要经过电阻接在 +5V 和 0V 之间。请仔细地观察这一部分的电路图，可以看出 引脚上平时是 +5V（即 1）。当按下按键开关时， 引脚就变成了 0V（即 0），而放开按键开关后又会回到 +5V（即 1）。电阻是为了防止短路而加入的，否则一旦按下了按键开关，+5V 和 0V 就会直接接到一起发生短路。像这样通过加入电阻把 +5V 和 0V 连接起来的方法在电路图中随处可见（如图 2.8 所示）。

![]({{site.baseurl}}/images/20220821/20220821114356.png)

图 2.8 如何用开关输入 0 或 1

连接在 引脚上的电容，用于在电路接通电源时自动重置 CPU。电容就好像一个充电电池，具有储存电荷的功能。在通电后的一刹那，由于电容正在充电，所以 引脚上的电压并不会立刻上升到 +5V。而完成充电后， 引脚的电压会变为 +5V，这样就相当于 引脚上的值从 0 变成了 1，重置了一次 CPU。

总线是连接到 CPU 中数据引脚、地址引脚、控制引脚上的电路的统称。使用快动开关可以使 Z80 CPU 的 引脚（即 Bus Request，总线请求）上的值在 0 和 1 之间切换。若将 引脚的值设为 0，则 Z80 CPU 从电路中隔离。当处于这种隔离状态时，就可以不通过 CPU，手动地向内存写入程序了。像这样不经过 CPU 而直接从外部设备读写内存的行为叫作 DMA（Direct Memory Access，直接存储器访问）。在诸位所使用的个人计算机里，硬盘等设备要读写内存时使用的就是 DMA。

当 Z80 CPU 从电路中隔离后， 引脚（即 Bus Acknowledge，响应总线请求）上的值就会变成 0。也就是说，把 引脚上的值设成 0 以后，还要确认 引脚上的值已经变成了 0，然后才能进行 DMA。请把 引脚分别连接到 4 个 74367 的 和 引脚上。有关 74367 的作用将在后面说明。

Z80 CPU 的其他控制引脚并未使用。所以要把 引脚和 引脚上的值设为 1，即连接到 +5V 上。之所以在连接时加入电阻，是为了便于今后加入开关等元件。请诸位先记住一个词——上拉（Pull-up），指的就是像这样通过加入电阻把元件的引脚和 +5V 连接起来。剩下的 引脚和 引脚什么都不连接。

Z80 PIO 的 PA0～PA7（PA 表示 Port A）以及 PB0～PB7（PB 表示 Port B）用于与外部设备进行输入输出，所以稍后要把它们分别连接到指拨开关和 LED 上。对于剩下的几个引脚可以这样处理：将 IEI 引脚上拉，IEO 引脚、 引脚、ARDY 引脚、 引脚和 BRDY 引脚则什么都不连接。

到此为止，Z80 CPU、TC5517、Z80 PIO 以及时钟发生器上要用到的引脚就都接入电路了。这意味着计算机主机系统的功能完成了。作为总结，表 2.3 汇总了这几块 IC 上引脚的作用以及电信号的输入输出方向（从各个 IC 的角度看）。

表 2.3 Z80 CPU、TC5517、Z80 PIO 的引脚作用以及输入输出方向

![]({{site.baseurl}}/images/20220821/20220821114925.png)

![]({{site.baseurl}}/images/20220821/20220821114942.png)

用红铅笔尝试布线的诸位觉得怎么样呢？虽然需要连接的电路有点多，但也并不是太复杂吧？其实计算机的工作原理非常简单。CPU 在时钟信号的控制下解释、执行内存中存储的程序，按照程序中的指令从内存或 I/O 中把数据输入到 CPU 中，在 CPU 内部进行运算，再把运算结果输出到内存或 I/O 中。无论是小型的微型计算机，还是高性能的个人计算机，其工作原理都是相同的。

2.8 连接外部设备，通过 DMA 输入程序

下面我们继续布线，这次将计算机主机系统和外部设备连接起来。我们要使用 2 个指拨开关和 1 个按键开关，向地址总线引脚和数据总线引脚发送电信号，然后通过 DMA 将数据总线上的数据存储到内存。下面我们就先将这些元件连接到电路中。

首先将图 2.1 中右侧最上方的一个指拨开关连接到作为内存的 TC5517 的数据总线引脚 D0～D7 上。再将它下面紧挨着它的指拨开关连接到 TC5517 的地址总线引脚 A0～A7 上。接下来将用于控制内存写入的按键开关连接到 TC5517 的 引脚上。为了写入数据，还要将 TC5517 的 引脚上拉起来，连接到 +5V 上，然后把 引脚连接到 0V 上。把这些元件都连接起来以后，就可以拨动指拨开关，用二进制数设定地址总线引脚和数据总线引脚上的数据了。设定完后按下按键开关，数据就会被写入 TC5517 中。在 2 个指拨开关下方还有一个指拨开关，它通过电阻接到 +5V 上，这样拨动这个指拨开关就可以输入 +5V 或 0V 的信号了。

但是如果这些开关直接连接到了 TC5517 的各个引脚上，在程序执行时，开关的状态就会对电路产生影响。因此要使用 74367，在程序执行时把开关从电路中隔离出来。74367 是一种叫作“三态总线缓冲器”的 IC。在这个 IC 的电路图符号中，有用三角形标志代表的缓冲器，表示使电信号从右向左直接通过。但是，只有在 74367 的 引脚和 引脚同时为 0 的时候，电信号才能通过。而当 引脚和 引脚同时 为 1 时，74367 就会与电路隔离。

一旦打开了 Z80 CPU 的 引脚连接着的开关，就可以通过 引脚输出 0 得知 CPU 进入了 DMA 状态。因此只要把 > 引脚连接到 4 个 74367 的 引脚和 引脚上，就可以实现通过 DMA 向内存写入数据了。

2.9 连接用于输入输出的外部设备

布线终于快结束了。下面该轮到把最下方用于输入数据的指拨开关和 LED 连接到 Z80 PIO 上了。当微型计算机运行起来后，指拨开关可用于从外部输入数据，LED 可用于向外部输出数据。

用于输入数据的指拨开关，要连接到 Z80 PIO 的 PA0～PA7 引脚上。连接时没有使用 74367 是为了在程序运行中可以通过 Z80 PIO 从指拨开关获得输入的数据。

表示输出数据的 LED 要通过电阻连接到 +5V 上。这里的布线方法依据惯例，输入 0V 点亮 LED（如图 2.9 所示）。LED 要通过 7404 这样的 IC 连接到 Z80 PIO 的 PB0～PB7 引脚上。在 7404 的电路图符号中，末端带有一个小圆圈的三角形符号表示反相器，作用是将左侧输入的电信号反转后（即 0 变 1、1 变 0）输出到右侧。通过这样的设计，当 Z80 PIO 的 PB0～PB7 引脚上的值为 0 时 LED 就会熄灭，为 1 时 LED 就会点亮。

![]({{site.baseurl}}/images/20220821/20220821114944.png)

图 2.9 点亮 LED 的方法

是不是觉得忘记了什么呢？没错！ 74367 和 7404 上也都有 Vcc 引脚和 GND 引脚。请将它们分别连接到 +5V 和 0V 上。对于 74367 和 7404 中未使用的引脚（标有 NC 的引脚），或者什么都不连接，或者将它们连接到 GND 上。

2.10 输入测试程序并进行调试

微型计算机终于顺利地制作出来了，诸位辛苦了！微型计算机接上电源就能用了吗？其实还不能，因为尽管硬件组装好了，但若没有输入软件，计算机还是不能工作的。所以即使为微型计算机接通了电源，它也什么都执行不了。

下面就编写一段测试程序吧。编写时可以使用哪种编程语言呢？是 BASIC、C 语言，还是 Java 呢？其实这些语言都无法使用，因为作为计算机大脑的 CPU 只能解释执行一种编程语言，那就是靠罗列二进制数构成的机器语言（原生代码）。代码清单 2.1 展示了一段用机器语言编写的测试程序。程序是指令和数据的集合，表示指令或数据的数值是以 8 比特为一个单位存储到内存中的。这段程序只实现了一个简单的功能，那就是通过拨动连接到 Z80 PIO 上的指拨开关控制 LED 的亮或灭。有关机器语言的细节将在接下来的第 3 章中介绍。

代码清单 2.1 用机器语言编写的测试程序

```
地址           程序
00000000       00111110
00000001       11001111
00000010       11010011
00000011       00000010
00000100       00111110
00000101       11111111
00000110       11010011
00000111       00000010
00001000       00111110
00001001       11001111
00001010       11010011
00001011       00000011
00001100       00111110
00001101       00000000
00001110       11010011
00001111       00000011
00010000       11011011
00010001       00000000
00010010       11010011
00010011       00000001
00010100       11000011
00010101       00010000
00010110       00000000
```

接通了微型计算机的电源后，请按下 Z80 CPU 上的 DMA 请求开关。在这个状态下，拨动用于输入内存程序和指定内存输入地址的两个指拨开关，把代码清单 2.1 所示的程序一行接一行地输入内存。先来输入第一行代码，拨动用于指定地址的指拨开关，设定出第一行代码所在的内存地址 00000000，然后拨动用于输入程序的指拨开关，设定出程序代码 00111110。再然后按下用于向内存写入程序的按键开关。接下来输入第二行代码，设定出内存地址 00000001，设定出程序代码 11001111，再次按下按键开关。反复进行这三步操作，直至输入完程序代码的最后一行。所有的指令都输入完成后，按下用于重置 CPU 的按键开关，控制 DMA 请求的快动开关就会还原成关闭状态，与此同时程序也就运行起来了。“太棒了，终于成功了！”这真是令人激动的一瞬间 啊（如照片 2.2 所示）。

![]({{site.baseurl}}/images/20220821/20220821114946.png)

照片 2.2 运行中的微型计算机

程序一旦运行起来，就可以用用于输入数据的指拨开关控制 LED 的亮与灭。只要拨动指拨开关，LED 的亮灭就会随之改变。LED 并不会只亮一下，而是一直亮着，时刻保持着指拨开关上的状态。

☆   ☆   ☆

如今活跃在计算机行业第一线的工程师们，他们多数都在年轻的时候玩过微型计算机。诸位可以把这本书拿给他们看，他们也许会这样说：现在还有人玩这个？不过不管怎么说，对计算机理解程度的深浅还是和有没有制作过微型计算机有很大关系的。

笔者真的按照图 2.1 所示的电路图制作过微型计算机，收集零件就费了不少劲。而在单片机广泛应用的今天，CPU、I/O、内存都被集成到了一块 IC 上。可话又说回来，即便只是在纸上体验制作微型计算机的过程，也还是非常有益的。诸位在本章制作了微型计算机，想必这一体验定会加深诸位对计算机的理解，使诸位越来越喜欢计算机。

在接下来的第 3 章中，笔者会先用汇编语言为微型计算机编写程序，然后尝试“手工汇编”，即以手工作业的方式将这段程序转换成机器语言（原生代码）。敬请期待！

## 第 3 章 体验一次手工汇编

在阅读本章内容前，让我们先回答下面的几个问题来热热身吧。

* 问题

初级问题

什么是机器语言？

中级问题

通常把标识内存或I/O 中存储单元的数字称作什么？

高级问题

CPU 中的标志寄存器（Flags Register）有什么作用？

怎么样？被这么一问，是不是发现有一些问题无法简单地解释清楚呢？下面，笔者就公布答案并解释。

* 答案

初级问题： 由二进制数字构成的程序，CPU 可以直接对其解释、执行。

中级问题： 标识内存或I/O 中存储单元的数字叫作“地址”。

高级问题： 用于在运算指令执行后，存储运算结果的某些状态。

* 解释

初级问题： 不仅是汇编语言，用C 语言、Java、BASIC 等编程语言编写的程序，也都需要先转换成机器语言才能被执行。
机器语言有时也叫作“原生代码”（Native Code）。

中级问题： 内存中有多个数据存储单元。计算机用从0 开始的编号标识每个存储单元，这些编号就是地址（Address）。
I/O 中的寄存器也可以用地址来标识。哪个寄存器对应哪个地址，取决于CPU 和I/O 之间的布线方式。

高级问题： Flag 的本意是“旗子”，这里引申为“标志”。一旦执行了算术运算、逻辑运算、比较运算等指令后，
标志寄存器并不会存放运算结果的值，而是会把运算后的某些状态存储起来，
例如运算结果是否为0、是否产生了负数、是否有溢出（Overflow）等。

* 本章重点

本章的目标是通过编写程序使诸位亲身体验计算机的运行机制。为了达到这个目的，
就需要使用一种叫作“汇编语言”的编程语言来编写程序，然后再把编好的程序通过手工作业转换成CPU 可以直接执行的机器语言。

这样的转换工作叫作“手工汇编”（Hand Assemble）。也许会有
人觉得听起来就好像挺麻烦的，事实上也的确如此，但是还是希望所
有和计算机相关的技术人员都能亲身体验一下用汇编语言编程和手工
汇编。

这次体验应该能加深诸位对计算机的理解，使诸位犹如拨云见日，
找到长期困惑着自己的问题的答案，不仅能因“我能看懂程序了”而
获得成就感，更能因发现“计算机原来很简单啊”而信心倍增。虽然
本章的主题稍有些复杂，但是笔者会放慢讲解的步伐，还请诸位努力
跟上。

3.1 从程序员的角度看硬件

为了体验手工汇编，下面我们就为在第2 章制作的微型计算机编写一个程序吧。因为程序的作用是驱动硬件工作，所以在编写程序之
前必须要先了解微型计算机的硬件信息。然而真正需要了解的硬件信
息只有以下7 种（如图3.1 所示），所以没有必要在编程时还总是盯着
详细的电路图看。

![]({{site.baseurl}}/images/20220821/20220821140221.png)

图3.1 编写程序之前需要了解的硬件信息

【CPU（处理器）信息】
* CPU的种类
* 时钟信号的频率

【内存信息】
* 地址空间
* 每个地址中可以存储多少比特的信息

【I/O 信息】
* I/O 的种类
* 地址空间
* 连接着何种周边设备

可以使用哪种机器语言取决于CPU（也称作处理器）的种类。所谓
机器语言就是只用0 和1 两个二进制数书写的编程语言。即便是相同
的机器语言，例如01010011，只要CPU 的种类不同，对它的解释也就
不同。有的CPU 会把它解释成是执行加法运算，有的CPU 会把它解释
成是向I/O 输出。这就好比同样是man 这个词，有的人会理解成“慢”，
有的人会理解成“男人”。

由于微型计算机上的CPU 是Z80 CPU，所以就要使用适用于Z80
CPU 的机器语言。顾名思义，机器语言就是处理器可以直接理解（与
生俱来就能理解）的编程语言。机器语言有时也叫作原生代码（Native
Code）。

所谓时钟信号的频率，就是由时钟发生器发送给CPU 的电信号的
频率。表示时钟信号频率的单位是MHz（兆赫兹 = 100 万回／秒）。微
型计算机使用的是2.5MHz 的时钟信号。时钟信号是在0 和1 两个数之
间反复变换的电信号，就像滴答滴答左右摆动的钟摆一样。通常把发
出一次滴答的时间称作一个时钟周期。

在机器语言当中，指令执行时所需要的时钟周期数取决于指令的
类型。程序员不但可以通过累加时钟周期数估算程序执行的时间，还
可以仅在特定的时间执行点亮LED（发光二极管）等操作。

每个地址都标示着一个内存中的数据存储单元，而这些地址所构
成的范围就是内存的地址空间。在我们的微型计算机中，地址空间为
0～255，每一个地址中可以存储8 比特（1 字节）的指令或数据。

连接着的I/O 的种类，就是指连接着微型计算机和周边设备的I/O
的种类。在微型计算机中，只安装了一个I/O，即上面带有4 个8 比特
寄存器的Z80 PIO。只要用CPU 控制I/O 的寄存器，就可以设定I/O 的
功能，与周边设备进行数据的输入输出。

所谓I/O 的地址空间，是指用于指定I/O 寄存器的地址范围。在
Z80 PIO 上，地址空间为0～3，每一个地址对应一个寄存器。

在内存中，每个地址的功能都一样，既可用于存储指令又可用于
存储数据。而I/O 则不同，地址编号不同（即寄存器的类型不同），功
能也就不同。在微型计算机中，是这样分配Z80 PIO 上的寄存器的：端
口A 数据寄存器对应0 号地址，端口B 数据寄存器对应1 号地址，端
口A 控制寄存器对应2 号地址，端口B 控制寄存器对应3 号地址。端
口A 数据寄存器和端口B 数据寄存器存储的是与周边设备进行输入输
出时所需的数据。其中，端口A 连接用于输入数据的指拨开关，端口
B 连接用于输出数据的LED。而端口A 控制寄存器和端口B 控制寄存
器则存储的是用于设定Z80 PIO 功能的参数。

3.2 机器语言和汇编语言

请看代码清单3.1 中列出的机器语言程序，这段程序在第2 章中已
经介绍过了，功能是把由指拨开关输入的数据输入CPU，然后CPU 再
把这些数据原封不动地输出到LED。也就是说，可以通过拨动指拨开
关控制LED 的亮或灭。

代码清单3.1 点亮LED 的机器语言程序

```
地址        机器语言
00000000    00111110
00000001    11001111
00000010    11010011
00000011    00000010
00000100    00111110
00000101    11111111
00000110    11010011
00000111    00000010
00001000    00111110
00001001    11001111
00001010    11010011
00001011    00000011
00001100    00111110
00001101    00000000
00001110    11010011
00001111    00000011
00010000    11011011
00010001    00000000
00010010    11010011
00010011    00000001
00010100    11000011
00010101    00010000
00010110    00000000
```

这段由8 比特二进制数构成的机器语言程序总共23 个字节。若把
这些字节一个接一个地依次写入内存中，所占据的内存空间就是
00000000～00010110。一旦重置了CPU，CPU 就会从0 号地址开始顺
序执行这段程序。

在机器语言程序中，虽然到处都是0 和1 的组合，但是每个组合
都是有特定含义的指令或数据。可是对人来说，如果只看0 和1 的话，
恐怕很难判断各个组合都表示什么。

于是就有人发明出了一种编程方法，根据表示指令功能的英语单
词起一个相似的昵称，并将这个昵称赋予给0 和1 的组合。这种类似
英语单词的昵称叫作“助记符”，使用助记符的编程语言叫作“汇编语
言”。无论是使用机器语言还是汇编语言，所实现的功能都是一样的，
区别只在于程序是用数字表示，还是用助记符表示。也就是说，如果
理解了汇编语言，也就理解了机器语言，更进一步也就理解了计算机
的原始的工作方式。

代码清单3.1 中的机器语言可以转换成如代码清单3.2 所示的汇编
语言。汇编语言的语法十分简单，以至于语法只有一个，即把“标
签”“操作码（指令）”和“操作数（指令的对象）”并排写在一行上，仅此而已。

代码清单3.2 用汇编语言的代码表示代码清单3.1 中的机器语言

```
标签    操作码    操作数
        LD        A, 207
        OUT       (2), A
        LD        A, 255
        OUT       (2), A
        LD        A, 207
        OUT       (3), A
        LD        A, 0
        OUT       (3), A
LOOP:   IN        A, (0)
        OUT       (1), A
        JP        LOOP
```

标签的作用是为该行代码对应的内存地址起一个名字。编程时如
果总要考虑“这一行的内存地址是什么来着？”就会很不方便，所以在
汇编语言中用标签来代替地址。用汇编语言编程时可以在任何需要标
签的地方“贴上”名称任意的标签。在代码清单3.2 所示的程序中，使
用了名称为“LOOP:”的标签。

操作码就是表示“做什么”的指令。因为用助记符表示的指令是
英语单词的缩写，比如LD 是Load（加载）的缩写，所以多多少少能
猜出其中的含义。汇编语言中提供了多少种助记符，CPU 就有多少种
功能。Z80 CPU 的指令全部加起来有70 条左右。这里先把主要的指
令列在表3.1 中，请诸位粗略地浏览一下。在浏览的过程中请注意这
些指令的分类，按功能这些指令可以分成运算、与内存的输入输出和
与I/O 的输入输出三类。这是因为计算机能做的事也只有输入、运
算、输出这三种了。

操作数表示的是指令执行的对象。CPU 的寄存器、内存地址、I/O
地址或者直接给出的数字都可以作为操作数。如果某条指令需要多个
操作数，那么它们之间就要用逗号分割。操作数的个数取决于指令的
种类。也有不需要操作数的指令，比如用于停止CPU 运转的HALT
指令。

汇编语言的语法和英语祈使句的语法很像。若对比英语的祈使句
Give me money 和汇编语言的语句，就可以看出在英语的祈使句中，一
开头放置了一个表示“做什么”的动词，这个动词就相当于汇编语言中
的操作码。在动词后面放置了一个表示“动作作用到什么上”的宾语，
这个宾语就相当于汇编语言中的操作数。因为程序的作用是向CPU 发
出指令，而且编程语言又是由说英语的人发明的，所以编程语言与英
语祈使句类似也就不足为奇了。

构成机器语言的是二进制数，而在汇编语言中，则使用十进制数
和十六进制数记录数据。若仅仅写出123 这样的数字，表示的就是十进
制数；而像123H 这样在数字末尾加上了一个H（H 表示Hexadecimal，
即十六进制数），表示的就是十六进制数。在代码清单3.2 所示的程序
中，使用的都是十进制数。

在表3.1 中有这样几条指令希望诸位注意。在第2 章中介绍过，
Z80 CPU 的MREQ 引脚和IORQ 引脚实现了一种能区分输入输出对象
的机制，可以区分出使用着相同内存地址的内存和I/O。在汇编语言
中，读写内存的指令不同于读写I/O 的指令。一旦执行了读写内存的指
令，比如LD 指令，MREQ 引脚上的值就会变为0，于是内存被选为输
入输出的对象；而一旦执行了读写I/O 的指令，比如IN 或OUT 指令，
IORQ 引脚上的值就会变为0，于是I/O（这里用的是Z80 PIO）被选为
输入输出的对象。

表3.1 Z80 CPU 中的主要指令

![]({{site.baseurl}}/images/20220821/20220821141648.png)

3.3 Z80 CPU 的寄存器结构

这里先稍微复习一下第2 章的内容。计算机的硬件有三个基本要
素，CPU、内存和I/O。CPU 负责解释、执行程序，从内存或I/O 输入
数据，在内部进行运算，再把运算结果输出到内存或I/O。内存中存放
着程序，程序是指令和数据的集合。I/O 中临时存放着用于与周边设备
进行输入输出的数据。

复习就到这里，下面就来扩充所学到的知识吧。既然数据的运算是在CPU 中进行的，那么在CPU 内部就应该有存储数据的地方。
这种存储数据的地方叫作“寄存器”。虽然也叫寄存器，但是与I/O 的寄存器不同，CPU 的寄存器不仅能存储数据，
还具备对数据进行运算的能力。CPU 带有什么样的寄存器取决于CPU 的种类。
Z80 CPU 所带有的寄存器如图3.2 所示。A、B、C、D 等字母是寄存器的名字。
在汇编语言当中，可以将寄存器的名字指定为操作数。

图3.2 Z80 CPU 的寄存器

    Z80 CPU
    A    F
    B    C
    D    E
    H    L
    I    R
      IX
      IY
      SP
      PC

A、B、C、D、E、F、H、L 每个寄存器都带有一个辅助寄存器，本节省略了对它们的介绍。

IX、IY、SP、PC 这4 个寄存器的大小是16 比特，其余寄存器的大小都是8 比特。寄存器的用途取决于它的类型。
有的指令只能将特定的寄存器指定为操作数。

举例来说，A 寄存器也叫作“累加器”，是运算的核心。所以连接
到它上面的导线也一定会比其他寄存器的多。F 寄存器也叫作“标志寄
存器”，用于存储运算结果的状态，比如是否发生了进位，数字大小的
比较结果等。PC 寄存器也叫作“程序指针”，存储着指向CPU 接下来
要执行的指令的地址。PC 寄存器的值会随着滴答滴答的时钟信号自动
更新，可以说程序就是依靠不断变化的PC 寄存器的值运行起来的。SP
寄存器也叫作“栈顶指针”，用于在内存中创建出一块称为“栈”的临
时数据存储区域。

既然诸位已经熟悉了寄存器的功能，下面笔者就开始介绍代码清
单3.2 的内容。这段程序大体上可以分为两部分——“设定Z80 PIO”
和“与Z80 PIO 进行输入输出”。Z80 PIO 带有两个端口（端口A 和端
口B），用于与周边设备输入输出数据。首先必须为每个端口设定输入
输出模式。这里端口A 用于接收由指拨开关输入的数据，为了实现这
个功能，需要如下的代码。
```
LD A, 207
OUT (2), A
LD A, 255
OUT (2), A
```

这里的207 和255 是连续向Z80 PIO 的端口A 控制寄存器（对应
该I/O 的地址编号为2）写入的两个数据。虽然使用OUT 指令可以向
I/O 写入数据，但是不能直接把207、255 这样的数字作为OUT 指令的
操作数。操作数必须是已存储在CPU 寄存器中的数字，这是汇编语言
的规定。

于是，先通过指令“LD A, 207”把数字207 读入到寄存器A 中，
再通过指令“OUT (2), A”把寄存器A 中的数据写入到I/O 地址所对应
的寄存器中。像“(2)”这样用括号括起来的数字，表示的是地址编号。
端口A 控制寄存器的I/O 地址是2 号。

一旦把207 写入到端口A 控制寄存器，Z80 PIO 就明白了：“哦，
想要设定端口A 的输入输出模式啊。”而通过接下来写入的255，Z80
PIO 就又知道：“哦，要把端口A 设定为输入模式啊。”

同样地，通过下面的程序可以将端口B 设定为输出模式。
```
LD A, 207
OUT (3), A
LD A, 0
OUT (3), A
```

先把207 写入到端口B 控制寄存器（对应的I/O 地址为3 号），然
后写入0。这个0 表示要把端口B 设定为输出模式。应该使用什么样的
数字设定端口，在Z80 PIO 的资料上都有说明。用207、255、0 这样
的数字来表示功能设定参数，这也是为了适应计算机的处理方式。

完成了Z80 PIO 的设定后，就进入了一段死循环处理，用于把由指
拨开关输入的数据输出到LED。为了实现这个功能，需要如下的代码。
```
LOOP: IN A, (0)
    OUT (1), A
    JP LOOP
```

“IN A, (0)”的作用是把数据由端口A 数据寄存器（连接在指拨开
关上，对应的I/O 地址为0 号）输入到CPU 的寄存器A。“OUT (1), A”
的作用是把寄存器A 的值输出到端口B 数据寄存器上（连接在LED
上，对应的I/O 地址为1 号）。

“JP LOOP”的作用是使程序的流程跳转到LOOP（笔者随意起的
一个标签名）标签所标识的指令上。JP 是Jump 的缩写。“IN A, (0)”所
在行的开头有一个标签“LOOP:”，代表着这一行的内存地址。正如刚
才所讲的那样，在用汇编语言编程时，如果老想着“这一行对应的内存
地址是什么来着？”就会很不方便，所以就要用“LOOP:”这样的标签
代替内存地址。当把标签作为JP 指令的操作数时，标签名的结尾不需
要冒号“:”，但是在设定标签时，标签名的结尾则需要加上一个冒号，
这一点请诸位注意。

3.4 追踪程序的运行过程

用汇编语言编写的程序是不能直接运行的，必须先转换成机器语
言。机器语言是唯一一种CPU 能直接理解的编程语言。从汇编语言到
机器语言的转换方法将在稍后介绍，这里先来看一下代码清单3.3，里
面列出了事先转换出来的机器语言，以及对应的汇编语言。1 条汇编语
言的指令所对应的机器语言由多个字节构成。而且，同样是汇编语言
中的1 条指令，有的指令对应着1 个字节的机器语言，有的指令则对
应着多个字节的机器语言。汇编语言中的1 条指令能转换成多少条机
器语言取决于指令的种类以及操作数的个数。代码清单3.3 中第一个内
存地址是00000000（0 号地址），下一个地址是00000010（2 号地址），
中间隔了2 个地址，这说明如果从0 号地址开始存储一条2 字节的机
器语言，那么下一条机器语言就从2 号地址开始存储。

下面就一边看着代码清单3.3，一边跟随着CPU 解释、执行机器
语言程序吧。在这里，我们假设机器语言的程序是像代码清单3.3 那样
被存储在内存中的。

一旦重置了CPU，00000000 就会被自动存储到PC 寄存器中，这
意味着接下来CPU 将要从00000000 号地址读出程序。首先CPU 会从
00000000 号地址读出指令00111110，判断出这是一条由2 个字节构成
的指令，于是接下来会从下一个地址（即00000001，1 号地址，代码清
单3.3 中并没有标记出该地址本身）读出数据11001111，把这两个数据
汇集到一起解释、执行。执行的指令是把数值207 写入到寄存器A，
用汇编语言表示的话就是“LD A, 207”。这时，由于刚刚从内存读出了
一条2 字节的指令（占用2 个内存地址），所以PC 寄存器的值要增加
2，并接着从00000010 号地址读出指令，解释并执行。

接下来的流程与此类似，通过反复进行“读取指令”“解释、执行
指令”“更新PC 寄存器的值”这3 个操作，程序就能运行起来了。一
旦执行完最后一行的JP LOOP 所对应的机器语言，PC 寄存器的值就会
被设为标签LOOP 对应的地址00010000，这样就可以循环执行同样的
操作。请诸位重点观察PC 寄存器是如何控制程序流程的。

代码清单3.3 汇编语言与机器语言的对应关系
```
地址        机器语言                        标签     操作码     操作数
00000000    00111110 11001111                        LD          A, 207
00000010    11010011 00000010                        OUT         (2), A
00000100    00111110 11111111                        LD          A, 255
00000110    11010011 00000010                        OUT         (2), A
00001000    00111110 11001111                        LD          A, 207
00001010    11010011 00000011                        OUT         (3), A
00001100    00111110 00000000                        LD          A, 0
00001110    11010011 00000011                        OUT         (3), A
00010000    11011011 00000000               LOOP:    IN          A, (0)
00010010    11010011 00000001                        OUT         (1), A
00010100    11000011 00010000 00000000               JP          LOOP
```

3.5 尝试手工汇编

在CPU 的资料中，明确写有所有可以使用的助记符，以及助记符
转换成机器语言后的数值。只要查看这些资料，就可以把用汇编语言
编写的程序手工转换成机器语言的程序，这样的工作称为“手工汇编”。
进行手工汇编时，要一行一行地把用汇编语言编写的程序转换成机器
语言。下面就实际动手试一试吧。表3.2 列出了汇编语言中必要指令的
助记符、助记符所对应的机器语言，以及执行这些机器语言所需的时
钟周期数。

表3.2 从助记符到机器语言的转换方法
```
助记符        机器语言        时钟周期数
LD A, num     00111110 num     7
OUT (num), A  11010011 num     11
IN A, (num)   11011011 num     11
JP num        11000011 num     10
```

下面就从汇编语言的第1 行开始转换。第一行的“LD A, 207”匹
配“LD A, num”这个模式，所以可以先转换成“00111110 num”。然后
将十进制数的207 转换成8 比特的二进制数，用这个二进制数替换
num。使用Windows 自带的计算器程序就可以很方便地把十进制数转
换成二进制数。从Windows 的开始菜单中选择“运行”，输入calc 后点
击“确定”按钮，就可以启动计算器程序。

接下来，从计算器的“查看”菜单中选择“科学型”，这样就得到
了一个可以用十进制数或二进制数表示数字的计算器了。首先选中“十
进制”单选框，然后输入207，接下来选中“二进制”单选框，这样
207 就变成了二进制数的11001111（如图3.3 所示）。至此，“LD A,
207”就转换成了机器语言00111110 11001111。由于这条指令存储在内
存最开始的部分（00000000 号地址），所以要把这条指令和内存地址像
下面这样并排写下来。
```
地址         汇编语言        机器语言
00000000     LD A, 207       00111110 11001111
```

![]({{site.baseurl}}/images/20220821/20220821143102.png)

图3.3 用Windows 的计算器程序把十进制数转换成二进制数

第2 条指令“OUT (2), A”匹配“OUT (num), A”这个模式，所以
可以先转换成“11010011 num”。然后把num 的部分替换成00000010，
即用8 比特的二进制数表示的十进制数2，最终就得到了机器语言
“11010011 00000010”。因为内存中已经存储了2 字节的机器语言，所
以这条机器语言要从00000010 号地址（用十进制表示的话就是2 号地
址）开始记录。
```
地址          汇编语言            机器语言
00000010      OUT (2), A          11010011 00000010
```

这之后由于LD 指令和OUT 指令又以相同的模式出现了3 次，所
以可以用相同的步骤转换成机器语言。请诸位注意，机器语言中每条
语句的字节数是多少，内存地址就相应地增加多少。
```
地址          汇编语言            机器语言
00000100      LD A, 255           00111110 11111111
00000110      OUT (2), A          11010011 00000010
00001000      LD A, 207           00111110 11001111
00001010      OUT (3), A          11010011 00000011
00001100      LD A, 0             00111110 00000000
00001110      OUT (3), A          11010011 00000011
```

接下来是“IN A, (0)”匹配“IN A, (num)”这个模式，所以可以先转
换成“11011011 num”。然后把num 替换成00000000，即用8 比特的二
进制数表示的十进制数0，最终就得到了机器语言“11011011 00000000”。
对于接下来的“OUT (1), A”，也可以按照同样的方法转换。
```
地址           汇编语言          机器语言
00010000       IN A, (0)         11011011 00000000
00010010       OUT (1), A        11010011 00000001
```

最后一句的JP LOOP 匹配模式“JP num”， 所以可以先转换成
“11000011 num”。请注意这里要用16 比特的二进制数替代作为内存地
址的num。在微型计算机中是以8 比特为单位指定内存地址的，但在
Z80 CPU 中用于设定内存地址的引脚却有16 个，所以在机器语言中也
要用16 比特的二进制数设定内存地址。JP 指令跳转的目的地为
00010000，即“LOOP:”标签所标示的语句“LD A, 0”对应的内存地
址。把这个地址扩充为16 比特就是“00000000 00010000”。要扩充到
16 位，只需要把高8 位全部设为0 就可以了。

还有一点希望诸位注意，在将一个2 字节的数据存储到内存时，
存储顺序是低8 位在前、高8 位在后（也就是逆序存储）。这样的存储
顺序叫作“小端序”（Little Endian），与此相反，将数据由高位到低位
顺序地存储到内存的存储顺序则叫作“大端序”（Big Endian）。根据
CPU 种类的不同，有的CPU 使用大端序，有的CPU 使用小端序。Z80
CPU 使用的是小端序，因此JP LOOP 对应的机器语言为“11000011
00010000 00000000”。
```
地址              汇编语言          机器语言
00010100          JP LOOP           11000011 00010000 00000000
```

手工汇编至此就结束了。自己写的汇编语言程序，又通过自己的
双手转换成了机器语言，我们应该为此感到骄傲。

3.6 尝试估算程序的执行时间

在本章的最后，介绍一下如何通过时钟周期数估算程序的执行时
间。请先向前翻到表3.2，找出执行每条汇编语言指令所需的时钟周期
数。然后把代码清单3.2 中所用到的每条指令的时钟周期数累加起来。
于是可以算出到LOOP 标签为止的8 条指令共需要7＋11＋7＋11＋7＋
11＋7＋11 = 72 个时钟周期；LOOP 标签之后的3 条指令共需要11＋11
＋10 = 32 个时钟周期。因为微型计算机采用的是2.5MHz 的晶振，也
就是1 秒可以产生250 万个时钟周期，所以每个时钟周期是1 秒÷250
万 = 0.0000004 秒 = 0.4 微秒。72 个时钟周期就是72×0.4 = 28.8 微秒；
32 个时钟周期就是12.8 微秒。这段程序是用LED 的亮或灭来表示指
拨开关的开关状态，所以LOOP 标签之后所执行的操作“输入、输出、
跳转”每1 秒可以反复执行1 秒÷12.8 微秒/ 次 = 78125 次之多，可见
计算机的计算速度有多么惊人。

☆ ☆ ☆

比起C 语言或BASIC 等高级语言，汇编语言的语法简单、指令数少，说不定会更加容易学习，可是今天还在使用汇编语言的人却是凤
毛麟角了。使用汇编语言编程时，因为要事无巨细地列出计算机的行为，所以程序会变得冗长繁复。
因此诸位只在纸上体验汇编语言、机器语言以及手工汇编就足够了。只要具备了这些知识，
即便是用C 语言或BASIC 等编程语言编程时，也一样能感受到计算机底层的工作方式，也就是说变得更加了解计算机了。

在接下来的第4 章中，笔者将要介绍条件分支和循环等“程序的流程”，还会稍微介绍一些有关“算法”的内容。敬请期待！

## 第 4 章 程序像河水一样流动着

* 热身问答

在阅读本章内容前，让我们先回答下面的几个问题来热热身吧。

初级问题

Flow Chart 的中文意思是什么？

中级问题

请说出自然界中河流的三种流动方式。

高级问题

事件驱动是什么？

* 答案

初级问题： 流程图。

中级问题： 向着一个方向流淌；流着流着产生支流；卷成漩涡。

高级问题： 用户的操作等产生事件后，由事件决定程序的流程。

* 解释

初级问题： 流程图（Flow Chart）是指用图的形式表示程序的流程。

中级问题： 与河流的流动方式一样，程序的流程也分为三种。在
程序中，把犹如水流向着一个方向流淌的流程称作
“顺序执行”；把犹如水流流着流着产生了支流的流程
称作“条件分支”；把犹如水流卷成漩涡的流程称作
“循环”。

高级问题： Windows 应用程序的运行就是由事件驱动的。例如，
选择“打开文件”菜单项就能打开一个窗口，在里面可
以指定要打开文件的名称和存储位置。之所以能够这
样是因为一旦触发了“选中了菜单项”这个事件，程序
的流程就相应地流转到了处理打开窗口的那部分。

* 本章重点

本章的主题是程序的流程。程序员一般都是先考
虑程序的流程再开始编写程序的。只有编写过程序的
人才能体会到“程序是流动着的”。一个人编写的程序如果不能按照预
期运行，就说明他还没有很好地掌握“程序是流动着的”这一概念。
为什么说“程序是流动着的”呢？因为作为计算机大脑的CPU 在
同一时刻基本上只能够解释、执行一条指令。把指令和作为指令操作
对象的数据排列起来就形成了程序。请想象把若干条指令一条挨一条
地依次排列到一条长长的纸带上。然后把这条纸带展开抻平，从顶端
开始依次解释并执行上面的每条指令，这样看起来程序就好像流动起
来了。这就是程序的流程。但是程序的流程并不是只有这一种。那么
下面笔者就先介绍一下程序流程的种类吧。

* 4.1　程序的流程分为三种

诸位读到此处，应该能够从硬件上想像出计算机的运作方式了吧。
计算机的硬件系统由CPU、I/O 和内存三部分构成。内存中存储着程
序，也就是指令和数据。CPU 配合着由时钟发生器发出的滴答滴答的
时钟信号，从内存中读出指令，然后再依次对其进行解释和执行。
CPU 中有各种各样的各司其职的寄存器。其中有一个被称为PC
（Program Counter，程序计数器）的寄存器，负责存储内存地址，该地
址指向下一条即将执行的指令。每解释执行完一条指令，PC 寄存器的
值就会自动被更新为下一条指令的地址。
PC 寄存器的值在大多数情况下只会增加。下面假设PC 寄存器正
指向内存中一个从10 号地址开始的3 字节指令。CPU 解释执行完这条
指令后，PC 寄存器中的值就变成10＋3 = 13 了。也就是说，程序基本
上是从内存中的低地址（编号较小的地址）开始，向着高地址（编号较
大的地址）流下去的 。我们把程序的这种流动称为“顺序执行”（如图
4.1 所示）。

![]({{site.baseurl}}/images/20220821/20220821144102.png)

程序的流程总共有三种。除了顺序执行以外，还有“条件分支”和
“循环”。因为只有这三种，记忆起来还是很轻松的吧。
正如上文所述，顺序执行是按照指令记录在内存中的先后顺序依
次执行的一种流程。而循环则是在程序的特定范围内反复执行若干次
的一种流程。条件分支是根据若干个条件的成立与否，在程序的流程
中产生若干个分支的一种流程。无论规模多么大多么复杂的程序，都
是通过把以上三种流程组合起来实现的。
程序的三种流程正像是河流本身。从高山的泉眼中涌出的清泉形
成了河流的源头（程序执行的起点）。水流从山中缓缓流下，有时向着
一个方向流淌（顺序执行），有时中途分出了支流（条件分支），还有时
由于地势卷起了漩涡（循环）。难道诸位不认为程序的流程也很美吗？
完全就像是裱在画轴上的山水画一样（如图4.2 所示）。还有一种称作
“无条件分支”的流程，它就仿佛是大雨瓢泼引发的泥石流，突然就向
着某处流去了，可以认为这是一种特殊的条件分支。

![]({{site.baseurl}}/images/20220821/20220821144104.png)

虽然可能不如山水画那样优美，但是我还是要给诸位展示一段简
单的程序。代码清单4.1 中列出了用VBScript（Visual Basic Scripting
Edition）编写的“石头剪刀布游戏”的代码，VBScript 是BASIC 语言
的一个版本。该程序可以在Windows 98/Me/2000/XP 操作系统上运
行（用于执行VBScript 程序的WSH（Windows Script Host）已作为标准组件，被集成进Windows 98/Me/2000/XP 操作系统。）。
玩家和计算机可以进行五轮石头剪刀布比赛，比完后会显示玩家
获胜的次数。
请诸位用记事本等文本编辑器编写这个程序，并存储到扩展名为
“.vbs”的文件中，比如ShitouJiandaoBu.vbs。只要双击保存后的文件，
程序就可以执行了（如图4.3 所示）。

![]({{site.baseurl}}/images/20220821/20220821144106.png)

代码清单4.1　用VBScript 编写的“石头剪刀布游戏”
```
' 初始化表示手势的变量
Dim gesture(2)
gesture(0) = " 石头"
gesture(1) = " 剪刀"
gesture(2) = " 布"
' 初始化对玩家获胜次数计数的变量
wins = 0
' 初始化随机数种子
Randomize
' 显示程序启动信息
MsgBox " 石头剪刀布游戏 Ver.1.00 by H.Yazawa"
' 进行五轮比试
For i = 1 To 5
' 输入玩家的手势
user = CInt(InputBox("0: 石头、1: 剪刀、2: 布"))
' 用随机数决定计算机的手势
computer = CInt(Rnd * 2)
' 生成提示双方出的手势的字符串
s = " 玩家：" & gesture(user) & "、计算机：" & gesture(computer)
' 判定胜负，显示结果
If user = computer Then
MsgBox s & "... 平局！ "
ElseIf computer = (user + 1) Mod 3 Then
MsgBox s & "... 玩家获胜！ "
wins = wins + 1
Else
MsgBox s & "... 计算机获胜！ "
End If
Next
' 显示玩家的获胜次数
MsgBox " 玩家获胜次数： " & wins
```

* 4.2　用流程图表示程序的流程

代码清单4.1 所示的“石头剪刀布游戏”的程序是由顺序执行、条
件分支和循环三种流程组成的。对于没有学过VBScript 的人来说，也
许会觉得程序代码就好像是魔法的咒语一样。因此就需要用一种无论
是谁都能明白的方法来表示代码清单4.1 中的程序。为此所使用的图
表，就是诸位都已经知道的“流程图”。

所谓流程图，正如其名，就是表示程序流程（Flow）的图（Chart）。
有很多专业的程序员，他们在编写程序前，都会通过画流程图或是类
似的图来思考程序的流程（如图4.4 所示）。

![]({{site.baseurl}}/images/20220821/20220821144108.png)

流程图的方便之处在于它并不依赖于特定的编程语言。图4.4 的流
程图所表示的流程不仅能转换成VBScript 程序，还可以转换成用其他
语言编写的程序，比如C 语言或Java 语言。可以认为编程语言只不过
是将流程图上的流程用文字（程序）重现出来罢了。各种编程语言的差
异正如一种自然语言中各地方言的差异一样。只要给出了详细的流程
图，就可以编写出基本相同的程序。笔者也曾有过这样的经历，画流
程图花费了一个月之久，但是对照着流程图专心写程序只需要两天的
时间。

话说回来，诸位都善于画流程图吗？是不是有很多人会觉得在流
程图中有那么多的符号，在画图时要把这些符号都用上很麻烦呢？
实际上用于表示程序流程的最基础的符号并没有多少。只要先记
住表4.1 中的符号就足够了。就连笔者也很少使用这张表以外的符号。
虽然有时也能见到形如显示器或者打印纸的符号，但是可以认为这些
只是为了丰富流程图的表现所附加的符号。

![]({{site.baseurl}}/images/20220821/20220821144110.png)

![]({{site.baseurl}}/images/20220821/20220821144112.png)

只使用表4.1 中所示的符号，就可以画出程序的三种流程（如图
4.5 所示）。顺序执行只需用直线将矩形框连接起来(a)。条件分支用菱
形表示(b)。循环的表示方法是通过条件分支回到前面的处理步骤(c)。
这样就能将所有的流程都表示出来了。

作为程序员必须要学会灵活地运用流程图。在思考程序流程的时
候，也要首先在头脑中画出流程图。

* 4.3　表示循环程序块的“帽子”和“短裤”

![]({{site.baseurl}}/images/20220821/20220821144114.png)

再继续介绍一些有关流程图的内容吧。如果诸位曾经备考过“信息
技术水平考试”，就应该见过用如图4.6 所示的符号表示循环的流程图。
笔者将这一对符号称作“帽子和短裤”（这当然不是正式的名称）。

对于帽子形状和短裤形状的符号，为了表示它们是成对出现的，
要在上面写下适当的名字。然后用“帽子”和“短裤”把需要反复执行
的步骤包围起来。如果要在循环中嵌套循环，就需要对每个循环分别
使用一对“帽子”和“短裤”。为了区分成对出现的“帽子”和“短裤”，
要为每一对起不同的名字。

![]({{site.baseurl}}/images/20220821/20220821144116.png)

稍微说一点题外话。笔者的名字是久雄，有一个叫康男的哥哥。
洗衣服时，如果把哥哥的帽子和短裤和我的混在一起洗的话，就不知
道哪件是哥哥的、哪件是我的了。于是，母亲就在我们哥俩儿的帽子
和短裤上分别写上了个人的名字。在流程图的“帽子”和“短裤”符号
上写名字也出于同样的目的（如图4.7 所示）。

上面的内容稍微有点跑题，下面我们回到正题。在计算机硬件上
的操作中，循环是通过当满足条件时就返回到之前处理过的步骤来实
现的。一旦使用了机器语言或汇编语言所提供的跳转指令，就可以将
PC 寄存器的值设置为任意的内存地址。如果将它的值设为之前执行过
的步骤所对应的内存地址，那么就构成了循环。因此，在表示循环的
时候，正如图4.5(c) 所示的那样，仅仅使用带有菱形符号的流程图也就
足够了。用机器语言或者汇编语言表示循环时，都是先进行某种比较，
再根据比较结果，跳转到之前的地址（如图4.8 所示）。

![]({{site.baseurl}}/images/20220821/20220821144118.png)

但是，现在还在使用机器语言或汇编语言的人已经不多了。程序
员使用的都是能够更加高效地编写程序的高级语言，如BASIC、C 语
言和Java 等。在这些高级语言中，程序员使用“程序块”表示循环而
不是跳转指令。所谓“程序块”就是程序中代码的集合。程序中要被循
环处理的部分，就是一种程序块。如图4.6 所示的用帽子和短裤符号表
示循环的方法就适用于使用了程序块的高级语言。

代码清单4.2　用高级语言表示循环
```
' 进行5 轮比试
For i = 1 To 5      # 相当于“帽子”
    ' 处理步骤
    …
Next               # 相当于“短裤”
```

代码清单4.2 列出了从之前的“石头剪刀布游戏”中摘录出的程序
块，这段代码用于循环双方的比试过程。由此可见，在VBScript 中，
是用For 和Next 两个关键字表示循环的程序块的。For 对应着“帽子”，
Next 则对应着“短裤”。For 的后面写有循环条件。“For i = 1 To 5”表
示用变量i 存储循环次数，将i 的值从1 加到5，每进行1 次循环就增
加1，如果i 的值超过了5 循环就终止。画图时循环条件也要写在“帽
子”中（如图4.9 所示）。

![]({{site.baseurl}}/images/20220821/20220821144120.png)

用“帽子”和“短裤”表示循环结构没有什么问题，也适用于使用
高级语言编写的程序。但是在直接表示硬件操作的机器语言和汇编语
言中，是通过条件分支返回到之前处理过的指令来实现循环的，并没
有相当于For 或者Next 的指令。条件分支本身也是通过跳转指令实现
的。根据比较操作的结果，跳转到之前处理过的步骤就是循环；跳转到
之后尚未处理的步骤就是条件分支（如图4.10 所示）。

![]({{site.baseurl}}/images/20220821/20220821144122.png)

在高级语言中，条件分支也是由程序块表示的。在VBScript 中，
使用If、ElseIf、Else、End If 表示条件分支的程序块。通过这几个关键
字就可以形成一个被分成三个区域的程序块（如代码清单4.3 所示）。

代码片段4.3　用高级语言表示的条件分支
```
' 判定胜负，显示结果
If use = computer Then
    MsgBox s & "... 平局！ "                      # 区域(1)
ElseIf computer = (user + 1) Mod 3 Then
    MsgBOx s & "... 玩家获胜！ "                  # 区域(2)
    wins = wins + 1                               # 区域(2)
Else
    MsgBox s % "... 计算机获胜！ "                # 区域(3)
End If
```

如果If 关键字后面所写的条件成立，区域(1) 中所写的代码就会被执
行，形成分支。如果ElseIf 后面所写的条件成立，区域(2) 中所写的代
码就会被执行，形成分支。当这两个条件都不成立时，区域(3) 中所写
的代码就会被执行，形成分支。高级语言的条件分支代码块，可以用
画有菱形符号的流程图表示。

* 4.4　结构化程序设计

既然谈到了程序块，就再介绍一下结构化程序设计吧。诸位即使
不曾亲身经历，也应该在什么地方听说过这个词吧。结构化程序设计
是由学者戴克斯特拉提倡的一种编程风格。简单地说，所谓结构化程
序设计就是“为了把程序编写得具备结构性，仅使用顺序执行、条件分
支和循环表示程序的流程即可，而不再使用跳转指令”。“仅用顺序执
行、条件分支和循环表示程序的流程”这一点是不言自明的，需要请诸
位注意的是“不使用跳转指令”这一点。

作为计算机硬件上的行为，无论是条件分支还是循环都必须使用
跳转指令实现。但是在VBScript 等高级语言中，可以用If～ElseIf～
Else～End If 程序块表示条件分支，用For～Next 程序块表示循环。跳
转指令因此就变得可有可无了。但是即便如此，在很多高级语言中，
还是提供了与机器语言中跳转指令相当的语句，例如VBScript 中的
GoTo 语句。其实戴克斯特拉想表达的是“既然好不容易使用上了高级
语言，就别再使用相当于跳转指令的语句了。即使不使用跳转语句，
程序的所有流程仍然可以表述出来”。他这样说是因为跳转指令所带来
的危害性不小，会使程序陷入到流程错综复杂的状态，就像意大利面
条那样缠绕在一起（如图4.11 所示）。

![]({{site.baseurl}}/images/20220821/20220821144124.png)

在程序设计的世界中，如果看到了以“结构化”开头的术语，就可
以这样认为：程序的流程是由程序块表示的，而不是用GoTo 语句等跳
转指令实现的。例如，微软的.NET 框架所提供的新版BASIC 语言
Visual Basic.NET 中，就以增加新语法的方式加入了被称作“结构化异
常处理”的错误处理机制。这里所说的异常类似于错误。

在旧版本的Visual Basic 中，一旦发生了错误，程序的流程就会跳
转到执行错误处理的地方。用程序块来表示这种错误处理方式的机制，
就是结构化异常处理。在Visual Basic.NET 中， 用Try～Catch～End
Try 程序块来表示结构化异常处理（如代码清单4.4 所示）。但是即使使
用了结构化异常处理，在硬件上使用的也还是跳转指令，只是说在高
级语言中不用再写相当于跳转指令的语句了。如果把用高级语言所编
写的程序转换成机器语言，像结构化异常处理这样的语句还是会被转
换为跳转指令。

代码清单4.4　原始的错误处理机制和结构化异常处理的区别

![]({{site.baseurl}}/images/20220821/20220821144126.png)

* 4.5　画流程图来思考算法

为了充分体现流程图的用途，下面稍微涉及一些有关算法的内容。
所谓算法（Algorithm），就是解决既定问题的步骤。想让计算机解决问
题，就需要把问题的解法转换成程序的流程。

仅用一条语句就能实现出“石头剪刀布游戏”的编程语言是不存在
的。如果眼下待解决的问题是如何编写“石头剪刀布游戏”，那么就必
须考虑如何把若干条指令组合起来并形成一个解决问题的流程。如果
能够想出可以巧妙实现“石头剪刀布游戏”的流程，那么这个问题也就
解决了，换言之算法也就实现了。要是诸位被前辈问到：“这个程序的
算法是怎样的呢？”那么只要回答清楚程序的流程就可以了。或者画出
流程图也是可以的，因为表示程序流程的流程图本身就能解释算法。

思考算法时的要点是要分两步走，先从整体上考虑程序的粗略流
程，再考虑程序各个部分细节的流程。有关细节上的流程将在下一章
介绍，在这里笔者先介绍粗略的流程。这是一种相当简单的流程，虽
然或多或少会有例外，但是几乎所有的程序从整体来看都具有一个一
成不变的流程，那就是“初始化处理”→“循环处理”→“收尾处理”。

请试想，用户是怎样使用程序的呢？首先，用户启动了程序（程序
执行初始化处理）。接下来用户根据自己的需求操作程序（程序进入循
环处理阶段）。最后用户关闭了程序（程序执行收尾处理）。这样的使用
方法就可以直接作为程序的整体流程。还是以“石头剪刀布游戏”为
例，分出初始化处理、循环处理、收尾处理之后，就可以画出如图
4.12 那样的粗略的流程图。图中把5 次循环处理看作是一个整体，当
成是一次处理（用矩形表示）。

![]({{site.baseurl}}/images/20220821/20220821144128.png)

反映程序整体流程的粗略流程图还可以用来描述笔者写作本书时
的流程（如图4.13 所示）。首先，启动文字处理机，加载已经写到一半
的稿件（初始化处理）。接下来，不断地输入文字（循环处理）。最后，
保存稿件（收尾处理）。

![]({{site.baseurl}}/images/20220821/20220821144130.png)

我建议那些因为程序没有按照自己的想法来工作而烦恼的人，不
妨试试从勾画反映程序整体流程的粗略流程图下手。只要在此之上慢
慢地细化流程，就能得到详细的流程图。接下来再按照流程图所示的
流程埋头编写程序就轻松了。

* 4.6　特殊的程序流程——中断处理

最后，稍微介绍一下两种特殊的程序流程——中断处理和事件驱
动（Event Driven）。首先说明中断处理。

中断处理是指计算机使程序的流程突然跳转到程序中的特定地方，
这样的地方被称为中断处理例程（Routine）或是中断处理程序
（Handler），而这种跳转是通过CPU 所具备的硬件功能实现的。人们通
常把中断处理比作是接听电话。假设诸位都正坐在书桌前处理文件，
这时突然来电话了，诸位就不得不停下手头的工作去接电话，接完电
话再回到之前的工作。像这样由于外部的原因使正常的流程中断，中
断后再返回到之前流程的过程就是中断处理流程。

在第2 章微型计算机的电路图中已经展示过，在Z80 CPU 中有INT 和 NMI 两个引脚，
它们可以接收从I/O 设备发出的中断请求信号（INT 引脚用于处理一般的中断请求。NMI 引脚则用于即使CPU 屏蔽了中断，
也可在执行中的指令结束后立刻响应中断请求的情况。）。
以硬件形式连接到CPU 上的I/O 模块会发出中断请求信号，CPU根据该信号执行相应的中断处理程序。
在诸位使用的个人计算机上，中断请求信号是由连接到周边设备上的I/O 模块发出的。
例如每当用户按下键盘上的按键，键盘上的I/O 模块就会把中断请求信号发送给CPU。
CPU 通过这种方式就可以知道有按键被按下，于是就会从I/O设备读入数据（如图4.14 所示）。
CPU 并不会时刻监控键盘是否有按键被按下。

![]({{site.baseurl}}/images/20220821/20220821144132.png)

中断处理以从硬件发出的请求为条件，使程序的流程产生分支，
因此可以说它是一种特殊的条件分支。可是，在诸位编写的程序中并
不需要编写有关中断处理的代码。因为处理中断请求的程序，或是内
置于被烧录在计算机ROM 中的BIOS 系统（Basic Input Output System，
基本输入输出系统）中，或是内置于Windows 等操作系统中。诸位只
需要先记住以下两点即可：计算机具有硬件上处理中断的能力；中断一
词的英文是Interrupt。

* 4.7　特殊的程序流程——事件驱动

程序员们经常用事件驱动的方式编写那些工作在GUI（Graphical
User Inteface，图形用户界面）环境中的应用程序，例如Windows 操作
系统中的应用程序。这听起来好像挺复杂的，但其实如果把事件驱动
想象成是两个程序在对话，理解起来就简单了。

下面看一个实际的例子吧。代码清单4.5 中列出了一段用C 语言编
写的Windows 应用程序， 这里只列出了程序的骨架。在程序中有
WinMain() 和WndProc() 两个函数（代码块）。WinMain() 是在程序启动
时被调用的主例程（Main Routine）。而WndProc() 并不会被诸位所编写
的程序本身调用，Windows 操作系统才是WndProc() 的调用者。这种
机制就使得Windows 和诸位所编写的应用程序这两个程序之间可以进
行对话。

代码清单4.5　用C 语言编写的Windows 应用程序的骨架
```
/* 主例程 */
int APIENTRY WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpCmdLine, int nCmdShow){
    …
}
/* 窗口过程 */
LRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam){
    …
}
```

通常把用户在应用程序中点击鼠标或者敲击键盘这样的操作称作
“事件”（Event）。负责检测事件的是Windows。Windows 通过调用应
用程序的WndProc() 函数通知应用程序事件的发生。而应用程序则根
据事件的类型做出相应的处理。这种机制就是事件驱动。可以说事件
驱动也是一种特殊的条件分支，它以从Windows 送来的通知为条件，
根据通知的内容决定程序下一步的流程。

要实现事件驱动，就必须把应用程序中的WndProc() 函数（称为窗
口过程，Window Procedure）的起始内存地址告诉Windows。这一步将
在应用程序WinMain() 中作为初始化处理被执行。

事件驱动是一种适用于GUI 环境的编程风格，在这种环境中用户
可以通过鼠标和键盘来操作应用程序。虽然事件驱动的流程也可以用
流程图表示，但是由于要排列很多的菱形符号（表示条件分支），画起
来会很复杂。所以下面介绍便于表示事件驱动的“状态转化图”。状态
转化图中有多个状态，反映了由于某种原因从某个状态转化到另一个
状态的流程。工作在GUI 环境中的程序，其显示在画面上的窗口就有若
干个状态。

![]({{site.baseurl}}/images/20220821/20220821144134.png)

例如，如图4.15 所示的计算器应用程序就可以看作包含三个
状态：“显示计算结果”“显示第一个输入的数”以及“显示第二个输入的
数”。随着用户按下不同种类的按键，状态也会发生转变。在状态转化图
中，在矩形中写上状态的名称，用箭头表示状态转化的方向，并且在箭
头上标注引起状态转化的原因（事件）（如图4.16 所示）。

![]({{site.baseurl}}/images/20220821/20220821144136.png)

![]({{site.baseurl}}/images/20220821/20220821144138.png)

对于那些觉得画图很麻烦的人，笔者推荐使用“状态转化表”（如
表4.2 所示）。因为制表的话，用Microsoft Excel 等表格软件就可以完
成，修改起来也要比图方便。在状态转化表中，行标题是带有编号的
状态，列标题是状态转化的原因，而单元格中是目标状态的编号。

☆ ☆ ☆

也许读完中断处理和事件驱动的这两节，诸位会觉得稍微有些混
乱，但是程序的流程还是只有顺序执行、条件分支和循环这三种，这
一点是没有改变的。其中的顺序执行是最基本的程序流程，这是因为
CPU 中的PC 寄存器的值会自动更新。条件分支和循环，在高级语言
中用程序块表示，在机器语言和汇编语言中用跳转指令表示，在硬件
上是通过把PC 寄存器的值设为要跳转到的目的地的内存地址来实现。
只要能充分理解这些概念就OK 了。

在接下来的第5 章，笔者将更加详细地介绍在本章略有涉及的算法。敬请期待！

## 第 5 章 与算法成为好朋友的七个要点

## 第 6 章 与数据结构成为好朋友的七个要点

## 第 7 章 成为会使用面向对象编程的程序员吧

## 第 8 章 一用就会的数据库

## 第 9 章 通过七个简单的实验理解 TCP/IP 网络

## 第 10 章 试着加密数据吧

## 第 11 章 XML 究竟是什么

## 第 12 章 SE 负责监管计算机系统的构建

## 结束语

## 谢辞




## 程序是怎样跑起来的




<br/><br/><br/><br/><br/>
## 参考资料

计算机是怎样跑起来的 web版 <https://www.ituring.com.cn/book/1139>

计算机是怎样跑起来的 （可参考阅读，这个就不要用了） <http://www.javashuo.com/article/p-ebgzhuvv-nw.html>





