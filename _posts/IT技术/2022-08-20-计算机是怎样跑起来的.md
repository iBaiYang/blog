---
layout: post
categories: IT技术
title: 计算机是怎样跑起来的
meta: 计算机是怎样跑起来的
---
* content
{:toc}
  

版权声明
 
前言
 
关键词

本书结构

## 第 1 章　计算机的三大原则

## 第 2 章　试着制造一台计算机吧

## 第 3 章　体验一次手工汇编

在阅读本章内容前，让我们先回答下面的几个问题来热热身吧。

初级问题

什么是机器语言？

中级问题

通常把标识内存或I/O 中存储单元的数字称作什么？

高级问题

CPU 中的标志寄存器（Flags Register）有什么作用？


怎么样？被这么一问，是不是发现有一些问题无法简单地解释清楚呢？下面，笔者就公布答案并解释。

初级问题： 由二进制数字构成的程序，CPU 可以直接对其解释、执行。
中级问题： 标识内存或I/O 中存储单元的数字叫作“地址”。
高级问题： 用于在运算指令执行后，存储运算结果的某些状态。
解释
初级问题： 不仅是汇编语言，用C 语言、Java、BASIC 等编程语
言编写的程序，也都需要先转换成机器语言才能被执
行。机器语言有时也叫作“原生代码”（Native Code）。
中级问题： 内存中有多个数据存储单元。计算机用从0 开始的编
号标识每个存储单元，这些编号就是地址（Address）。
I/O 中的寄存器也可以用地址来标识。哪个寄存器对应
哪个地址，取决于CPU 和I/O 之间的布线方式。
高级问题： Flag 的本意是“旗子”，这里引申为“标志”。一旦执行
了算术运算、逻辑运算、比较运算等指令后，标志寄
存器并不会存放运算结果的值，而是会把运算后的某
些状态存储起来，例如运算结果是否为0、是否产生了
负数、是否有溢出（Overflow）等。


### 3.1　从程序员的角度看硬件

为了体验手工汇编，下面我们就为在第2 章制作的微型计算机编
写一个程序吧。因为程序的作用是驱动硬件工作，所以在编写程序之
前必须要先了解微型计算机的硬件信息。然而真正需要了解的硬件信
息只有以下7 种（如图3.1 所示），所以没有必要在编程时还总是盯着
详细的电路图看。
本章的目标是通过编写程序使诸位亲身体验计算
机的运行机制。为了达到这个目的，就需要使用一种
叫作“汇编语言”的编程语言来编写程序，然后再把编好的程序通过手
工作业转换成CPU 可以直接执行的机器语言。
这样的转换工作叫作“手工汇编”（Hand Assemble）。也许会有
人觉得听起来就好像挺麻烦的，事实上也的确如此，但是还是希望所
有和计算机相关的技术人员都能亲身体验一下用汇编语言编程和手工
汇编。
这次体验应该能加深诸位对计算机的理解，使诸位犹如拨云见日，
找到长期困惑着自己的问题的答案，不仅能因“我能看懂程序了”而
获得成就感，更能因发现“计算机原来很简单啊”而信心倍增。虽然
本章的主题稍有些复杂，但是笔者会放慢讲解的步伐，还请诸位努力
跟上。
􀰴􁉥
􁧗􀽁
􁧗􀽁
42
  
图


### 3.1　编写程序之前需要了解的硬件信息


内存
　0号地址
　1号地址
　2号地址
　3号地址
255号地址
8比特信息
8比特信息
8比特信息
8比特信息
8比特信息
Z80 PIO
0号地址
1号地址
2号地址
3号地址
端口A数据寄存器
端口B数据寄存器
端口A控制寄存器
端口B控制寄存器
指拨开关
□□□□□□□□
LED
○○○○○○○○
Z80 CPU
时钟
发生器
2.5MHz
计算机主机系统
周边设备
【CPU（处理器）信息】
● CPU的种类
● 时钟信号的频率
【内存信息】
● 地址空间
● 每个地址中可以存储多少比特的信息
【I/O 信息】
● I/O 的种类
● 地址空间
● 连接着何种周边设备
可以使用哪种机器语言取决于CPU（也称作处理器）的种类。所谓
43
3.1　从程序员的角度看硬件
机器语言就是只用0 和1 两个二进制数书写的编程语言。即便是相同
的机器语言，例如01010011，只要CPU 的种类不同，对它的解释也就
不同。有的CPU 会把它解释成是执行加法运算，有的CPU 会把它解释
成是向I/O 输出。这就好比同样是man 这个词，有的人会理解成“慢”，
有的人会理解成“男人”。
由于微型计算机上的CPU 是Z80 CPU，所以就要使用适用于Z80
CPU 的机器语言。顾名思义，机器语言就是处理器可以直接理解（与
生俱来就能理解）的编程语言。机器语言有时也叫作原生代码（Native
Code）。
所谓时钟信号的频率，就是由时钟发生器发送给CPU 的电信号的
频率。表示时钟信号频率的单位是MHz（兆赫兹 = 100 万回／秒）。微
型计算机使用的是2.5MHz 的时钟信号。时钟信号是在0 和1 两个数之
间反复变换的电信号，就像滴答滴答左右摆动的钟摆一样。通常把发
出一次滴答的时间称作一个时钟周期。
在机器语言当中，指令执行时所需要的时钟周期数取决于指令的
类型。程序员不但可以通过累加时钟周期数估算程序执行的时间，还
可以仅在特定的时间执行点亮LED（发光二极管）等操作。
每个地址都标示着一个内存中的数据存储单元，而这些地址所构
成的范围就是内存的地址空间。在我们的微型计算机中，地址空间为
0～255，每一个地址中可以存储8 比特（1 字节）的指令或数据。
连接着的I/O 的种类，就是指连接着微型计算机和周边设备的I/O
的种类。在微型计算机中，只安装了一个I/O，即上面带有4 个8 比特
寄存器的Z80 PIO。只要用CPU 控制I/O 的寄存器，就可以设定I/O 的
功能，与周边设备进行数据的输入输出。
44
第3章　体验一次手工汇编
所谓I/O 的地址空间，是指用于指定I/O 寄存器的地址范围。在
Z80 PIO 上，地址空间为0～3，每一个地址对应一个寄存器。
在内存中，每个地址的功能都一样，既可用于存储指令又可用于
存储数据。而I/O 则不同，地址编号不同（即寄存器的类型不同），功
能也就不同。在微型计算机中，是这样分配Z80 PIO 上的寄存器的：端
口A 数据寄存器对应0 号地址，端口B 数据寄存器对应1 号地址，端
口A 控制寄存器对应2 号地址，端口B 控制寄存器对应3 号地址。端
口A 数据寄存器和端口B 数据寄存器存储的是与周边设备进行输入输
出时所需的数据。其中，端口A 连接用于输入数据的指拨开关，端口
B 连接用于输出数据的LED。而端口A 控制寄存器和端口B 控制寄存
器则存储的是用于设定Z80 PIO 功能的参数。
3.2　机器语言和汇编语言
请看代码清单3.1 中列出的机器语言程序，这段程序在第2 章中已
经介绍过了，功能是把由指拨开关输入的数据输入CPU，然后CPU 再
把这些数据原封不动地输出到LED。也就是说，可以通过拨动指拨开
关控制LED 的亮或灭。
代码清单3.1　点亮LED 的机器语言程序
地址 机器语言
00000000 00111110
00000001 11001111
00000010 11010011
00000011 00000010
00000100 00111110
00000101 11111111
00000110 11010011
00000111 00000010
00001000 00111110
00001001 11001111
00001010 11010011
45
3.2　机器语言和汇编语言
00001011 00000011
00001100 00111110
00001101 00000000
00001110 11010011
00001111 00000011
00010000 11011011
00010001 00000000
00010010 11010011
00010011 00000001
00010100 11000011
00010101 00010000
00010110 00000000
这段由8 比特二进制数构成的机器语言程序总共23 个字节。若把
这些字节一个接一个地依次写入内存中，所占据的内存空间就是
00000000～00010110。一旦重置了CPU，CPU 就会从0 号地址开始顺
序执行这段程序。
在机器语言程序中，虽然到处都是0 和1 的组合，但是每个组合
都是有特定含义的指令或数据。可是对人来说，如果只看0 和1 的话，
恐怕很难判断各个组合都表示什么。
于是就有人发明出了一种编程方法，根据表示指令功能的英语单
词起一个相似的昵称，并将这个昵称赋予给0 和1 的组合。这种类似
英语单词的昵称叫作“助记符”，使用助记符的编程语言叫作“汇编语
言”。无论是使用机器语言还是汇编语言，所实现的功能都是一样的，
区别只在于程序是用数字表示，还是用助记符表示。也就是说，如果
理解了汇编语言，也就理解了机器语言，更进一步也就理解了计算机
的原始的工作方式。
代码清单3.1 中的机器语言可以转换成如代码清单3.2 所示的汇编
语言。汇编语言的语法十分简单，以至于语法只有一个，即把“标
签”“操作码（指令）”和“操作数（指令的对象）”并排写在一行上，仅
46
第3章　体验一次手工汇编
此而已。
代码清单3.2　用汇编语言的代码表示代码清单3.1 中的机器语言
标签 操作码 操作数
LD A, 207
OUT (2), A
LD A, 255
OUT (2), A
LD A, 207
OUT (3), A
LD A, 0
OUT (3), A
LOOP: IN A, (0)
OUT (1), A
JP LOOP
标签的作用是为该行代码对应的内存地址起一个名字。编程时如
果总要考虑“这一行的内存地址是什么来着？”就会很不方便，所以在
汇编语言中用标签来代替地址。用汇编语言编程时可以在任何需要标
签的地方“贴上”名称任意的标签。在代码清单3.2 所示的程序中，使
用了名称为“LOOP:”的标签。
操作码就是表示“做什么”的指令。因为用助记符表示的指令是
英语单词的缩写，比如LD 是Load（加载）的缩写，所以多多少少能
猜出其中的含义。汇编语言中提供了多少种助记符，CPU 就有多少种
功能。Z80 CPU 的指令全部加起来有70 条左右。这里先把主要的指
令列在表3.1 中，请诸位粗略地浏览一下。在浏览的过程中请注意这
些指令的分类，按功能这些指令可以分成运算、与内存的输入输出和
与I/O 的输入输出三类。这是因为计算机能做的事也只有输入、运
算、输出这三种了。
操作数表示的是指令执行的对象。CPU 的寄存器、内存地址、I/O
地址或者直接给出的数字都可以作为操作数。如果某条指令需要多个
47
3.2　机器语言和汇编语言
操作数，那么它们之间就要用逗号分割。操作数的个数取决于指令的
种类。也有不需要操作数的指令，比如用于停止CPU 运转的HALT
指令。
汇编语言的语法和英语祈使句的语法很像。若对比英语的祈使句
Give me money 和汇编语言的语句，就可以看出在英语的祈使句中，一
开头放置了一个表示“做什么”的动词，这个动词就相当于汇编语言中
的操作码。在动词后面放置了一个表示“动作作用到什么上”的宾语，
这个宾语就相当于汇编语言中的操作数。因为程序的作用是向CPU 发
出指令，而且编程语言又是由说英语的人发明的，所以编程语言与英
语祈使句类似也就不足为奇了。
构成机器语言的是二进制数，而在汇编语言中，则使用十进制数
和十六进制数记录数据。若仅仅写出123 这样的数字，表示的就是十进
制数；而像123H 这样在数字末尾加上了一个H（H 表示Hexadecimal，
即十六进制数），表示的就是十六进制数。在代码清单3.2 所示的程序
中，使用的都是十进制数。
在表3.1 中有这样几条指令希望诸位注意。在第2 章中介绍过，
Z80 CPU 的MREQ 引脚和IORQ 引脚实现了一种能区分输入输出对象
的机制，可以区分出使用着相同内存地址的内存和I/O。在汇编语言
中，读写内存的指令不同于读写I/O 的指令。一旦执行了读写内存的指
令，比如LD 指令，MREQ 引脚上的值就会变为0，于是内存被选为输
入输出的对象；而一旦执行了读写I/O 的指令，比如IN 或OUT 指令，
IORQ 引脚上的值就会变为0，于是I/O（这里用的是Z80 PIO）被选为
输入输出的对象。
48
第3章　体验一次手工汇编
表3.1　Z80 CPU 中的主要指令
指令的种类助记符功能
运算指令ADD A, num
ADD A, reg
把数值num 加到寄存器A 的值上
把寄存器reg 的值加到寄存器A 的值上
SUB num
SUB reg
从寄存器A 的值中减去数值num
从寄存器A 的值中减去寄存器reg 的值
INC reg 将寄存器reg 的值加1
DEC reg 将寄存器reg 的值减1
AND num
AND reg
计算寄存器A 的值和数值num 的逻辑积
计算寄存器A 的值和寄存器reg 的值的逻辑积
OR num
OR reg
计算寄存器A 的值和数值num 的逻辑和
计算寄存器A 的值和寄存器reg 的值的的逻辑和
XOR num
XOR reg
计算寄存器A 的值和数值num 的逻辑异或
计算寄存器A 的值和寄存器reg 的值的逻辑异或
SLA reg 对寄存器reg 的值进行算数左移运算
SRA reg 对寄存器reg 的值进行算数右移运算
SRL reg 对寄存器reg 的值进行逻辑右移运算
CP num
CP reg
比较寄存器A 的值和数值num 的大小
比较寄存器A 的值和寄存器reg 的值的大小
内存与CPU
之间的输入
输出指令
LD reg, num
LD reg1, reg2
LD (num), reg
LD (reg), reg
把数值num 写入到寄存器reg 中
把寄存器reg2 的值写入到寄存器reg1 中
把寄存器reg 的值写入到地址num 上
把寄存器reg2 的值写入到存放在寄存器reg1 中的
地址上
PUSH reg 把寄存器reg 的值写入到栈中
POP reg 把由栈顶读出的数据存放到寄存器reg 中
I/O 与CPU
之间的输入
输出指令
IN A, (num)
IN reg, (C)
从地址num 中读出数据，存放到寄存器A 中
从存储在寄存器C 中的地址上读出数据，存放到
寄存器reg 中
OUT (num), A
OUT (C), reg
把寄存器A 的值写入到地址num 上
把寄存器reg 的值写入到存储在寄存器C 中的地址上
程序流程控
制指令
JP num 使程序的流程跳转到地址num 上，接下来从那个
地址上的指令开始执行
CALL num
RET
HALT
调用存放在地址num 上的子例程
从子例程中返回
中止CPU 的运行
num ：表示1 个数值，(num) ：表示值为num 的地址
reg、reg1、reg2：名为reg、reg1、reg2 的寄存器，(reg) ：存储在名为reg 的寄存器中的地址
49
3.3　Z80 CPU的寄存器结构
3.3　Z80 CPU 的寄存器结构
这里先稍微复习一下第2 章的内容。计算机的硬件有三个基本要
素，CPU、内存和I/O。CPU 负责解释、执行程序，从内存或I/O 输入
数据，在内部进行运算，再把运算结果输出到内存或I/O。内存中存放
着程序，程序是指令和数据的集合。I/O 中临时存放着用于与周边设备
进行输入输出的数据。
复习就到这里，下面就来扩充所学到的知识吧。既然数据的运算
是在CPU 中进行的，那么在CPU 内部就应该有存储数据的地方。这种
存储数据的地方叫作“寄存器”。虽然也叫寄存器，但是与I/O 的寄存
器不同，CPU 的寄存器不仅能存储数据，还具备对数据进行运算的能
力。CPU 带有什么样的寄存器取决于CPU 的种类。Z80 CPU 所带有的
寄存器如图3.2 所示A。A、B、C、D 等字母是寄存器的名字。在汇编语
言当中，可以将寄存器的名字指定为操作数。
图3.2　Z80 CPU 的寄存器
A
B
D
H
F
C
E
L
I R
IX
IY
SP
PC
Z80 CPU
A A、B、C、D、E、F、H、L 每个寄存器都带有一个辅助寄存器，本节省略
了对它们的介绍。
50
第3章　体验一次手工汇编
IX、IY、SP、PC 这4 个寄存器的大小是16 比特，其余寄存器的
大小都是8 比特。寄存器的用途取决于它的类型。有的指令只能将特
定的寄存器指定为操作数。
举例来说，A 寄存器也叫作“累加器”，是运算的核心。所以连接
到它上面的导线也一定会比其他寄存器的多。F 寄存器也叫作“标志寄
存器”，用于存储运算结果的状态，比如是否发生了进位，数字大小的
比较结果等。PC 寄存器也叫作“程序指针”，存储着指向CPU 接下来
要执行的指令的地址。PC 寄存器的值会随着滴答滴答的时钟信号自动
更新，可以说程序就是依靠不断变化的PC 寄存器的值运行起来的。SP
寄存器也叫作“栈顶指针”，用于在内存中创建出一块称为“栈”的临
时数据存储区域。
既然诸位已经熟悉了寄存器的功能，下面笔者就开始介绍代码清
单3.2 的内容。这段程序大体上可以分为两部分——“设定Z80 PIO”
和“与Z80 PIO 进行输入输出”。Z80 PIO 带有两个端口（端口A 和端
口B），用于与周边设备输入输出数据。首先必须为每个端口设定输入
输出模式。这里端口A 用于接收由指拨开关输入的数据，为了实现这
个功能，需要如下的代码。
LD A, 207
OUT (2), A
LD A, 255
OUT (2), A
这里的207 和255 是连续向Z80 PIO 的端口A 控制寄存器（对应
该I/O 的地址编号为2）写入的两个数据。虽然使用OUT 指令可以向
I/O 写入数据，但是不能直接把207、255 这样的数字作为OUT 指令的
操作数。操作数必须是已存储在CPU 寄存器中的数字，这是汇编语言
51
3.3　Z80 CPU的寄存器结构
的规定。
于是，先通过指令“LD A, 207”把数字207 读入到寄存器A 中，
再通过指令“OUT (2), A”把寄存器A 中的数据写入到I/O 地址所对应
的寄存器中。像“(2)”这样用括号括起来的数字，表示的是地址编号。
端口A 控制寄存器的I/O 地址是2 号。
一旦把207 写入到端口A 控制寄存器，Z80 PIO 就明白了：“哦，
想要设定端口A 的输入输出模式啊。”而通过接下来写入的255，Z80
PIO 就又知道：“哦，要把端口A 设定为输入模式啊。”
同样地，通过下面的程序可以将端口B 设定为输出模式。
LD A, 207
OUT (3), A
LD A, 0
OUT (3), A
先把207 写入到端口B 控制寄存器（对应的I/O 地址为3 号），然
后写入0。这个0 表示要把端口B 设定为输出模式。应该使用什么样的
数字设定端口，在Z80 PIO 的资料上都有说明。用207、255、0 这样
的数字来表示功能设定参数，这也是为了适应计算机的处理方式。
完成了Z80 PIO 的设定后，就进入了一段死循环处理，用于把由指
拨开关输入的数据输出到LED。为了实现这个功能，需要如下的代码。
LOOP: IN A, (0)
　　　 OUT (1), A
　　　 JP LOOP
“IN A, (0)”的作用是把数据由端口A 数据寄存器（连接在指拨开
关上，对应的I/O 地址为0 号）输入到CPU 的寄存器A。“OUT (1), A”
52
第3章　体验一次手工汇编
的作用是把寄存器A 的值输出到端口B 数据寄存器上（连接在LED
上，对应的I/O 地址为1 号）。
“JP LOOP”的作用是使程序的流程跳转到LOOP（笔者随意起的
一个标签名）标签所标识的指令上。JP 是Jump 的缩写。“IN A, (0)”所
在行的开头有一个标签“LOOP:”，代表着这一行的内存地址。正如刚
才所讲的那样，在用汇编语言编程时，如果老想着“这一行对应的内存
地址是什么来着？”就会很不方便，所以就要用“LOOP:”这样的标签
代替内存地址。当把标签作为JP 指令的操作数时，标签名的结尾不需
要冒号“:”，但是在设定标签时，标签名的结尾则需要加上一个冒号，
这一点请诸位注意。
3.4　追踪程序的运行过程
用汇编语言编写的程序是不能直接运行的，必须先转换成机器语
言。机器语言是唯一一种CPU 能直接理解的编程语言。从汇编语言到
机器语言的转换方法将在稍后介绍，这里先来看一下代码清单3.3，里
面列出了事先转换出来的机器语言，以及对应的汇编语言。1 条汇编语
言的指令所对应的机器语言由多个字节构成。而且，同样是汇编语言
中的1 条指令，有的指令对应着1 个字节的机器语言，有的指令则对
应着多个字节的机器语言。汇编语言中的1 条指令能转换成多少条机
器语言取决于指令的种类以及操作数的个数。代码清单3.3 中第一个内
存地址是00000000（0 号地址），下一个地址是00000010（2 号地址），
中间隔了2 个地址，这说明如果从0 号地址开始存储一条2 字节的机
器语言，那么下一条机器语言就从2 号地址开始存储。
下面就一边看着代码清单3.3，一边跟随着CPU 解释、执行机器
53
3.4　追踪程序的运行过程
语言程序吧。在这里，我们假设机器语言的程序是像代码清单3.3 那样
被存储在内存中的。
一旦重置了CPU，00000000 就会被自动存储到PC 寄存器中，这
意味着接下来CPU 将要从00000000 号地址读出程序。首先CPU 会从
00000000 号地址读出指令00111110，判断出这是一条由2 个字节构成
的指令，于是接下来会从下一个地址（即00000001，1 号地址，代码清
单3.3 中并没有标记出该地址本身）读出数据11001111，把这两个数据
汇集到一起解释、执行。执行的指令是把数值207 写入到寄存器A，
用汇编语言表示的话就是“LD A, 207”。这时，由于刚刚从内存读出了
一条2 字节的指令（占用2 个内存地址），所以PC 寄存器的值要增加
2，并接着从00000010 号地址读出指令，解释并执行。
接下来的流程与此类似，通过反复进行“读取指令”“解释、执行
指令”“更新PC 寄存器的值”这3 个操作，程序就能运行起来了。一
旦执行完最后一行的JP LOOP 所对应的机器语言，PC 寄存器的值就会
被设为标签LOOP 对应的地址00010000，这样就可以循环执行同样的
操作。请诸位重点观察PC 寄存器是如何控制程序流程的。
代码清单3.3　汇编语言与机器语言的对应关系
地址　　　　机器语言 　　　 标签　 操作码　 操作数
00000000　00111110 11001111 LD 　　 A, 207
00000010　11010011 00000010 OUT 　　(2), A
00000100　00111110 11111111 LD 　　 A, 255
00000110　11010011 00000010 OUT 　　(2), A
00001000　00111110 11001111 LD 　　 A, 207
00001010　11010011 00000011 OUT 　　(3), A
00001100　00111110 00000000 LD 　　 A, 0
00001110　11010011 00000011 OUT 　　(3), A
00010000　11011011 00000000 LOOP: IN　　　　　 A, (0)
00010010　11010011 00000001 OUT 　　(1), A
00010100　11000011 00010000 00000000 　　 JP　　　 LOOP
54
第3章　体验一次手工汇编
3.5　尝试手工汇编
在CPU 的资料中，明确写有所有可以使用的助记符，以及助记符
转换成机器语言后的数值。只要查看这些资料，就可以把用汇编语言
编写的程序手工转换成机器语言的程序，这样的工作称为“手工汇编”。
进行手工汇编时，要一行一行地把用汇编语言编写的程序转换成机器
语言。下面就实际动手试一试吧。表3.2 列出了汇编语言中必要指令的
助记符、助记符所对应的机器语言，以及执行这些机器语言所需的时
钟周期数。
表3.2　从助记符到机器语言的转换方法
助记符机器语言时钟周期数
LD A, num 00111110 num 7
OUT (num), A 11010011 num 11
IN A, (num) 11011011 num 11
JP num 11000011 num 10
下面就从汇编语言的第1 行开始转换。第一行的“LD A, 207”匹
配“LD A, num”这个模式，所以可以先转换成“00111110 num”。然后
将十进制数的207 转换成8 比特的二进制数，用这个二进制数替换
num。使用Windows 自带的计算器程序就可以很方便地把十进制数转
换成二进制数。从Windows 的开始菜单中选择“运行”，输入calc 后点
击“确定”按钮，就可以启动计算器程序。
接下来，从计算器的“查看”菜单中选择“科学型”，这样就得到
了一个可以用十进制数或二进制数表示数字的计算器了。首先选中“十
进制”单选框，然后输入207，接下来选中“二进制”单选框，这样
207 就变成了二进制数的11001111（如图3.3 所示）。至此，“LD A,
207”就转换成了机器语言00111110 11001111。由于这条指令存储在内
55
3.5　尝试手工汇编
存最开始的部分（00000000 号地址），所以要把这条指令和内存地址像
下面这样并排写下来。
地址 汇编语言 机器语言
00000000 LD A, 207 00111110 11001111
图3.3　用Windows 的计算器程序把十进制数转换成二进制数
（1）选择“十进制”单选框，然后输入207
（2）选择“二进制”单选框
用十进制数
表示
用二进制数
表示
第2 条指令“OUT (2), A”匹配“OUT (num), A”这个模式，所以
可以先转换成“11010011 num”。然后把num 的部分替换成00000010，
即用8 比特的二进制数表示的十进制数2，最终就得到了机器语言
“11010011 00000010”。因为内存中已经存储了2 字节的机器语言，所
56
第3章　体验一次手工汇编
以这条机器语言要从00000010 号地址（用十进制表示的话就是2 号地
址）开始记录。
地址 汇编语言 机器语言
00000010 OUT (2), A 11010011 00000010
这之后由于LD 指令和OUT 指令又以相同的模式出现了3 次，所
以可以用相同的步骤转换成机器语言。请诸位注意，机器语言中每条
语句的字节数是多少，内存地址就相应地增加多少。
地址 汇编语言 机器语言
00000100 LD A, 255 00111110 11111111
00000110 OUT (2), A 11010011 00000010
00001000 LD A, 207 00111110 11001111
00001010 OUT (3), A 11010011 00000011
00001100 LD A, 0 00111110 00000000
00001110 OUT (3), A 11010011 00000011
接下来是“IN A, (0)”匹配“IN A, (num)”这个模式，所以可以先转
换成“11011011 num”。然后把num 替换成00000000，即用8 比特的二
进制数表示的十进制数0，最终就得到了机器语言“11011011 00000000”。
对于接下来的“OUT (1), A”，也可以按照同样的方法转换。
地址 汇编语言 机器语言
00010000 IN A, (0) 11011011 00000000
00010010 OUT (1), A 11010011 00000001
最后一句的JP LOOP 匹配模式“JP num”， 所以可以先转换成
“11000011 num”。请注意这里要用16 比特的二进制数替代作为内存地
址的num。在微型计算机中是以8 比特为单位指定内存地址的，但在
Z80 CPU 中用于设定内存地址的引脚却有16 个，所以在机器语言中也
57
3.6　尝试估算程序的执行时间
要用16 比特的二进制数设定内存地址。JP 指令跳转的目的地为
00010000，即“LOOP:”标签所标示的语句“LD A, 0”对应的内存地
址。把这个地址扩充为16 比特就是“00000000 00010000”。要扩充到
16 位，只需要把高8 位全部设为0 就可以了。
还有一点希望诸位注意，在将一个2 字节的数据存储到内存时，
存储顺序是低8 位在前、高8 位在后（也就是逆序存储）。这样的存储
顺序叫作“小端序”（Little Endian），与此相反，将数据由高位到低位
顺序地存储到内存的存储顺序则叫作“大端序”（Big Endian）。根据
CPU 种类的不同，有的CPU 使用大端序，有的CPU 使用小端序。Z80
CPU 使用的是小端序，因此JP LOOP 对应的机器语言为“11000011
00010000 00000000”。
地址 汇编语言 机器语言
00010100 JP LOOP 11000011 00010000 00000000
手工汇编至此就结束了。自己写的汇编语言程序，又通过自己的
双手转换成了机器语言，我们应该为此感到骄傲。
3.6　尝试估算程序的执行时间
在本章的最后，介绍一下如何通过时钟周期数估算程序的执行时
间。请先向前翻到表3.2，找出执行每条汇编语言指令所需的时钟周期
数。然后把代码清单3.2 中所用到的每条指令的时钟周期数累加起来。
于是可以算出到LOOP 标签为止的8 条指令共需要7＋11＋7＋11＋7＋
11＋7＋11 = 72 个时钟周期；LOOP 标签之后的3 条指令共需要11＋11
＋10 = 32 个时钟周期。因为微型计算机采用的是2.5MHz 的晶振，也
就是1 秒可以产生250 万个时钟周期，所以每个时钟周期是1 秒÷250
万 = 0.0000004 秒 = 0.4 微秒。72 个时钟周期就是72×0.4 = 28.8 微秒；
58
第3章　体验一次手工汇编
32 个时钟周期就是12.8 微秒。这段程序是用LED 的亮或灭来表示指
拨开关的开关状态，所以LOOP 标签之后所执行的操作“输入、输出、
跳转”每1 秒可以反复执行1 秒÷12.8 微秒/ 次 = 78125 次之多，可见
计算机的计算速度有多么惊人。

☆ ☆ ☆

比起C 语言或BASIC 等高级语言，汇编语言的语法简单、指令数少，说不定会更加容易学习，可是今天还在使用汇编语言的人却是凤
毛麟角了。使用汇编语言编程时，因为要事无巨细地列出计算机的行为，所以程序会变得冗长繁复。
因此诸位只在纸上体验汇编语言、机器语言以及手工汇编就足够了。只要具备了这些知识，
即便是用C 语言或BASIC 等编程语言编程时，也一样能感受到计算机底层的工作方式，也就是说变得更加了解计算机了。

在接下来的第4 章中，笔者将要介绍条件分支和循环等“程序的流程”，还会稍微介绍一些有关“算法”的内容。敬请期待！



## 第 4 章　程序像河水一样流动着

## 第 5 章　与算法成为好朋友的七个要点

## 第 6 章　与数据结构成为好朋友的七个要点

## 第 7 章　成为会使用面向对象编程的程序员吧

## 第 8 章　一用就会的数据库

## 第 9 章　通过七个简单的实验理解 TCP/IP 网络

## 第 10 章　试着加密数据吧

## 第 11 章　XML 究竟是什么

## 第 12 章　SE 负责监管计算机系统的构建

## 结束语

## 谢辞






<br/><br/><br/><br/><br/>
## 参考资料

资料地址 <https://www.ituring.com.cn/book/1139>





