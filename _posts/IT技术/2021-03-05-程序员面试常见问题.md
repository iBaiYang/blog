---
layout: post
categories: IT技术
title: 程序员面试常见问题
meta: 程序员面试常见问题
---
* content
{:toc}

## 正文

### HR Phone Screen

Phone Screen，一般是提交简历后，程序员面试开始的第一步，由公司HR负责。目的是了解一下候选人的背景，为下一步tech interview做准备。


常见问题如下：

1- 你为什么对本公司的这个职位感兴趣？

这一问HR主要想考察你有没有做好“功课”，事先研究了解过公司。

2- 你有没有用过本公司常用的编程语言？

如果你对这种特定语言没有太多的经验，那就说实话，否则就算过了电话关，也过不了之后的coding关。
但你也要告诉HR你自己会的语言，并表示有能力学习新的语言。

3- 你有没有做过什么项目？

简明扼要。直接简洁地描述你参与过的项目和在里面扮演的角色。

4- 你有没有领导别人的经验？

这一题的答案不仅仅局限于技术上的领导力。如果你在学校里有过志愿者活动的领导经验，都可以说。 
尽可能地将你以前的领导经验和你要申请的职位联系起来。

5- 为什么你要离开现在的公司？

你可以坦率地说出你的想法，但答案不要仅仅围绕在钱和利益上。你可以从职场文化、创意实践，
解决现实问题的满意度等几个角度来回答这题。

注意，跟HR的面试，并不需要你深入地探讨一些技术上的问题和经验。要做到简明扼要，不要让HR睡着了。

### Onsite Interview

当你顺利通过了HR的phone screen、或是之后的technical phone interview后，你就会进入程序员面试的下一个环节。
也就是一个4-5轮的Onsite Interview。面试官会从项目经历、行为、文化、技术、coding等几个角度来全方位了解你是不是他们想要的程序员。

### Experiential Questions

6- 在给其他团队成员reveiw code时，你觉得最重要的是什么？

这题的答案没有明确的对与错，目的是为了检验你的知识，以及你在面试中是否可以表达好code review的过程。回答角度可以围绕：
* Functionality
* Readability
* Maintainability
* Security
* Simplicity
* Regulatory requirements
* Resource optimization

7- 描述一下你写代码的全部过程。

面试官想知道你在写代码时，是否有一个清晰的流程，并确保你的工作方式是有组织的，而不是杂乱无章的。


8- 你做complex algorithms的首选语言是什么？

你可以说实话，但至少要给出两个答案，以表明自己“多才多艺”和“不钻牛角尖”。你可以说 “XYZ是我的第一选择，
但ABC也是一个很好的选择。” 然后告诉他们为什么。


9- 如何设计一个可以扩大规模的APP？

这个面试题测试的是你的知识和思维过程。


10- 你做过的最满意、最值得骄傲的项目是什么？

这是你表现自己的时刻，告诉面试官你的coding实力，并描述一个你最引以为傲的项目。一定说出理由，
为什么你觉得这个项目让你骄傲 （比如它满足了某种需求等等）。


11- 描述一个你做过的失败的项目。

你可以清楚地说明为什么这个项目最终失败了。你还可以说你之后花时间剖析了这个项目，并且总结了问题，
从失败中学到了经验。并在下一次项目中，没有再犯。


### Cultural / Behavioral Questions

12- 你目前所在的公司，有什么吸引你的地方吗？

在面试的时候，千万不要说，“没有，我讨厌现在的公司”。可以选择说一说目前公司和所申请公司共同的优点。
如果这是你的第一份工作，你可以谈谈在学习或实习期间喜欢什么。


13- 描述你理想的公司文化。

在进行onsite面试之前，做好你的research，提前了解这个公司。确保说出来的理想文化，和这个公司的程序员文化相似。


14- 你的同事是怎么描述你的？

你可以通过这个问题来向面试官展示你的社交意识，你可以说通过与同事的交流协作，你了解到了自己在别人眼中的样子。
同时，你可以用这个问题来表明你是有自我认知的。你知道自己的长处和短处，以及你能给团队带来什么。诚实回答，不要过度自嘲。


### Technical Questions

这可以说是程序员面试中最重要的一个环节之一。这一类的面试题，会根据不同候选人的不同知识背景进行考核。


常见问题举例：

15- mutex 和 semaphore 有什么区别？

16- 什么是多线程编程？

17- Local Variable和Global Variable有什么区别？

18- 哈希表如何工作？

19- 给出一个真实生活中哈希表的例子，并描述一个哈希表为何是一个糟糕的数据结构选择。

20- 假设你有一个单线程的C标准应用程序，它不断崩溃，但从来不在同一个地方崩溃。你觉得可能导致它崩溃的原因是什么？

21- queue和stack之间有什么区别？

22- 什么是regression test？


### Coding Questions

这个阶段是所有程序员面试中最难的一关。你不仅需要在高压的环节中展示你的知识成果，
而且你还要在不熟悉的环境（白板上的手写代码）和时间限制下工作。每个候选人会遇到的具体问题有所不同，
但以下是一些常考的经典题目：


23- Linked lists（删除重复，反转链表，确定它是否有环）

24- 时间和空间复杂度分析

25- Tree：基本构造，遍历和操作算法。知道如何实现平衡二叉树。

26- Stack（用两个栈实现一个队列）

27- 数组和字符串（反转字符串，permutations）


面试时，确保你不断向面试官解释你的思考过程（即使你被困住了）。 尝试着与面试官协作，并可以在遇到困难时勇敢地提问。
因为这可以表明你愿意在团队中寻求帮助、以便把工作良好地进行下去。

## 软件工程的核心概念

软件工程的核心概念包括抽象、建模、分解和复用。这些概念的具体内容如下：

* 抽象：将复杂的事物简化为简单的事物，以便于处理。在软件工程中，抽象是一种重要的工具，用于对软件系统进行高层次描述，
以便在保持关键信息的条件下，忽略不必要的细节。
* 建模：对现实世界进行某种形式的描述或模拟，以解决特定问题。在软件工程中，建模是对软件系统的行为和结构进行描述的方式，
常用的建模技术包括面向对象建模、数据流图和事件驱动系统设计等。
* 分解：将复杂问题分解为更小、更易于管理的部分，以便分别理解和解决。在软件工程中，
分解用于将大型软件系统划分为更小、更易于开发的模块，这种技术有助于降低问题的复杂性，提高开发效率。
* 复用：使用已有的软件组件或模块来开发新的软件系统，而不是重新编写代码。复用可以显著提高开发效率，减少错误，
并改善软件的可维护性。在软件工程中，复用通常涉及设计模式、组件化和面向对象编程等概念。

### 具体分析

如何从一个需求落实到一个系统设计，如何衡量两个不同设计的好坏，
如何在各种限制下（人员、时间、资源等）选择其中更合适的设计，以及提升该设计的可拓展性？

从需求落实到系统设计，需要经过以下步骤：
1. 明确需求：理解并清晰表述需求，包括功能需求、非功能需求和约束。
2. 需求分析：对需求进行深入理解，分析其可行性和合理性，评估其优先级和重要性。
3. 系统设计：根据需求分析的结果，进行系统设计，包括总体架构、模块划分、接口设计、数据结构等。
4. 设计评审：邀请同行或专家对设计进行评审，提出改进建议，进一步完善设计。
5. 原型开发：根据设计，开发一个原型系统，用于验证设计的可行性和合理性。
6. 原型测试：对原型系统进行全面测试，包括功能测试、性能测试、安全测试等，确保系统满足需求。

衡量两个不同设计的好坏，可以从以下几个方面考虑：
1. 功能性：评估两个设计的功能是否满足需求，以及功能的完善程度和实用性。
2. 效率：比较两个设计的运行速度、处理能力等效率指标，评估其性能表现。
3. 可靠性：评估两个设计的容错处理、故障恢复等能力，以及系统的稳定性和可用性。
4. 可维护性：评估两个设计的可修改性、可扩展性等，以便在未来进行维护和升级。
5. 成本：比较两个设计的开发成本、运行成本等，以确定哪个设计更具经济性。

在各种限制下（人员、时间、资源等）选择更合适的设计，需要综合考虑以下因素：
1. 人员技能和经验：考虑团队成员的技能和经验，选择他们能够胜任的设计。
2. 时间限制：考虑项目的开发周期和时间安排，选择能够在规定时间内完成的设计。
3. 资源限制：考虑项目的预算和硬件资源，选择符合预算和资源限制的设计。
4. 技术选型：考虑所使用的技术是否符合项目需求，以及技术的成熟度和可维护性。
5. 风险评估：考虑可能出现的风险和问题，选择风险较低的设计。

提升设计可拓展性的方法包括：
1. 设计开放式结构：使系统能够方便地添加或删除功能，以满足未来的需求变化。
2. 使用面向对象编程：通过使用类、对象和继承等概念，使代码更加模块化和可重用。
3. 设计松散耦合：使系统的各个部分之间尽可能减少依赖关系，以便于单独进行维护和升级。
4. 使用抽象和接口：通过抽象和接口的定义，使系统的各个部分之间能够相互独立地进行开发和扩展。
5. 数据模型设计：合理设计数据库结构，保证数据的完整性和一致性，以支持未来的数据分析和决策。

除了上述提到的点外，还需要注意以下几点：
1. 可移植性：确保设计能够在不同的平台或环境中运行，以便在未来进行迁移或升级。
2. 安全性：考虑系统的安全性需求，包括数据加密、访问控制、漏洞修复等，以确保系统的安全性和稳定性。
3. 可维护性：确保设计易于维护和修改，包括代码的可读性、模块化、注释等，以便在未来进行维护和升级。
4. 测试和验证：进行充分的测试和验证，确保设计的正确性和可靠性，包括单元测试、集成测试、系统测试等。
5. 技术趋势和未来发展：考虑未来技术和趋势的发展，选择具有较好前瞻性和可扩展性的设计。
6. 用户反馈和需求：持续收集和分析用户反馈和需求，以便在未来进行改进和升级。

总之，从需求到设计是一个复杂的过程，需要考虑多方面的因素，包括功能性、效率、可靠性、可维护性、成本等，
以及各种限制条件和未来的发展趋势。通过不断的迭代和改进，可以不断提升系统的质量和性能。

软件工程中还有其他一些核心概念，包括：
1. 敏捷开发：一种以人为核心、迭代、循序渐进的软件开发方法。它强调快速响应变化和持续交付价值，
而不是遵循详细的计划和预测。敏捷开发的核心原则包括适应变化、频繁交付、明确目标、团队协作和自我组织等。
2. 瀑布模型：一种传统的软件开发模型，按照顺序依次经历需求分析、设计、编码、测试和维护阶段。
每个阶段都有明确的任务和输出，前一阶段的输出是后一阶段的输入。瀑布模型要求在每个阶段都进行严格的评审和审查，
以确保软件的质量和稳定性。
3. 迭代开发：一种软件开发方法，将整个项目划分为一系列的迭代，每个迭代都包含需求分析、设计、编码、测试等阶段。
通过迭代开发，可以将大型项目分解为更小、更易于管理的部分，并且可以尽早发现和解决问题，提高项目的成功率。
4. 螺旋模型：一种风险驱动的软件开发模型，它将瀑布模型和迭代开发结合在一起。它从初始阶段开始，
然后逐渐增加功能和复杂性，同时不断进行风险评估和管理。螺旋模型适用于高风险或需求不确定的项目，
因为它可以逐步增加功能和降低风险。
5. 测试驱动开发（TDD）：一种软件开发方法，强调通过自动化测试来驱动代码的设计和实现。
它要求在编写测试代码之前先编写实现代码，并且测试代码的数量和质量要与实现代码的数量和质量相当。
TDD可以提高代码的质量和可维护性，同时降低错误和缺陷的数量。

这些核心概念都是软件工程中重要的组成部分，每种方法都有其适用范围和局限性。在实际应用中，
需要根据项目的具体需求和情况选择合适的方法和技术，以达到最佳的软件开发效果。

除了上述提到的核心概念外，还有一些需要补充的点，包括：
1. 持续集成和持续交付（CI/CD）：是一种软件工程实践，旨在提高软件开发的效率和质量。
CI/CD强调频繁地集成、构建、测试和交付软件，同时自动化这些过程。通过CI/CD，可以快速发现和修复问题，提高软件的可维护性和可靠性。
1. 代码复审：是一种软件开发过程中的质量控制方法，通过同行或专业人士对代码进行审查，
发现并纠正错误、优化代码结构和提高质量。代码复审可以提高代码的可读性、可维护性和可扩展性。
1. 版本控制：是一种软件工程工具，用于管理和跟踪代码的变更和版本。
版本控制可以帮助团队成员协同工作、追踪变更历史、恢复旧版本和比较不同版本之间的差异。
1. 设计模式：是一种解决常见设计问题的经验总结，包括对象类设计模式、设计模式原则等。
设计模式可以提高代码的可重用性、可维护性和可扩展性。
1. 软件开发过程模型：是一种软件开发的框架和方法，提供了一种标准的流程和步骤，用于指导项目管理和软件开发。
常见的软件开发过程模型包括CMMI、敏捷开发过程框架等。

这些点都是软件工程中的重要组成部分，可以进一步提高软件开发的效率和质量。在实际应用中，
需要根据项目的具体需求和情况选择合适的方法和技术，以达到最佳的软件开发效果。

总结：软件工程的核心概念包括抽象、建模、分解和复用，这些概念有助于我们更好地理解和解决软件开发中的问题。
此外，敏捷开发、瀑布模型、迭代开发、螺旋模型、测试驱动开发、持续集成和持续交付、代码复审、
版本控制以及设计模式等也是软件工程中的重要概念。
这些概念和方法可以帮助我们提高软件开发的效率和质量，降低风险和成本。在选择具体的方法和技术时，
需要根据项目的具体需求和情况进行评估和选择。同时，持续学习和实践也是软件工程发展的重要保证，
只有不断地学习和实践，才能不断提高软件开发的水平和能力。

上面提到的设计模式是一种解决常见设计问题的经验总结，通常包括问题描述、解决方案和效果。
设计模式可以帮助软件开发人员设计更好的软件，提高代码的可重用性、可维护性和可扩展性。
     
设计模式通常分为三种类型：创建型模式、结构型模式和行为型模式。
创建型模式主要关注对象的创建和初始化，包括单例模式、原型模式、建造者模式等。
结构型模式关注对象之间的结构关系，包括代理模式、装饰器模式、桥接模式等。
行为型模式关注对象之间的行为和交互，包括策略模式、观察者模式、模板方法模式等。

每种设计模式都有其特定的应用场景和效果，选择适当的设计模式可以提高代码的质量和可维护性。
在实际应用中，需要根据项目的具体需求和情况选择合适的设计模式，以达到最佳的软件开发效果。
同时，也需要根据实际需求进行适当的调整和优化，以满足项目的具体需求。

创建型模式：关注对象的创建和初始化。
* 单例模式：确保一个类只有一个实例，并提供一个全局访问点。
* 原型模式：通过复制或克隆现有对象来创建新对象。
* 建造者模式：将一个复杂对象的创建与其表示分离，使得同样的构建过程可以创建不同的表示。
    
结构型模式：关注对象之间的结构关系。
* 代理模式：提供一个代理对象来控制对一个对象的访问。
* 装饰器模式：通过添加新功能来动态地装饰一个对象。
* 桥接模式：将抽象部分与实现部分分离，使它们可以独立变化。
    
行为型模式：关注对象之间的行为和交互。
* 策略模式：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换，从而使算法的选择可以独立于使用它的客户端。
* 观察者模式：定义了对象之间的一对多依赖关系，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。
* 模板方法模式：定义了一个操作中的算法骨架，将某些步骤延迟到子类中实现。

这些设计模式都有其特定的应用场景和效果。在实际应用中，需要根据项目的具体需求和情况选择合适的设计模式，
以达到最佳的软件开发效果。同时，也需要根据实际需求进行适当的调整和优化，以满足项目的具体需求。

## 白板

如何白板上练习算法题目，写出清晰、简洁、bug free的代码,，并衡量时间和空间复杂度以及可能存在的副作用？

在白板上练习算法题目，以下是一些建议：

* 清晰地理解问题：在开始编写代码之前，确保你已经清晰地理解了问题。在白板上上写下问题的描述，并针对每个步骤分析其含义和目的。
* 简化问题：在解决问题之前，尝试将问题简化为更小、更易于管理的部分。将大问题分解为小问题，然后分别解决每个小问题。
* 伪代码：在白板上写出解决问题的伪代码。这将有助于你理清解决问题的思路，找出潜在的错误，并在编写代码之前理解问题的结构。
* 编写代码：一旦你有了伪代码，就可以开始编写代码。确保你的代码清晰、简洁，并遵循编程的最佳实践，例如使用有意义的变量名、编写注释等。
* 测试代码：编写完代码后，一定要进行测试。在白板上写下测试用例，并逐一运行代码来验证每个测试用例是否通过。
这将有助于你发现潜在的错误，并确保你的代码能够正确地解决问题。
* 时间和空间复杂度：在解决问题时，一定要考虑时间和空间复杂度。在白板上分析你的算法的时间和空间复杂度，并尝试优化它们。
* 副作用：在编写代码时，一定要考虑可能存在的副作用。例如，某些算法可能会改变输入数据或占用大量内存。
在白板上分析你的算法的潜在副作用，并尝试避免它们。

通过以上步骤，你可以在白板上练习算法题目，并编写清晰、简洁、bug free的代码，同时考虑时间和空间复杂度以及可能存在的副作用。

## 如何衡量时间和空间复杂度

时间和空间复杂度的衡量通常是通过分析算法中基本操作的数量和所需的存储空间来评估。

时间复杂度是衡量一个算法运行时间的度量，它描述了算法执行的基本操作数量随着输入规模的增长而增长的速率。通常用大O符号表示，描述了算法中基本操作的数量随着输入规模的增长而增长的速率。例如，一个排序算法的时间复杂度可能是O(n log n)，表示算法的基本操作数量是输入规模n的log n级别。

空间复杂度是衡量一个算法所需存储空间的度量，它描述了算法所需的存储空间随着输入规模的增长而增长的速率。同样用大O符号表示，描述了算法所需的存储空间随着输入规模的增长而增长的速率。例如，一个排序算法的空间复杂度可能是O(n)，表示算法所需的存储空间是输入规模n级别。

在白板上分析算法的时间和空间复杂度时，可以使用以下步骤：
1. 分析算法的基本操作：分析算法中的基本操作，例如循环、条件判断、函数调用等。了解每个操作所需的时间和空间。
2. 计算基本操作的数量：根据问题的规模，计算算法中基本操作的数量。例如，在排序算法中，可能需要比较、交换等操作，而这些操作的数量与输入规模有关。
3. 确定时间复杂度：根据基本操作的数量和问题的规模，确定算法的时间复杂度。例如，如果算法中的基本操作数量是输入规模n的log n级别，那么算法的时间复杂度就是O(n log n)。
4. 分析所需的存储空间：分析算法所需的存储空间，例如数组、栈、队列等。了解每个存储结构所需的内存空间。
5. 确定空间复杂度：根据存储结构所需的内存空间和问题的规模，确定算法的空间复杂度。例如，如果算法中需要使用一个大小为n的数组来存储结果，那么算法的空间复杂度就是O(n)。

通过以上步骤，你可以在白板上分析算法的时间和空间复杂度，并对其进行评估和优化。

**顺序查找** 

问题描述：给定一个整数数组，找出数组中最大的元素。

算法描述：

    初始化一个变量max为数组的第一个元素。
    遍历数组中的每个元素。
        如果当前元素比max大，则将max更新为当前元素。
    返回max。

时间复杂度分析：

    基本操作：遍历数组中的每个元素，共n次。
    基本操作数量：n。
    时间复杂度：O(n)，因为算法中的基本操作数量与输入规模n成正比。

空间复杂度分析：

    存储需求：max变量，存储最大值。
    存储空间：常数级别，可以忽略不计。
    空间复杂度：O(1)，因为算法所需的存储空间是常数级别，不随输入规模n增长。

通过以上分析，我们可以得出该算法的时间复杂度为O(n)，空间复杂度为O(1)。

**插入排序**

插入排序的时间复杂度为O(n^2)，空间复杂度为O(1)。

在插入排序中，我们需要进行两层循环，外层循环对除了第一个元素之外的所有元素，
内层循环对当前元素前面已经排好序的元素进行查找和移动。因此，内层循环的平均时间复杂度为O(n)，
外层循环的时间复杂度也为O(n)，总的平均时间复杂度为O(n^2)。

空间复杂度为O(1)，因为插入排序不需要额外的辅助数据结构，只需要一个额外的空间来存储索引。

**冒泡排序**

冒泡排序的时间复杂度为O(n^2)，空间复杂度为O(1)。

在冒泡排序中，我们需要进行两层循环，外层循环对除了最后一个元素之外的所有元素，
内层循环对当前元素后面已经排好序的元素进行比较和移动。因此，内层循环的平均时间复杂度为O(n)，
外层循环的时间复杂度也为O(n)，总的平均时间复杂度为O(n^2)。

空间复杂度为O(1)，因为冒泡排序只需要进行元素的交换，不需要额外的辅助数据结构。

**快速排序**

快速排序的时间复杂度为O(n log n)，空间复杂度为O(log n)。

在快速排序中，我们使用分治策略，将数组分成两个子数组，对每个子数组进行递归排序。
这个过程需要使用一个额外的空间来存储分治后的子数组的指针。因此，空间复杂度为O(log n)。

快速排序的核心操作是分区操作，它将数组分成两个子数组，并使用递归对每个子数组进行排序。
分区操作的时间复杂度为O(n)，因为我们需要遍历整个数组。在最好的情况下，快速排序的时间复杂度为O(n log n)，
因为每次分区操作都可以将数组分成两个等长的子数组，这样递归的深度就为log n。在最坏的情况下，
时间复杂度为O(n^2)，因为分区操作可能无法将数组等分。

总的来说，快速排序的平均时间复杂度为O(n log n)，空间复杂度为O(log n)。

**希尔排序**

希尔排序（Shell Sort）是希尔（Donald Shell）于1959年提出的一种排序算法。它是一种插入排序的改进版本，也称为缩小增量排序。

希尔排序算法的基本思想是：先将整个待排序的记录序列分割成为若干子序列（由相隔某个“增量”的记录组成的），
分别进行直接插入排序，然后依次缩减增量再进行排序，直到增量为1时，进行最后一次直接插入排序。

希尔排序算法的实现过程如下：

1. 初始化增量序列：选择一个合适的整数作为初始增量，例如gap=length/2=10/2=5，
将待排序文件分割成若干长度为gap的子序列，然后对每个子序列进行直接插入排序。
2. 缩小增量：gap每次除以2，直到gap=1为止。

希尔排序算法的时间复杂度取决于增量序列的选择。最坏情况下，当输入数据已经部分排序时，
增量序列的选择可能会使时间复杂度达到O(n^2)。然而，在平均情况下，通过选择合适的增量序列，
希尔排序的时间复杂度可以达到O(n log n)。

希尔排序算法是一种高效的排序算法，尤其是对于大型数据集。在实际应用中，它比冒泡排序、选择排序等算法更快。

**堆排序**

堆排序的时间复杂度为O(n log n)，空间复杂度为O(1)。

在堆排序中，我们首先将数组构建成一个最大堆或最小堆，然后交换最大元素（或最小元素）与最后一个元素的位置，
再将除最后一个元素之外的剩余元素重新调整为最大堆或最小堆。这个过程需要使用一个辅助的数组来构建和调整堆，
但不需要额外的递归调用。因此，空间复杂度为O(1)。

堆排序的核心操作是构建和调整堆，这个过程的时间复杂度为O(n log n)，因为我们需要对每个元素进行比较和交换。
在最大堆或最小堆构建完成后，我们可以快速地找到最大元素（或最小元素），并且只需要对剩余的元素进行一次遍历，
因此整个排序过程的时间复杂度为O(n log n)。

总的来说，堆排序的时间复杂度为O(n log n)，空间复杂度为O(1)。

**归并排序**

归并排序的时间复杂度为O(n log n)，空间复杂度为O(n)。

在归并排序中，我们首先将数组分成两个子数组，然后对每个子数组进行递归排序。
这个过程需要使用一个额外的空间来存储归并排序的中间结果。因此，空间复杂度为O(n)。

归并排序的核心操作是归并操作，它将两个已经排好序的子数组合并成一个排好序的数组。归并操作的时间复杂度为O(n)，
因为我们需要遍历两个子数组中的所有元素。在最好的情况下，归并排序的时间复杂度为O(n log n)，
因为每次归并操作都可以将数组分成两个等长的子数组，这样递归的深度就为log n。
在最坏的情况下，时间复杂度为O(n^2)，因为归并操作可能无法将数组等分。

总的来说，归并排序的时间复杂度为O(n log n)，空间复杂度为O(n)。

**飞梭排序**

飞梭排序（Fisher-Jenkins Sort）是一种排序算法，它是由罗纳德·费雪和哈斯利·詹金斯于1972年提出的。
这种排序算法基于奇偶排序的思想，也被称为奇偶移动排序或偶移动排序。

飞梭排序算法的基本步骤如下：
1. 从最后一个元素开始，每隔一个元素取一个值，将取到的元素按照升序插入到一个新的序列中。
2. 对于剩下的未排序元素，采用相同的方式，每隔一个元素取一个，并插入到新序列中。
3. 重复这个过程，直到整个序列都排好序。

飞梭排序算法的时间复杂度为O(n^2)，与冒泡排序算法相同。这种排序算法在实际应用中并不常用，
因为它比其他更高效的排序算法（如快速排序、归并排序等）更慢。

**二分查找**

二分查找的时间复杂度为O(n log n)，空间复杂度为O(1)。

在二分查找中，我们需要将数组分成两部分，对每部分进行递归查找。
这个过程需要使用一个额外的空间来存储分区的索引。因此，空间复杂度为O(1)。

二分查找的核心操作是查找操作，它将数组分成两个部分，并选择其中一个部分进行递归查找。
这个操作的时间复杂度为O(log n)，因为每次查找操作都可以将数组分成两个等长的子数组，这样递归的深度就为log n。
在整个数组中查找每个元素都需要进行一次二分查找，因此时间复杂度为O(n log n)。

总的来说，二分查找的时间复杂度为O(n log n)，空间复杂度为O(1)。

**暴力匹配算法**

暴力匹配算法，也称为朴素匹配算法，是一种简单的字符串匹配算法。它的基本思想是从文本串的第一个字符开始，
逐个字符地与模式串进行比较，如果匹配失败，则将模式串的指针向后移动一位，再与文本串的下一个字符进行比较，
直到找到匹配的子串或者文本串遍历完毕。

暴力匹配算法的时间复杂度为O(mn)，其中m和n分别为模式串和文本串的长度。在最坏情况下，需要将模式串移动n-m+1次，
因此算法的效率较低，不适用于处理大规模的文本匹配问题。

**KMP算法**

KMP算法（Knuth-Morris-Pratt算法）是一种改进的暴力匹配算法，它的时间复杂度为O(m+n)，其中m和n分别为模式串和文本串的长度。
KMP算法通过预处理模式串，建立一个“部分匹配表”（也称为“部分匹配表”或“失败函数”），用来减少字符串的比较次数。

KMP算法的核心是当模式串与文本串不匹配时，能够利用已经部分匹配的信息，跳过一些不必要的比较。
具体来说，当模式串中的某个字符与文本串中的某个字符不匹配时，KMP算法根据“部分匹配表”中的信息，
将模式串向右移动若干个位置，使得模式串中的某个已匹配的前缀能够与文本串中的某个子串匹配，从而避免了不必要的比较。

KMP算法的实现需要用到一个辅助函数next，该函数用于生成“部分匹配表”。next函数根据模式串的自身特点计算得到一个next数组，
数组中的每个元素`next[i]`表示当模式串的第i个字符与文本串中的某个字符不匹配时，模式串应该向右移动的位数。
在实际使用时，还需要根据next数组生成一个`next[0]`数组，
其中`next[0][i]`表示当模式串的前缀的第i个字符与文本串中的某个字符不匹配时，模式串应该向右移动的位数。

**广度优先搜索**

广度优先搜索（BFS）是一种遍历或搜索树（或图）的算法，它从根节点（或任意节点）开始，并探索所有邻居节点，
然后再探索邻居的邻居节点。这种算法属于一种盲目搜寻法，并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。

广度优先搜索的时间复杂度是O(V+E)，其中V是顶点数，E是边数。在最坏的情况下，需要检查图中的所有顶点和边。
在平均情况下，如果图是相对稀疏的，其时间复杂度可以更优。

该算法使用队列来保存待探索的节点，每探索一个节点，就将其相邻的未探索过的节点加入队列。通过重复这个过程，
直到队列为空，算法结束。广度优先搜索常用于找到从源节点到另一个节点的最短路径，或者在图中找到一个特定的节点。

**深度优先搜索**

深度优先搜索（DFS）是一种用于遍历或搜索树（或图）的算法。这种算法会沿着一条路径尽可能深入地搜索，
然后回溯，尝试下一条路径，直到找到目标或搜索完所有可能的路径。

深度优先搜索的时间复杂度取决于图的连通性。对于连通的图，其时间复杂度为O(V+E)，其中V是顶点数，E是边数。
对于非连通的图，其时间复杂度为O(V)，因为需要访问所有顶点。

该算法使用递归函数来实现。从一个起始顶点开始，递归函数首先访问该顶点的所有相邻顶点。
然后，对于每个相邻顶点，递归函数再访问它们未被访问过的相邻顶点，并以此类推，直到访问到最后一个相邻顶点。
如果已经访问过相邻顶点，则回溯到前一个顶点，并尝试下一条路径。深度优先搜索常用于解决一些需要遍历图的问题，
例如找到从一个顶点到另一个顶点的最短路径，或者确定一个图是否是二分图。

**迪克斯特拉算法**

迪杰斯特拉算法（Dijkstra）是由荷兰计算机科学家艾兹格·迪杰斯特拉于1956年提出的，因此也叫迪杰斯特拉算法。
这是一种用于解决有权有向图中最短路径问题的算法。

迪杰斯特拉算法的主要特点是从起始点开始，采用贪心算法的策略，每次遍历到起始点距离最近且未访问过的顶点的邻接节点，
直到扩展到终点为止。算法的核心是维护一个尚未到达终点的顶点的集合，并按照距离排序，每次选取当前距离最小的顶点进行扩展。

迪杰斯特拉算法的时间复杂度为O((V+E)logV)，其中V是顶点数，E是边数。
在空间复杂度方面，该算法需要存储每个顶点的距离和是否被访问的状态，因此空间复杂度为O(V)。

**哈希表查找算法**

哈希表查找算法是一种非常快速的查找算法，它的时间复杂度可以达到O(1)。
哈希表利用哈希函数将键映射到桶中，并在桶中进行数据的存储和查找。

哈希表查找算法的基本步骤如下：
1. 构建哈希表：根据要查找的数据，建立一个哈希表，其中每个键对应一个桶。
2. 计算哈希值：将要查找的数据通过哈希函数计算出哈希值，这个哈希值对应一个桶。
3. 查找数据：在对应的桶中查找数据，如果有数据存在，则返回数据；否则返回空值或者一个特定的标记。

哈希表查找算法的优点是查找速度快，时间复杂度为O(1)；缺点是如果键冲突较多，则会影响查找效率。
为了解决键冲突的问题，可以采用一些方法，例如二次哈希、链地址法等。

## 数据结构

常见的数据结构有：

* 数组（Array）：这是最简单的一种数据结构，它是一个有序的元素集合，可以通过索引访问。
* 链表（Linked List）：链表是一种非连续的数据结构，每个元素都包含一个链接到下一个元素的引用。
* 栈（Stack）：栈是一种后进先出（LIFO）的数据结构，只有栈顶元素可以被访问和删除。
* 队列（Queue）：队列是一种先进先出（FIFO）的数据结构，只有队列头元素可以被访问和删除。
* 链式表（LinkedList）：链式表是一种特殊的链表，它在内存中分配一块连续的空间来存储元素。
* 树（Tree）：树是一种非线性的数据结构，由节点和边组成。它可以用于表示分层数据。
1. 二叉树
2. 堆（特殊类型的树）
3. AVL树：AVL树是一种自平衡的二叉搜索树，它在插入和删除操作时会对树的平衡进行调整，从而保证最坏情况下的时间复杂度为O(log n)。
4. 红黑树
5. B树
6. B+树
7. Trie树（前缀树）
* 图（Graph）：图是由节点和边组成的数据结构，可以用于表示复杂的网络关系。
* 哈希表（Hash Table）：哈希表是一种关联数组的数据结构，它可以存储键值对，
根据键（Key）直接访问在内存存储区域中的值（Value）的数据结构，并能在常数时间内完成查找、插入和删除操作。
* 集合（Set）：集合是一种无序的数据结构，用于存储互不相同的元素。
* 字典（Dictionary）：字典是一种关联数组的数据结构，用于存储键值对，键必须是唯一的。
* 堆（Heap）：堆是一种特殊的完全二叉树，用于实现优先队列。
* 数据框（Data Frame）：在数据分析中，数据框是一种特殊的数据结构，用于存储表格数据。
* 位图（Bitmap）：位图是一种二进制数据结构，用于存储大量的布尔值。
* 矩阵（Matrix）：矩阵是一种二维的数据结构，用于存储线性代数中的数据。

其他的数据结构：

* 跳跃列表（Skip List）：跳跃列表是一种概率平衡的线性时间复杂度数据结构，它是一种可以进行快速查找和删除的有序链表。
* 斐波那契堆（Fibonacci Heap）：斐波那契堆是一种特殊的优先队列，用于实现高效的动态图算法。
* 后缀数组（Suffix Array）：后缀数组是一种基于字符串的数据结构，它按照字典序将所有后缀存储在一个数组中，用于解决字符串相关问题。
* 平衡树（Balanced Tree）：平衡树是一种自平衡的二叉搜索树，包括AVL树、红黑树等。
* 字典（Hash Map）：字典或哈希映射是一种关联数组的数据结构，用于存储键值对，并能够在平均情况下实现 O(1) 的查找、插入和删除操作。
* 字典树（Trie Tree）：字典树也被称为前缀树，是一种树形结构，用于存储字符串集合，有效地支持字符串查找操作。
* B+树：B+树是一种自平衡的树，它是B树的变种，它对于内部节点增加了链接，使得范围查询更加方便，用于数据库和文件系统等领域。
* B-tree：B-tree是一种自平衡的搜索树，主要用于存储在磁盘上的数据，以便进行高效的随机访问。
* `B*树`：`B*树`是B+树的一种改进型，它通过在节点间增加链接来支持更高效的删除操作。
* K-D 树（k-dimensional tree）：K-D 树是一种用于处理多维空间数据的数据结构，常用于空间索引和机器学习等领域。
* Yen's 数据结构：Yen's 数据结构是一种用于解决线段交点问题的数据结构。
* 主席树（Climbing Tree）：主席树是一种二叉搜索树，它通过维护多个路径来加快查找速度。
* 主席树（主席链、M-tree）：主席树是一种多叉树，用于实现高效的布尔查询操作。
* 主席树（Chairman Tree、Chairman's Tree、Chairman's Data Structure）：主席树是一种多叉树，用于实现高效的布尔查询操作。
* 矩阵链（Matrix Chain）：矩阵链是一种表示一系列矩阵乘法运算的数据结构，常用于优化矩阵乘法的计算顺序。
* 哈夫曼树（Huffman Tree）：哈夫曼树是一种最优二叉树，它的每个节点都表示一个字符，而树的边则表示字符的二进制编码。
* 并查集（Disjoint Set）：并查集是一种树形数据结构，用于处理一些不交集的集合的合并及查询问题。
* 线段树（Segment Tree）：线段树是一种二叉树，它提供了对线段的快速查询、更新和删除操作。
* R-树（R-tree）：R-树是一种空间索引数据结构，用于高效地存储和查询空间数据。
* `R*树`（R*-tree）：`R*树`是一种改进的R-树，它在插入、删除和旋转操作方面具有更好的性能。
* R-tree及其变种（R-tree, Rtree, R+tree, Rtree等）：R-tree及其变种是一种用于处理空间数据的数据结构，常用于空间索引和数据库等领域。
* Broom Tree：Broom Tree 是一种可用于缓存和优先队列的数据结构。
* K-d 树（k-dimensional tree）：K-d 树是一种用于处理多维空间数据的数据结构，常用于空间索引和机器学习等领域。
* 莫比乌斯反演（Möbius Inversion）：莫比乌斯反演是一种基于拉格朗日乘数法的技术，用于解决某些数学问题。
* Trie 树（有时也称为前缀树或数字树）：Trie 树是一种用于存储字符串的数据结构，适用于字符串查找和前缀查询。
* Van Emde Boas 树：Van Emde Boas 树是一种近似于哈希表的高效数据结构，适用于小集合的查询问题。
* 斜率优化二叉搜索树（Splay Tree）：Splay Tree 是一种自适应的数据结构，能够根据查询频率进行动态调整，以优化查询效率。
* 优先队列（Priority Queue）：优先队列是一种能够存储元素并保证任何时候最小的元素总是位于队列的头部或按照其他优先级规则排列的数据结构。
* 滑动窗口树（Sliding Window Tree）：滑动窗口树是一种能够高效处理具有时间窗口限制的数据结构。
* Rabin-Karp 算法：Rabin-Karp 算法是一种字符串搜索算法，用于查找一个短字符串（或模式）在一个长字符串中的所有出现位置。
* Fibonacci 堆：Fibonacci 堆是一种用于实现动态集合的数据结构，它支持插入、删除和查找操作。
* 红黑树：红黑树是一种自平衡的二叉搜索树，它在插入和删除操作时能够保持树的平衡，从而保证最坏情况下的时间复杂度为O(log n)。
* Treap：Treap是一种结合了二叉搜索树和堆（优先队列）特点的数据结构。
* Splay树：Splay树是一种自适应的数据结构，能够根据查询频率进行动态调整，以优化查询效率。

## HTTP各版本的区别是什么

一、HTTP1.0

HTTP1.0默认使用 Connection:close ，浏览器每次请求都需要与服务器建立一个 TCP 连接，
服务器处理完成后立即断开 TCP 连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。

二、HTTP1.1

HTTP1.1默认使用 Connection:keep-alive （长连接），避免了连接建立和释放的开销；
通过 Content-Length 字段来判断当前请求的数据是否已经全部接受。不允许同时存在两个并行的响应。

1、为什么需要持久连接？

Http协议的初始版本中，每进行一次Http通信就要断开一次TCP连接。每次请求都会造成TCP连接的建立和断开，增加通信量的开销。

持久连接的特点：
* 持久连接也称为Http keep-alive，只要任意一端没有明确提出断开连接，则保存TCP连接状态。
* 减少了TCP连接的重复建立和断开所造成的额外开销，减去了服务器端的压力。
* 持久连接使得多数请求以管线化方式（pipelining）成为可能。可以同时并行发送多个请求，而不需要一个接一个的等待响应了。
（请求打包一次传输过去，响应打包一次传递回来），管线化的前提是在持久连接下。

2、Http1.1缺陷

（1）高延迟，带来页面加载速度的降低。（网络延迟问题只要由于队头阻塞，导致宽带无法被充分利用）

（2）无状态特性，带来巨大的Http头部。

（3）明文传输，不安全。

（4）不支持服务器推送消息。

三、HTTP2.0

SPDY协议：2009年谷歌公开了SPDY协议，主要解决Http1.1效率不高的问题。

TCP -> SSL -> SPDY -> HTTP

SPDY被当做HTTP2.0的基础，其主要特性（兼容老版本HTTP协议，同时可以使用SSL功能）都在HTTP2.0中得到继承。

HTTP2.0：基于SPDY，专注于性能，目标是在用户和网站直接只用一个连接。

1、HTTP2.0新特性

（1）二进制传输

http2.0将请求和响应数据分割为更小的帧，并且它们采用二进制编码(http1.0基于文本格式)。
多个帧之间可以乱序发送，根据帧首部的流表示可以重新组装。

（2）Header压缩

Http2.0开发了专门的“HPACK”算法，大大压缩了Header信息。

（3）多路复用

http2.0中引入了多路复用技术，很好的解决了浏览器限制同一个域名下的请求数量的问题。

多路复用技术可以只通过一个TCP链接就可以传输所有的请求数据。

（4）服务端推送

HTTP2.0在一定程度上改变了传统的“请求-应答”工作模式，服务器不再完全被动地响应请求，
也可以新建“流”主动向客户端发送消息。（例如，浏览器在刚请求html的时候就提前把可能会用到的JS、CSS文件发送给客户端，
减少等待延迟，这被称为“服务端推送Server Push”）

服务器也不能随便将第三方资源推送给客户端，必须经过双方确认。

2、HTTP2.0缺点

（1）TCP以及TCP+TLS建立连接的延迟（握手延迟）

（2）TCP的队头阻塞没有彻底解决（http2.0中，多个请求是跑在一个TCP管道中的，
一旦丢包，TCP就要等待重传（丢失的包等待重新传输确认），从而阻塞该TCP连接中的所有请求）

因为HTTP2.0存在这些缺点，所以出现了HTTP3.0。

四、HTTP3.0

Google在推行SPDY的时候意识到了上述http2.0一系列问题，于是又产生了基于UDP协议的“QUIC”协议，
让HTTP跑在QUIC上而不是TCP上。从而产生了HTTP3.0版本，它解决了“队头阻塞”的问题。

特点：

（1）实现了类似TCP的流量控制，传输可靠性的功能。

（2）实现了快速握手功能（QUIC基于UDP，UDP是面向无连接的，不需要握手和挥手，比TCP快）

（3）集成了TLS加密功能

（4）多路复用，彻底解决TCP中队头阻塞的问题（单个“流”是有序的，可能会因为丢包而阻塞，但是其他流不会受到影响）

五、总结

HTTP1.1的缺点：安全性不足和性能不高；

HTTP2.0完全兼容HTTTP1.0，是“更安全的HTTP，更快的HTTPS”，头部压缩，多路复用等技术充分利用了带宽，降低了延迟。

HTTP3.0的底层支撑协议QUIC基于UDP实现，又含TCP的特点，实现了又快又可靠的协议。

## 浏览器中输入网址到内容展示发生了什么

在浏览器中输入一个网址，到窗口页面中展示内容，过程中发生了哪些事？

电脑上有一块 网卡，每个网卡出场时都有自己的一个 mac地址，网卡工作在第二层，即链路层。
网卡工作时，首先需要有自己 IP地址 ，网卡会通过 交换机 在局域网内广播一条信息，让 DHCP服务器 给自己分配一个IP地址。
DHCP服务器收到这条信息后，会回复有一个IP地址可以使用，网卡向DHCP服务器确认自己要使用这个IP。
DHCP服务器收到这条信息后，会记录下这个mac对应的IP，然后回复一条确认信息，并把 网关路由器IP地址 、DNS服务器IP地址 附带上。
网卡向 域名定位的服务器 获取数据时要先知道 域名定位的服务器的IP地址。这要使用到DNS服务。
网卡发送信息是要通过 网关路由器 的，但却只有 网关路由器的IP地址，却不知道 网关路由器的mac地址，所以信息不知道发送给谁。
现在网卡还要知道 网关路由器的mac地址，网卡会通过广播询问网关路由器IP地址的mac地址是多少，
网关路由器收到后会把自己的mac地址回复过去，然后网卡会把这个mac地址记录下来，这就是 ARP地址解析协议。
现在网卡可以通过网关路由器向DNS服务器查询 域名的IP地址 了，DNS服务器返回域名的IP地址。
然后网卡把要发送的信息发送到域名的IP地址上去，具体发送给网关路由器后就不管了，后面由广域网来负责传输。

其中牵涉到的协议有：
* DHCP
* ARP
* DNS

具体可以参阅下 <https://mp.weixin.qq.com/s/vyHlB9pem4rv4htJS9ca6Q>






<br/><br/><br/><br/><br/>
## 参考资料

程序员面试中最常见的27个问题，拿走不谢！ <https://zhuanlan.zhihu.com/p/36896984>

有了这份程序员面试指南，你离大厂Offer还远吗？ <https://zhuanlan.zhihu.com/p/165413854>

程序员面试 10 大潜规则，千万不要踩坑！ <https://mp.weixin.qq.com/s?__biz=Mzg2MzE5MjMxNQ==&mid=2247502803&idx=1&sn=f9cf74b6dc0ddd24482f9204108fe023&chksm=ce7ede47f9095751180c9c2145c481c5d45a3465f30fc570154fbcfe1a1c01bc60748468fac3&scene=21#wechat_redirect>

面试了一个 39 岁程序员，我有点慌……  <https://mp.weixin.qq.com/s?__biz=Mzg2MzE5MjMxNQ==&mid=2247502845&idx=1&sn=510126368bb6d9eb5c279e99a378f13f&chksm=ce7ede69f909577f5a022abd584b46427ddd25bf29569b67539586e231e7b506f043b71bd7c1&scene=21#wechat_redirect>

HTTP及其版本（HTTP1.0、HTTP1.1、HTTP2.0、HTTP3.0）详解 <https://blog.csdn.net/weixin_53186633/article/details/123624445>

